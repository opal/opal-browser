(function(global_object) {
  "use strict";

  // @note
  //   A few conventions for the documentation of this file:
  //   1. Always use "//" (in contrast with "/**/")
  //   2. The syntax used is Yardoc (yardoc.org), which is intended for Ruby (se below)
  //   3. `@param` and `@return` types should be preceded by `JS.` when referring to
  //      JavaScript constructors (e.g. `JS.Function`) otherwise Ruby is assumed.
  //   4. `nil` and `null` being unambiguous refer to the respective
  //      objects/values in Ruby and JavaScript
  //   5. This is still WIP :) so please give feedback and suggestions on how
  //      to improve or for alternative solutions
  //
  //   The way the code is digested before going through Yardoc is a secret kept
  //   in the docs repo (https://github.com/opal/docs/tree/master).

  var console;

  // Detect the global object
  if (typeof(globalThis) !== 'undefined') { global_object = globalThis; }
  else if (typeof(global) !== 'undefined') { global_object = global; }
  else if (typeof(window) !== 'undefined') { global_object = window; }

  // Setup a dummy console object if missing
  if (global_object.console == null) {
    global_object.console = {};
  }

  if (typeof(global_object.console) === 'object') {
    console = global_object.console;
  } else {
    console = {};
  }

  if (!('log' in console)) { console.log = function () {}; }
  if (!('warn' in console)) { console.warn = console.log; }

  if (typeof(global_object.Opal) !== 'undefined') {
    console.warn('Opal already loaded. Loading twice can cause troubles, please fix your setup.');
    return global_object.Opal;
  }

  var nil;

  // The actual class for BasicObject
  var BasicObject;

  // The actual Object class.
  // The leading underscore is to avoid confusion with window.Object()
  var _Object;

  // The actual Module class
  var Module;

  // The actual Class class
  var Class;

  // The Opal.Opal class (helpers etc.)
  var _Opal;

  // The Kernel module
  var Kernel;

  // The Opal object that is exposed globally
  var Opal = global_object.Opal = {};

  // This is a useful reference to global object inside ruby files
  Opal.global = global_object;

  // Configure runtime behavior with regards to require and unsupported features
  Opal.config = {
    missing_require_severity: 'error',        // error, warning, ignore
    unsupported_features_severity: 'warning', // error, warning, ignore
    experimental_features_severity: 'warning',// warning, ignore
    enable_stack_trace: true                  // true, false
  };

  // Minify common function calls
  var $call      = Function.prototype.call;
  var $bind      = Function.prototype.bind;
  var $has_own   = Object.hasOwn || $call.bind(Object.prototype.hasOwnProperty);
  var $set_proto = Object.setPrototypeOf;
  var $slice     = $call.bind(Array.prototype.slice);
  var $splice    = $call.bind(Array.prototype.splice);

  // Nil object id is always 4
  var nil_id = 4;

  // Generates even sequential numbers greater than 4
  // (nil_id) to serve as unique ids for ruby objects
  var unique_id = nil_id;

  // Return next unique id
  function $uid() {
    unique_id += 2;
    return unique_id;
  };
  Opal.uid = $uid;

  // Retrieve or assign the id of an object
  Opal.id = function(obj) {
    if (obj.$$is_number) return (obj * 2)+1;
    if (obj.$$id == null) {
      $prop(obj, '$$id', $uid());
    }
    return obj.$$id;
  };

  // Globals table
  var $gvars = Opal.gvars = {};

  // Exit function, this should be replaced by platform specific implementation
  // (See nodejs and chrome for examples)
  Opal.exit = function(status) { if ($gvars.DEBUG) console.log('Exited with status '+status); };

  // keeps track of exceptions for $!
  Opal.exceptions = [];

  // @private
  // Pops an exception from the stack and updates `$!`.
  Opal.pop_exception = function(rescued_exception) {
    var exception = Opal.exceptions.pop();
    if (exception === rescued_exception) {
      // Current $! is raised in the rescue block, so we don't update it
    }
    else if (exception) {
      $gvars["!"] = exception;
    }
    else {
      $gvars["!"] = nil;
    }
  };

  // A helper function for raising things, that gracefully degrades if necessary
  // functionality is not yet loaded.
  function $raise(klass, message) {
    // Raise Exception, so we can know that something wrong is going on.
    if (!klass) klass = Opal.Exception || Error;

    if (Kernel && Kernel.$raise) {
      if (arguments.length > 2) {
        Kernel.$raise(klass.$new.apply(klass, $slice(arguments, 1)));
      }
      else {
        Kernel.$raise(klass, message);
      }
    }
    else if (!klass.$new) {
      throw new klass(message);
    }
    else {
      throw klass.$new(message);
    }
  }

  // Reuse the same object for performance/memory sake
  var prop_options = {
    value: undefined,
    enumerable: false,
    configurable: true,
    writable: true
  };

  function $prop(object, name, initialValue) {
    if (typeof(object) === "string") {
      // Special case for:
      //   s = "string"
      //   def s.m; end
      // String class is the only class that:
      // + compiles to JS primitive
      // + allows method definition directly on instances
      // numbers, true, false and null do not support it.
      object[name] = initialValue;
    } else {
      prop_options.value = initialValue;
      Object.defineProperty(object, name, prop_options);
    }
  }

  Opal.prop = $prop;

  // @deprecated
  Opal.defineProperty = Opal.prop;

  Opal.slice = $slice;

  // Helpers
  // -----

  var $truthy = Opal.truthy = function(val) {
    return false !== val && nil !== val && undefined !== val && null !== val && (!(val instanceof Boolean) || true === val.valueOf());
  };

  Opal.falsy = function(val) {
    return !$truthy(val);
  };

  Opal.type_error = function(object, type, method, coerced) {
    object = object.$$class;

    if (coerced && method) {
      coerced = coerced.$$class;
      $raise(Opal.TypeError,
        "can't convert " + object + " into " + type +
        " (" + object + "#" + method + " gives " + coerced + ")"
      )
    } else {
      $raise(Opal.TypeError,
        "no implicit conversion of " + object + " into " + type
      )
    }
  };

  Opal.coerce_to = function(object, type, method, args) {
    var body;

    if (method === 'to_int' && type === Opal.Integer && object.$$is_number)
      return object < 0 ? Math.ceil(object) : Math.floor(object);

    if (method === 'to_str' && type === Opal.String && object.$$is_string)
      return object;

    if (Opal.is_a(object, type)) return object;

    // Fast path for the most common situation
    if (object['$respond_to?'].$$pristine && object.$method_missing.$$pristine) {
      body = object[$jsid(method)];
      if (body == null || body.$$stub) Opal.type_error(object, type);
      return body.apply(object, args);
    }

    if (!object['$respond_to?'](method)) {
      Opal.type_error(object, type);
    }

    if (args == null) args = [];
    return Opal.send(object, method, args);
  }

  Opal.respond_to = function(obj, jsid, include_all) {
    if (obj == null || !obj.$$class) return false;
    include_all = !!include_all;
    var body = obj[jsid];

    if (obj['$respond_to?'].$$pristine) {
      if (typeof(body) === "function" && !body.$$stub) {
        return true;
      }
      if (!obj['$respond_to_missing?'].$$pristine) {
        return Opal.send(obj, obj['$respond_to_missing?'], [jsid.substr(1), include_all]);
      }
    } else {
      return Opal.send(obj, obj['$respond_to?'], [jsid.substr(1), include_all]);
    }
  }

  // TracePoint support
  // ------------------
  //
  // Support for `TracePoint.trace(:class) do ... end`
  Opal.trace_class = false;
  Opal.tracers_for_class = [];

  function invoke_tracers_for_class(klass_or_module) {
    var i, ii, tracer;

    for(i = 0, ii = Opal.tracers_for_class.length; i < ii; i++) {
      tracer = Opal.tracers_for_class[i];
      tracer.trace_object = klass_or_module;
      tracer.block.$call(tracer);
    }
  }

  function handle_autoload(cref, name) {
    if (!cref.$$autoload[name].loaded) {
      cref.$$autoload[name].loaded = true;
      try {
        Opal.Kernel.$require(cref.$$autoload[name].path);
      } catch (e) {
        cref.$$autoload[name].exception = e;
        throw e;
      }
      cref.$$autoload[name].required = true;
      if (cref.$$const[name] != null) {
        cref.$$autoload[name].success = true;
        return cref.$$const[name];
      }
    } else if (cref.$$autoload[name].loaded && !cref.$$autoload[name].required) {
      if (cref.$$autoload[name].exception) { throw cref.$$autoload[name].exception; }
    }
  }

  // Constants
  // ---------
  //
  // For future reference:
  // - The Rails autoloading guide (http://guides.rubyonrails.org/v5.0/autoloading_and_reloading_constants.html)
  // - @ConradIrwin's 2012 post on “Everything you ever wanted to know about constant lookup in Ruby” (http://cirw.in/blog/constant-lookup.html)
  //
  // Legend of MRI concepts/names:
  // - constant reference (cref): the module/class that acts as a namespace
  // - nesting: the namespaces wrapping the current scope, e.g. nesting inside
  //            `module A; module B::C; end; end` is `[B::C, A]`

  // Get the constant in the scope of the current cref
  function const_get_name(cref, name) {
    if (cref) {
      if (cref.$$const[name] != null) { return cref.$$const[name]; }
      if (cref.$$autoload && cref.$$autoload[name]) {
        return handle_autoload(cref, name);
      }
    }
  }

  // Walk up the nesting array looking for the constant
  function const_lookup_nesting(nesting, name) {
    var i, ii, constant;

    if (nesting.length === 0) return;

    // If the nesting is not empty the constant is looked up in its elements
    // and in order. The ancestors of those elements are ignored.
    for (i = 0, ii = nesting.length; i < ii; i++) {
      constant = nesting[i].$$const[name];
      if (constant != null) {
        return constant;
      } else if (nesting[i].$$autoload && nesting[i].$$autoload[name]) {
        return handle_autoload(nesting[i], name);
      }
    }
  }

  // Walk up the ancestors chain looking for the constant
  function const_lookup_ancestors(cref, name) {
    var i, ii, ancestors;

    if (cref == null) return;

    ancestors = $ancestors(cref);

    for (i = 0, ii = ancestors.length; i < ii; i++) {
      if (ancestors[i].$$const && $has_own(ancestors[i].$$const, name)) {
        return ancestors[i].$$const[name];
      } else if (ancestors[i].$$autoload && ancestors[i].$$autoload[name]) {
        return handle_autoload(ancestors[i], name);
      }
    }
  }

  // Walk up Object's ancestors chain looking for the constant,
  // but only if cref is missing or a module.
  function const_lookup_Object(cref, name) {
    if (cref == null || cref.$$is_module) {
      return const_lookup_ancestors(_Object, name);
    }
  }

  // Call const_missing if nothing else worked
  function const_missing(cref, name) {
    return (cref || _Object).$const_missing(name);
  }

  // Look for the constant just in the current cref or call `#const_missing`
  Opal.const_get_local = function(cref, name, skip_missing) {
    var result;

    if (cref == null) return;

    if (cref === '::') cref = _Object;

    if (!cref.$$is_module && !cref.$$is_class) {
      $raise(Opal.TypeError, cref.toString() + " is not a class/module");
    }

    result = const_get_name(cref, name);
    return result != null || skip_missing ? result : const_missing(cref, name);
  };

  // Look for the constant relative to a cref or call `#const_missing` (when the
  // constant is prefixed by `::`).
  Opal.const_get_qualified = function(cref, name, skip_missing) {
    var result, cache, cached, current_version = Opal.const_cache_version;

    if (name == null) {
      // A shortpath for calls like ::String => $$$("String")
      result = const_get_name(_Object, cref);

      if (result != null) return result;
      return Opal.const_get_qualified(_Object, cref, skip_missing);
    }

    if (cref == null) return;

    if (cref === '::') cref = _Object;

    if (!cref.$$is_module && !cref.$$is_class) {
      $raise(Opal.TypeError, cref.toString() + " is not a class/module");
    }

    if ((cache = cref.$$const_cache) == null) {
      $prop(cref, '$$const_cache', Object.create(null));
      cache = cref.$$const_cache;
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      ((result = const_get_name(cref, name))              != null) ||
      ((result = const_lookup_ancestors(cref, name))      != null);
      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null || skip_missing ? result : const_missing(cref, name);
  };

  // Initialize the top level constant cache generation counter
  Opal.const_cache_version = 1;

  // Look for the constant in the open using the current nesting and the nearest
  // cref ancestors or call `#const_missing` (when the constant has no :: prefix).
  Opal.const_get_relative = function(nesting, name, skip_missing) {
    var cref = nesting[0], result, current_version = Opal.const_cache_version, cache, cached;

    if ((cache = nesting.$$const_cache) == null) {
      $prop(nesting, '$$const_cache', Object.create(null));
      cache = nesting.$$const_cache;
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      ((result = const_get_name(cref, name))              != null) ||
      ((result = const_lookup_nesting(nesting, name))     != null) ||
      ((result = const_lookup_ancestors(cref, name))      != null) ||
      ((result = const_lookup_Object(cref, name))         != null);

      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null || skip_missing ? result : const_missing(cref, name);
  };

  // Register the constant on a cref and opportunistically set the name of
  // unnamed classes/modules.
  function $const_set(cref, name, value) {
    var new_const = true;

    if (cref == null || cref === '::') cref = _Object;

    if (value.$$is_a_module) {
      if (value.$$name == null || value.$$name === nil) value.$$name = name;
      if (value.$$base_module == null) value.$$base_module = cref;
    }

    cref.$$const = (cref.$$const || Object.create(null));

    if (name in cref.$$const || ("$$autoload" in cref && name in cref.$$autoload)) {
      new_const = false;
    }

    cref.$$const[name] = value;

    // Add a short helper to navigate constants manually.
    // @example
    //   Opal.$$.Regexp.$$.IGNORECASE
    cref.$$ = cref.$$const;

    Opal.const_cache_version++;

    // Expose top level constants onto the Opal object
    if (cref === _Object) Opal[name] = value;

    // Name new class directly onto current scope (Opal.Foo.Baz = klass)
    $prop(cref, name, value);

    if (new_const && cref.$const_added && !cref.$const_added.$$pristine) {
      cref.$const_added(name);
    }

    return value;
  };

  Opal.const_set = $const_set;

  // Get all the constants reachable from a given cref, by default will include
  // inherited constants.
  Opal.constants = function(cref, inherit) {
    if (inherit == null) inherit = true;

    var module, modules = [cref], i, ii, constants = {}, constant;

    if (inherit) modules = modules.concat($ancestors(cref));
    if (inherit && cref.$$is_module) modules = modules.concat([Opal.Object]).concat($ancestors(Opal.Object));

    for (i = 0, ii = modules.length; i < ii; i++) {
      module = modules[i];

      // Do not show Objects constants unless we're querying Object itself
      if (cref !== _Object && module == _Object) break;

      for (constant in module.$$const) {
        constants[constant] = true;
      }
      if (module.$$autoload) {
        for (constant in module.$$autoload) {
          constants[constant] = true;
        }
      }
    }

    return Object.keys(constants);
  };

  // Remove a constant from a cref.
  Opal.const_remove = function(cref, name) {
    Opal.const_cache_version++;

    if (cref.$$const[name] != null) {
      var old = cref.$$const[name];
      delete cref.$$const[name];
      return old;
    }

    if (cref.$$autoload && cref.$$autoload[name]) {
      delete cref.$$autoload[name];
      return nil;
    }

    $raise(Opal.NameError, "constant "+cref+"::"+cref.$name()+" not defined");
  };

  // Generates a function that is a curried const_get_relative.
  Opal.const_get_relative_factory = function(nesting) {
    return function(name, skip_missing) {
      return Opal.$$(nesting, name, skip_missing);
    }
  }

  // Setup some shortcuts to reduce compiled size
  Opal.$$ = Opal.const_get_relative;
  Opal.$$$ = Opal.const_get_qualified;
  Opal.$r = Opal.const_get_relative_factory;

  function descends_from_bridged_class(klass) {
    if (klass == null) return false;
    if (klass.$$bridge) return klass;
    if (klass.$$super) return descends_from_bridged_class(klass.$$super);
    return false;
  }

  // Modules & Classes
  // -----------------

  // A `class Foo; end` expression in ruby is compiled to call this runtime
  // method which either returns an existing class of the given name, or creates
  // a new class in the given `base` scope.
  //
  // If a constant with the given name exists, then we check to make sure that
  // it is a class and also that the superclasses match. If either of these
  // fail, then we raise a `TypeError`. Note, `superclass` may be null if one
  // was not specified in the ruby code.
  //
  // We pass a constructor to this method of the form `function ClassName() {}`
  // simply so that classes show up with nicely formatted names inside debuggers
  // in the web browser (or node/sprockets).
  //
  // The `scope` is the current `self` value where the class is being created
  // from. We use this to get the scope for where the class should be created.
  // If `scope` is an object (not a class/module), we simple get its class and
  // use that as the scope instead.
  //
  // @param scope        [Object] where the class is being created
  // @param superclass   [Class,null] superclass of the new class (may be null)
  // @param singleton    [Boolean,null] a true value denotes we want to allocate
  //                                    a singleton
  //
  // @return new [Class]  or existing ruby class
  //
  function $allocate_class(name, superclass, singleton) {
    var klass, bridged_descendant;

    if (bridged_descendant = descends_from_bridged_class(superclass)) {
      // Inheritance from bridged classes requires
      // calling original JS constructors
      klass = function() {
        var self = new ($bind.apply(bridged_descendant.$$constructor, $prepend(null, arguments)))();

        // and replacing a __proto__ manually
        $set_proto(self, klass.$$prototype);
        return self;
      }
    } else {
      klass = function(){};
    }

    if (name && name !== nil) {
      $prop(klass, 'displayName', '::'+name);
    }

    $prop(klass, '$$name', name);
    $prop(klass, '$$constructor', klass);
    $prop(klass, '$$prototype', klass.prototype);
    $prop(klass, '$$const', {});
    $prop(klass, '$$is_class', true);
    $prop(klass, '$$is_a_module', true);
    $prop(klass, '$$super', superclass);
    $prop(klass, '$$cvars', {});
    $prop(klass, '$$own_included_modules', []);
    $prop(klass, '$$own_prepended_modules', []);
    $prop(klass, '$$ancestors', []);
    $prop(klass, '$$ancestors_cache_version', null);
    $prop(klass, '$$subclasses', []);
    $prop(klass, '$$cloned_from', []);

    $prop(klass.$$prototype, '$$class', klass);

    // By default if there are no singleton class methods
    // __proto__ is Class.prototype
    // Later singleton methods generate a singleton_class
    // and inject it into ancestors chain
    if (Opal.Class) {
      $set_proto(klass, Opal.Class.prototype);
    }

    if (superclass != null) {
      $set_proto(klass.$$prototype, superclass.$$prototype);

      if (singleton !== true) {
        // Let's not forbid GC from cleaning up our
        // subclasses.
        if (typeof WeakRef !== 'undefined') {
          // First, let's clean up our array from empty objects.
          var i, subclass, rebuilt_subclasses = [];
          for (i = 0; i < superclass.$$subclasses.length; i++) {
            subclass = superclass.$$subclasses[i];
            if (subclass.deref() !== undefined) {
              rebuilt_subclasses.push(subclass);
            }
          }
          // Now, let's add our class.
          rebuilt_subclasses.push(new WeakRef(klass));
          superclass.$$subclasses = rebuilt_subclasses;
        }
        else {
          superclass.$$subclasses.push(klass);
        }
      }

      if (superclass.$$meta) {
        // If superclass has metaclass then we have explicitely inherit it.
        Opal.build_class_singleton_class(klass);
      }
    }

    return klass;
  };
  Opal.allocate_class = $allocate_class;


  function find_existing_class(scope, name) {
    // Try to find the class in the current scope
    var klass = const_get_name(scope, name);

    // If the class exists in the scope, then we must use that
    if (klass) {
      // Make sure the existing constant is a class, or raise error
      if (!klass.$$is_class) {
        $raise(Opal.TypeError, name + " is not a class");
      }

      return klass;
    }
  }

  function ensureSuperclassMatch(klass, superclass) {
    if (klass.$$super !== superclass) {
      $raise(Opal.TypeError, "superclass mismatch for class " + klass.$$name);
    }
  }

  Opal.klass = function(scope, superclass, name) {
    var bridged;

    if (scope == null || scope == '::') {
      // Global scope
      scope = _Object;
    } else if (!scope.$$is_class && !scope.$$is_module) {
      // Scope is an object, use its class
      scope = scope.$$class;
    }

    // If the superclass is not an Opal-generated class then we're bridging a native JS class
    if (
      superclass != null && (!superclass.hasOwnProperty || (
        superclass.hasOwnProperty && !superclass.hasOwnProperty('$$is_class')
      ))
    ) {
      if (superclass.constructor && superclass.constructor.name == "Function") {
        bridged = superclass;
        superclass = _Object;
      } else {
        $raise(Opal.TypeError, "superclass must be a Class (" + (
          (superclass.constructor && (superclass.constructor.name || superclass.constructor.$$name)) ||
          typeof(superclass)
        ) + " given)");
      }
    }

    var klass = find_existing_class(scope, name);

    if (klass != null) {
      if (superclass) {
        // Make sure existing class has same superclass
        ensureSuperclassMatch(klass, superclass);
      }
    }
    else {
      // Class doesn't exist, create a new one with given superclass...

      // Not specifying a superclass means we can assume it to be Object
      if (superclass == null) {
        superclass = _Object;
      }

      // Create the class object (instance of Class)
      klass = $allocate_class(name, superclass);
      $const_set(scope, name, klass);

      // Call .inherited() hook with new class on the superclass
      if (superclass.$inherited) {
        superclass.$inherited(klass);
      }

      if (bridged) {
        Opal.bridge(bridged, klass);
      }
    }

    if (Opal.trace_class) { invoke_tracers_for_class(klass); }

    return klass;
  };

  // Define new module (or return existing module). The given `scope` is basically
  // the current `self` value the `module` statement was defined in. If this is
  // a ruby module or class, then it is used, otherwise if the scope is a ruby
  // object then that objects real ruby class is used (e.g. if the scope is the
  // main object, then the top level `Object` class is used as the scope).
  //
  // If a module of the given name is already defined in the scope, then that
  // instance is just returned.
  //
  // If there is a class of the given name in the scope, then an error is
  // generated instead (cannot have a class and module of same name in same scope).
  //
  // Otherwise, a new module is created in the scope with the given name, and that
  // new instance is returned back (to be referenced at runtime).
  //
  // @param  scope [Module, Class] class or module this definition is inside
  // @param  id   [String] the name of the new (or existing) module
  //
  // @return [Module]
  function $allocate_module(name) {
    var constructor = function(){};
    var module = constructor;

    if (name)
      $prop(constructor, 'displayName', name+'.constructor');

    $prop(module, '$$name', name);
    $prop(module, '$$prototype', constructor.prototype);
    $prop(module, '$$const', {});
    $prop(module, '$$is_module', true);
    $prop(module, '$$is_a_module', true);
    $prop(module, '$$cvars', {});
    $prop(module, '$$iclasses', []);
    $prop(module, '$$own_included_modules', []);
    $prop(module, '$$own_prepended_modules', []);
    $prop(module, '$$ancestors', [module]);
    $prop(module, '$$ancestors_cache_version', null);
    $prop(module, '$$cloned_from', []);

    $set_proto(module, Opal.Module.prototype);

    return module;
  };
  Opal.allocate_module = $allocate_module;

  function find_existing_module(scope, name) {
    var module = const_get_name(scope, name);
    if (module == null && scope === _Object) module = const_lookup_ancestors(_Object, name);

    if (module) {
      if (!module.$$is_module && module !== _Object) {
        $raise(Opal.TypeError, name + " is not a module");
      }
    }

    return module;
  }

  Opal.module = function(scope, name) {
    var module;

    if (scope == null || scope == '::') {
      // Global scope
      scope = _Object;
    } else if (!scope.$$is_class && !scope.$$is_module) {
      // Scope is an object, use its class
      scope = scope.$$class;
    }

    module = find_existing_module(scope, name);

    if (module == null) {
      // Module doesnt exist, create a new one...
      module = $allocate_module(name);
      $const_set(scope, name, module);
    }

    if (Opal.trace_class) { invoke_tracers_for_class(module); }

    return module;
  };

  // Return the singleton class for the passed object.
  //
  // If the given object alredy has a singleton class, then it will be stored on
  // the object as the `$$meta` property. If this exists, then it is simply
  // returned back.
  //
  // Otherwise, a new singleton object for the class or object is created, set on
  // the object at `$$meta` for future use, and then returned.
  //
  // @param object [Object] the ruby object
  // @return [Class] the singleton class for object
  Opal.get_singleton_class = function(object) {
    if (object.$$is_number) {
      $raise(Opal.TypeError, "can't define singleton");
    }
    if (object.$$meta) {
      return object.$$meta;
    }

    if (object.hasOwnProperty('$$is_class')) {
      return Opal.build_class_singleton_class(object);
    } else if (object.hasOwnProperty('$$is_module')) {
      return Opal.build_module_singleton_class(object);
    } else {
      return Opal.build_object_singleton_class(object);
    }
  };

  // helper to set $$meta on klass, module or instance
  function set_meta(obj, meta) {
    if (obj.hasOwnProperty('$$meta')) {
      obj.$$meta = meta;
    } else {
      $prop(obj, '$$meta', meta);
    }
    if (obj.$$frozen) {
      // If a object is frozen (sealed), freeze $$meta too.
      // No need to inject $$meta.$$prototype in the prototype chain,
      // as $$meta cannot be modified anyway.
      obj.$$meta.$freeze();
    } else {
      $set_proto(obj, meta.$$prototype);
    }
  };

  // Build the singleton class for an existing class. Class object are built
  // with their singleton class already in the prototype chain and inheriting
  // from their superclass object (up to `Class` itself).
  //
  // NOTE: Actually in MRI a class' singleton class inherits from its
  // superclass' singleton class which in turn inherits from Class.
  //
  // @param klass [Class]
  // @return [Class]
  Opal.build_class_singleton_class = function(klass) {
    if (klass.$$meta) {
      return klass.$$meta;
    }

    // The singleton_class superclass is the singleton_class of its superclass;
    // but BasicObject has no superclass (its `$$super` is null), thus we
    // fallback on `Class`.
    var superclass = klass === BasicObject ? Class : Opal.get_singleton_class(klass.$$super);

    var meta = $allocate_class(null, superclass, true);

    $prop(meta, '$$is_singleton', true);
    $prop(meta, '$$singleton_of', klass);
    set_meta(klass, meta);
    // Restoring ClassName.class
    $prop(klass, '$$class', Opal.Class);

    return meta;
  };

  Opal.build_module_singleton_class = function(mod) {
    if (mod.$$meta) {
      return mod.$$meta;
    }

    var meta = $allocate_class(null, Opal.Module, true);

    $prop(meta, '$$is_singleton', true);
    $prop(meta, '$$singleton_of', mod);
    set_meta(mod, meta);
    // Restoring ModuleName.class
    $prop(mod, '$$class', Opal.Module);

    return meta;
  };

  // Build the singleton class for a Ruby (non class) Object.
  //
  // @param object [Object]
  // @return [Class]
  Opal.build_object_singleton_class = function(object) {
    var superclass = object.$$class,
        klass = $allocate_class(nil, superclass, true);

    $prop(klass, '$$is_singleton', true);
    $prop(klass, '$$singleton_of', object);

    delete klass.$$prototype.$$class;

    set_meta(object, klass);

    return klass;
  };

  Opal.is_method = function(prop) {
    return (prop[0] === '$' && prop[1] !== '$');
  };

  Opal.instance_methods = function(mod) {
    var processed = Object.create(null), results = [], ancestors = $ancestors(mod);

    for (var i = 0, l = ancestors.length; i < l; i++) {
      var ancestor = ancestors[i],
          proto = ancestor.$$prototype;

      if (proto.hasOwnProperty('$$dummy')) {
        proto = proto.$$define_methods_on;
      }

      var props = Object.getOwnPropertyNames(proto);

      for (var j = 0, ll = props.length; j < ll; j++) {
        var prop = props[j];

        if (processed[prop]) {
          continue;
        }
        if (Opal.is_method(prop)) {
          var method = proto[prop];

          if (!method.$$stub) {
            var method_name = prop.slice(1);
            results.push(method_name);
          }
        }
        processed[prop] = true;
      }
    }

    return results;
  };

  Opal.own_instance_methods = function(mod) {
    var results = [],
        proto = mod.$$prototype;

    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }

    var props = Object.getOwnPropertyNames(proto);

    for (var i = 0, length = props.length; i < length; i++) {
      var prop = props[i];

      if (Opal.is_method(prop)) {
        var method = proto[prop];

        if (!method.$$stub) {
          var method_name = prop.slice(1);
          results.push(method_name);
        }
      }
    }

    return results;
  };

  Opal.methods = function(obj) {
    return Opal.instance_methods(obj.$$meta || obj.$$class);
  };

  Opal.own_methods = function(obj) {
    return obj.$$meta ? Opal.own_instance_methods(obj.$$meta) : [];
  };

  Opal.receiver_methods = function(obj) {
    var mod = Opal.get_singleton_class(obj);
    var singleton_methods = Opal.own_instance_methods(mod);
    var instance_methods = Opal.own_instance_methods(mod.$$super);
    return singleton_methods.concat(instance_methods);
  };

  // Returns an object containing all pairs of names/values
  // for all class variables defined in provided +module+
  // and its ancestors.
  //
  // @param module [Module]
  // @return [Object]
  Opal.class_variables = function(module) {
    var ancestors = $ancestors(module),
        i, length = ancestors.length,
        result = {};

    for (i = length - 1; i >= 0; i--) {
      var ancestor = ancestors[i];

      for (var cvar in ancestor.$$cvars) {
        result[cvar] = ancestor.$$cvars[cvar];
      }
    }

    return result;
  };

  // Sets class variable with specified +name+ to +value+
  // in provided +module+
  //
  // @param module [Module]
  // @param name [String]
  // @param value [Object]
  Opal.class_variable_set = function(module, name, value) {
    var ancestors = $ancestors(module),
        i, length = ancestors.length;

    for (i = length - 2; i >= 0; i--) {
      var ancestor = ancestors[i];

      if ($has_own(ancestor.$$cvars, name)) {
        ancestor.$$cvars[name] = value;
        return value;
      }
    }

    module.$$cvars[name] = value;

    return value;
  };

  // Gets class variable with specified +name+ from provided +module+
  //
  // @param module [Module]
  // @param name [String]
  Opal.class_variable_get = function(module, name, tolerant) {
    if ($has_own(module.$$cvars, name))
      return module.$$cvars[name];

    var ancestors = $ancestors(module),
      i, length = ancestors.length;

    for (i = 0; i < length; i++) {
      var ancestor = ancestors[i];

      if ($has_own(ancestor.$$cvars, name)) {
        return ancestor.$$cvars[name];
      }
    }

    if (!tolerant)
      $raise(Opal.NameError, 'uninitialized class variable '+name+' in '+module.$name());

    return nil;
  }

  function isRoot(proto) {
    return proto.hasOwnProperty('$$iclass') && proto.hasOwnProperty('$$root');
  }

  function own_included_modules(module) {
    var result = [], mod, proto = Object.getPrototypeOf(module.$$prototype);

    while (proto) {
      if (proto.hasOwnProperty('$$class')) {
        // superclass
        break;
      }
      mod = protoToModule(proto);
      if (mod) {
        result.push(mod);
      }
      proto = Object.getPrototypeOf(proto);
    }

    return result;
  }

  function own_prepended_modules(module) {
    var result = [], mod, proto = Object.getPrototypeOf(module.$$prototype);

    if (module.$$prototype.hasOwnProperty('$$dummy')) {
      while (proto) {
        if (proto === module.$$prototype.$$define_methods_on) {
          break;
        }

        mod = protoToModule(proto);
        if (mod) {
          result.push(mod);
        }

        proto = Object.getPrototypeOf(proto);
      }
    }

    return result;
  }


  // The actual inclusion of a module into a class.
  //
  // ## Class `$$parent` and `iclass`
  //
  // To handle `super` calls, every class has a `$$parent`. This parent is
  // used to resolve the next class for a super call. A normal class would
  // have this point to its superclass. However, if a class includes a module
  // then this would need to take into account the module. The module would
  // also have to then point its `$$parent` to the actual superclass. We
  // cannot modify modules like this, because it might be included in more
  // then one class. To fix this, we actually insert an `iclass` as the class'
  // `$$parent` which can then point to the superclass. The `iclass` acts as
  // a proxy to the actual module, so the `super` chain can then search it for
  // the required method.
  //
  // @param module [Module] the module to include
  // @param includer [Module] the target class to include module into
  // @return [null]
  Opal.append_features = function(module, includer) {
    var module_ancestors = $ancestors(module);
    var iclasses = [];

    if (module_ancestors.indexOf(includer) !== -1) {
      $raise(Opal.ArgumentError, 'cyclic include detected');
    }

    for (var i = 0, length = module_ancestors.length; i < length; i++) {
      var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
      $prop(iclass, '$$included', true);
      iclasses.push(iclass);
    }
    var includer_ancestors = $ancestors(includer),
        chain = chain_iclasses(iclasses),
        start_chain_after,
        end_chain_on;

    if (includer_ancestors.indexOf(module) === -1) {
      // first time include

      // includer -> chain.first -> ...chain... -> chain.last -> includer.parent
      start_chain_after = includer.$$prototype;
      end_chain_on = Object.getPrototypeOf(includer.$$prototype);
    } else {
      // The module has been already included,
      // we don't need to put it into the ancestors chain again,
      // but this module may have new included modules.
      // If it's true we need to copy them.
      //
      // The simplest way is to replace ancestors chain from
      //          parent
      //            |
      //   `module` iclass (has a $$root flag)
      //            |
      //   ...previos chain of module.included_modules ...
      //            |
      //  "next ancestor" (has a $$root flag or is a real class)
      //
      // to
      //          parent
      //            |
      //    `module` iclass (has a $$root flag)
      //            |
      //   ...regenerated chain of module.included_modules
      //            |
      //   "next ancestor" (has a $$root flag or is a real class)
      //
      // because there are no intermediate classes between `parent` and `next ancestor`.
      // It doesn't break any prototypes of other objects as we don't change class references.

      var parent = includer.$$prototype, module_iclass = Object.getPrototypeOf(parent);

      while (module_iclass != null) {
        if (module_iclass.$$module === module && isRoot(module_iclass)) {
          break;
        }

        parent = module_iclass;
        module_iclass = Object.getPrototypeOf(module_iclass);
      }

      if (module_iclass) {
        // module has been directly included
        var next_ancestor = Object.getPrototypeOf(module_iclass);

        // skip non-root iclasses (that were recursively included)
        while (next_ancestor.hasOwnProperty('$$iclass') && !isRoot(next_ancestor)) {
          next_ancestor = Object.getPrototypeOf(next_ancestor);
        }

        start_chain_after = parent;
        end_chain_on = next_ancestor;
      } else {
        // module has not been directly included but was in ancestor chain because it was included by another module
        // include it directly
        start_chain_after = includer.$$prototype;
        end_chain_on = Object.getPrototypeOf(includer.$$prototype);
      }
    }

    $set_proto(start_chain_after, chain.first);
    $set_proto(chain.last, end_chain_on);

    // recalculate own_included_modules cache
    includer.$$own_included_modules = own_included_modules(includer);

    Opal.const_cache_version++;
  };

  Opal.prepend_features = function(module, prepender) {
    // Here we change the ancestors chain from
    //
    //   prepender
    //      |
    //    parent
    //
    // to:
    //
    // dummy(prepender)
    //      |
    //  iclass(module)
    //      |
    // iclass(prepender)
    //      |
    //    parent
    var module_ancestors = $ancestors(module);
    var iclasses = [];

    if (module_ancestors.indexOf(prepender) !== -1) {
      $raise(Opal.ArgumentError, 'cyclic prepend detected');
    }

    for (var i = 0, length = module_ancestors.length; i < length; i++) {
      var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
      $prop(iclass, '$$prepended', true);
      iclasses.push(iclass);
    }

    var chain = chain_iclasses(iclasses),
        dummy_prepender = prepender.$$prototype,
        previous_parent = Object.getPrototypeOf(dummy_prepender),
        prepender_iclass,
        start_chain_after,
        end_chain_on;

    if (dummy_prepender.hasOwnProperty('$$dummy')) {
      // The module already has some prepended modules
      // which means that we don't need to make it "dummy"
      prepender_iclass = dummy_prepender.$$define_methods_on;
    } else {
      // Making the module "dummy"
      prepender_iclass = create_dummy_iclass(prepender);
      flush_methods_in(prepender);
      $prop(dummy_prepender, '$$dummy', true);
      $prop(dummy_prepender, '$$define_methods_on', prepender_iclass);

      // Converting
      //   dummy(prepender) -> previous_parent
      // to
      //   dummy(prepender) -> iclass(prepender) -> previous_parent
      $set_proto(dummy_prepender, prepender_iclass);
      $set_proto(prepender_iclass, previous_parent);
    }

    var prepender_ancestors = $ancestors(prepender);

    if (prepender_ancestors.indexOf(module) === -1) {
      // first time prepend

      start_chain_after = dummy_prepender;

      // next $$root or prepender_iclass or non-$$iclass
      end_chain_on = Object.getPrototypeOf(dummy_prepender);
      while (end_chain_on != null) {
        if (
          end_chain_on.hasOwnProperty('$$root') ||
          end_chain_on === prepender_iclass ||
          !end_chain_on.hasOwnProperty('$$iclass')
        ) {
          break;
        }

        end_chain_on = Object.getPrototypeOf(end_chain_on);
      }
    } else {
      $raise(Opal.RuntimeError, "Prepending a module multiple times is not supported");
    }

    $set_proto(start_chain_after, chain.first);
    $set_proto(chain.last, end_chain_on);

    // recalculate own_prepended_modules cache
    prepender.$$own_prepended_modules = own_prepended_modules(prepender);

    Opal.const_cache_version++;
  };

  function flush_methods_in(module) {
    var proto = module.$$prototype,
        props = Object.getOwnPropertyNames(proto);

    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      if (Opal.is_method(prop)) {
        delete proto[prop];
      }
    }
  }

  function create_iclass(module) {
    var iclass = create_dummy_iclass(module);

    if (module.$$is_module) {
      module.$$iclasses.push(iclass);
    }

    return iclass;
  }

  // Dummy iclass doesn't receive updates when the module gets a new method.
  function create_dummy_iclass(module) {
    var iclass = {},
        proto = module.$$prototype;

    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }

    var props = Object.getOwnPropertyNames(proto),
        length = props.length, i;

    for (i = 0; i < length; i++) {
      var prop = props[i];
      $prop(iclass, prop, proto[prop]);
    }

    $prop(iclass, '$$iclass', true);
    $prop(iclass, '$$module', module);

    return iclass;
  }

  function chain_iclasses(iclasses) {
    var length = iclasses.length, first = iclasses[0];

    $prop(first, '$$root', true);

    if (length === 1) {
      return { first: first, last: first };
    }

    var previous = first;

    for (var i = 1; i < length; i++) {
      var current = iclasses[i];
      $set_proto(previous, current);
      previous = current;
    }


    return { first: iclasses[0], last: iclasses[length - 1] };
  }

  // For performance, some core Ruby classes are toll-free bridged to their
  // native JavaScript counterparts (e.g. a Ruby Array is a JavaScript Array).
  //
  // This method is used to setup a native constructor (e.g. Array), to have
  // its prototype act like a normal Ruby class. Firstly, a new Ruby class is
  // created using the native constructor so that its prototype is set as the
  // target for the new class. Note: all bridged classes are set to inherit
  // from Object.
  //
  // Example:
  //
  //    Opal.bridge(self, Function);
  //
  // @param klass       [Class] the Ruby class to bridge
  // @param constructor [JS.Function] native JavaScript constructor to use
  // @return [Class] returns the passed Ruby class
  //
  Opal.bridge = function(native_klass, klass) {
    if (native_klass.hasOwnProperty('$$bridge')) {
      $raise(Opal.ArgumentError, "already bridged");
    }

    // constructor is a JS function with a prototype chain like:
    // - constructor
    //   - super
    //
    // What we need to do is to inject our class (with its prototype chain)
    // between constructor and super. For example, after injecting ::Object
    // into JS String we get:
    //
    // - constructor (window.String)
    //   - Opal.Object
    //     - Opal.Kernel
    //       - Opal.BasicObject
    //         - super (window.Object)
    //           - null
    //
    $prop(native_klass, '$$bridge', klass);
    $set_proto(native_klass.prototype, (klass.$$super || Opal.Object).$$prototype);
    $prop(klass, '$$prototype', native_klass.prototype);

    $prop(klass.$$prototype, '$$class', klass);
    $prop(klass, '$$constructor', native_klass);
    $prop(klass, '$$bridge', true);
  };

  function protoToModule(proto) {
    if (proto.hasOwnProperty('$$dummy')) {
      return;
    } else if (proto.hasOwnProperty('$$iclass')) {
      return proto.$$module;
    } else if (proto.hasOwnProperty('$$class')) {
      return proto.$$class;
    }
  }

  function own_ancestors(module) {
    return module.$$own_prepended_modules.concat([module]).concat(module.$$own_included_modules);
  }

  // The Array of ancestors for a given module/class
  function $ancestors(module) {
    if (!module) { return []; }

    if (module.$$ancestors_cache_version === Opal.const_cache_version) {
      return module.$$ancestors;
    }

    var result = [], i, mods, length;

    for (i = 0, mods = own_ancestors(module), length = mods.length; i < length; i++) {
      result.push(mods[i]);
    }

    if (module.$$super) {
      for (i = 0, mods = $ancestors(module.$$super), length = mods.length; i < length; i++) {
        result.push(mods[i]);
      }
    }

    module.$$ancestors_cache_version = Opal.const_cache_version;
    module.$$ancestors = result;

    return result;
  };
  Opal.ancestors = $ancestors;

  Opal.included_modules = function(module) {
    var result = [], mod = null, proto = Object.getPrototypeOf(module.$$prototype);

    for (; proto && Object.getPrototypeOf(proto); proto = Object.getPrototypeOf(proto)) {
      mod = protoToModule(proto);
      if (mod && mod.$$is_module && proto.$$iclass && proto.$$included) {
        result.push(mod);
      }
    }

    return result;
  };


  // Method Missing
  // --------------

  // Methods stubs are used to facilitate method_missing in opal. A stub is a
  // placeholder function which just calls `method_missing` on the receiver.
  // If no method with the given name is actually defined on an object, then it
  // is obvious to say that the stub will be called instead, and then in turn
  // method_missing will be called.
  //
  // When a file in ruby gets compiled to javascript, it includes a call to
  // this function which adds stubs for every method name in the compiled file.
  // It should then be safe to assume that method_missing will work for any
  // method call detected.
  //
  // Method stubs are added to the BasicObject prototype, which every other
  // ruby object inherits, so all objects should handle method missing. A stub
  // is only added if the given property name (method name) is not already
  // defined.
  //
  // Note: all ruby methods have a `$` prefix in javascript, so all stubs will
  // have this prefix as well (to make this method more performant).
  //
  //    Opal.add_stubs("foo,bar,baz=");
  //
  // All stub functions will have a private `$$stub` property set to true so
  // that other internal methods can detect if a method is just a stub or not.
  // `Kernel#respond_to?` uses this property to detect a methods presence.
  //
  // @param stubs [Array] an array of method stubs to add
  // @return [undefined]
  Opal.add_stubs = function(stubs) {
    var proto = Opal.BasicObject.$$prototype;
    var stub, existing_method;
    stubs = stubs.split(',');

    for (var i = 0, length = stubs.length; i < length; i++) {
      stub = $jsid(stubs[i]), existing_method = proto[stub];

      if (existing_method == null || existing_method.$$stub) {
        Opal.add_stub_for(proto, stub);
      }
    }
  };

  // Add a method_missing stub function to the given prototype for the
  // given name.
  //
  // @param prototype [Prototype] the target prototype
  // @param stub [String] stub name to add (e.g. "$foo")
  // @return [undefined]
  Opal.add_stub_for = function(prototype, stub) {
    // Opal.stub_for(stub) is the method_missing_stub
    $prop(prototype, stub, Opal.stub_for(stub));
  };

  // Generate the method_missing stub for a given method name.
  //
  // @param method_name [String] The js-name of the method to stub (e.g. "$foo")
  // @return [undefined]
  Opal.stub_for = function(method_name) {
    function method_missing_stub() {
      // Copy any given block onto the method_missing dispatcher
      this.$method_missing.$$p = method_missing_stub.$$p;

      // Set block property to null ready for the next call (stop false-positives)
      method_missing_stub.$$p = null;

      // call method missing with correct args (remove '$' prefix on method name)
      return this.$method_missing.apply(this, $prepend(method_name.slice(1), arguments));
    };

    method_missing_stub.$$stub = true;

    return method_missing_stub;
  };


  // Methods
  // -------

  // Arity count error dispatcher for methods
  //
  // @param actual [Fixnum] number of arguments given to method
  // @param expected [Fixnum] expected number of arguments
  // @param object [Object] owner of the method +meth+
  // @param meth [String] method name that got wrong number of arguments
  // @raise [ArgumentError]
  Opal.ac = function(actual, expected, object, meth) {
    var inspect = '';
    if (object.$$is_a_module) {
      inspect += object.$$name + '.';
    }
    else {
      inspect += object.$$class.$$name + '#';
    }
    inspect += meth;

    $raise(Opal.ArgumentError, '[' + inspect + '] wrong number of arguments (given ' + actual + ', expected ' + expected + ')');
  };

  // Arity count error dispatcher for blocks
  //
  // @param actual [Fixnum] number of arguments given to block
  // @param expected [Fixnum] expected number of arguments
  // @param context [Object] context of the block definition
  // @raise [ArgumentError]
  Opal.block_ac = function(actual, expected, context) {
    var inspect = "`block in " + context + "'";

    $raise(Opal.ArgumentError, inspect + ': wrong number of arguments (given ' + actual + ', expected ' + expected + ')');
  };

  function get_ancestors(obj) {
    if (obj.hasOwnProperty('$$meta') && obj.$$meta !== null) {
      return $ancestors(obj.$$meta);
    } else {
      return $ancestors(obj.$$class);
    }
  };

  // Super dispatcher
  Opal.find_super = function(obj, mid, current_func, defcheck, allow_stubs) {
    var jsid = $jsid(mid), ancestors, ancestor, super_method, method_owner, current_index = -1, i;

    ancestors = get_ancestors(obj);
    method_owner = current_func.$$owner;

    for (i = 0; i < ancestors.length; i++) {
      ancestor = ancestors[i];
      if (ancestor === method_owner || ancestor.$$cloned_from.indexOf(method_owner) !== -1) {
        current_index = i;
        break;
      }
    }

    for (i = current_index + 1; i < ancestors.length; i++) {
      ancestor = ancestors[i];
      var proto = ancestor.$$prototype;

      if (proto.hasOwnProperty('$$dummy')) {
        proto = proto.$$define_methods_on;
      }

      if (proto.hasOwnProperty(jsid)) {
        super_method = proto[jsid];
        break;
      }
    }

    if (!defcheck && super_method && super_method.$$stub && obj.$method_missing.$$pristine) {
      // method_missing hasn't been explicitly defined
      $raise(Opal.NoMethodError, 'super: no superclass method `'+mid+"' for "+obj, mid);
    }

    return (super_method.$$stub && !allow_stubs) ? null : super_method;
  };

  // Iter dispatcher for super in a block
  Opal.find_block_super = function(obj, jsid, current_func, defcheck, implicit) {
    var call_jsid = jsid;

    if (!current_func) {
      $raise(Opal.RuntimeError, "super called outside of method");
    }

    if (implicit && current_func.$$define_meth) {
      $raise(Opal.RuntimeError,
        "implicit argument passing of super from method defined by define_method() is not supported. " +
        "Specify all arguments explicitly"
      );
    }

    if (current_func.$$def) {
      call_jsid = current_func.$$jsid;
    }

    return Opal.find_super(obj, call_jsid, current_func, defcheck);
  };

  // @deprecated
  Opal.find_super_dispatcher = Opal.find_super;

  // @deprecated
  Opal.find_iter_super_dispatcher = Opal.find_block_super;

  function call_lambda(block, arg, ret) {
    try {
      block(arg);
    } catch (e) {
      if (e === ret) {
        return ret.$v;
      }
      throw e;
    }
  }

  // handles yield calls for 1 yielded arg
  Opal.yield1 = function(block, arg) {
    if (typeof(block) !== "function") {
      $raise(Opal.LocalJumpError, "no block given");
    }

    var has_mlhs = block.$$has_top_level_mlhs_arg,
        has_trailing_comma = block.$$has_trailing_comma_in_args,
        is_returning_lambda = block.$$is_lambda && block.$$ret;

    if (block.length > 1 || ((has_mlhs || has_trailing_comma) && block.length === 1)) {
      arg = Opal.to_ary(arg);
    }

    if ((block.length > 1 || (has_trailing_comma && block.length === 1)) && arg.$$is_array) {
      if (is_returning_lambda) {
        return call_lambda(block.apply.bind(block, null), arg, block.$$ret);
      }
      return block.apply(null, arg);
    }
    else {
      if (is_returning_lambda) {
        return call_lambda(block, arg, block.$$ret);
      }
      return block(arg);
    }
  };

  // handles yield for > 1 yielded arg
  Opal.yieldX = function(block, args) {
    if (typeof(block) !== "function") {
      $raise(Opal.LocalJumpError, "no block given");
    }

    if (block.length > 1 && args.length === 1) {
      if (args[0].$$is_array) {
        args = args[0];
      }
    }

    if (block.$$is_lambda && block.$$ret) {
      return call_lambda(block.apply.bind(block, null), args, block.$$ret);
    }
    return block.apply(null, args);
  };

  // Finds the corresponding exception match in candidates.  Each candidate can
  // be a value, or an array of values.  Returns null if not found.
  Opal.rescue = function(exception, candidates) {
    for (var i = 0; i < candidates.length; i++) {
      var candidate = candidates[i];

      if (candidate.$$is_array) {
        var result = Opal.rescue(exception, candidate);

        if (result) {
          return result;
        }
      }
      else if (candidate === Opal.JS.Error || candidate['$==='](exception)) {
        return candidate;
      }
    }

    return null;
  };

  Opal.is_a = function(object, klass) {
    if (klass != null && object.$$meta === klass || object.$$class === klass) {
      return true;
    }

    if (object.$$is_number && klass.$$is_number_class) {
      return (klass.$$is_integer_class) ? (object % 1) === 0 : true;
    }

    var ancestors = $ancestors(object.$$is_class ? Opal.get_singleton_class(object) : (object.$$meta || object.$$class));

    return ancestors.indexOf(klass) !== -1;
  };

  // Helpers for extracting kwsplats
  // Used for: { **h }
  Opal.to_hash = function(value) {
    if (value.$$is_hash) {
      return value;
    }
    else if (value['$respond_to?']('to_hash', true)) {
      var hash = value.$to_hash();
      if (hash.$$is_hash) {
        return hash;
      }
      else {
        $raise(Opal.TypeError, "Can't convert " + value.$$class +
          " to Hash (" + value.$$class + "#to_hash gives " + hash.$$class + ")");
      }
    }
    else {
      $raise(Opal.TypeError, "no implicit conversion of " + value.$$class + " into Hash");
    }
  };

  // Helpers for implementing multiple assignment
  // Our code for extracting the values and assigning them only works if the
  // return value is a JS array.
  // So if we get an Array subclass, extract the wrapped JS array from it

  // Used for: a, b = something (no splat)
  Opal.to_ary = function(value) {
    if (value.$$is_array) {
      return value;
    }
    else if (value['$respond_to?']('to_ary', true)) {
      var ary = value.$to_ary();
      if (ary === nil) {
        return [value];
      }
      else if (ary.$$is_array) {
        return ary;
      }
      else {
        $raise(Opal.TypeError, "Can't convert " + value.$$class +
          " to Array (" + value.$$class + "#to_ary gives " + ary.$$class + ")");
      }
    }
    else {
      return [value];
    }
  };

  // Used for: a, b = *something (with splat)
  Opal.to_a = function(value) {
    if (value.$$is_array) {
      // A splatted array must be copied
      return value.slice();
    }
    else if (value['$respond_to?']('to_a', true)) {
      var ary = value.$to_a();
      if (ary === nil) {
        return [value];
      }
      else if (ary.$$is_array) {
        return ary;
      }
      else {
        $raise(Opal.TypeError, "Can't convert " + value.$$class +
          " to Array (" + value.$$class + "#to_a gives " + ary.$$class + ")");
      }
    }
    else {
      return [value];
    }
  };

  // Used for extracting keyword arguments from arguments passed to
  // JS function.
  //
  // @param parameters [Array]
  // @return [Hash] or undefined
  //
  Opal.extract_kwargs = function(parameters) {
    var kwargs = parameters[parameters.length - 1];
    if (kwargs != null && Opal.respond_to(kwargs, '$to_hash', true)) {
      $splice(parameters, parameters.length - 1);
      return kwargs;
    }
  };

  // Used to get a list of rest keyword arguments. Method takes the given
  // keyword args, i.e. the hash literal passed to the method containing all
  // keyword arguments passed to method, as well as the used args which are
  // the names of required and optional arguments defined. This method then
  // just returns all key/value pairs which have not been used, in a new
  // hash literal.
  //
  // @param given_args [Hash] all kwargs given to method
  // @param used_args [Object<String: true>] all keys used as named kwargs
  // @return [Hash]
  //
  Opal.kwrestargs = function(given_args, used_args) {
    var map = new Map();

    Opal.hash_each(given_args, false, function(key, value) {
      if (!used_args[key]) {
        Opal.hash_put(map, key, value);
      }
      return [false, false];
    });

    return map;
  };

  function apply_blockopts(block, blockopts) {
    if (typeof(blockopts) === 'number') {
      block.$$arity = blockopts;
    }
    else if (typeof(blockopts) === 'object') {
      Object.assign(block, blockopts);
    }
  }

  // Optimization for a costly operation of prepending '$' to method names
  var jsid_cache = new Map();
  function $jsid(name) {
    var jsid = jsid_cache.get(name);
    if (!jsid) {
      jsid = '$' + name;
      jsid_cache.set(name, jsid);
    }
    return jsid;
  }
  Opal.jsid = $jsid;

  function $prepend(first, second) {
    if (!second.$$is_array) second = $slice(second);
    return [first].concat(second);
  }

  // Calls passed method on a ruby object with arguments and block:
  //
  // Can take a method or a method name.
  //
  // 1. When method name gets passed it invokes it by its name
  //    and calls 'method_missing' when object doesn't have this method.
  //    Used internally by Opal to invoke method that takes a block or a splat.
  // 2. When method (i.e. method body) gets passed, it doesn't trigger 'method_missing'
  //    because it doesn't know the name of the actual method.
  //    Used internally by Opal to invoke 'super'.
  //
  // @example
  //   var my_array = [1, 2, 3, 4]
  //   Opal.send(my_array, 'length')                    # => 4
  //   Opal.send(my_array, my_array.$length)            # => 4
  //
  //   Opal.send(my_array, 'reverse!')                  # => [4, 3, 2, 1]
  //   Opal.send(my_array, my_array['$reverse!']')      # => [4, 3, 2, 1]
  //
  // @param recv [Object] ruby object
  // @param method [Function, String] method body or name of the method
  // @param args [Array] arguments that will be passed to the method call
  // @param block [Function] ruby block
  // @param blockopts [Object, Number] optional properties to set on the block
  // @return [Object] returning value of the method call
  Opal.send = function(recv, method, args, block, blockopts) {
    var body;

    if (typeof(method) === 'function') {
      body = method;
      method = null;
    } else if (typeof(method) === 'string') {
      body = recv[$jsid(method)];
    } else {
      $raise(Opal.NameError, "Passed method should be a string or a function");
    }

    return Opal.send2(recv, body, method, args, block, blockopts);
  };

  Opal.send2 = function(recv, body, method, args, block, blockopts) {
    if (body == null && method != null && recv.$method_missing) {
      body = recv.$method_missing;
      args = $prepend(method, args);
    }

    apply_blockopts(block, blockopts);

    if (typeof block === 'function') body.$$p = block;
    return body.apply(recv, args);
  };

  Opal.refined_send = function(refinement_groups, recv, method, args, block, blockopts) {
    var i, j, k, ancestors, ancestor, refinements, refinement, refine_modules, refine_module, body;

    ancestors = get_ancestors(recv);

    // For all ancestors that there are, starting from the closest to the furthest...
    for (i = 0; i < ancestors.length; i++) {
      ancestor = Opal.id(ancestors[i]);

      // For all refinement groups there are, starting from the closest scope to the furthest...
      for (j = 0; j < refinement_groups.length; j++) {
        refinements = refinement_groups[j];

        // For all refinements there are, starting from the last `using` call to the furthest...
        for (k = refinements.length - 1; k >= 0; k--) {
          refinement = refinements[k];
          if (typeof refinement.$$refine_modules === 'undefined') continue;

          // A single module being given as an argument of the `using` call contains multiple
          // refinement modules
          refine_modules = refinement.$$refine_modules;

          // Does this module refine a given call for a given ancestor module?
          if (typeof refine_modules[ancestor] === 'undefined') continue;
          refine_module = refine_modules[ancestor];

          // Does this module define a method we want to call?
          if (typeof refine_module.$$prototype[$jsid(method)] !== 'undefined') {
            body = refine_module.$$prototype[$jsid(method)];
            return Opal.send2(recv, body, method, args, block, blockopts);
          }
        }
      }
    }

    return Opal.send(recv, method, args, block, blockopts);
  };

  Opal.lambda = function(block, blockopts) {
    block.$$is_lambda = true;

    apply_blockopts(block, blockopts);

    return block;
  };

  // Used to define methods on an object. This is a helper method, used by the
  // compiled source to define methods on special case objects when the compiler
  // can not determine the destination object, or the object is a Module
  // instance. This can get called by `Module#define_method` as well.
  //
  // ## Modules
  //
  // Any method defined on a module will come through this runtime helper.
  // The method is added to the module body, and the owner of the method is
  // set to be the module itself. This is used later when choosing which
  // method should show on a class if more than 1 included modules define
  // the same method. Finally, if the module is in `module_function` mode,
  // then the method is also defined onto the module itself.
  //
  // ## Classes
  //
  // This helper will only be called for classes when a method is being
  // defined indirectly; either through `Module#define_method`, or by a
  // literal `def` method inside an `instance_eval` or `class_eval` body. In
  // either case, the method is simply added to the class' prototype. A special
  // exception exists for `BasicObject` and `Object`. These two classes are
  // special because they are used in toll-free bridged classes. In each of
  // these two cases, extra work is required to define the methods on toll-free
  // bridged class' prototypes as well.
  //
  // ## Objects
  //
  // If a simple ruby object is the object, then the method is simply just
  // defined on the object as a singleton method. This would be the case when
  // a method is defined inside an `instance_eval` block.
  //
  // @param obj  [Object, Class] the actual obj to define method for
  // @param jsid [String] the JavaScript friendly method name (e.g. '$foo')
  // @param body [JS.Function] the literal JavaScript function used as method
  // @param blockopts [Object, Number] optional properties to set on the body
  // @return [null]
  //
  Opal.def = function(obj, jsid, body, blockopts) {
    apply_blockopts(body, blockopts);

    // Special case for a method definition in the
    // top-level namespace
    if (obj === Opal.top) {
      return Opal.defn(Opal.Object, jsid, body);
    }
    // if instance_eval is invoked on a module/class, it sets inst_eval_mod
    else if (!obj.$$eval && obj.$$is_a_module) {
      return Opal.defn(obj, jsid, body);
    }
    else {
      return Opal.defs(obj, jsid, body);
    }
  };

  // Define method on a module or class (see Opal.def).
  Opal.defn = function(module, jsid, body) {
    $deny_frozen_access(module);

    body.displayName = jsid;
    body.$$owner = module;

    var name = jsid.substr(1);

    var proto = module.$$prototype;
    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }
    $prop(proto, jsid, body);

    if (module.$$is_module) {
      if (module.$$module_function) {
        Opal.defs(module, jsid, body)
      }

      for (var i = 0, iclasses = module.$$iclasses, length = iclasses.length; i < length; i++) {
        var iclass = iclasses[i];
        $prop(iclass, jsid, body);
      }
    }

    var singleton_of = module.$$singleton_of;
    if (module.$method_added && !module.$method_added.$$stub && !singleton_of) {
      module.$method_added(name);
    }
    else if (singleton_of && singleton_of.$singleton_method_added && !singleton_of.$singleton_method_added.$$stub) {
      singleton_of.$singleton_method_added(name);
    }

    return name;
  };

  // Define a singleton method on the given object (see Opal.def).
  Opal.defs = function(obj, jsid, body, blockopts) {
    apply_blockopts(body, blockopts);

    if (obj.$$is_string || obj.$$is_number) {
      $raise(Opal.TypeError, "can't define singleton");
    }
    return Opal.defn(Opal.get_singleton_class(obj), jsid, body);
  };

  // Since JavaScript has no concept of modules, we create proxy classes
  // called `iclasses` that store copies of methods loaded. We need to
  // update them if we remove a method.
  function remove_method_from_iclasses(obj, jsid) {
    if (obj.$$is_module) {
      for (var i = 0, iclasses = obj.$$iclasses, length = iclasses.length; i < length; i++) {
        var iclass = iclasses[i];
        delete iclass[jsid];
      }
    }
  }

  // Called from #remove_method.
  Opal.rdef = function(obj, jsid) {
    if (!$has_own(obj.$$prototype, jsid)) {
      $raise(Opal.NameError, "method '" + jsid.substr(1) + "' not defined in " + obj.$name());
    }

    delete obj.$$prototype[jsid];

    remove_method_from_iclasses(obj, jsid);

    if (obj.$$is_singleton) {
      if (obj.$$prototype.$singleton_method_removed && !obj.$$prototype.$singleton_method_removed.$$stub) {
        obj.$$prototype.$singleton_method_removed(jsid.substr(1));
      }
    }
    else {
      if (obj.$method_removed && !obj.$method_removed.$$stub) {
        obj.$method_removed(jsid.substr(1));
      }
    }
  };

  // Called from #undef_method.
  Opal.udef = function(obj, jsid) {
    if (!obj.$$prototype[jsid] || obj.$$prototype[jsid].$$stub) {
      $raise(Opal.NameError, "method '" + jsid.substr(1) + "' not defined in " + obj.$name());
    }

    Opal.add_stub_for(obj.$$prototype, jsid);

    remove_method_from_iclasses(obj, jsid);

    if (obj.$$is_singleton) {
      if (obj.$$prototype.$singleton_method_undefined && !obj.$$prototype.$singleton_method_undefined.$$stub) {
        obj.$$prototype.$singleton_method_undefined(jsid.substr(1));
      }
    }
    else {
      if (obj.$method_undefined && !obj.$method_undefined.$$stub) {
        obj.$method_undefined(jsid.substr(1));
      }
    }
  };

  function is_method_body(body) {
    return (typeof(body) === "function" && !body.$$stub);
  }

  Opal.alias = function(obj, name, old) {
    var id     = $jsid(name),
        old_id = $jsid(old),
        body,
        alias;

    // Aliasing on main means aliasing on Object...
    if (typeof obj.$$prototype === 'undefined') {
      obj = Opal.Object;
    }

    body = obj.$$prototype[old_id];

    // When running inside #instance_eval the alias refers to class methods.
    if (obj.$$eval) {
      return Opal.alias(Opal.get_singleton_class(obj), name, old);
    }

    if (!is_method_body(body)) {
      var ancestor = obj.$$super;

      while (typeof(body) !== "function" && ancestor) {
        body     = ancestor[old_id];
        ancestor = ancestor.$$super;
      }

      if (!is_method_body(body) && obj.$$is_module) {
        // try to look into Object
        body = Opal.Object.$$prototype[old_id]
      }

      if (!is_method_body(body)) {
        $raise(Opal.NameError, "undefined method `" + old + "' for class `" + obj.$name() + "'")
      }
    }

    // If the body is itself an alias use the original body
    // to keep the max depth at 1.
    if (body.$$alias_of) body = body.$$alias_of;

    // We need a wrapper because otherwise properties
    // would be overwritten on the original body.
    alias = Opal.wrap_method_body(body);

    // Try to make the browser pick the right name
    alias.displayName  = name;
    alias.$$alias_of   = body;
    alias.$$alias_name = name;

    Opal.defn(obj, id, alias);

    return obj;
  };

  Opal.wrap_method_body = function(body) {
    var wrapped = function() {
      var block = wrapped.$$p;

      wrapped.$$p = null;

      return Opal.send(this, body, arguments, block);
    };

    // Assign the 'length' value with defineProperty because
    // in strict mode the property is not writable.
    // It doesn't work in older browsers (like Chrome 38), where
    // an exception is thrown breaking Opal altogether.
    try {
      Object.defineProperty(wrapped, 'length', { value: body.length });
    } catch (e) {}

    wrapped.$$arity           = body.$$arity == null ? body.length : body.$$arity;
    wrapped.$$parameters      = body.$$parameters;
    wrapped.$$source_location = body.$$source_location;

    return wrapped;
  };

  Opal.alias_gvar = function(new_name, old_name) {
    Object.defineProperty($gvars, new_name, {
      configurable: true,
      enumerable: true,
      get: function() {
        return $gvars[old_name];
      },
      set: function(new_value) {
        $gvars[old_name] = new_value;
      }
    });
    return nil;
  }

  Opal.alias_native = function(obj, name, native_name) {
    var id   = $jsid(name),
        body = obj.$$prototype[native_name];

    if (typeof(body) !== "function" || body.$$stub) {
      $raise(Opal.NameError, "undefined native method `" + native_name + "' for class `" + obj.$name() + "'")
    }

    Opal.defn(obj, id, body);

    return obj;
  };


  // Hashes
  // ------

  Opal.hash_init = function (_hash) {
    console.warn("DEPRECATION: Opal.hash_init is deprecated and is now a no-op.");
  }

  Opal.hash_clone = function(from_hash, to_hash) {
    to_hash.$$none = from_hash.$$none;
    to_hash.$$proc = from_hash.$$proc;

    return Opal.hash_each(from_hash, to_hash, function(key, value) {
      Opal.hash_put(to_hash, key, value);
      return [false, to_hash];
    });
  };

  Opal.hash_put = function(hash, key, value) {
    var type = typeof key;
    if (type === "string" || type === "symbol" || type === "number" || type === "boolean" || type === "bigint") {
      hash.set(key, value)
    } else if (key.$$is_string) {
      hash.set(key.valueOf(), value);
    } else {
      if (!hash.$$keys)
        hash.$$keys = new Map();

      var key_hash = key.$$is_string ? key.valueOf() : (hash.$$by_identity ? Opal.id(key) : key.$hash()),
          keys = hash.$$keys;

      if (!keys.has(key_hash)) {
        keys.set(key_hash, [key]);
        hash.set(key, value);
        return;
      }

      var objects = keys.get(key_hash),
          object;

      for (var i=0; i<objects.length; i++) {
        object = objects[i];
        if (key === object || key['$eql?'](object)) {
          hash.set(object, value);
          return;
        }
      }

      objects.push(key);
      hash.set(key, value);
    }
  };

  Opal.hash_get = function(hash, key) {
    var type = typeof key;
    if (type === "string" || type === "symbol" || type === "number" || type === "boolean" || type === "bigint") {
      return hash.get(key)
    } else if (hash.$$keys) {
      var key_hash = key.$$is_string ? key.valueOf() : (hash.$$by_identity ? Opal.id(key) : key.$hash()),
          objects = hash.$$keys.get(key_hash),
          object;

      if (objects !== undefined) {
        for (var i=0; i<objects.length; i++) {
          object = objects[i];
          if (key === object || key['$eql?'](object))
            return hash.get(object);
        }
      } else if (key.$$is_string) {
        return hash.get(key_hash);
      }
    } else if (key.$$is_string) {
      return hash.get(key.valueOf());
    }
  };

  function $hash_delete_stage2(hash, key) {
    var value = hash.get(key);
    if (value !== undefined) {
      hash.delete(key);
      return value;
    }
  }

  Opal.hash_delete = function(hash, key) {
    var type = typeof key
    if (type === "string" || type === "symbol" || type === "number" || type === "boolean" || type === "bigint") {
      return $hash_delete_stage2(hash, key);
    } else if (hash.$$keys) {
      var key_hash = key.$$is_string ? key.valueOf() : (hash.$$by_identity ? Opal.id(key) : key.$hash()),
          objects = hash.$$keys.get(key_hash),
          object;

      if (objects !== undefined) {
        for (var i=0; i<objects.length; i++) {
          object = objects[i];
          if (key === object || key['$eql?'](object)) {
            objects.splice(i, 1);
            if (objects.length === 0)
              hash.$$keys.delete(key_hash);
            return $hash_delete_stage2(hash, object);
          }
        }
      } else if (key.$$is_string) {
        return $hash_delete_stage2(hash, key_hash);
      }
    } else if (key.$$is_string) {
      return $hash_delete_stage2(hash, key.valueOf());
    }
  };

  Opal.hash_rehash = function(hash) {
    var keys = hash.$$keys;

    if (keys)
      keys.clear();

    Opal.hash_each(hash, false, function(key, value) {
      var type = typeof key;
      if (type === "string" || type === "symbol" || type === "number" || type === "boolean" || type === "bigint")
        return [false, false]; // nothing to rehash

      var key_hash = key.$$is_string ? key.valueOf() : (hash.$$by_identity ? Opal.id(key) : key.$hash());

      if (!keys)
        hash.$$keys = keys = new Map();

      if (!keys.has(key_hash)) {
        keys.set(key_hash, [key]);
        return [false, false];
      }

      var objects = keys.get(key_hash),
          objects_copy = (objects.length === 1) ? objects : $slice(objects),
          object;

      for (var i=0; i<objects_copy.length; i++) {
        object = objects_copy[i];
        if (key === object || key['$eql?'](object)) {
          // got a duplicate, remove it
          objects.splice(objects.indexOf(object), 1);
          hash.delete(object);
        }
      }

      objects.push(key);

      return [false, false]
    });

    return hash;
  };

  Opal.hash = function () {
    var arguments_length = arguments.length,
      args,
      hash,
      i,
      length,
      key,
      value;

    if (arguments_length === 1 && arguments[0].$$is_hash) {
      return arguments[0];
    }

    hash = new Map();

    if (arguments_length === 1) {
      args = arguments[0];

      if (arguments[0].$$is_array) {
        length = args.length;

        for (i = 0; i < length; i++) {
          if (args[i].length !== 2) {
            $raise(Opal.ArgumentError, 'value not of length 2: ' + args[i].$inspect());
          }

          key = args[i][0];
          value = args[i][1];

          Opal.hash_put(hash, key, value);
        }

        return hash;
      } else {
        args = arguments[0];
        for (key in args) {
          if ($has_own(args, key)) {
            value = args[key];

            Opal.hash_put(hash, key, value);
          }
        }

        return hash;
      }
    }

    if (arguments_length % 2 !== 0) {
      $raise(Opal.ArgumentError, 'odd number of arguments for Hash');
    }

    for (i = 0; i < arguments_length; i += 2) {
      key = arguments[i];
      value = arguments[i + 1];

      Opal.hash_put(hash, key, value);
    }

    return hash;
  };

  // A faster Hash creator for hashes that just use symbols and
  // strings as keys. The map and keys array can be constructed at
  // compile time, so they are just added here by the constructor
  // function.
  //
  Opal.hash2 = function(keys, smap) {
    console.warn("DEPRECATION: `Opal.hash2` is deprecated and will be removed in Opal 2.0. Use `new Map()` with an array of key/value pairs instead.");

    var hash = new Map();
    for (var i = 0, max = keys.length; i < max; i++) {
      hash.set(keys[i], smap[keys[i]]);
    }
    return hash;
  };

  Opal.hash_each = function (hash, dres, fun) {
    // dres = default result, returned if hash is empty
    // fun is called as fun(key, value) and must return a array with [break, result]
    // if break is true, iteration stops and result is returned
    // if break is false, iteration continues and eventually the last result is returned
    var res;
    for (var i = 0, entry, entries = Array.from(hash.entries()), l = entries.length; i < l; i++) {
      entry = entries[i];
      res = fun(entry[0], entry[1]);
      if (res[0]) return res[1];
    }
    return res ? res[1] : dres;
  };

  // Create a new range instance with first and last values, and whether the
  // range excludes the last value.
  //
  Opal.range = function(first, last, exc) {
    var range         = new Opal.Range();
        range.begin   = first;
        range.end     = last;
        range.excl    = exc;

    return range;
  };

  var reserved_ivar_names = [
    // properties
    "constructor", "displayName", "__count__", "__noSuchMethod__",
    "__parent__", "__proto__",
    // methods
    "hasOwnProperty", "valueOf"
  ];

  // Get the ivar name for a given name.
  // Mostly adds a trailing $ to reserved names.
  //
  Opal.ivar = function(name) {
    if (reserved_ivar_names.indexOf(name) !== -1) {
      name += "$";
    }

    return name;
  };

  // Support for #freeze
  // -------------------

  // helper that can be used from methods
  function $deny_frozen_access(obj) {
    if (obj.$$frozen) {
      $raise(Opal.FrozenError, "can't modify frozen " + (obj.$class()) + ": " + (obj), new Map([["receiver", obj]]));
    }
  };
  Opal.deny_frozen_access = $deny_frozen_access;

  // common #freeze runtime support
  Opal.freeze = function(obj) {
    $prop(obj, "$$frozen", true);

    // set $$id
    if (!obj.hasOwnProperty('$$id')) { $prop(obj, '$$id', $uid()); }

    if (obj.hasOwnProperty('$$meta')) {
      // freeze $$meta if it has already been set
      obj.$$meta.$freeze();
    } else {
      // ensure $$meta can be set lazily, $$meta is frozen when set in runtime.js
      $prop(obj, '$$meta', null);
    }

    // $$comparable is used internally and set multiple times
    // defining it before sealing ensures it can be modified later on
    if (!obj.hasOwnProperty('$$comparable')) { $prop(obj, '$$comparable', null); }

    // seal the Object
    Object.seal(obj);

    return obj;
  };

  // Iterate over every instance variable and call func for each one
  // giving name of the ivar and optionally the property descriptor.
  function $each_ivar(obj, func) {
    var own_props = Object.getOwnPropertyNames(obj), own_props_length = own_props.length, i, prop, desc;

    for(i = 0; i < own_props_length; i++) {
      prop = own_props[i];

      if (prop[0] === '$') continue;

      desc = Object.getOwnPropertyDescriptor(obj, prop);

      if (desc && desc.enumerable) {
        func(prop, desc);
      }
    }
  }

  Opal.each_ivar = $each_ivar;

  // freze props, make setters of instance variables throw FrozenError
  Opal.freeze_props = function(obj) {
    var dp_template = {
      get: null,
      set: function(_val) { $deny_frozen_access(obj); },
      enumerable: true
    };

    $each_ivar(obj, function(prop, desc) {
      if (!desc.writable) return;

      // Redefine a property with a setter that raises an error.
      dp_template.get = $return_val(desc.value);

      Object.defineProperty(obj, prop, dp_template);
    });
  };

  // Regexps
  // -------

  // Escape Regexp special chars letting the resulting string be used to build
  // a new Regexp.
  //
  Opal.escape_regexp = function(str) {
    return str.replace(/([-[\]\/{}()*+?.^$\\| ])/g, '\\$1')
              .replace(/[\n]/g, '\\n')
              .replace(/[\r]/g, '\\r')
              .replace(/[\f]/g, '\\f')
              .replace(/[\t]/g, '\\t');
  };

  // Create a global Regexp from a RegExp object and cache the result
  // on the object itself ($$g attribute).
  //
  Opal.global_regexp = function(pattern) {
    if (pattern.global) {
      return pattern; // RegExp already has the global flag
    }
    if (pattern.$$g == null) {
      pattern.$$g = new RegExp(pattern.source, (pattern.multiline ? 'gm' : 'g') + (pattern.ignoreCase ? 'i' : ''));
    } else {
      pattern.$$g.lastIndex = null; // reset lastIndex property
    }
    return pattern.$$g;
  };

  // Create a global multiline Regexp from a RegExp object and cache the result
  // on the object itself ($$gm or $$g attribute).
  //
  Opal.global_multiline_regexp = function(pattern) {
    var result, flags;

    // RegExp already has the global and multiline flag
    if (pattern.global && pattern.multiline) return pattern;

    flags = 'gm' + (pattern.ignoreCase ? 'i' : '');
    if (pattern.multiline) {
      // we are using the $$g attribute because the Regexp is already multiline
      if (pattern.$$g == null) {
        pattern.$$g = new RegExp(pattern.source, flags);
      }
      result = pattern.$$g;
    } else {
      if (pattern.$$gm == null) {
        pattern.$$gm = new RegExp(pattern.source, flags);
      }
      result = pattern.$$gm;
    }
    result.lastIndex = null; // reset lastIndex property
    return result;
  };

  // Combine multiple regexp parts together
  Opal.regexp = function(parts, flags) {
    var part;
    var ignoreCase = typeof flags !== 'undefined' && flags && flags.indexOf('i') >= 0;

    for (var i = 0, ii = parts.length; i < ii; i++) {
      part = parts[i];
      if (part instanceof RegExp) {
        if (part.ignoreCase !== ignoreCase)
          Opal.Kernel.$warn(
            "ignore case doesn't match for " + part.source.$inspect(),
            new Map([['uplevel',  1]])
          )

        part = part.source;
      }
      if (part === '') part = '(?:' + part + ')';
      parts[i] = part;
    }

    if (flags) {
      return new RegExp(parts.join(''), flags);
    } else {
      return new RegExp(parts.join(''));
    }
  };

  // Require system
  // --------------

  Opal.modules         = {};
  Opal.loaded_features = ['corelib/runtime'];
  Opal.current_dir     = '.';
  Opal.require_table   = {'corelib/runtime': true};

  Opal.normalize = function(path) {
    var parts, part, new_parts = [], SEPARATOR = '/';

    if (Opal.current_dir !== '.') {
      path = Opal.current_dir.replace(/\/*$/, '/') + path;
    }

    path = path.replace(/^\.\//, '');
    path = path.replace(/\.(rb|opal|js)$/, '');
    parts = path.split(SEPARATOR);

    for (var i = 0, ii = parts.length; i < ii; i++) {
      part = parts[i];
      if (part === '') continue;
      (part === '..') ? new_parts.pop() : new_parts.push(part)
    }

    return new_parts.join(SEPARATOR);
  };

  Opal.loaded = function(paths) {
    var i, l, path;

    for (i = 0, l = paths.length; i < l; i++) {
      path = Opal.normalize(paths[i]);

      if (Opal.require_table[path]) {
        continue;
      }

      Opal.loaded_features.push(path);
      Opal.require_table[path] = true;
    }
  };

  Opal.load_normalized = function(path) {
    Opal.loaded([path]);

    var module = Opal.modules[path];

    if (module) {
      var retval = module(Opal);
      if (typeof Promise !== 'undefined' && retval instanceof Promise) {
        // A special case of require having an async top:
        // We will need to await it.
        return retval.then($return_val(true));
      }
    }
    else {
      var severity = Opal.config.missing_require_severity;
      var message  = 'cannot load such file -- ' + path;

      if (severity === "error") {
        $raise(Opal.LoadError, message);
      }
      else if (severity === "warning") {
        console.warn('WARNING: LoadError: ' + message);
      }
    }

    return true;
  };

  Opal.load = function(path) {
    path = Opal.normalize(path);

    return Opal.load_normalized(path);
  };

  Opal.require = function(path) {
    path = Opal.normalize(path);

    if (Opal.require_table[path]) {
      return false;
    }

    return Opal.load_normalized(path);
  };


  // Strings
  // -------

  Opal.encodings = Object.create(null);

  // Sets the encoding on a string, will treat string literals as frozen strings
  // raising a FrozenError.
  //
  // @param str [String] the string on which the encoding should be set
  // @param name [String] the canonical name of the encoding
  // @param type [String] possible values are either `"encoding"`, `"internal_encoding"`, or `undefined
  Opal.set_encoding = function(str, name, type) {
    if (typeof type === "undefined") type = "encoding";
    if (typeof str === 'string' || str.$$frozen === true)
      $raise(Opal.FrozenError, "can't modify frozen String");

    var encoding = Opal.find_encoding(name);

    if (encoding === str[type]) { return str; }

    str[type] = encoding;

    return str;
  };

  // Fetches the encoding for the given name or raises ArgumentError.
  Opal.find_encoding = function(name) {
    var register = Opal.encodings;
    var encoding = register[name] || register[name.toUpperCase()];
    if (!encoding) $raise(Opal.ArgumentError, "unknown encoding name - " + name);
    return encoding;
  }

  // @returns a String object with the encoding set from a string literal
  Opal.enc = function(str, name) {
    var dup = new String(str);
    dup = Opal.set_encoding(dup, name);
    dup.internal_encoding = dup.encoding;
    return dup
  }

  // @returns a String object with the internal encoding set to Binary
  Opal.binary = function(str) {
    var dup = new String(str);
    return Opal.set_encoding(dup, "binary", "internal_encoding");
  }

  Opal.last_promise = null;
  Opal.promise_unhandled_exception = false;

  // Run a block of code, but if it returns a Promise, don't run the next
  // one, but queue it.
  Opal.queue = function(proc) {
    if (Opal.last_promise) {
      // The async path is taken only if anything before returned a
      // Promise(V2).
      Opal.last_promise = Opal.last_promise.then(function() {
        if (!Opal.promise_unhandled_exception) return proc(Opal);
      })['catch'](function(error) {
        if (Opal.respond_to(error, '$full_message')) {
          error = error.$full_message();
        }
        console.error(error);
        // Abort further execution
        Opal.promise_unhandled_exception = true;
        Opal.exit(1);
      });
      return Opal.last_promise;
    }
    else {
      var ret = proc(Opal);
      if (typeof Promise === 'function' && typeof ret === 'object' && ret instanceof Promise) {
        Opal.last_promise = ret;
      }
      return ret;
    }
  }

  // Operator helpers
  // ----------------

  function are_both_numbers(l,r) { return typeof(l) === 'number' && typeof(r) === 'number' }

  Opal.rb_plus   = function(l,r) { return are_both_numbers(l,r) ? l + r : l['$+'](r); }
  Opal.rb_minus  = function(l,r) { return are_both_numbers(l,r) ? l - r : l['$-'](r); }
  Opal.rb_times  = function(l,r) { return are_both_numbers(l,r) ? l * r : l['$*'](r); }
  Opal.rb_divide = function(l,r) { return are_both_numbers(l,r) ? l / r : l['$/'](r); }
  Opal.rb_lt     = function(l,r) { return are_both_numbers(l,r) ? l < r : l['$<'](r); }
  Opal.rb_gt     = function(l,r) { return are_both_numbers(l,r) ? l > r : l['$>'](r); }
  Opal.rb_le     = function(l,r) { return are_both_numbers(l,r) ? l <= r : l['$<='](r); }
  Opal.rb_ge     = function(l,r) { return are_both_numbers(l,r) ? l >= r : l['$>='](r); }

  // Optimized helpers for calls like $truthy((a)['$==='](b)) -> $eqeqeq(a, b)
  function are_both_numbers_or_strings(lhs, rhs) {
    return (typeof lhs === 'number' && typeof rhs === 'number') ||
           (typeof lhs === 'string' && typeof rhs === 'string');
  }

  function $eqeq(lhs, rhs) {
    return are_both_numbers_or_strings(lhs,rhs) ? lhs === rhs : $truthy((lhs)['$=='](rhs));
  };
  Opal.eqeq = $eqeq;
  Opal.eqeqeq = function(lhs, rhs) {
    return are_both_numbers_or_strings(lhs,rhs) ? lhs === rhs : $truthy((lhs)['$==='](rhs));
  };
  Opal.neqeq = function(lhs, rhs) {
    return are_both_numbers_or_strings(lhs,rhs) ? lhs !== rhs : $truthy((lhs)['$!='](rhs));
  };
  Opal.not = function(arg) {
    if (undefined === arg || null === arg || false === arg || nil === arg) return true;
    if (true === arg || arg['$!'].$$pristine) return false;
    return $truthy(arg['$!']());
  }

  // Shortcuts - optimized function generators for simple kinds of functions
  function $return_val(arg) {
    return function() {
      return arg;
    }
  }
  Opal.return_val = $return_val;

  Opal.return_self = function() {
    return this;
  }
  Opal.return_ivar = function(ivar) {
    return function() {
      if (this[ivar] == null) { return nil; }
      return this[ivar];
    }
  }
  Opal.assign_ivar = function(ivar) {
    return function(val) {
      $deny_frozen_access(this);
      return this[ivar] = val;
    }
  }
  Opal.assign_ivar_val = function(ivar, static_val) {
    return function() {
      $deny_frozen_access(this);
      return this[ivar] = static_val;
    }
  }

  // Primitives for handling parameters
  Opal.ensure_kwargs = function(kwargs) {
    if (kwargs == null) {
      return new Map();
    } else if (kwargs.$$is_hash) {
      return kwargs;
    } else {
      $raise(Opal.ArgumentError, 'expected kwargs');
    }
  }

  Opal.get_kwarg = function(kwargs, key) {
    var kwarg = Opal.hash_get(kwargs, key);
    if (kwarg === undefined) {
      $raise(Opal.ArgumentError, 'missing keyword: '+key);
    }
    return kwarg;
  }

  // Arrays of size > 32 elements that contain only strings,
  // symbols, integers and nils are compiled as a self-extracting
  // string.
  Opal.large_array_unpack = function(str) {
    var array = str.split(","), length = array.length, i;
    for (i = 0; i < length; i++) {
      switch(array[i][0]) {
        case undefined:
          array[i] = nil
          break;
        case '-':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          array[i] = +array[i];
      }
    }
    return array;
  }

  // Opal32-checksum algorithm for #hash
  // -----------------------------------
  Opal.opal32_init = $return_val(0x4f70616c);

  function $opal32_ror(n, d) {
    return (n << d)|(n >>> (32 - d));
  };

  Opal.opal32_add = function(hash, next) {
    hash ^= next;
    hash = $opal32_ror(hash, 1);
    return hash;
  };

  // Initialization
  // --------------
  Opal.BasicObject = BasicObject = $allocate_class('BasicObject', null);
  Opal.Object      = _Object     = $allocate_class('Object', Opal.BasicObject);
  Opal.Module      = Module      = $allocate_class('Module', Opal.Object);
  Opal.Class       = Class       = $allocate_class('Class', Opal.Module);
  Opal.Opal        = _Opal       = $allocate_module('Opal');
  Opal.Kernel      = Kernel      = $allocate_module('Kernel');

  $set_proto(Opal.BasicObject, Opal.Class.$$prototype);
  $set_proto(Opal.Object, Opal.Class.$$prototype);
  $set_proto(Opal.Module, Opal.Class.$$prototype);
  $set_proto(Opal.Class, Opal.Class.$$prototype);

  // BasicObject can reach itself, avoid const_set to skip the $$base_module logic
  BasicObject.$$const.BasicObject = BasicObject;

  // Assign basic constants
  $const_set(_Object, "BasicObject",  BasicObject);
  $const_set(_Object, "Object",       _Object);
  $const_set(_Object, "Module",       Module);
  $const_set(_Object, "Class",        Class);
  $const_set(_Object, "Opal",         _Opal);
  $const_set(_Object, "Kernel",       Kernel);

  // Fix booted classes to have correct .class value
  BasicObject.$$class = Class;
  _Object.$$class     = Class;
  Module.$$class      = Class;
  Class.$$class       = Class;
  _Opal.$$class       = Module;
  Kernel.$$class      = Module;

  // Forward .toString() to #to_s
  $prop(_Object.$$prototype, 'toString', function() {
    var to_s = this.$to_s();
    if (to_s.$$is_string && typeof(to_s) === 'object') {
      // a string created using new String('string')
      return to_s.valueOf();
    } else {
      return to_s;
    }
  });

  // Make Kernel#require immediately available as it's needed to require all the
  // other corelib files.
  $prop(_Object.$$prototype, '$require', Opal.require);

  // Instantiate the main object
  Opal.top = new _Object();
  Opal.top.$to_s = Opal.top.$inspect = $return_val('main');
  Opal.top.$define_method = top_define_method;

  // Foward calls to define_method on the top object to Object
  function top_define_method() {
    var block = top_define_method.$$p;
    top_define_method.$$p = null;
    return Opal.send(_Object, 'define_method', arguments, block)
  };

  // Nil
  Opal.NilClass = $allocate_class('NilClass', Opal.Object);
  $const_set(_Object, 'NilClass', Opal.NilClass);
  nil = Opal.nil = new Opal.NilClass();
  nil.$$id = nil_id;
  nil.call = nil.apply = function() { $raise(Opal.LocalJumpError, 'no block given'); };
  nil.$$frozen = true;
  nil.$$comparable = false;
  Object.seal(nil);

  Opal.thrower = function(type) {
    var thrower = {
      $thrower_type: type,
      $throw: function(value, called_from_lambda) {
        if (value == null) value = nil;
        if (this.is_orphan && !called_from_lambda) {
          $raise(Opal.LocalJumpError, 'unexpected ' + type, value, type.$to_sym());
        }
        this.$v = value;
        throw this;
      },
      is_orphan: false
    }
    return thrower;
  };

  // Define a "$@" global variable, which would compute and return a backtrace on demand.
  Object.defineProperty($gvars, "@", {
    enumerable: true,
    configurable: true,
    get: function() {
      if ($truthy($gvars["!"])) return $gvars["!"].$backtrace();
      return nil;
    },
    set: function(bt) {
      if ($truthy($gvars["!"]))
        $gvars["!"].$set_backtrace(bt);
      else
        $raise(Opal.ArgumentError, "$! not set");
    }
  });

  Opal.t_eval_return = Opal.thrower("return");

  TypeError.$$super = Error;

  // If enable-file-source-embed compiler option is enabled, each module loaded will add its
  // sources to this object
  Opal.file_sources = {};
}).call(this);
Opal.loaded(["corelib/runtime.js"]);
Opal.modules["corelib/helpers"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $type_error = Opal.type_error, $coerce_to = Opal.coerce_to, $module = Opal.module, $defs = Opal.defs, $slice = Opal.slice, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $truthy = Opal.truthy, $Opal = Opal.Opal, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('===,raise,respond_to?,nil?,__send__,<=>,class,coerce_to!,new,to_s,__id__');
  return (function($base) {
    var self = $module($base, 'Opal');

    
    
    $defs(self, '$bridge', function $$bridge(constructor, klass) {
      
      return Opal.bridge(constructor, klass);
    });
    $defs(self, '$coerce_to!', function $Opal_coerce_to$excl$1(object, type, method, $a) {
      var $post_args, args, coerced = nil;

      
      $post_args = $slice(arguments, 3);
      args = $post_args;
      coerced = $coerce_to(object, type, method, args);
      if (!$eqeqeq(type, coerced)) {
        $Kernel.$raise($type_error(object, type, method, coerced))
      };
      return coerced;
    }, -4);
    $defs(self, '$coerce_to?', function $Opal_coerce_to$ques$2(object, type, method, $a) {
      var $post_args, args, coerced = nil;

      
      $post_args = $slice(arguments, 3);
      args = $post_args;
      if (!$truthy(object['$respond_to?'](method))) {
        return nil
      };
      coerced = $coerce_to(object, type, method, args);
      if ($truthy(coerced['$nil?']())) {
        return nil
      };
      if (!$eqeqeq(type, coerced)) {
        $Kernel.$raise($type_error(object, type, method, coerced))
      };
      return coerced;
    }, -4);
    $defs(self, '$try_convert', function $$try_convert(object, type, method) {
      
      
      if ($eqeqeq(type, object)) {
        return object
      };
      if ($truthy(object['$respond_to?'](method))) {
        return object.$__send__(method)
      } else {
        return nil
      };
    });
    $defs(self, '$compare', function $$compare(a, b) {
      var compare = nil;

      
      compare = a['$<=>'](b);
      if ($truthy(compare === nil)) {
        $Kernel.$raise($$$('ArgumentError'), "comparison of " + (a.$class()) + " with " + (b.$class()) + " failed")
      };
      return compare;
    });
    $defs(self, '$destructure', function $$destructure(args) {
      
      
      if (args.length == 1) {
        return args[0];
      }
      else if (args.$$is_array) {
        return args;
      }
      else {
        var args_ary = new Array(args.length);
        for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }

        return args_ary;
      }
    
    });
    $defs(self, '$respond_to?', function $Opal_respond_to$ques$3(obj, method, include_all) {
      
      
      if (include_all == null) include_all = false;
      
      if (obj == null || !obj.$$class) {
        return false;
      }
    ;
      return obj['$respond_to?'](method, include_all);
    }, -3);
    $defs(self, '$instance_variable_name!', function $Opal_instance_variable_name$excl$4(name) {
      
      
      name = $Opal['$coerce_to!'](name, $$$('String'), "to_str");
      if (!$truthy(/^@[a-zA-Z_][a-zA-Z0-9_]*?$/.test(name))) {
        $Kernel.$raise($$$('NameError').$new("'" + (name) + "' is not allowed as an instance variable name", name))
      };
      return name;
    });
    $defs(self, '$class_variable_name!', function $Opal_class_variable_name$excl$5(name) {
      
      
      name = $Opal['$coerce_to!'](name, $$$('String'), "to_str");
      if ($truthy(name.length < 3 || name.slice(0,2) !== '@@')) {
        $Kernel.$raise($$$('NameError').$new("`" + (name) + "' is not allowed as a class variable name", name))
      };
      return name;
    });
    $defs(self, '$const_name?', function $Opal_const_name$ques$6(const_name) {
      
      
      if (typeof const_name !== 'string') {
        (const_name = $Opal['$coerce_to!'](const_name, $$$('String'), "to_str"))
      }

      return const_name[0] === const_name[0].toUpperCase()
    
    });
    $defs(self, '$const_name!', function $Opal_const_name$excl$7(const_name) {
      var $a, self = this;

      
      if ($truthy((($a = $$$('::', 'String', 'skip_raise')) ? 'constant' : nil))) {
        const_name = $Opal['$coerce_to!'](const_name, $$$('String'), "to_str")
      };
      
      if (!const_name || const_name[0] != const_name[0].toUpperCase()) {
        self.$raise($$$('NameError'), "wrong constant name " + (const_name))
      }
    ;
      return const_name;
    });
    $defs(self, '$pristine', function $$pristine(owner_class, $a) {
      var $post_args, method_names;

      
      $post_args = $slice(arguments, 1);
      method_names = $post_args;
      
      var method_name, method;
      for (var i = method_names.length - 1; i >= 0; i--) {
        method_name = method_names[i];
        method = owner_class.$$prototype[Opal.jsid(method_name)];

        if (method && !method.$$stub) {
          method.$$pristine = true;
        }
      }
    ;
      return nil;
    }, -2);
    var inspect_stack = [];
    return $defs(self, '$inspect', function $$inspect(value) {
      var e = nil;

      
      ;
      var pushed = false;
      
      return (function() { try {
      try {
        
        
        if (value === null) {
          // JS null value
          return 'null';
        }
        else if (value === undefined) {
          // JS undefined value
          return 'undefined';
        }
        else if (typeof value.$$class === 'undefined') {
          // JS object / other value that is not bridged
          return Object.prototype.toString.apply(value);
        }
        else if (typeof value.$inspect !== 'function' || value.$inspect.$$stub) {
          // BasicObject and friends
          return "#<" + (value.$$class) + ":0x" + (value.$__id__().$to_s(16)) + ">"
        }
        else if (inspect_stack.indexOf(value.$__id__()) !== -1) {
          // inspect recursing inside inspect to find out about the
          // same object
          return "#<" + (value.$$class) + ":0x" + (value.$__id__().$to_s(16)) + ">"
        }
        else {
          // anything supporting Opal
          inspect_stack.push(value.$__id__());
          pushed = true;
          return value.$inspect();
        }
      ;
        return nil;
      } catch ($err) {
        if (Opal.rescue($err, [$$$('Exception')])) {(e = $err)
          try {
            return "#<" + (value.$$class) + ":0x" + (value.$__id__().$to_s(16)) + ">"
          } finally { Opal.pop_exception($err); }
        } else { throw $err; }
      }
      } finally {
        if (pushed) inspect_stack.pop()
      }; })();;
    }, -1);
  })('::')
};

Opal.modules["corelib/module"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $const_set = Opal.const_set, $Object = Opal.Object, $return_ivar = Opal.return_ivar, $assign_ivar = Opal.assign_ivar, $ivar = Opal.ivar, $deny_frozen_access = Opal.deny_frozen_access, $freeze = Opal.freeze, $prop = Opal.prop, $jsid = Opal.jsid, $each_ivar = Opal.each_ivar, $klass = Opal.klass, $Opal = Opal.Opal, $Kernel = Opal.Kernel, $defs = Opal.defs, $send = Opal.send, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $Module = Opal.Module, $rb_lt = Opal.rb_lt, $rb_gt = Opal.rb_gt, $slice = Opal.slice, $to_a = Opal.to_a, $return_val = Opal.return_val, $eqeq = Opal.eqeq, $not = Opal.not, $rb_le = Opal.rb_le, $range = Opal.range, $send2 = Opal.send2, $find_super = Opal.find_super, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('try_convert,raise,class,module_eval,to_proc,===,equal?,<,>,nil?,attr_reader,attr_writer,warn,attr_accessor,const_name?,class_variable_name!,pristine,const_name!,=~,new,inject,split,const_get,==,start_with?,!~,owner,!,<=,frozen?,append_features,included,name,cover?,size,merge,compile,proc,any?,prepend_features,prepended,to_s,__id__,constants,include?,copy_class_variables,copy_constants,copy_singleton_methods,class_exec,module_exec,inspect');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Module');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    function ensure_symbol_or_string(name) {
      if (name.$$is_string) {
        return name;
      };
      var converted_name = $Opal.$try_convert(name, $$$('String'), "to_str");
      if (converted_name.$$is_string) {
        return converted_name;
      } else if (converted_name === nil) {
        $Kernel.$raise($$$('TypeError'), "" + (name) + " is not a symbol nor a string")
      } else {
        $Kernel.$raise($$$('TypeError'), "can't convert " + ((name).$class()) + " to String (" + ((name).$class()) + "#to_str gives " + ((converted_name).$class()))
      }
    }
  ;
    $defs(self, '$allocate', function $$allocate() {
      var self = this;

      
      var module = Opal.allocate_module(nil, function(){});
      // Link the prototype of Module subclasses
      if (self !== Opal.Module) Object.setPrototypeOf(module, self.$$prototype);
      return module;
    
    });
    
    $def(self, '$initialize', function $$initialize() {
      var block = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      ;
      if ((block !== nil)) {
        return $send(self, 'module_eval', [], block.$to_proc())
      } else {
        return nil
      };
    });
    
    $def(self, '$===', function $Module_$eq_eq_eq$1(object) {
      var self = this;

      
      if ($truthy(object == null)) {
        return false
      };
      return Opal.is_a(object, self);;
    });
    
    $def(self, '$<', function $Module_$lt$2(other) {
      var self = this;

      
      if (!$eqeqeq($Module, other)) {
        $Kernel.$raise($$$('TypeError'), "compared with non class/module")
      };
      
      var working = self,
          ancestors,
          i, length;

      if (working === other) {
        return false;
      }

      for (i = 0, ancestors = Opal.ancestors(self), length = ancestors.length; i < length; i++) {
        if (ancestors[i] === other) {
          return true;
        }
      }

      for (i = 0, ancestors = Opal.ancestors(other), length = ancestors.length; i < length; i++) {
        if (ancestors[i] === self) {
          return false;
        }
      }

      return nil;
    ;
    });
    
    $def(self, '$<=', function $Module_$lt_eq$3(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self['$equal?'](other)))) {
        return $ret_or_1
      } else {
        return $rb_lt(self, other)
      }
    });
    
    $def(self, '$>', function $Module_$gt$4(other) {
      var self = this;

      
      if (!$eqeqeq($Module, other)) {
        $Kernel.$raise($$$('TypeError'), "compared with non class/module")
      };
      return $rb_lt(other, self);
    });
    
    $def(self, '$>=', function $Module_$gt_eq$5(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self['$equal?'](other)))) {
        return $ret_or_1
      } else {
        return $rb_gt(self, other)
      }
    });
    
    $def(self, '$<=>', function $Module_$lt_eq_gt$6(other) {
      var self = this, lt = nil;

      
      
      if (self === other) {
        return 0;
      }
    ;
      if (!$eqeqeq($Module, other)) {
        return nil
      };
      lt = $rb_lt(self, other);
      if ($truthy(lt['$nil?']())) {
        return nil
      };
      if ($truthy(lt)) {
        return -1
      } else {
        return 1
      };
    });
    
    $def(self, '$alias_method', function $$alias_method(newname, oldname) {
      var self = this;

      
      $deny_frozen_access(self);
      newname = $coerce_to(newname, $$$('String'), 'to_str');
      oldname = $coerce_to(oldname, $$$('String'), 'to_str');
      Opal.alias(self, newname, oldname);
      return self;
    });
    
    $def(self, '$alias_native', function $$alias_native(mid, jsid) {
      var self = this;

      
      if (jsid == null) jsid = mid;
      $deny_frozen_access(self);
      Opal.alias_native(self, mid, jsid);
      return self;
    }, -2);
    
    $def(self, '$ancestors', function $$ancestors() {
      var self = this;

      return Opal.ancestors(self);
    });
    
    $def(self, '$append_features', function $$append_features(includer) {
      var self = this;

      
      $deny_frozen_access(includer);
      Opal.append_features(self, includer);
      return self;
    });
    
    $def(self, '$attr_accessor', function $$attr_accessor($a) {
      var $post_args, names, self = this;

      
      $post_args = $slice(arguments);
      names = $post_args;
      $send(self, 'attr_reader', $to_a(names));
      return $send(self, 'attr_writer', $to_a(names));
    }, -1);
    
    $def(self, '$attr', function $$attr($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      
      if (args.length == 2 && (args[1] === true || args[1] === false)) {
        self.$warn("optional boolean argument is obsoleted", (new Map([["uplevel", 1]])))

        args[1] ? self.$attr_accessor(args[0]) : self.$attr_reader(args[0]);
        return nil;
      }
    ;
      return $send(self, 'attr_reader', $to_a(args));
    }, -1);
    
    $def(self, '$attr_reader', function $$attr_reader($a) {
      var $post_args, names, self = this;

      
      $post_args = $slice(arguments);
      names = $post_args;
      
      $deny_frozen_access(self);

      var proto = self.$$prototype;

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i],
            id   = $jsid(name),
            ivar = $ivar(name);

        var body = $return_ivar(ivar);

        // initialize the instance variable as nil
        Opal.prop(proto, ivar, nil);

        body.$$parameters = [];
        body.$$arity = 0;

        Opal.defn(self, id, body);
      }
    ;
      return nil;
    }, -1);
    
    $def(self, '$attr_writer', function $$attr_writer($a) {
      var $post_args, names, self = this;

      
      $post_args = $slice(arguments);
      names = $post_args;
      
      $deny_frozen_access(self);

      var proto = self.$$prototype;

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i],
            id   = $jsid(name + '='),
            ivar = $ivar(name);

        var body = $assign_ivar(ivar)

        body.$$parameters = [['req']];
        body.$$arity = 1;

        // initialize the instance variable as nil
        Opal.prop(proto, ivar, nil);

        Opal.defn(self, id, body);
      }
    ;
      return nil;
    }, -1);
    
    $def(self, '$autoload', function $$autoload(const$, path) {
      var self = this;

      
      $deny_frozen_access(self);

      if (!$$('Opal')['$const_name?'](const$)) {
        $Kernel.$raise($$$('NameError'), "autoload must be constant name: " + (const$))
      }

      if (path == "") {
        $Kernel.$raise($$$('ArgumentError'), "empty file name")
      }

      if (!self.$$const.hasOwnProperty(const$)) {
        if (!self.$$autoload) {
          self.$$autoload = {};
        }
        Opal.const_cache_version++;
        self.$$autoload[const$] = { path: path, loaded: false, required: false, success: false, exception: false };

        if (self.$const_added && !self.$const_added.$$pristine) {
          self.$const_added(const$);
        }
      }
      return nil;
    
    });
    
    $def(self, '$autoload?', function $Module_autoload$ques$7(const$) {
      var self = this;

      
      if (self.$$autoload && self.$$autoload[const$] && !self.$$autoload[const$].required && !self.$$autoload[const$].success) {
        return self.$$autoload[const$].path;
      }

      var ancestors = self.$ancestors();

      for (var i = 0, length = ancestors.length; i < length; i++) {
        if (ancestors[i].$$autoload && ancestors[i].$$autoload[const$] && !ancestors[i].$$autoload[const$].required && !ancestors[i].$$autoload[const$].success) {
          return ancestors[i].$$autoload[const$].path;
        }
      }
      return nil;
    
    });
    
    $def(self, '$class_variables', function $$class_variables() {
      var self = this;

      return Object.keys(Opal.class_variables(self));
    });
    
    $def(self, '$class_variable_get', function $$class_variable_get(name) {
      var self = this;

      
      name = $Opal['$class_variable_name!'](name);
      return Opal.class_variable_get(self, name, false);;
    });
    
    $def(self, '$class_variable_set', function $$class_variable_set(name, value) {
      var self = this;

      
      $deny_frozen_access(self);
      name = $Opal['$class_variable_name!'](name);
      return Opal.class_variable_set(self, name, value);;
    });
    
    $def(self, '$class_variable_defined?', function $Module_class_variable_defined$ques$8(name) {
      var self = this;

      
      name = $Opal['$class_variable_name!'](name);
      return Opal.class_variables(self).hasOwnProperty(name);;
    });
    
    $def(self, '$const_added', $return_val(nil));
    $Opal.$pristine(self, "const_added");
    
    $def(self, '$remove_class_variable', function $$remove_class_variable(name) {
      var self = this;

      
      $deny_frozen_access(self);
      name = $Opal['$class_variable_name!'](name);
      
      if (Opal.hasOwnProperty.call(self.$$cvars, name)) {
        var value = self.$$cvars[name];
        delete self.$$cvars[name];
        return value;
      } else {
        $Kernel.$raise($$$('NameError'), "cannot remove " + (name) + " for " + (self))
      }
    ;
    });
    
    $def(self, '$constants', function $$constants(inherit) {
      var self = this;

      
      if (inherit == null) inherit = true;
      return Opal.constants(self, inherit);;
    }, -1);
    $defs(self, '$constants', function $$constants(inherit) {
      var self = this;

      
      ;
      
      if (inherit == null) {
        var nesting = (self.$$nesting || []).concat($Object),
            constant, constants = {},
            i, ii;

        for(i = 0, ii = nesting.length; i < ii; i++) {
          for (constant in nesting[i].$$const) {
            constants[constant] = true;
          }
        }
        return Object.keys(constants);
      } else {
        return Opal.constants(self, inherit)
      }
    ;
    }, -1);
    $defs(self, '$nesting', function $$nesting() {
      var self = this;

      return self.$$nesting || [];
    });
    
    $def(self, '$const_defined?', function $Module_const_defined$ques$9(name, inherit) {
      var self = this;

      
      if (inherit == null) inherit = true;
      name = $$('Opal')['$const_name!'](name);
      if (!$truthy(name['$=~']($$$($Opal, 'CONST_NAME_REGEXP')))) {
        $Kernel.$raise($$$('NameError').$new("wrong constant name " + (name), name))
      };
      
      var module, modules = [self], module_constants, i, ii;

      // Add up ancestors if inherit is true
      if (inherit) {
        modules = modules.concat(Opal.ancestors(self));

        // Add Object's ancestors if it's a module – modules have no ancestors otherwise
        if (self.$$is_module) {
          modules = modules.concat([$Object]).concat(Opal.ancestors($Object));
        }
      }

      for (i = 0, ii = modules.length; i < ii; i++) {
        module = modules[i];
        if (module.$$const[name] != null) { return true; }
        if (
          module.$$autoload &&
          module.$$autoload[name] &&
          !module.$$autoload[name].required &&
          !module.$$autoload[name].success
        ) {
          return true;
        }
      }

      return false;
    ;
    }, -2);
    
    $def(self, '$const_get', function $$const_get(name, inherit) {
      var self = this;

      
      if (inherit == null) inherit = true;
      name = $$('Opal')['$const_name!'](name);
      
      if (name.indexOf('::') === 0 && name !== '::'){
        name = name.slice(2);
      }
    ;
      if ($truthy(name.indexOf('::') != -1 && name != '::')) {
        return $send(name.$split("::"), 'inject', [self], function $$10(o, c){
          
          if (o == null) o = nil;
          if (c == null) c = nil;
          return o.$const_get(c);})
      };
      if (!$truthy(name['$=~']($$$($Opal, 'CONST_NAME_REGEXP')))) {
        $Kernel.$raise($$$('NameError').$new("wrong constant name " + (name), name))
      };
      
      if (inherit) {
        return Opal.$$([self], name);
      } else {
        return Opal.const_get_local(self, name);
      }
    ;
    }, -2);
    
    $def(self, '$const_missing', function $$const_missing(name) {
      var self = this, full_const_name = nil;

      
      full_const_name = ($eqeq(self, $Object) ? (name) : ("" + (self) + "::" + (name)));
      return $Kernel.$raise($$$('NameError').$new("uninitialized constant " + (full_const_name), name));
    });
    
    $def(self, '$const_set', function $$const_set(name, value) {
      var self = this;

      
      $deny_frozen_access(self);
      name = $Opal['$const_name!'](name);
      if (($truthy(name['$!~']($$$($Opal, 'CONST_NAME_REGEXP'))) || ($truthy(name['$start_with?']("::"))))) {
        $Kernel.$raise($$$('NameError').$new("wrong constant name " + (name), name))
      };
      $const_set(self, name, value);
      return value;
    });
    
    $def(self, '$public_constant', $return_val(nil));
    
    $def(self, '$define_method', function $$define_method(name, method) {
      var block = $$define_method.$$p || nil, self = this, $ret_or_1 = nil, owner = nil, message = nil;

      $$define_method.$$p = null;
      
      ;
      ;
      
      $deny_frozen_access(self);

      if (method === undefined && block === nil)
        $Kernel.$raise($$$('ArgumentError'), "tried to create a Proc object without a block")

      name = ensure_symbol_or_string(name);
    ;
      if ($truthy(method !== undefined)) {
        
        block = ($eqeqeq($$$('Proc'), ($ret_or_1 = method)) ? (method) : ($eqeqeq($$$('Method'), $ret_or_1) ? (method.$to_proc().$$unbound) : ($eqeqeq($$$('UnboundMethod'), $ret_or_1) ? (Opal.wrap_method_body(method.$$method)) : ($Kernel.$raise($$$('TypeError'), "wrong argument type " + (method.$class()) + " (expected Proc/Method/UnboundMethod)")))));
        if ($truthy(!method.$$is_proc)) {
          
          owner = method.$owner();
          if (($truthy(owner.$$is_class) && ($not($rb_le(self, owner))))) {
            
            message = ($truthy(owner.$$is_singleton) ? ("can't bind singleton method to a different class") : ("bind argument must be a subclass of " + (owner)));
            $Kernel.$raise($$$('TypeError'), message);
          };
        };
      };
      
      if (typeof(Proxy) !== 'undefined') {
        var meta = Object.create(null)

        block.$$proxy_target = block
        block = new Proxy(block, {
          apply: function(target, self, args) {
            var old_name = target.$$jsid, old_lambda = target.$$is_lambda;
            target.$$jsid = name;
            target.$$is_lambda = true;
            try {
              return target.apply(self, args);
            } catch(e) {
              if (e === target.$$brk || e === target.$$ret) return e.$v;
              throw e;
            } finally {
              target.$$jsid = old_name;
              target.$$is_lambda = old_lambda;
            }
          }
        })
      }

      block.$$jsid        = name;
      block.$$s           = null;
      block.$$def         = block;
      block.$$define_meth = true;

      return Opal.defn(self, $jsid(name), block);
    ;
    }, -2);
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if ($truthy(self['$frozen?']())) {
        return self
      };
      
      if (!self.hasOwnProperty('$$base_module')) { $prop(self, '$$base_module', null); }

      return $freeze(self);
    ;
    });
    
    $def(self, '$remove_method', function $$remove_method($a) {
      var $post_args, names, self = this;

      
      $post_args = $slice(arguments);
      names = $post_args;
      
      for (var i = 0; i < names.length; i++) {
        var name = ensure_symbol_or_string(names[i]);
        $deny_frozen_access(self);

        Opal.rdef(self, "$" + name);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$singleton_class?', function $Module_singleton_class$ques$11() {
      var self = this;

      return !!self.$$is_singleton;
    });
    
    $def(self, '$include', function $$include($a) {
      var $post_args, mods, self = this;

      
      $post_args = $slice(arguments);
      mods = $post_args;
      
      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$append_features(self);
        (mod).$included(self);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$included_modules', function $$included_modules() {
      var self = this;

      return Opal.included_modules(self);
    });
    
    $def(self, '$include?', function $Module_include$ques$12(mod) {
      var self = this;

      
      if (!mod.$$is_module) {
        $Kernel.$raise($$$('TypeError'), "wrong argument type " + ((mod).$class()) + " (expected Module)");
      }

      var i, ii, mod2, ancestors = Opal.ancestors(self);

      for (i = 0, ii = ancestors.length; i < ii; i++) {
        mod2 = ancestors[i];
        if (mod2 === mod && mod2 !== self) {
          return true;
        }
      }

      return false;
    
    });
    
    $def(self, '$instance_method', function $$instance_method(name) {
      var self = this;

      
      var meth = self.$$prototype[$jsid(name)];

      if (!meth || meth.$$stub) {
        $Kernel.$raise($$$('NameError').$new("undefined method `" + (name) + "' for class `" + (self.$name()) + "'", name));
      }

      return $$$('UnboundMethod').$new(self, meth.$$owner || self, meth, name);
    
    });
    
    $def(self, '$instance_methods', function $$instance_methods(include_super) {
      var self = this;

      
      if (include_super == null) include_super = true;
      
      if ($truthy(include_super)) {
        return Opal.instance_methods(self);
      } else {
        return Opal.own_instance_methods(self);
      }
    ;
    }, -1);
    
    $def(self, '$included', $return_val(nil));
    
    $def(self, '$extended', $return_val(nil));
    
    $def(self, '$extend_object', function $$extend_object(object) {
      
      
      $deny_frozen_access(object);
      return nil;
    });
    
    $def(self, '$method_added', function $$method_added($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$method_removed', function $$method_removed($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$method_undefined', function $$method_undefined($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$module_eval', function $$module_eval($a) {
      var block = $$module_eval.$$p || nil, $post_args, args, $b, self = this, string = nil, file = nil, _lineno = nil, default_eval_options = nil, $ret_or_1 = nil, compiling_options = nil, compiled = nil;

      $$module_eval.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      if (($truthy(block['$nil?']()) && ($truthy(!!Opal.compile)))) {
        
        if (!$truthy($range(1, 3, false)['$cover?'](args.$size()))) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (0 for 1..3)")
        };
        $b = [].concat($to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;
        default_eval_options = (new Map([["file", ($truthy(($ret_or_1 = file)) ? ($ret_or_1) : ("(eval)"))], ["eval", true]]));
        compiling_options = (new Map([['arity_check', false]])).$merge(default_eval_options);
        compiled = $Opal.$compile(string, compiling_options);
        block = $send($Kernel, 'proc', [], function $$13(){var self = $$13.$$s == null ? this : $$13.$$s;

          return new Function("Opal,self", "return " + compiled)(Opal, self);}, {$$s: self});
      } else if ($truthy(args['$any?']())) {
        $Kernel.$raise($$$('ArgumentError'), "" + ("wrong number of arguments (" + (args.$size()) + " for 0)") + "\n\n  NOTE:If you want to enable passing a String argument please add \"require 'opal-parser'\" to your script\n")
      };
      
      var old = block.$$s,
          result;

      block.$$s = null;
      result = block.apply(self, [self]);
      block.$$s = old;

      return result;
    ;
    }, -1);
    
    $def(self, '$module_exec', function $$module_exec($a) {
      var block = $$module_exec.$$p || nil, $post_args, args, self = this;

      $$module_exec.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      
      if (block === nil) {
        $Kernel.$raise($$$('LocalJumpError'), "no block given")
      }

      var block_self = block.$$s, result;

      block.$$s = null;
      result = block.apply(self, args);
      block.$$s = block_self;

      return result;
    ;
    }, -1);
    
    $def(self, '$method_defined?', function $Module_method_defined$ques$14(method) {
      var self = this;

      
      var body = self.$$prototype[$jsid(method)];
      return (!!body) && !body.$$stub;
    
    });
    
    $def(self, '$module_function', function $$module_function($a) {
      var $post_args, methods, self = this;

      
      $post_args = $slice(arguments);
      methods = $post_args;
      
      $deny_frozen_access(self);

      if (methods.length === 0) {
        self.$$module_function = true;
        return nil;
      }
      else {
        for (var i = 0, length = methods.length; i < length; i++) {
          var meth = methods[i],
              id   = $jsid(meth),
              func = self.$$prototype[id];

          Opal.defs(self, id, func);
        }
        return methods.length === 1 ? methods[0] : methods;
      }

      return self;
    ;
    }, -1);
    
    $def(self, '$name', function $$name() {
      var self = this;

      
      if (self.$$full_name) {
        return self.$$full_name;
      }

      var result = [], base = self;

      while (base) {
        // Give up if any of the ancestors is unnamed
        if (base.$$name === nil || base.$$name == null) return nil;

        result.unshift(base.$$name);

        base = base.$$base_module;

        if (base === $Object) {
          break;
        }
      }

      if (result.length === 0) {
        return nil;
      }

      return self.$$full_name = result.join('::');
    
    });
    
    $def(self, '$prepend', function $$prepend($a) {
      var $post_args, mods, self = this;

      
      $post_args = $slice(arguments);
      mods = $post_args;
      
      if (mods.length === 0) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (given 0, expected 1+)")
      }

      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$prepend_features(self);
        (mod).$prepended(self);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$prepend_features', function $$prepend_features(prepender) {
      var self = this;

      
      
      $deny_frozen_access(prepender);

      if (!self.$$is_module) {
        $Kernel.$raise($$$('TypeError'), "wrong argument type " + (self.$class()) + " (expected Module)");
      }

      Opal.prepend_features(self, prepender)
    ;
      return self;
    });
    
    $def(self, '$prepended', $return_val(nil));
    
    $def(self, '$remove_const', function $$remove_const(name) {
      var self = this;

      
      $deny_frozen_access(self);
      return Opal.const_remove(self, name);;
    });
    
    $def(self, '$to_s', function $$to_s() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = Opal.Module.$name.call(self)))) {
        return $ret_or_1
      } else {
        return "#<" + (self.$$is_module ? 'Module' : 'Class') + ":0x" + (self.$__id__().$to_s(16)) + ">"
      }
    });
    
    $def(self, '$undef_method', function $$undef_method($a) {
      var $post_args, names, self = this;

      
      $post_args = $slice(arguments);
      names = $post_args;
      
      for (var i = 0; i < names.length; i++) {
        var name = ensure_symbol_or_string(names[i]);
        $deny_frozen_access(self);

        Opal.udef(self, "$" + name);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$instance_variables', function $$instance_variables() {
      var self = this, consts = nil;

      
      consts = (Opal.Module.$$nesting = $nesting, self.$constants());
      
      var result = [];

      $each_ivar(self, function(name) {
        if (name !== 'constructor' && !consts['$include?'](name)) {
          result.push('@' + name);
        }
      });

      return result;
    ;
    });
    
    function copyInstanceMethods(from, to) {
      var i, method_names = Opal.own_instance_methods(from);
      for (i = 0; i < method_names.length; i++) {
        var name = method_names[i],
            jsid = $jsid(name),
            body = from.$$prototype[jsid],
            wrapped = Opal.wrap_method_body(body);

        wrapped.$$jsid = name;
        Opal.defn(to, jsid, wrapped);
      }
    }

    function copyIncludedModules(from, to) {
      var modules = from.$$own_included_modules;
      for (var i = modules.length - 1; i >= 0; i--) {
        Opal.append_features(modules[i], to);
      }
    }

    function copyPrependedModules(from, to) {
      var modules = from.$$own_prepended_modules;
      for (var i = modules.length - 1; i >= 0; i--) {
        Opal.prepend_features(modules[i], to);
      }
    }
  ;
    
    $def(self, '$initialize_copy', function $$initialize_copy(other) {
      var self = this;

      
      
      copyInstanceMethods(other, self);
      copyIncludedModules(other, self);
      copyPrependedModules(other, self);
      self.$$cloned_from = other.$$cloned_from.concat(other);
    ;
      self.$copy_class_variables(other);
      return self.$copy_constants(other);
    });
    
    $def(self, '$initialize_dup', function $$initialize_dup(other) {
      var $yield = $$initialize_dup.$$p || nil, self = this;

      $$initialize_dup.$$p = null;
      
      $send2(self, $find_super(self, 'initialize_dup', $$initialize_dup, false, true), 'initialize_dup', [other], $yield);
      return self.$copy_singleton_methods(other);
    });
    
    $def(self, '$copy_class_variables', function $$copy_class_variables(other) {
      var self = this;

      
      for (var name in other.$$cvars) {
        self.$$cvars[name] = other.$$cvars[name];
      }
    
    });
    
    $def(self, '$copy_constants', function $$copy_constants(other) {
      var self = this;

      
      var name, other_constants = other.$$const;

      for (name in other_constants) {
        $const_set(self, name, other_constants[name]);
      }
    
    });
    
    $def(self, '$refine', function $$refine(klass) {
      var block = $$refine.$$p || nil, $a, self = this, refinement_module = nil, m = nil, klass_id = nil;

      $$refine.$$p = null;
      
      ;
      $a = [self, nil, nil], (refinement_module = $a[0]), (m = $a[1]), (klass_id = $a[2]), $a;
      
      klass_id = Opal.id(klass);
      if (typeof self.$$refine_modules === "undefined") {
        self.$$refine_modules = Object.create(null);
      }
      if (typeof self.$$refine_modules[klass_id] === "undefined") {
        m = self.$$refine_modules[klass_id] = $$$('Refinement').$new();
      }
      else {
        m = self.$$refine_modules[klass_id];
      }
      m.refinement_module = refinement_module
      m.refined_class = klass
    ;
      $send(m, 'class_exec', [], block.$to_proc());
      return m;
    });
    
    $def(self, '$refinements', function $$refinements() {
      var self = this;

      
      var refine_modules = self.$$refine_modules, hash = (new Map());;
      if (typeof refine_modules === "undefined") return hash;
      for (var id in refine_modules) {
        hash['$[]='](refine_modules[id].refined_class, refine_modules[id]);
      }
      return hash;
    
    });
    
    $def(self, '$using', function $$using(mod) {
      
      return $Kernel.$raise("Module#using is not permitted in methods")
    });
    $alias(self, "class_eval", "module_eval");
    $alias(self, "class_exec", "module_exec");
    return $alias(self, "inspect", "to_s");
  })('::', null, $nesting);
  return (function($base, $super) {
    var self = $klass($base, $super, 'Refinement');

    var $proto = self.$$prototype;

    $proto.refinement_module = $proto.refined_class = nil;
    
    self.$attr_reader("refined_class");
    return $def(self, '$inspect', function $$inspect() {
      var $yield = $$inspect.$$p || nil, self = this;

      $$inspect.$$p = null;
      if ($truthy(self.refinement_module)) {
        return "#<refinement:" + (self.refined_class.$inspect()) + "@" + (self.refinement_module.$inspect()) + ">"
      } else {
        return $send2(self, $find_super(self, 'inspect', $$inspect, false, true), 'inspect', [], $yield)
      }
    });
  })('::', $Module);
};

Opal.modules["corelib/class"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $send = Opal.send, $defs = Opal.defs, $def = Opal.def, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $eqeq = Opal.eqeq, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $return_val = Opal.return_val, $slice = Opal.slice, $send2 = Opal.send2, $find_super = Opal.find_super, $Kernel = Opal.Kernel, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,class_eval,to_proc,==,nil?,raise,class,copy_instance_variables,copy_singleton_methods,initialize_clone,frozen?,freeze,initialize_dup,+,subclasses,flatten,map,allocate,name,to_s');
  
  self.$require("corelib/module");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Class');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $defs(self, '$new', function $Class_new$1(superclass) {
      var block = $Class_new$1.$$p || nil;

      $Class_new$1.$$p = null;
      
      ;
      if (superclass == null) superclass = $$('Object');
      
      if (!superclass.$$is_class) {
        throw Opal.TypeError.$new("superclass must be a Class");
      }

      var klass = Opal.allocate_class(nil, superclass);
      superclass.$inherited(klass);
      ((block !== nil) ? ($send((klass), 'class_eval', [], block.$to_proc())) : nil)
      return klass;
    ;
    }, -1);
    
    $def(self, '$allocate', function $$allocate() {
      var self = this;

      
      var obj = new self.$$constructor();
      obj.$$id = Opal.uid();
      return obj;
    
    });
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze, self = this, copy = nil;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $hash_get($kwargs, "freeze");if (freeze == null) freeze = nil;
      if (!(($truthy(freeze['$nil?']()) || ($eqeq(freeze, true))) || ($eqeq(freeze, false)))) {
        self.$raise($$('ArgumentError'), "unexpected value for freeze: " + (freeze.$class()))
      };
      copy = Opal.allocate_class(nil, self.$$super);
      copy.$copy_instance_variables(self);
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self, (new Map([["freeze", freeze]])));
      if (($eqeq(freeze, true) || (($truthy(freeze['$nil?']()) && ($truthy(self['$frozen?']())))))) {
        copy.$freeze()
      };
      return copy;
    }, -1);
    
    $def(self, '$dup', function $$dup() {
      var self = this, copy = nil;

      
      copy = Opal.allocate_class(nil, self.$$super);
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    });
    
    $def(self, '$descendants', function $$descendants() {
      var self = this;

      return $rb_plus(self.$subclasses(), $send(self.$subclasses(), 'map', [], "descendants".$to_proc()).$flatten())
    });
    
    $def(self, '$inherited', $return_val(nil));
    
    $def(self, '$new', function $Class_new$2($a) {
      var block = $Class_new$2.$$p || nil, $post_args, args, self = this;

      $Class_new$2.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      
      var object = self.$allocate();
      Opal.send(object, object.$initialize, args, block);
      return object;
    ;
    }, -1);
    
    $def(self, '$subclasses', function $$subclasses() {
      var self = this;

      
      if (typeof WeakRef !== 'undefined') {
        var i, subclass, out = [];
        for (i = 0; i < self.$$subclasses.length; i++) {
          subclass = self.$$subclasses[i].deref();
          if (subclass !== undefined) {
            out.push(subclass);
          }
        }
        return out;
      }
      else {
        return self.$$subclasses;
      }
    
    });
    
    $def(self, '$superclass', function $$superclass() {
      var self = this;

      return self.$$super || nil;
    });
    
    $def(self, '$to_s', function $$to_s() {
      var $yield = $$to_s.$$p || nil, self = this;

      $$to_s.$$p = null;
      
      var singleton_of = self.$$singleton_of;

      if (singleton_of && singleton_of.$$is_a_module) {
        return "#<Class:" + ((singleton_of).$name()) + ">";
      }
      else if (singleton_of) {
        // a singleton class created from an object
        return "#<Class:#<" + ((singleton_of.$$class).$name()) + ":0x" + ((Opal.id(singleton_of)).$to_s(16)) + ">>";
      }

      return $send2(self, $find_super(self, 'to_s', $$to_s, false, true), 'to_s', [], null);
    
    });
    
    $def(self, '$attached_object', function $$attached_object() {
      var self = this;

      
      if (self.$$singleton_of != null) {
        return self.$$singleton_of;
      }
      else {
        $Kernel.$raise($$$('TypeError'), "`" + (self) + "' is not a singleton class")
      }
    
    });
    return $alias(self, "inspect", "to_s");
  })('::', null, $nesting);
};

Opal.modules["corelib/basic_object"] = function(Opal) {/* Generated by Opal 1.8.2 */
  "use strict";
  var $klass = Opal.klass, $slice = Opal.slice, $def = Opal.def, $alias = Opal.alias, $return_val = Opal.return_val, $Opal = Opal.Opal, $truthy = Opal.truthy, $range = Opal.range, $Kernel = Opal.Kernel, $to_a = Opal.to_a, $send = Opal.send, $eqeq = Opal.eqeq, $rb_ge = Opal.rb_ge, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('==,raise,inspect,pristine,!,nil?,cover?,size,merge,compile,proc,[],first,>=,length,instance_variable_get,any?,new,caller');
  return (function($base, $super) {
    var self = $klass($base, $super, 'BasicObject');

    
    
    
    $def(self, '$initialize', function $$initialize($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$==', function $BasicObject_$eq_eq$1(other) {
      var self = this;

      return self === other;
    });
    
    $def(self, '$eql?', function $BasicObject_eql$ques$2(other) {
      var self = this;

      return self['$=='](other)
    });
    $alias(self, "equal?", "==");
    
    $def(self, '$__id__', function $$__id__() {
      var self = this;

      
      if (self.$$id != null) {
        return self.$$id;
      }
      Opal.prop(self, '$$id', Opal.uid());
      return self.$$id;
    
    });
    
    $def(self, '$__send__', function $$__send__(symbol, $a) {
      var block = $$__send__.$$p || nil, $post_args, args, self = this;

      $$__send__.$$p = null;
      
      ;
      $post_args = $slice(arguments, 1);
      args = $post_args;
      
      if (!symbol.$$is_string) {
        self.$raise($$$('TypeError'), "" + (self.$inspect()) + " is not a symbol nor a string")
      }

      var func = self[Opal.jsid(symbol)];

      if (func) {
        if (block !== nil) {
          func.$$p = block;
        }

        return func.apply(self, args);
      }

      if (block !== nil) {
        self.$method_missing.$$p = block;
      }

      return self.$method_missing.apply(self, [symbol].concat(args));
    ;
    }, -2);
    
    $def(self, '$!', $return_val(false));
    $Opal.$pristine("!");
    
    $def(self, '$!=', function $BasicObject_$not_eq$3(other) {
      var self = this;

      return self['$=='](other)['$!']()
    });
    
    $def(self, '$instance_eval', function $$instance_eval($a) {
      var block = $$instance_eval.$$p || nil, $post_args, args, $b, self = this, string = nil, file = nil, _lineno = nil, default_eval_options = nil, $ret_or_1 = nil, compiling_options = nil, compiled = nil;

      $$instance_eval.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      if (($truthy(block['$nil?']()) && ($truthy(!!Opal.compile)))) {
        
        if (!$truthy($range(1, 3, false)['$cover?'](args.$size()))) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (0 for 1..3)")
        };
        $b = [].concat($to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;
        default_eval_options = (new Map([["file", ($truthy(($ret_or_1 = file)) ? ($ret_or_1) : ("(eval)"))], ["eval", true]]));
        compiling_options = (new Map([['arity_check', false]])).$merge(default_eval_options);
        compiled = $Opal.$compile(string, compiling_options);
        block = $send($Kernel, 'proc', [], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

          return new Function("Opal,self", "return " + compiled)(Opal, self);}, {$$s: self});
      } else if ((($truthy(block['$nil?']()) && ($truthy($rb_ge(args.$length(), 1)))) && ($eqeq(args.$first()['$[]'](0), "@")))) {
        return self.$instance_variable_get(args.$first())
      } else if ($truthy(args['$any?']())) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (args.$size()) + " for 0)")
      };
      
      var old = block.$$s,
          result;

      block.$$s = null;

      // Need to pass $$eval so that method definitions know if this is
      // being done on a class/module. Cannot be compiler driven since
      // send(:instance_eval) needs to work.
      if (self.$$is_a_module) {
        self.$$eval = true;
        try {
          result = block.call(self, self);
        }
        finally {
          self.$$eval = false;
        }
      }
      else {
        result = block.call(self, self);
      }

      block.$$s = old;

      return result;
    ;
    }, -1);
    
    $def(self, '$instance_exec', function $$instance_exec($a) {
      var block = $$instance_exec.$$p || nil, $post_args, args, self = this;

      $$instance_exec.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      if (!$truthy(block)) {
        $Kernel.$raise($$$('ArgumentError'), "no block given")
      };
      
      var block_self = block.$$s,
          result;

      block.$$s = null;

      if (self.$$is_a_module) {
        self.$$eval = true;
        try {
          result = block.apply(self, args);
        }
        finally {
          self.$$eval = false;
        }
      }
      else {
        result = block.apply(self, args);
      }

      block.$$s = block_self;

      return result;
    ;
    }, -1);
    
    $def(self, '$singleton_method_added', function $$singleton_method_added($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$singleton_method_removed', function $$singleton_method_removed($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$singleton_method_undefined', function $$singleton_method_undefined($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return nil;
    }, -1);
    
    $def(self, '$method_missing', function $$method_missing(symbol, $a) {
      var block = $$method_missing.$$p || nil, $post_args, args, self = this, inspect_result = nil;

      $$method_missing.$$p = null;
      
      ;
      $post_args = $slice(arguments, 1);
      args = $post_args;
      inspect_result = $Opal.$inspect(self);
      return $Kernel.$raise($$$('NoMethodError').$new("undefined method `" + (symbol) + "' for " + (inspect_result), symbol, args), nil, $Kernel.$caller(1));
    }, -2);
    $Opal.$pristine(self, "method_missing");
    return $def(self, '$respond_to_missing?', function $BasicObject_respond_to_missing$ques$5(method_name, include_all) {
      
      
      if (include_all == null) include_all = false;
      return false;
    }, -2);
  })('::', null)
};

Opal.modules["corelib/kernel"] = function(Opal) {/* Generated by Opal 1.8.2 */
  "use strict";
  var $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $Opal = Opal.Opal, $deny_frozen_access = Opal.deny_frozen_access, $freeze = Opal.freeze, $freeze_props = Opal.freeze_props, $jsid = Opal.jsid, $each_ivar = Opal.each_ivar, $module = Opal.module, $return_val = Opal.return_val, $def = Opal.def, $Kernel = Opal.Kernel, $gvars = Opal.gvars, $slice = Opal.slice, $send = Opal.send, $to_a = Opal.to_a, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $eqeq = Opal.eqeq, $rb_plus = Opal.rb_plus, $extract_kwargs = Opal.extract_kwargs, $eqeqeq = Opal.eqeqeq, $return_self = Opal.return_self, $rb_le = Opal.rb_le, $rb_lt = Opal.rb_lt, $Object = Opal.Object, $alias = Opal.alias, $klass = Opal.klass, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('!,=~,==,object_id,raise,new,class,coerce_to?,<<,map,caller,nil?,allocate,copy_instance_variables,copy_singleton_methods,initialize_clone,frozen?,freeze,initialize_copy,define_method,singleton_class,to_proc,initialize_dup,for,empty?,pop,call,append_features,extend_object,extended,gets,__id__,include?,each,instance_variables,instance_variable_get,inspect,+,to_s,instance_variable_name!,respond_to?,to_int,to_i,Integer,coerce_to!,===,enum_for,result,shift,write,format,puts,<=,length,[],print,readline,<,first,split,to_str,exception,rand,respond_to_missing?,pristine,try_convert!,expand_path,join,start_with?,new_seed,srand,tag,value,open,is_a?,__send__,yield_self,include');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$=~', $return_val(false));
    
    $def(self, '$!~', function $Kernel_$excl_tilde$1(obj) {
      var self = this;

      return self['$=~'](obj)['$!']()
    });
    
    $def(self, '$===', function $Kernel_$eq_eq_eq$2(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.$object_id()['$=='](other.$object_id())))) {
        return $ret_or_1
      } else {
        return self['$=='](other)
      }
    });
    
    $def(self, '$<=>', function $Kernel_$lt_eq_gt$3(other) {
      var self = this;

      
      // set guard for infinite recursion
      self.$$comparable = true;

      var x = self['$=='](other);

      if (x && x !== nil) {
        return 0;
      }

      return nil;
    
    });
    
    $def(self, '$method', function $$method(name) {
      var self = this;

      
      var meth = self[$jsid(name)];

      if (!meth || meth.$$stub) {
        $Kernel.$raise($$$('NameError').$new("undefined method `" + (name) + "' for class `" + (self.$class()) + "'", name));
      }

      return $$$('Method').$new(self, meth.$$owner || self.$class(), meth, name);
    
    });
    
    $def(self, '$methods', function $$methods(all) {
      var self = this;

      
      if (all == null) all = true;
      
      if ($truthy(all)) {
        return Opal.methods(self);
      } else {
        return Opal.own_methods(self);
      }
    ;
    }, -1);
    
    $def(self, '$public_methods', function $$public_methods(all) {
      var self = this;

      
      if (all == null) all = true;
      
      if ($truthy(all)) {
        return Opal.methods(self);
      } else {
        return Opal.receiver_methods(self);
      }
    ;
    }, -1);
    
    $def(self, '$Array', function $$Array(object) {
      
      
      var coerced;

      if (object === nil) {
        return [];
      }

      if (object.$$is_array) {
        return object;
      }

      coerced = $Opal['$coerce_to?'](object, $$$('Array'), "to_ary");
      if (coerced !== nil) { return coerced; }

      coerced = $Opal['$coerce_to?'](object, $$$('Array'), "to_a");
      if (coerced !== nil) { return coerced; }

      return [object];
    
    });
    
    $def(self, '$at_exit', function $$at_exit() {
      var block = $$at_exit.$$p || nil, $ret_or_1 = nil;
      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

      $$at_exit.$$p = null;
      
      ;
      $gvars.__at_exit__ = ($truthy(($ret_or_1 = $gvars.__at_exit__)) ? ($ret_or_1) : ([]));
      $gvars.__at_exit__['$<<'](block);
      return block;
    });
    
    $def(self, '$caller', function $$caller(start, length) {
      
      
      if (start == null) start = 1;
      if (length == null) length = nil;
      
      var stack, result;

      stack = new Error().$backtrace();
      result = [];

      for (var i = start + 1, ii = stack.length; i < ii; i++) {
        if (!stack[i].match(/runtime\.js/)) {
          result.push(stack[i]);
        }
      }
      if (length != nil) result = result.slice(0, length);
      return result;
    ;
    }, -1);
    
    $def(self, '$caller_locations', function $$caller_locations($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return $send($send(self, 'caller', $to_a(args)), 'map', [], function $$4(loc){
        
        if (loc == null) loc = nil;
        return $$$($$$($$$('Thread'), 'Backtrace'), 'Location').$new(loc);});
    }, -1);
    
    $def(self, '$class', function $Kernel_class$5() {
      var self = this;

      return self.$$class;
    });
    
    $def(self, '$copy_instance_variables', function $$copy_instance_variables(other) {
      var self = this;

      
      var keys = Object.keys(other), i, ii, name;
      for (i = 0, ii = keys.length; i < ii; i++) {
        name = keys[i];
        if (name.charAt(0) !== '$' && other.hasOwnProperty(name)) {
          self[name] = other[name];
        }
      }
    
    });
    
    $def(self, '$copy_singleton_methods', function $$copy_singleton_methods(other) {
      var self = this;

      
      var i, name, names, length;

      if (other.hasOwnProperty('$$meta') && other.$$meta !== null) {
        var other_singleton_class = Opal.get_singleton_class(other);
        var self_singleton_class = Opal.get_singleton_class(self);
        names = Object.getOwnPropertyNames(other_singleton_class.$$prototype);

        for (i = 0, length = names.length; i < length; i++) {
          name = names[i];
          if (Opal.is_method(name)) {
            self_singleton_class.$$prototype[name] = other_singleton_class.$$prototype[name];
          }
        }

        self_singleton_class.$$const = Object.assign({}, other_singleton_class.$$const);
        Object.setPrototypeOf(
          self_singleton_class.$$prototype,
          Object.getPrototypeOf(other_singleton_class.$$prototype)
        );
      }

      for (i = 0, names = Object.getOwnPropertyNames(other), length = names.length; i < length; i++) {
        name = names[i];
        if (name.charAt(0) === '$' && name.charAt(1) !== '$' && other.hasOwnProperty(name)) {
          self[name] = other[name];
        }
      }
    
    });
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze, self = this, copy = nil;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $hash_get($kwargs, "freeze");if (freeze == null) freeze = nil;
      if (!(($truthy(freeze['$nil?']()) || ($eqeq(freeze, true))) || ($eqeq(freeze, false)))) {
        self.$raise($$('ArgumentError'), "unexpected value for freeze: " + (freeze.$class()))
      };
      copy = self.$class().$allocate();
      copy.$copy_instance_variables(self);
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self, (new Map([["freeze", freeze]])));
      if (($eqeq(freeze, true) || (($truthy(freeze['$nil?']()) && ($truthy(self['$frozen?']())))))) {
        copy.$freeze()
      };
      return copy;
    }, -1);
    
    $def(self, '$initialize_clone', function $$initialize_clone(other, $kwargs) {
      var freeze, self = this;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $hash_get($kwargs, "freeze");if (freeze == null) freeze = nil;
      self.$initialize_copy(other);
      return self;
    }, -2);
    
    $def(self, '$define_singleton_method', function $$define_singleton_method(name, method) {
      var block = $$define_singleton_method.$$p || nil, self = this;

      $$define_singleton_method.$$p = null;
      
      ;
      ;
      return $send(self.$singleton_class(), 'define_method', [name, method], block.$to_proc());
    }, -2);
    
    $def(self, '$dup', function $$dup() {
      var self = this, copy = nil;

      
      copy = self.$class().$allocate();
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    });
    
    $def(self, '$initialize_dup', function $$initialize_dup(other) {
      var self = this;

      return self.$initialize_copy(other)
    });
    
    $def(self, '$enum_for', function $$enum_for($a, $b) {
      var block = $$enum_for.$$p || nil, $post_args, method, args, self = this;

      $$enum_for.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      
      if ($post_args.length > 0) method = $post_args.shift();if (method == null) method = "each";
      args = $post_args;
      return $send($$$('Enumerator'), 'for', [self, method].concat($to_a(args)), block.$to_proc());
    }, -1);
    
    $def(self, '$equal?', function $Kernel_equal$ques$6(other) {
      var self = this;

      return self === other;
    });
    
    $def(self, '$exit', function $$exit(status) {
      var $ret_or_1 = nil, block = nil;
      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

      
      if (status == null) status = true;
      $gvars.__at_exit__ = ($truthy(($ret_or_1 = $gvars.__at_exit__)) ? ($ret_or_1) : ([]));
      while (!($truthy($gvars.__at_exit__['$empty?']()))) {
      
        block = $gvars.__at_exit__.$pop();
        block.$call();
      };
      
      if (status.$$is_boolean) {
        status = status ? 0 : 1;
      } else {
        status = $coerce_to(status, $$$('Integer'), 'to_int')
      }

      Opal.exit(status);
    ;
      return nil;
    }, -1);
    
    $def(self, '$extend', function $$extend($a) {
      var $post_args, mods, self = this;

      
      $post_args = $slice(arguments);
      mods = $post_args;
      
      if (mods.length == 0) {
        self.$raise($$$('ArgumentError'), "wrong number of arguments (given 0, expected 1+)")
      }

      $deny_frozen_access(self);

      var singleton = self.$singleton_class();

      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$append_features(singleton);
        (mod).$extend_object(self);
        (mod).$extended(self);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if ($truthy(self['$frozen?']())) {
        return self
      };
      
      if (typeof(self) === "object") {
        $freeze_props(self);
        return $freeze(self);
      }
      return self;
    ;
    });
    
    $def(self, '$frozen?', function $Kernel_frozen$ques$7() {
      var self = this;

      
      switch (typeof(self)) {
      case "string":
      case "symbol":
      case "number":
      case "boolean":
        return true;
      case "object":
        return (self.$$frozen || false);
      default:
        return false;
      }
    
    });
    
    $def(self, '$gets', function $$gets($a) {
      var $post_args, args;
      if ($gvars.stdin == null) $gvars.stdin = nil;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return $send($gvars.stdin, 'gets', $to_a(args));
    }, -1);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return self.$__id__()
    });
    
    $def(self, '$initialize_copy', $return_val(nil));
    var inspect_stack = [];
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, ivs = nil, id = nil, pushed = nil, e = nil;

      return (function() { try {
      try {
        
        ivs = "";
        id = self.$__id__();
        if ($truthy((inspect_stack)['$include?'](id))) {
          ivs = " ..."
        } else {
          
          (inspect_stack)['$<<'](id);
          pushed = true;
          $send(self.$instance_variables(), 'each', [], function $$8(i){var self = $$8.$$s == null ? this : $$8.$$s, ivar = nil, inspect = nil;

            
            if (i == null) i = nil;
            ivar = self.$instance_variable_get(i);
            inspect = $$('Opal').$inspect(ivar);
            return (ivs = $rb_plus(ivs, " " + (i) + "=" + (inspect)));}, {$$s: self});
        };
        return "#<" + (self.$class()) + ":0x" + (id.$to_s(16)) + (ivs) + ">";
      } catch ($err) {
        if (Opal.rescue($err, [$$('StandardError')])) {(e = $err)
          try {
            return "#<" + (self.$class()) + ":0x" + (id.$to_s(16)) + ">"
          } finally { Opal.pop_exception($err); }
        } else { throw $err; }
      }
      } finally {
        ($truthy(pushed) ? ((inspect_stack).$pop()) : nil)
      }; })()
    });
    
    $def(self, '$instance_of?', function $Kernel_instance_of$ques$9(klass) {
      var self = this;

      
      if (!klass.$$is_class && !klass.$$is_module) {
        $Kernel.$raise($$$('TypeError'), "class or module required");
      }

      return self.$$class === klass;
    
    });
    
    $def(self, '$instance_variable_defined?', function $Kernel_instance_variable_defined$ques$10(name) {
      var self = this;

      
      name = $Opal['$instance_variable_name!'](name);
      return Opal.hasOwnProperty.call(self, name.substr(1));;
    });
    
    $def(self, '$instance_variable_get', function $$instance_variable_get(name) {
      var self = this;

      
      name = $Opal['$instance_variable_name!'](name);
      
      var ivar = self[Opal.ivar(name.substr(1))];

      return ivar == null ? nil : ivar;
    ;
    });
    
    $def(self, '$instance_variable_set', function $$instance_variable_set(name, value) {
      var self = this;

      
      $deny_frozen_access(self);
      name = $Opal['$instance_variable_name!'](name);
      return self[Opal.ivar(name.substr(1))] = value;;
    });
    
    $def(self, '$remove_instance_variable', function $$remove_instance_variable(name) {
      var self = this;

      
      name = $Opal['$instance_variable_name!'](name);
      
      var key = Opal.ivar(name.substr(1)),
          val;
      if (self.hasOwnProperty(key)) {
        val = self[key];
        delete self[key];
        return val;
      }
    ;
      return $Kernel.$raise($$$('NameError'), "instance variable " + (name) + " not defined");
    });
    
    $def(self, '$instance_variables', function $$instance_variables() {
      var self = this;

      
      var result = [], name;

      $each_ivar(self, function(name) {
        if (name.substr(-1) === '$') {
          name = name.slice(0, name.length - 1);
        }
        result.push('@' + name);
      });

      return result;
    
    });
    
    $def(self, '$Integer', function $$Integer(value, $a, $b) {
      var $post_args, $kwargs, base, exception;

      
      $post_args = $slice(arguments, 1);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      
      if ($post_args.length > 0) base = $post_args.shift();;
      
      exception = $hash_get($kwargs, "exception");if (exception == null) exception = true;
      
      var i, str, base_digits;

      exception = $truthy(exception);

      if (!value.$$is_string) {
        if (base !== undefined) {
          if (exception) {
            $Kernel.$raise($$$('ArgumentError'), "base specified for non string value")
          } else {
            return nil;
          }
        }
        if (value === nil) {
          if (exception) {
            $Kernel.$raise($$$('TypeError'), "can't convert nil into Integer")
          } else {
            return nil;
          }
        }
        if (value.$$is_number) {
          if (value === Infinity || value === -Infinity || isNaN(value)) {
            if (exception) {
              $Kernel.$raise($$$('FloatDomainError'), value)
            } else {
              return nil;
            }
          }
          return Math.floor(value);
        }
        if (value['$respond_to?']("to_int")) {
          i = value.$to_int();
          if (Opal.is_a(i, $$$('Integer'))) {
            return i;
          }
        }
        if (value['$respond_to?']("to_i")) {
          i = value.$to_i();
          if (Opal.is_a(i, $$$('Integer'))) {
            return i;
          }
        }

        if (exception) {
          $Kernel.$raise($$$('TypeError'), "can't convert " + (value.$class()) + " into Integer")
        } else {
          return nil;
        }
      }

      if (value === "0") {
        return 0;
      }

      if (base === undefined) {
        base = 0;
      } else {
        base = $coerce_to(base, $$$('Integer'), 'to_int');
        if (base === 1 || base < 0 || base > 36) {
          if (exception) {
            $Kernel.$raise($$$('ArgumentError'), "invalid radix " + (base))
          } else {
            return nil;
          }
        }
      }

      str = value.toLowerCase();

      str = str.replace(/(\d)_(?=\d)/g, '$1');

      str = str.replace(/^(\s*[+-]?)(0[bodx]?)/, function (_, head, flag) {
        switch (flag) {
        case '0b':
          if (base === 0 || base === 2) {
            base = 2;
            return head;
          }
          // no-break
        case '0':
        case '0o':
          if (base === 0 || base === 8) {
            base = 8;
            return head;
          }
          // no-break
        case '0d':
          if (base === 0 || base === 10) {
            base = 10;
            return head;
          }
          // no-break
        case '0x':
          if (base === 0 || base === 16) {
            base = 16;
            return head;
          }
          // no-break
        }
        if (exception) {
          $Kernel.$raise($$$('ArgumentError'), "invalid value for Integer(): \"" + (value) + "\"")
        } else {
          return nil;
        }
      });

      base = (base === 0 ? 10 : base);

      base_digits = '0-' + (base <= 10 ? base - 1 : '9a-' + String.fromCharCode(97 + (base - 11)));

      if (!(new RegExp('^\\s*[+-]?[' + base_digits + ']+\\s*$')).test(str)) {
        if (exception) {
          $Kernel.$raise($$$('ArgumentError'), "invalid value for Integer(): \"" + (value) + "\"")
        } else {
          return nil;
        }
      }

      i = parseInt(str, base);

      if (isNaN(i)) {
        if (exception) {
          $Kernel.$raise($$$('ArgumentError'), "invalid value for Integer(): \"" + (value) + "\"")
        } else {
          return nil;
        }
      }

      return i;
    ;
    }, -2);
    
    $def(self, '$Float', function $$Float(value, $kwargs) {
      var exception;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      exception = $hash_get($kwargs, "exception");if (exception == null) exception = true;
      
      var str;

      exception = $truthy(exception);

      if (value === nil) {
        if (exception) {
          $Kernel.$raise($$$('TypeError'), "can't convert nil into Float")
        } else {
          return nil;
        }
      }

      if (value.$$is_string) {
        str = value.toString();

        str = str.replace(/(\d)_(?=\d)/g, '$1');

        //Special case for hex strings only:
        if (/^\s*[-+]?0[xX][0-9a-fA-F]+\s*$/.test(str)) {
          return $Kernel.$Integer(str);
        }

        if (!/^\s*[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?\s*$/.test(str)) {
          if (exception) {
            $Kernel.$raise($$$('ArgumentError'), "invalid value for Float(): \"" + (value) + "\"")
          } else {
            return nil;
          }
        }

        return parseFloat(str);
      }

      if (exception) {
        return $Opal['$coerce_to!'](value, $$$('Float'), "to_f");
      } else {
        return $coerce_to(value, $$$('Float'), 'to_f');
      }
    ;
    }, -2);
    
    $def(self, '$Hash', function $$Hash(arg) {
      
      
      if (($truthy(arg['$nil?']()) || ($eqeq(arg, [])))) {
        return (new Map())
      };
      if ($eqeqeq($$$('Hash'), arg)) {
        return arg
      };
      return $Opal['$coerce_to!'](arg, $$$('Hash'), "to_hash");
    });
    
    $def(self, '$is_a?', function $Kernel_is_a$ques$11(klass) {
      var self = this;

      
      if (!klass.$$is_class && !klass.$$is_module) {
        $Kernel.$raise($$$('TypeError'), "class or module required");
      }

      return Opal.is_a(self, klass);
    
    });
    
    $def(self, '$itself', $return_self);
    
    $def(self, '$lambda', function $$lambda() {
      var block = $$lambda.$$p || nil;

      $$lambda.$$p = null;
      
      ;
      return Opal.lambda(block);;
    });
    
    $def(self, '$load', function $$load(file) {
      
      
      file = $Opal['$coerce_to!'](file, $$$('String'), "to_str");
      return Opal.load(file);
    });
    
    $def(self, '$loop', function $$loop() {
      var $yield = $$loop.$$p || nil, self = this, e = nil;

      $$loop.$$p = null;
      
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["loop"], function $$12(){
          return $$$($$$('Float'), 'INFINITY')})
      };
      while ($truthy(true)) {
      
        try {
          Opal.yieldX($yield, [])
        } catch ($err) {
          if (Opal.rescue($err, [$$$('StopIteration')])) {(e = $err)
            try {
              return e.$result()
            } finally { Opal.pop_exception($err); }
          } else { throw $err; }
        };
      };
      return self;
    });
    
    $def(self, '$nil?', $return_val(false));
    
    $def(self, '$printf', function $$printf($a) {
      var $post_args, args, self = this, io = nil;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      $post_args = $slice(arguments);
      args = $post_args;
      if ($truthy(args['$empty?']())) {
        return nil
      };
      io = ($truthy(args[0].$$is_string) ? ($gvars.stdout) : (args.$shift()));
      io.$write($send(self, 'format', $to_a(args)));
      return nil;
    }, -1);
    
    $def(self, '$proc', function $$proc() {
      var block = $$proc.$$p || nil;

      $$proc.$$p = null;
      
      ;
      if (!$truthy(block)) {
        $Kernel.$raise($$$('ArgumentError'), "tried to create Proc object without a block")
      };
      block.$$is_lambda = false;
      return block;
    });
    
    $def(self, '$puts', function $$puts($a) {
      var $post_args, strs;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      $post_args = $slice(arguments);
      strs = $post_args;
      return $send($gvars.stdout, 'puts', $to_a(strs));
    }, -1);
    
    $def(self, '$p', function $$p($a) {
      var $post_args, args;

      
      $post_args = $slice(arguments);
      args = $post_args;
      $send(args, 'each', [], function $$13(obj){        if ($gvars.stdout == null) $gvars.stdout = nil;

        
        if (obj == null) obj = nil;
        return $gvars.stdout.$puts(obj.$inspect());});
      if ($truthy($rb_le(args.$length(), 1))) {
        return args['$[]'](0)
      } else {
        return args
      };
    }, -1);
    
    $def(self, '$print', function $$print($a) {
      var $post_args, strs;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      $post_args = $slice(arguments);
      strs = $post_args;
      return $send($gvars.stdout, 'print', $to_a(strs));
    }, -1);
    
    $def(self, '$readline', function $$readline($a) {
      var $post_args, args;
      if ($gvars.stdin == null) $gvars.stdin = nil;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return $send($gvars.stdin, 'readline', $to_a(args));
    }, -1);
    
    $def(self, '$warn', function $$warn($a, $b) {
      var $post_args, $kwargs, strs, uplevel, $c, $d, self = this, location = nil;
      if ($gvars.VERBOSE == null) $gvars.VERBOSE = nil;
      if ($gvars.stderr == null) $gvars.stderr = nil;

      
      $post_args = $slice(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      strs = $post_args;
      
      uplevel = $hash_get($kwargs, "uplevel");if (uplevel == null) uplevel = nil;
      if ($truthy(uplevel)) {
        
        uplevel = $Opal['$coerce_to!'](uplevel, $$$('Integer'), "to_str");
        if ($truthy($rb_lt(uplevel, 0))) {
          $Kernel.$raise($$$('ArgumentError'), "negative level (" + (uplevel) + ")")
        };
        location = ($c = ($d = self.$caller($rb_plus(uplevel, 1), 1).$first(), ($d === nil || $d == null) ? nil : $d.$split(":in `")), ($c === nil || $c == null) ? nil : $c.$first());
        if ($truthy(location)) {
          location = "" + (location) + ": "
        };
        strs = $send(strs, 'map', [], function $$14(s){
          
          if (s == null) s = nil;
          return "" + (location) + "warning: " + (s);});
      };
      if (($truthy($gvars.VERBOSE['$nil?']()) || ($truthy(strs['$empty?']())))) {
        return nil
      } else {
        return $send($gvars.stderr, 'puts', $to_a(strs))
      };
    }, -1);
    
    $def(self, '$raise', function $$raise(exception, string, backtrace) {
            if ($gvars["!"] == null) $gvars["!"] = nil;

      
      ;
      if (string == null) string = nil;
      if (backtrace == null) backtrace = nil;
      
      if (exception == null && $gvars["!"] !== nil) {
        throw $gvars["!"];
      }
      if (exception == null) {
        exception = $$$('RuntimeError').$new("");
      }
      else if ($respond_to(exception, '$to_str')) {
        exception = $$$('RuntimeError').$new(exception.$to_str());
      }
      // using respond_to? and not an undefined check to avoid method_missing matching as true
      else if (exception.$$is_class && $respond_to(exception, '$exception')) {
        exception = exception.$exception(string);
      }
      else if (exception.$$is_exception) {
        // exception is fine
      }
      else {
        exception = $$$('TypeError').$new("exception class/object expected");
      }

      if (backtrace !== nil) {
        exception.$set_backtrace(backtrace);
      }

      if ($gvars["!"] !== nil) {
        Opal.exceptions.push($gvars["!"]);
      }

      $gvars["!"] = exception;

      throw exception;
    ;
    }, -1);
    
    $def(self, '$rand', function $$rand(max) {
      
      
      ;
      
      if (max === undefined) {
        return $$$($$$('Random'), 'DEFAULT').$rand();
      }

      if (max.$$is_number) {
        if (max < 0) {
          max = Math.abs(max);
        }

        if (max % 1 !== 0) {
          max = max.$to_i();
        }

        if (max === 0) {
          max = undefined;
        }
      }
    ;
      return $$$($$$('Random'), 'DEFAULT').$rand(max);
    }, -1);
    
    $def(self, '$respond_to?', function $Kernel_respond_to$ques$15(name, include_all) {
      var self = this;

      
      if (include_all == null) include_all = false;
      
      var body = self[$jsid(name)];

      if (typeof(body) === "function" && !body.$$stub) {
        return true;
      }

      if (self['$respond_to_missing?'].$$pristine === true) {
        return false;
      } else {
        return self['$respond_to_missing?'](name, include_all);
      }
    ;
    }, -2);
    
    $def(self, '$respond_to_missing?', function $Kernel_respond_to_missing$ques$16(method_name, include_all) {
      
      
      if (include_all == null) include_all = false;
      return false;
    }, -2);
    $Opal.$pristine(self, "respond_to?", "respond_to_missing?");
    
    $def(self, '$require', function $$require(file) {
      
      
      // As Object.require refers to Kernel.require once Kernel has been loaded the String
      // class may not be available yet, the coercion requires both  String and Array to be loaded.
      if (typeof file !== 'string' && Opal.String && Opal.Array) {
        (file = $Opal['$coerce_to!'](file, $$$('String'), "to_str"))
      }
      return Opal.require(file)
    
    });
    
    $def(self, '$require_relative', function $$require_relative(file) {
      
      
      $Opal['$try_convert!'](file, $$$('String'), "to_str");
      file = $$$('File').$expand_path($$$('File').$join(Opal.current_file, "..", file));
      return Opal.require(file);
    });
    
    $def(self, '$require_tree', function $$require_tree(path, $kwargs) {
      var autoload;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      autoload = $hash_get($kwargs, "autoload");if (autoload == null) autoload = false;
      
      var result = [];

      path = $$$('File').$expand_path(path)
      path = Opal.normalize(path);
      if (path === '.') path = '';
      for (var name in Opal.modules) {
        if ((name)['$start_with?'](path)) {
          if(!autoload) {
            result.push([name, Opal.require(name)]);
          } else {
            result.push([name, true]); // do nothing, delegated to a autoloading
          }
        }
      }

      return result;
    ;
    }, -2);
    
    $def(self, '$singleton_class', function $$singleton_class() {
      var self = this;

      return Opal.get_singleton_class(self);
    });
    
    $def(self, '$sleep', function $$sleep(seconds) {
      
      
      if (seconds == null) seconds = nil;
      
      if (seconds === nil) {
        $Kernel.$raise($$$('TypeError'), "can't convert NilClass into time interval")
      }
      if (!seconds.$$is_number) {
        $Kernel.$raise($$$('TypeError'), "can't convert " + (seconds.$class()) + " into time interval")
      }
      if (seconds < 0) {
        $Kernel.$raise($$$('ArgumentError'), "time interval must be positive")
      }
      var get_time = Opal.global.performance ?
        function() {return performance.now()} :
        function() {return new Date()}

      var t = get_time();
      while (get_time() - t <= seconds * 1000);
      return Math.round(seconds);
    ;
    }, -1);
    
    $def(self, '$srand', function $$srand(seed) {
      
      
      if (seed == null) seed = $$('Random').$new_seed();
      return $$$('Random').$srand(seed);
    }, -1);
    
    $def(self, '$String', function $$String(str) {
      var $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = $Opal['$coerce_to?'](str, $$$('String'), "to_str")))) {
        return $ret_or_1
      } else {
        return $Opal['$coerce_to!'](str, $$$('String'), "to_s")
      }
    });
    
    $def(self, '$tap', function $$tap() {
      var block = $$tap.$$p || nil, self = this;

      $$tap.$$p = null;
      
      ;
      Opal.yield1(block, self);
      return self;
    });
    
    $def(self, '$to_proc', $return_self);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return "#<" + (self.$class()) + ":0x" + (self.$__id__().$to_s(16)) + ">"
    });
    
    $def(self, '$catch', function $Kernel_catch$17(tag) {
      var $yield = $Kernel_catch$17.$$p || nil, $ret_or_1 = nil, e = nil;

      $Kernel_catch$17.$$p = null;
      
      if (tag == null) tag = nil;
      try {
        
        tag = ($truthy(($ret_or_1 = tag)) ? ($ret_or_1) : ($Object.$new()));
        return Opal.yield1($yield, tag);;
      } catch ($err) {
        if (Opal.rescue($err, [$$$('UncaughtThrowError')])) {(e = $err)
          try {
            
            if ($eqeq(e.$tag(), tag)) {
              return e.$value()
            };
            return $Kernel.$raise();
          } finally { Opal.pop_exception($err); }
        } else { throw $err; }
      };
    }, -1);
    
    $def(self, '$throw', function $Kernel_throw$18(tag, obj) {
      
      
      if (obj == null) obj = nil;
      return $Kernel.$raise($$$('UncaughtThrowError').$new(tag, obj));
    }, -2);
    
    $def(self, '$open', function $$open($a) {
      var block = $$open.$$p || nil, $post_args, args;

      $$open.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      return $send($$$('File'), 'open', $to_a(args), block.$to_proc());
    }, -1);
    
    $def(self, '$yield_self', function $$yield_self() {
      var $yield = $$yield_self.$$p || nil, self = this;

      $$yield_self.$$p = null;
      
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["yield_self"], $return_val(1))
      };
      return Opal.yield1($yield, self);;
    });
    $alias(self, "fail", "raise");
    $alias(self, "kind_of?", "is_a?");
    $alias(self, "object_id", "__id__");
    $alias(self, "public_send", "__send__");
    $alias(self, "send", "__send__");
    $alias(self, "then", "yield_self");
    return $alias(self, "to_enum", "enum_for");
  })('::', $nesting);
  return (function($base, $super) {
    var self = $klass($base, $super, 'Object');

    
    
    delete $Object.$$prototype.$require;
    return self.$include($Kernel);
  })('::', null);
};

Opal.modules["corelib/main"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $return_val = Opal.return_val, $def = Opal.def, $Object = Opal.Object, $slice = Opal.slice, $Kernel = Opal.Kernel, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('include,raise');
  return (function(self, $parent_nesting) {
    
    
    
    $def(self, '$to_s', $return_val("main"));
    
    $def(self, '$include', function $$include(mod) {
      
      return $Object.$include(mod)
    });
    
    $def(self, '$autoload', function $$autoload($a) {
      var $post_args, args;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return Opal.Object.$autoload.apply(Opal.Object, args);;
    }, -1);
    return $def(self, '$using', function $$using(mod) {
      
      return $Kernel.$raise("main.using is permitted only at toplevel")
    });
  })(Opal.get_singleton_class(self), $nesting)
};

Opal.modules["corelib/error/errno"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $klass = Opal.klass, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('+,errno,class,attr_reader');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Errno');

    var $nesting = [self].concat($parent_nesting), errors = nil, klass = nil;

    
    errors = [["EINVAL", "Invalid argument", 22], ["EEXIST", "File exists", 17], ["EISDIR", "Is a directory", 21], ["EMFILE", "Too many open files", 24], ["ESPIPE", "Illegal seek", 29], ["EACCES", "Permission denied", 13], ["EPERM", "Operation not permitted", 1], ["ENOENT", "No such file or directory", 2], ["ENAMETOOLONG", "File name too long", 36]];
    klass = nil;
    
    var i;
    for (i = 0; i < errors.length; i++) {
      (function() { // Create a closure
        var class_name = errors[i][0];
        var default_message = errors[i][1];
        var errno = errors[i][2];

        klass = Opal.klass(self, Opal.SystemCallError, class_name);
        klass.errno = errno;

        (function(self, $parent_nesting) {
      
      return $def(self, '$new', function $new$1(name) {
        var $yield = $new$1.$$p || nil, self = this, message = nil;

        $new$1.$$p = null;
        
        if (name == null) name = nil;
        message = default_message;
        if ($truthy(name)) {
          message = $rb_plus(message, " - " + (name))
        };
        return $send2(self, $find_super(self, 'new', $new$1, false, true), 'new', [message], null);
      }, -1)
    })(Opal.get_singleton_class(klass), $nesting)
      })();
    }
  ;
  })('::', $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SystemCallError');

    var $nesting = [self].concat($parent_nesting);

    
    
    $def(self, '$errno', function $$errno() {
      var self = this;

      return self.$class().$errno()
    });
    return (function(self, $parent_nesting) {
      
      return self.$attr_reader("errno")
    })(Opal.get_singleton_class(self), $nesting);
  })('::', $$$('StandardError'), $nesting);
};

Opal.modules["corelib/error"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $slice = Opal.slice, $gvars = Opal.gvars, $defs = Opal.defs, $send = Opal.send, $to_a = Opal.to_a, $def = Opal.def, $send2 = Opal.send2, $find_super = Opal.find_super, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $not = Opal.not, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $Object = Opal.Object, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $module = Opal.module, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('new,map,backtrace,clone,to_s,merge,tty?,[],include?,raise,dup,empty?,!,caller,shift,+,class,join,cause,full_message,==,reverse,split,autoload,attr_reader,inspect');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Exception');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.message = nil;
    
    Opal.prop(self.$$prototype, '$$is_exception', true);
    var stack_trace_limit;
    Error.stackTraceLimit = 100;
    $defs(self, '$new', function $Exception_new$1($a) {
      var $post_args, args, self = this;
      if ($gvars["!"] == null) $gvars["!"] = nil;

      
      $post_args = $slice(arguments);
      args = $post_args;
      
      var message   = (args.length > 0) ? args[0] : nil;
      var error     = new self.$$constructor(message);
      error.name    = self.$$name;
      error.message = message;
      error.cause   = $gvars["!"];
      Opal.send(error, error.$initialize, args);

      // Error.captureStackTrace() will use .name and .toString to build the
      // first line of the stack trace so it must be called after the error
      // has been initialized.
      // https://nodejs.org/dist/latest-v6.x/docs/api/errors.html
      if (Opal.config.enable_stack_trace && Error.captureStackTrace) {
        // Passing Kernel.raise will cut the stack trace from that point above
        Error.captureStackTrace(error, stack_trace_limit);
      }

      return error;
    ;
    }, -1);
    stack_trace_limit = self.$new;
    $defs(self, '$exception', function $$exception($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return $send(self, 'new', $to_a(args));
    }, -1);
    
    $def(self, '$initialize', function $$initialize($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return self.message = (args.length > 0) ? args[0] : nil;;
    }, -1);
    
    $def(self, '$copy_instance_variables', function $$copy_instance_variables(other) {
      var $yield = $$copy_instance_variables.$$p || nil, self = this;

      $$copy_instance_variables.$$p = null;
      
      $send2(self, $find_super(self, 'copy_instance_variables', $$copy_instance_variables, false, true), 'copy_instance_variables', [other], $yield);
      
      self.message = other.message;
      self.cause = other.cause;
      self.stack = other.stack;
    ;
    });
    
    // Convert backtrace from any format to Ruby format
    function correct_backtrace(backtrace) {
      var new_bt = [], m;

      for (var i = 0; i < backtrace.length; i++) {
        var loc = backtrace[i];
        if (!loc || !loc.$$is_string) {
          /* Do nothing */
        }
        /* Chromium format */
        else if ((m = loc.match(/^    at (.*?) \((.*?)\)$/))) {
          new_bt.push(m[2] + ":in `" + m[1] + "'");
        }
        else if ((m = loc.match(/^    at (.*?)$/))) {
          new_bt.push(m[1] + ":in `undefined'");
        }
        /* Node format */
        else if ((m = loc.match(/^  from (.*?)$/))) {
          new_bt.push(m[1]);
        }
        /* Mozilla/Apple format */
        else if ((m = loc.match(/^(.*?)@(.*?)$/))) {
          new_bt.push(m[2] + ':in `' + m[1] + "'");
        }
      }

      return new_bt;
    }
  ;
    
    $def(self, '$backtrace', function $$backtrace() {
      var self = this;

      
      if (self.backtrace) {
        // nil is a valid backtrace
        return self.backtrace;
      }

      var backtrace = self.stack;

      if (typeof(backtrace) !== 'undefined' && backtrace.$$is_string) {
        return self.backtrace = correct_backtrace(backtrace.split("\n"));
      }
      else if (backtrace) {
        return self.backtrace = correct_backtrace(backtrace);
      }

      return [];
    
    });
    
    $def(self, '$backtrace_locations', function $$backtrace_locations() {
      var $a, self = this;

      
      if (self.backtrace_locations) return self.backtrace_locations;
      self.backtrace_locations = ($a = self.$backtrace(), ($a === nil || $a == null) ? nil : $send($a, 'map', [], function $$2(loc){
        
        if (loc == null) loc = nil;
        return $$$($$$($$$('Thread'), 'Backtrace'), 'Location').$new(loc);}))
      return self.backtrace_locations;
    
    });
    
    $def(self, '$cause', function $$cause() {
      var self = this;

      return self.cause || nil;
    });
    
    $def(self, '$exception', function $$exception(str) {
      var self = this;

      
      if (str == null) str = nil;
      
      if (str === nil || self === str) {
        return self;
      }

      var cloned = self.$clone();
      cloned.message = str;
      if (self.backtrace) cloned.backtrace = self.backtrace.$dup();
      cloned.stack = self.stack;
      cloned.cause = self.cause;
      return cloned;
    ;
    }, -1);
    
    $def(self, '$message', function $$message() {
      var self = this;

      return self.$to_s()
    });
    
    $def(self, '$full_message', function $$full_message(kwargs) {
      var $a, $b, self = this, $ret_or_1 = nil, highlight = nil, order = nil, bold_underline = nil, bold = nil, reset = nil, bt = nil, first = nil, msg = nil;
      if ($gvars.stderr == null) $gvars.stderr = nil;

      
      if (kwargs == null) kwargs = nil;
      if (!$truthy((($a = $$('Hash', 'skip_raise')) ? 'constant' : nil))) {
        return "" + (self.message) + "\n" + (self.stack)
      };
      kwargs = (new Map([["highlight", $gvars.stderr['$tty?']()], ["order", "top"]])).$merge(($truthy(($ret_or_1 = kwargs)) ? ($ret_or_1) : ((new Map()))));
      $b = [kwargs['$[]']("highlight"), kwargs['$[]']("order")], (highlight = $b[0]), (order = $b[1]), $b;
      if (!$truthy([true, false]['$include?'](highlight))) {
        $Kernel.$raise($$$('ArgumentError'), "expected true or false as highlight: " + (highlight))
      };
      if (!$truthy(["top", "bottom"]['$include?'](order))) {
        $Kernel.$raise($$$('ArgumentError'), "expected :top or :bottom as order: " + (order))
      };
      if ($truthy(highlight)) {
        
        bold_underline = "\u001b[1;4m";
        bold = "\u001b[1m";
        reset = "\u001b[m";
      } else {
        bold_underline = (bold = (reset = ""))
      };
      bt = self.$backtrace().$dup();
      if (($not(bt) || ($truthy(bt['$empty?']())))) {
        bt = self.$caller()
      };
      first = bt.$shift();
      msg = "" + (first) + ": ";
      msg = $rb_plus(msg, "" + (bold) + (self.$to_s()) + " (" + (bold_underline) + (self.$class()) + (reset) + (bold) + ")" + (reset) + "\n");
      msg = $rb_plus(msg, $send(bt, 'map', [], function $$3(loc){
        
        if (loc == null) loc = nil;
        return "\tfrom " + (loc) + "\n";}).$join());
      if ($truthy(self.$cause())) {
        msg = $rb_plus(msg, self.$cause().$full_message((new Map([["highlight", highlight]]))))
      };
      if ($eqeq(order, "bottom")) {
        
        msg = msg.$split("\n").$reverse().$join("\n");
        msg = $rb_plus("" + (bold) + "Traceback" + (reset) + " (most recent call last):\n", msg);
      };
      return msg;
    }, -1);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, as_str = nil;

      
      as_str = self.$to_s();
      if ($truthy(as_str['$empty?']())) {
        return self.$class().$to_s()
      } else {
        return "#<" + (self.$class().$to_s()) + ": " + (self.$to_s()) + ">"
      };
    });
    
    $def(self, '$set_backtrace', function $$set_backtrace(backtrace) {
      var self = this;

      
      var valid = true, i, ii;

      if (backtrace === nil) {
        self.backtrace = nil;
        self.stack = '';
      } else if (backtrace.$$is_string) {
        self.backtrace = [backtrace];
        self.stack = '  from ' + backtrace;
      } else {
        if (backtrace.$$is_array) {
          for (i = 0, ii = backtrace.length; i < ii; i++) {
            if (!backtrace[i].$$is_string) {
              valid = false;
              break;
            }
          }
        } else {
          valid = false;
        }

        if (valid === false) {
          $Kernel.$raise($$$('TypeError'), "backtrace must be Array of String")
        }

        self.backtrace = backtrace;
        self.stack = $send((backtrace), 'map', [], function $$4(i){
        
        if (i == null) i = nil;
        return $rb_plus("  from ", i);}).join("\n");
      }

      return backtrace;
    
    });
    return $def(self, '$to_s', function $$to_s() {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.message)) ? (self.message.$to_s()) : ($ret_or_2))))) {
        return $ret_or_1
      } else {
        return self.$class().$to_s()
      }
    });
  })('::', Error, $nesting);
  $klass('::', $$$('Exception'), 'ScriptError');
  $klass('::', $$$('ScriptError'), 'SyntaxError');
  $klass('::', $$$('ScriptError'), 'LoadError');
  $klass('::', $$$('ScriptError'), 'NotImplementedError');
  $klass('::', $$$('Exception'), 'SystemExit');
  $klass('::', $$$('Exception'), 'NoMemoryError');
  $klass('::', $$$('Exception'), 'SignalException');
  $klass('::', $$$('SignalException'), 'Interrupt');
  $klass('::', $$$('Exception'), 'SecurityError');
  $klass('::', $$$('Exception'), 'SystemStackError');
  $klass('::', $$$('Exception'), 'StandardError');
  $klass('::', $$$('StandardError'), 'EncodingError');
  $klass('::', $$$('StandardError'), 'ZeroDivisionError');
  $klass('::', $$$('StandardError'), 'NameError');
  $klass('::', $$$('NameError'), 'NoMethodError');
  $klass('::', $$$('StandardError'), 'RuntimeError');
  $klass('::', $$$('RuntimeError'), 'FrozenError');
  $klass('::', $$$('StandardError'), 'LocalJumpError');
  $klass('::', $$$('StandardError'), 'TypeError');
  $klass('::', $$$('StandardError'), 'ArgumentError');
  $klass('::', $$$('ArgumentError'), 'UncaughtThrowError');
  $klass('::', $$$('StandardError'), 'IndexError');
  $klass('::', $$$('IndexError'), 'StopIteration');
  $klass('::', $$$('StopIteration'), 'ClosedQueueError');
  $klass('::', $$$('IndexError'), 'KeyError');
  $klass('::', $$$('StandardError'), 'RangeError');
  $klass('::', $$$('RangeError'), 'FloatDomainError');
  $klass('::', $$$('StandardError'), 'IOError');
  $klass('::', $$$('IOError'), 'EOFError');
  $klass('::', $$$('StandardError'), 'SystemCallError');
  $klass('::', $$$('StandardError'), 'RegexpError');
  $klass('::', $$$('StandardError'), 'ThreadError');
  $klass('::', $$$('StandardError'), 'FiberError');
  $Object.$autoload("Errno", "corelib/error/errno");
  (function($base, $super) {
    var self = $klass($base, $super, 'FrozenError');

    
    
    self.$attr_reader("receiver");
    return $def(self, '$initialize', function $$initialize(message, $kwargs) {
      var receiver, $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      $kwargs = $ensure_kwargs($kwargs);
      
      receiver = $hash_get($kwargs, "receiver");if (receiver == null) receiver = nil;
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [message], null);
      return (self.receiver = receiver);
    }, -2);
  })('::', $$$('RuntimeError'));
  (function($base, $super) {
    var self = $klass($base, $super, 'UncaughtThrowError');

    var $proto = self.$$prototype;

    $proto.tag = nil;
    
    self.$attr_reader("tag", "value");
    return $def(self, '$initialize', function $$initialize(tag, value) {
      var $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      if (value == null) value = nil;
      self.tag = tag;
      self.value = value;
      return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', ["uncaught throw " + (self.tag.$inspect())], null);
    }, -2);
  })('::', $$$('ArgumentError'));
  (function($base, $super) {
    var self = $klass($base, $super, 'NameError');

    
    
    self.$attr_reader("name");
    return $def(self, '$initialize', function $$initialize(message, name) {
      var $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      if (name == null) name = nil;
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [message], null);
      return (self.name = name);
    }, -2);
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'NoMethodError');

    
    
    self.$attr_reader("args");
    return $def(self, '$initialize', function $$initialize(message, name, args) {
      var $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      if (name == null) name = nil;
      if (args == null) args = [];
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [message, name], null);
      return (self.args = args);
    }, -2);
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'StopIteration');

    
    return self.$attr_reader("result")
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'KeyError');

    var $proto = self.$$prototype;

    $proto.receiver = $proto.key = nil;
    
    
    $def(self, '$initialize', function $$initialize(message, $kwargs) {
      var receiver, key, $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      $kwargs = $ensure_kwargs($kwargs);
      
      receiver = $hash_get($kwargs, "receiver");if (receiver == null) receiver = nil;
      
      key = $hash_get($kwargs, "key");if (key == null) key = nil;
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [message], null);
      self.receiver = receiver;
      return (self.key = key);
    }, -2);
    
    $def(self, '$receiver', function $$receiver() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.receiver))) {
        return $ret_or_1
      } else {
        return $Kernel.$raise($$$('ArgumentError'), "no receiver is available")
      }
    });
    return $def(self, '$key', function $$key() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.key))) {
        return $ret_or_1
      } else {
        return $Kernel.$raise($$$('ArgumentError'), "no key is available")
      }
    });
  })('::', null);
  (function($base, $super) {
    var self = $klass($base, $super, 'LocalJumpError');

    
    
    self.$attr_reader("exit_value", "reason");
    return $def(self, '$initialize', function $$initialize(message, exit_value, reason) {
      var $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      if (exit_value == null) exit_value = nil;
      if (reason == null) reason = "noreason";
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [message], null);
      self.exit_value = exit_value;
      return (self.reason = reason);
    }, -2);
  })('::', null);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'JS');

    var $nesting = [self].concat($parent_nesting);

    return ($klass($nesting[0], null, 'Error'), nil)
  })('::', $nesting);
};

Opal.modules["corelib/constants"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $const_set = Opal.const_set, nil = Opal.nil, $$$ = Opal.$$$;

  
  $const_set('::', 'RUBY_PLATFORM', "opal");
  $const_set('::', 'RUBY_ENGINE', "opal");
  $const_set('::', 'RUBY_VERSION', "3.2.0");
  $const_set('::', 'RUBY_ENGINE_VERSION', "1.8.2");
  $const_set('::', 'RUBY_RELEASE_DATE', "2023-11-23");
  $const_set('::', 'RUBY_PATCHLEVEL', 0);
  $const_set('::', 'RUBY_REVISION', "0");
  $const_set('::', 'RUBY_COPYRIGHT', "opal - Copyright (C) 2011-2023 Adam Beynon and the Opal contributors");
  return $const_set('::', 'RUBY_DESCRIPTION', "opal " + ($$$('RUBY_ENGINE_VERSION')) + " (" + ($$$('RUBY_RELEASE_DATE')) + " revision " + ($$$('RUBY_REVISION')) + ")");
};

Opal.modules["opal/base"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $Object = Opal.Object, nil = Opal.nil;

  Opal.add_stubs('require');
  
  $Object.$require("corelib/runtime");
  $Object.$require("corelib/helpers");
  $Object.$require("corelib/module");
  $Object.$require("corelib/class");
  $Object.$require("corelib/basic_object");
  $Object.$require("corelib/kernel");
  $Object.$require("corelib/main");
  $Object.$require("corelib/error");
  return $Object.$require("corelib/constants");
};

Opal.modules["corelib/nil"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $Kernel = Opal.Kernel, $def = Opal.def, $return_val = Opal.return_val, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $NilClass = Opal.NilClass, $slice = Opal.slice, $truthy = Opal.truthy, $rb_gt = Opal.rb_gt, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('raise,name,new,>,length,Rational,to_i');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NilClass');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$prototype.$$meta = self;
    (function(self, $parent_nesting) {
      
      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + (self.$name()))
      });
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$!', $return_val(true));
    
    $def(self, '$&', $return_val(false));
    
    $def(self, '$|', function $NilClass_$$1(other) {
      
      return other !== false && other !== nil;
    });
    
    $def(self, '$^', function $NilClass_$$2(other) {
      
      return other !== false && other !== nil;
    });
    
    $def(self, '$==', function $NilClass_$eq_eq$3(other) {
      
      return other === nil;
    });
    
    $def(self, '$dup', $return_val(nil));
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $hash_get($kwargs, "freeze");if (freeze == null) freeze = true;
      return nil;
    }, -1);
    
    $def(self, '$inspect', $return_val("nil"));
    
    $def(self, '$nil?', $return_val(true));
    
    $def(self, '$singleton_class', function $$singleton_class() {
      
      return $NilClass
    });
    
    $def(self, '$to_a', function $$to_a() {
      
      return []
    });
    
    $def(self, '$to_h', function $$to_h() {
      
      return new Map();
    });
    
    $def(self, '$to_i', $return_val(0));
    
    $def(self, '$to_s', $return_val(""));
    
    $def(self, '$to_c', function $$to_c() {
      
      return $$$('Complex').$new(0, 0)
    });
    
    $def(self, '$rationalize', function $$rationalize($a) {
      var $post_args, args;

      
      $post_args = $slice(arguments);
      args = $post_args;
      if ($truthy($rb_gt(args.$length(), 1))) {
        $Kernel.$raise($$$('ArgumentError'))
      };
      return $Kernel.$Rational(0, 1);
    }, -1);
    
    $def(self, '$to_r', function $$to_r() {
      
      return $Kernel.$Rational(0, 1)
    });
    
    $def(self, '$instance_variables', function $$instance_variables() {
      
      return []
    });
    return $alias(self, "to_f", "to_i");
  })('::', null, $nesting)
};

Opal.modules["corelib/boolean"] = function(Opal) {/* Generated by Opal 1.8.2 */
  "use strict";
  var $klass = Opal.klass, $Kernel = Opal.Kernel, $def = Opal.def, $return_self = Opal.return_self, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $slice = Opal.slice, $truthy = Opal.truthy, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('raise,name,==,to_s,__id__');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Boolean');

    var $nesting = [self].concat($parent_nesting);

    
    Opal.prop(self.$$prototype, '$$is_boolean', true);
    
    var properties = ['$$class', '$$meta'];

    for (var i = 0; i < properties.length; i++) {
      Object.defineProperty(self.$$prototype, properties[i], {
        configurable: true,
        enumerable: false,
        get: function() {
          return this == true  ? Opal.TrueClass :
                 this == false ? Opal.FalseClass :
                                 Opal.Boolean;
        }
      });
    }

    Object.defineProperty(self.$$prototype, "$$id", {
      configurable: true,
      enumerable: false,
      get: function() {
        return this == true  ? 2 :
               this == false ? 0 :
                               nil;
      }
    });
  ;
    (function(self, $parent_nesting) {
      
      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + (self.$name()))
      });
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$__id__', function $$__id__() {
      var self = this;

      return self.valueOf() ? 2 : 0;
    });
    
    $def(self, '$!', function $Boolean_$excl$1() {
      var self = this;

      return self != true;
    });
    
    $def(self, '$&', function $Boolean_$$2(other) {
      var self = this;

      return (self == true) ? (other !== false && other !== nil) : false;
    });
    
    $def(self, '$|', function $Boolean_$$3(other) {
      var self = this;

      return (self == true) ? true : (other !== false && other !== nil);
    });
    
    $def(self, '$^', function $Boolean_$$4(other) {
      var self = this;

      return (self == true) ? (other === false || other === nil) : (other !== false && other !== nil);
    });
    
    $def(self, '$==', function $Boolean_$eq_eq$5(other) {
      var self = this;

      return (self == true) === other.valueOf();
    });
    
    $def(self, '$singleton_class', function $$singleton_class() {
      var self = this;

      return self.$$meta;
    });
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return (self == true) ? 'true' : 'false';
    });
    
    $def(self, '$dup', $return_self);
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze, self = this;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $hash_get($kwargs, "freeze");if (freeze == null) freeze = true;
      return self;
    }, -1);
    
    $def(self, '$method_missing', function $$method_missing(method, $a) {
      var block = $$method_missing.$$p || nil, $post_args, args, self = this;

      $$method_missing.$$p = null;
      
      ;
      $post_args = $slice(arguments, 1);
      args = $post_args;
      var body = self.$$class.$$prototype[Opal.jsid(method)];
      if (!$truthy(typeof body !== 'undefined' && !body.$$stub)) {
        $send2(self, $find_super(self, 'method_missing', $$method_missing, false, true), 'method_missing', [method].concat($to_a(args)), block)
      };
      return Opal.send(self, body, args, block);
    }, -2);
    
    $def(self, '$respond_to_missing?', function $Boolean_respond_to_missing$ques$6(method, _include_all) {
      var self = this;

      
      if (_include_all == null) _include_all = false;
      var body = self.$$class.$$prototype[Opal.jsid(method)];
      return typeof body !== 'undefined' && !body.$$stub;;
    }, -2);
    $alias(self, "eql?", "==");
    $alias(self, "equal?", "==");
    $alias(self, "inspect", "to_s");
    return $alias(self, "object_id", "__id__");
  })('::', Boolean, $nesting);
  $klass('::', $$$('Boolean'), 'TrueClass');
  return ($klass('::', $$$('Boolean'), 'FalseClass'), nil);
};

Opal.modules["corelib/comparable"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $truthy = Opal.truthy, $module = Opal.module, $rb_gt = Opal.rb_gt, $rb_lt = Opal.rb_lt, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $def = Opal.def, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('>,<,===,raise,class,<=>,equal?');
  return (function($base) {
    var self = $module($base, 'Comparable');

    var $ret_or_1 = nil;

    
    
    function normalize(what) {
      if (Opal.is_a(what, Opal.Integer)) { return what; }

      if ($rb_gt(what, 0)) { return 1; }
      if ($rb_lt(what, 0)) { return -1; }
      return 0;
    }

    function fail_comparison(lhs, rhs) {
      var class_name;
      (($eqeqeq(nil, ($ret_or_1 = rhs)) || (($eqeqeq(true, $ret_or_1) || (($eqeqeq(false, $ret_or_1) || (($eqeqeq($$$('Integer'), $ret_or_1) || ($eqeqeq($$$('Float'), $ret_or_1))))))))) ? (class_name = rhs.$inspect()) : (class_name = rhs.$$class))
      $Kernel.$raise($$$('ArgumentError'), "comparison of " + ((lhs).$class()) + " with " + (class_name) + " failed")
    }

    function cmp_or_fail(lhs, rhs) {
      var cmp = (lhs)['$<=>'](rhs);
      if (!$truthy(cmp)) fail_comparison(lhs, rhs);
      return normalize(cmp);
    }
  ;
    
    $def(self, '$==', function $Comparable_$eq_eq$1(other) {
      var self = this, cmp = nil;

      
      if ($truthy(self['$equal?'](other))) {
        return true
      };
      
      if (self["$<=>"] == Opal.Kernel["$<=>"]) {
        return false;
      }

      // check for infinite recursion
      if (self.$$comparable) {
        self.$$comparable = false;
        return false;
      }
    ;
      if (!$truthy((cmp = self['$<=>'](other)))) {
        return false
      };
      return normalize(cmp) == 0;;
    });
    
    $def(self, '$>', function $Comparable_$gt$2(other) {
      var self = this;

      return cmp_or_fail(self, other) > 0;
    });
    
    $def(self, '$>=', function $Comparable_$gt_eq$3(other) {
      var self = this;

      return cmp_or_fail(self, other) >= 0;
    });
    
    $def(self, '$<', function $Comparable_$lt$4(other) {
      var self = this;

      return cmp_or_fail(self, other) < 0;
    });
    
    $def(self, '$<=', function $Comparable_$lt_eq$5(other) {
      var self = this;

      return cmp_or_fail(self, other) <= 0;
    });
    
    $def(self, '$between?', function $Comparable_between$ques$6(min, max) {
      var self = this;

      
      if ($truthy($rb_lt(self, min))) {
        return false
      };
      if ($truthy($rb_gt(self, max))) {
        return false
      };
      return true;
    });
    return $def(self, '$clamp', function $$clamp(min, max) {
      var self = this;

      
      if (max == null) max = nil;
      
      var c, excl;

      if (max === nil) {
        // We are dealing with a new Ruby 2.7 behaviour that we are able to
        // provide a single Range argument instead of 2 Comparables.

        if (!Opal.is_a(min, Opal.Range)) {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + (min.$class()) + " (expected Range)")
        }

        excl = min.excl;
        max = min.end;
        min = min.begin;

        if (max !== nil && excl) {
          $Kernel.$raise($$$('ArgumentError'), "cannot clamp with an exclusive range")
        }
      }

      if (min !== nil && max !== nil && cmp_or_fail(min, max) > 0) {
        $Kernel.$raise($$$('ArgumentError'), "min argument must be smaller than max argument")
      }

      if (min !== nil) {
        c = cmp_or_fail(self, min);

        if (c == 0) return self;
        if (c < 0) return min;
      }

      if (max !== nil) {
        c = cmp_or_fail(self, max);

        if (c > 0) return max;
      }

      return self;
    ;
    }, -2);
  })('::')
};

Opal.modules["corelib/regexp"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $coerce_to = Opal.coerce_to, $prop = Opal.prop, $freeze = Opal.freeze, $klass = Opal.klass, $const_set = Opal.const_set, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $truthy = Opal.truthy, $gvars = Opal.gvars, $slice = Opal.slice, $Kernel = Opal.Kernel, $Opal = Opal.Opal, $alias = Opal.alias, $send = Opal.send, $regexp = Opal.regexp, $rb_plus = Opal.rb_plus, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $rb_ge = Opal.rb_ge, $to_a = Opal.to_a, $eqeqeq = Opal.eqeqeq, $rb_minus = Opal.rb_minus, $return_ivar = Opal.return_ivar, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('nil?,[],raise,escape,options,to_str,new,join,coerce_to!,!,match,coerce_to?,begin,frozen?,uniq,map,scan,source,to_proc,transform_values,group_by,each_with_index,+,last,=~,==,attr_reader,>=,length,is_a?,include?,names,regexp,named_captures,===,captures,-,inspect,empty?,each,to_a');
  
  $klass('::', $$$('StandardError'), 'RegexpError');
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Regexp');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $const_set(self, 'IGNORECASE', 1);
    $const_set(self, 'EXTENDED', 2);
    $const_set(self, 'MULTILINE', 4);
    Opal.prop(self.$$prototype, '$$is_regexp', true);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$allocate', function $$allocate() {
        var $yield = $$allocate.$$p || nil, self = this, allocated = nil;

        $$allocate.$$p = null;
        
        allocated = $send2(self, $find_super(self, 'allocate', $$allocate, false, true), 'allocate', [], $yield);
        allocated.uninitialized = true;
        return allocated;
      });
      
      $def(self, '$escape', function $$escape(string) {
        
        
        string = $coerce_to(string, $$$('String'), 'to_str');
        return Opal.escape_regexp(string);
      
      });
      
      $def(self, '$last_match', function $$last_match(n) {
                if ($gvars["~"] == null) $gvars["~"] = nil;

        
        if (n == null) n = nil;
        if ($truthy(n['$nil?']())) {
          return $gvars["~"]
        } else if ($truthy($gvars["~"])) {
          return $gvars["~"]['$[]'](n)
        } else {
          return nil
        };
      }, -1);
      
      $def(self, '$union', function $$union($a) {
        var $post_args, parts, self = this;

        
        $post_args = $slice(arguments);
        parts = $post_args;
        
        var is_first_part_array, quoted_validated, part, options, each_part_options;
        if (parts.length == 0) {
          return /(?!)/;
        }
        // return fast if there's only one element
        if (parts.length == 1 && parts[0].$$is_regexp) {
          return parts[0];
        }
        // cover the 2 arrays passed as arguments case
        is_first_part_array = parts[0].$$is_array;
        if (parts.length > 1 && is_first_part_array) {
          $Kernel.$raise($$$('TypeError'), "no implicit conversion of Array into String")
        }
        // deal with splat issues (related to https://github.com/opal/opal/issues/858)
        if (is_first_part_array) {
          parts = parts[0];
        }
        options = undefined;
        quoted_validated = [];
        for (var i=0; i < parts.length; i++) {
          part = parts[i];
          if (part.$$is_string) {
            quoted_validated.push(self.$escape(part));
          }
          else if (part.$$is_regexp) {
            each_part_options = (part).$options();
            if (options != undefined && options != each_part_options) {
              $Kernel.$raise($$$('TypeError'), "All expressions must use the same options")
            }
            options = each_part_options;
            quoted_validated.push('('+part.source+')');
          }
          else {
            quoted_validated.push(self.$escape((part).$to_str()));
          }
        }
      ;
        return self.$new((quoted_validated).$join("|"), options);
      }, -1);
      
      $def(self, '$new', function $new$1(regexp, options) {
        
        
        ;
        
        if (regexp.$$is_regexp) {
          return new RegExp(regexp);
        }

        regexp = $Opal['$coerce_to!'](regexp, $$$('String'), "to_str");

        if (regexp.charAt(regexp.length - 1) === '\\' && regexp.charAt(regexp.length - 2) !== '\\') {
          $Kernel.$raise($$$('RegexpError'), "too short escape sequence: /" + (regexp) + "/")
        }

        regexp = regexp.replace('\\A', '^').replace('\\z', '$')

        if (options === undefined || options['$!']()) {
          return new RegExp(regexp);
        }

        if (options.$$is_number) {
          var temp = '';
          if ($$('IGNORECASE') & options) { temp += 'i'; }
          if ($$('MULTILINE')  & options) { temp += 'm'; }
          options = temp;
        }
        else {
          options = 'i';
        }

        return new RegExp(regexp, options);
      ;
      }, -2);
      $alias(self, "compile", "new");
      return $alias(self, "quote", "escape");
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$==', function $Regexp_$eq_eq$2(other) {
      var self = this;

      return other instanceof RegExp && self.toString() === other.toString();
    });
    
    $def(self, '$===', function $Regexp_$eq_eq_eq$3(string) {
      var self = this;

      return self.$match($Opal['$coerce_to?'](string, $$$('String'), "to_str")) !== nil
    });
    
    $def(self, '$=~', function $Regexp_$eq_tilde$4(string) {
      var self = this, $ret_or_1 = nil;
      if ($gvars["~"] == null) $gvars["~"] = nil;

      if ($truthy(($ret_or_1 = self.$match(string)))) {
        return $gvars["~"].$begin(0)
      } else {
        return $ret_or_1
      }
    });
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if ($truthy(self['$frozen?']())) {
        return self
      };
      
      if (!self.hasOwnProperty('$$g')) { $prop(self, '$$g', null); }
      if (!self.hasOwnProperty('$$gm')) { $prop(self, '$$gm', null); }

      return $freeze(self);
    ;
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      var regexp_format = /^\/(.*)\/([^\/]*)$/;
      var value = self.toString();
      var matches = regexp_format.exec(value);
      if (matches) {
        var regexp_pattern = matches[1];
        var regexp_flags = matches[2];
        var chars = regexp_pattern.split('');
        var chars_length = chars.length;
        var char_escaped = false;
        var regexp_pattern_escaped = '';
        for (var i = 0; i < chars_length; i++) {
          var current_char = chars[i];
          if (!char_escaped && current_char == '/') {
            regexp_pattern_escaped = regexp_pattern_escaped.concat('\\');
          }
          regexp_pattern_escaped = regexp_pattern_escaped.concat(current_char);
          if (current_char == '\\') {
            if (char_escaped) {
              // does not over escape
              char_escaped = false;
            } else {
              char_escaped = true;
            }
          } else {
            char_escaped = false;
          }
        }
        return '/' + regexp_pattern_escaped + '/' + regexp_flags;
      } else {
        return value;
      }
    
    });
    
    $def(self, '$match', function $$match(string, pos) {
      var block = $$match.$$p || nil, self = this;
      if ($gvars["~"] == null) $gvars["~"] = nil;

      $$match.$$p = null;
      
      ;
      ;
      
      if (self.uninitialized) {
        $Kernel.$raise($$$('TypeError'), "uninitialized Regexp")
      }

      if (pos === undefined) {
        if (string === nil) return ($gvars["~"] = nil);
        var m = self.exec($coerce_to(string, $$$('String'), 'to_str'));
        if (m) {
          ($gvars["~"] = $$$('MatchData').$new(self, m));
          return block === nil ? $gvars["~"] : Opal.yield1(block, $gvars["~"]);
        } else {
          return ($gvars["~"] = nil);
        }
      }

      pos = $coerce_to(pos, $$$('Integer'), 'to_int');

      if (string === nil) {
        return ($gvars["~"] = nil);
      }

      string = $coerce_to(string, $$$('String'), 'to_str');

      if (pos < 0) {
        pos += string.length;
        if (pos < 0) {
          return ($gvars["~"] = nil);
        }
      }

      // global RegExp maintains state, so not using self/this
      var md, re = Opal.global_regexp(self);

      while (true) {
        md = re.exec(string);
        if (md === null) {
          return ($gvars["~"] = nil);
        }
        if (md.index >= pos) {
          ($gvars["~"] = $$$('MatchData').$new(re, md));
          return block === nil ? $gvars["~"] : Opal.yield1(block, $gvars["~"]);
        }
        re.lastIndex = md.index + 1;
      }
    ;
    }, -2);
    
    $def(self, '$match?', function $Regexp_match$ques$5(string, pos) {
      var self = this;

      
      ;
      
      if (self.uninitialized) {
        $Kernel.$raise($$$('TypeError'), "uninitialized Regexp")
      }

      if (pos === undefined) {
        return string === nil ? false : self.test($coerce_to(string, $$$('String'), 'to_str'));
      }

      pos = $coerce_to(pos, $$$('Integer'), 'to_int');

      if (string === nil) {
        return false;
      }

      string = $coerce_to(string, $$$('String'), 'to_str');

      if (pos < 0) {
        pos += string.length;
        if (pos < 0) {
          return false;
        }
      }

      // global RegExp maintains state, so not using self/this
      var md, re = Opal.global_regexp(self);

      md = re.exec(string);
      if (md === null || md.index < pos) {
        return false;
      } else {
        return true;
      }
    ;
    }, -2);
    
    $def(self, '$names', function $$names() {
      var self = this;

      return $send(self.$source().$scan($regexp(["\\(?<(\\w+)>"]), (new Map([["no_matchdata", true]]))), 'map', [], "first".$to_proc()).$uniq()
    });
    
    $def(self, '$named_captures', function $$named_captures() {
      var self = this;

      return $send($send($send(self.$source().$scan($regexp(["\\(?<(\\w+)>"]), (new Map([["no_matchdata", true]]))), 'map', [], "first".$to_proc()).$each_with_index(), 'group_by', [], "first".$to_proc()), 'transform_values', [], function $$6(i){
        
        if (i == null) i = nil;
        return $send(i, 'map', [], function $$7(j){
          
          if (j == null) j = nil;
          return $rb_plus(j.$last(), 1);});})
    });
    
    $def(self, '$~', function $Regexp_$$8() {
      var self = this;
      if ($gvars._ == null) $gvars._ = nil;

      return self['$=~']($gvars._)
    });
    
    $def(self, '$source', function $$source() {
      var self = this;

      return self.source;
    });
    
    $def(self, '$options', function $$options() {
      var self = this;

      
      if (self.uninitialized) {
        $Kernel.$raise($$$('TypeError'), "uninitialized Regexp")
      }
      var result = 0;
      // should be supported in IE6 according to https://msdn.microsoft.com/en-us/library/7f5z26w4(v=vs.94).aspx
      if (self.multiline) {
        result |= $$('MULTILINE');
      }
      if (self.ignoreCase) {
        result |= $$('IGNORECASE');
      }
      return result;
    
    });
    
    $def(self, '$casefold?', function $Regexp_casefold$ques$9() {
      var self = this;

      return self.ignoreCase;
    });
    $alias(self, "eql?", "==");
    return $alias(self, "to_s", "source");
  })('::', RegExp, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'MatchData');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.matches = nil;
    
    self.$attr_reader("post_match", "pre_match", "regexp", "string");
    
    $def(self, '$initialize', function $$initialize(regexp, match_groups, $kwargs) {
      var no_matchdata, self = this;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      no_matchdata = $hash_get($kwargs, "no_matchdata");if (no_matchdata == null) no_matchdata = false;
      if (!$truthy(no_matchdata)) {
        $gvars["~"] = self
      };
      self.regexp = regexp;
      self.begin = match_groups.index;
      self.string = match_groups.input;
      self.pre_match = match_groups.input.slice(0, match_groups.index);
      self.post_match = match_groups.input.slice(match_groups.index + match_groups[0].length);
      self.matches = [];
      
      for (var i = 0, length = match_groups.length; i < length; i++) {
        var group = match_groups[i];

        if (group == null) {
          self.matches.push(nil);
        }
        else {
          self.matches.push(group);
        }
      }
    ;
    }, -3);
    
    $def(self, '$match', function $$match(idx) {
      var self = this, match = nil;

      if ($truthy((match = self['$[]'](idx)))) {
        return match
      } else if (($truthy(idx['$is_a?']($$('Integer'))) && ($truthy($rb_ge(idx, self.$length()))))) {
        return $Kernel.$raise($$$('IndexError'), "index " + (idx) + " out of matches")
      } else {
        return nil
      }
    });
    
    $def(self, '$match_length', function $$match_length(idx) {
      var $a, self = this;

      return ($a = self.$match(idx), ($a === nil || $a == null) ? nil : $a.$length())
    });
    
    $def(self, '$[]', function $MatchData_$$$10($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      
      if (args[0].$$is_string) {
        if (self.$regexp().$names()['$include?'](args['$[]'](0))['$!']()) {
          $Kernel.$raise($$$('IndexError'), "undefined group name reference: " + (args['$[]'](0)))
        }
        return self.$named_captures()['$[]'](args['$[]'](0))
      }
      else {
        return $send(self.matches, '[]', $to_a(args))
      }
    ;
    }, -1);
    
    $def(self, '$offset', function $$offset(n) {
      var self = this;

      
      if (n !== 0) {
        $Kernel.$raise($$$('ArgumentError'), "MatchData#offset only supports 0th element")
      }
      return [self.begin, self.begin + self.matches[n].length];
    
    });
    
    $def(self, '$==', function $MatchData_$eq_eq$11(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil;

      
      if (!$eqeqeq($$$('MatchData'), other)) {
        return false
      };
      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = ($truthy(($ret_or_4 = self.string == other.string)) ? (self.regexp.toString() == other.regexp.toString()) : ($ret_or_4)))) ? (self.pre_match == other.pre_match) : ($ret_or_3)))) ? (self.post_match == other.post_match) : ($ret_or_2))))) {
        return self.begin == other.begin;
      } else {
        return $ret_or_1
      };
    });
    
    $def(self, '$begin', function $$begin(n) {
      var self = this;

      
      if (n !== 0) {
        $Kernel.$raise($$$('ArgumentError'), "MatchData#begin only supports 0th element")
      }
      return self.begin;
    
    });
    
    $def(self, '$end', function $$end(n) {
      var self = this;

      
      if (n !== 0) {
        $Kernel.$raise($$$('ArgumentError'), "MatchData#end only supports 0th element")
      }
      return self.begin + self.matches[n].length;
    
    });
    
    $def(self, '$captures', function $$captures() {
      var self = this;

      return self.matches.slice(1)
    });
    
    $def(self, '$named_captures', function $$named_captures() {
      var self = this, matches = nil;

      
      matches = self.$captures();
      return $send(self.$regexp().$named_captures(), 'transform_values', [], function $$12(i){
        
        if (i == null) i = nil;
        return matches['$[]']($rb_minus(i.$last(), 1));});
    });
    
    $def(self, '$names', function $$names() {
      var self = this;

      return self.$regexp().$names()
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      var str = "#<MatchData " + (self.matches[0]).$inspect();

      if (self.$regexp().$names()['$empty?']()) {
        for (var i = 1, length = self.matches.length; i < length; i++) {
          str += " " + i + ":" + (self.matches[i]).$inspect();
        }
      }
      else {
        $send(self.$named_captures(), 'each', [], function $$13(k, v){
        
        if (k == null) k = nil;
        if (v == null) v = nil;
        return                str += " " + k + ":" + v.$inspect();})
      }

      return str + ">";
    
    });
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.matches.length
    });
    
    $def(self, '$to_a', $return_ivar("matches"));
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return self.matches[0]
    });
    
    $def(self, '$values_at', function $$values_at($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      
      var i, a, index, values = [];

      for (i = 0; i < args.length; i++) {

        if (args[i].$$is_range) {
          a = (args[i]).$to_a();
          a.unshift(i, 1);
          Array.prototype.splice.apply(args, a);
        }

        index = $Opal['$coerce_to!'](args[i], $$$('Integer'), "to_int");

        if (index < 0) {
          index += self.matches.length;
          if (index < 0) {
            values.push(nil);
            continue;
          }
        }

        values.push(self.matches[index]);
      }

      return values;
    ;
    }, -1);
    $alias(self, "eql?", "==");
    return $alias(self, "size", "length");
  })($nesting[0], null, $nesting);
};

Opal.modules["corelib/string"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $global_multiline_regexp = Opal.global_multiline_regexp, $prop = Opal.prop, $opal32_init = Opal.opal32_init, $opal32_add = Opal.opal32_add, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $Opal = Opal.Opal, $defs = Opal.defs, $slice = Opal.slice, $send = Opal.send, $to_a = Opal.to_a, $extract_kwargs = Opal.extract_kwargs, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $truthy = Opal.truthy, $gvars = Opal.gvars, $rb_divide = Opal.rb_divide, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $alias = Opal.alias, $const_set = Opal.const_set, self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,coerce_to?,initialize,===,format,raise,respond_to?,to_s,to_str,<=>,==,=~,new,force_encoding,casecmp,empty?,ljust,ceil,/,+,rjust,floor,coerce_to!,nil?,class,copy_singleton_methods,initialize_clone,initialize_dup,enum_for,chomp,[],to_i,length,each_line,to_proc,to_a,match,match?,captures,proc,succ,escape,include?,upcase,unicode_normalize,dup,__id__,next,intern,pristine');
  
  self.$require("corelib/comparable");
  self.$require("corelib/regexp");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Comparable'));
    
    Opal.prop(self.$$prototype, '$$is_string', true);

    var string_id_map = new Map();
  ;
    
    (function() {
      'use strict';
      ($def(self, '$__id__', function $$__id__() {
      var $yield = $$__id__.$$p || nil, self = this;

      $$__id__.$$p = null;
      
            if (typeof self === 'object') {
              return $send2(self, $find_super(self, '__id__', $$__id__, false, true), '__id__', [], $yield)
            }
            if (string_id_map.has(self)) {
              return string_id_map.get(self);
            }
            var id = Opal.uid();
            string_id_map.set(self, id);
            return id;
          
    }), $def(self, '$hash', function $$hash() {
      var self = this;

      
            var hash = $opal32_init(), i, length = self.length;
            hash = $opal32_add(hash, 0x5);
            hash = $opal32_add(hash, length);
            for (i = 0; i < length; i++) {
              hash = $opal32_add(hash, self.charCodeAt(i));
            }
            return hash;
          
    }))
    })();
  ;
    $defs(self, '$try_convert', function $$try_convert(what) {
      
      return $Opal['$coerce_to?'](what, $$$('String'), "to_str")
    });
    $defs(self, '$new', function $String_new$1($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      
      var str = args[0] || "";
      var opts = args[args.length-1];
      str = $coerce_to(str, $$$('String'), 'to_str');
      if (opts && opts.$$is_hash) {
        if (opts.has('encoding')) str = str.$force_encoding(opts.get('encoding').value);
      }
      str = new self.$$constructor(str);
      if (!str.$initialize.$$pristine) $send((str), 'initialize', $to_a(args));
      return str;
    ;
    }, -1);
    
    $def(self, '$initialize', function $$initialize($a, $b) {
      var $post_args, $kwargs, str, encoding, capacity;

      
      $post_args = $slice(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      
      if ($post_args.length > 0) str = $post_args.shift();;
      
      encoding = $hash_get($kwargs, "encoding");if (encoding == null) encoding = nil;
      
      capacity = $hash_get($kwargs, "capacity");if (capacity == null) capacity = nil;
      return nil;
    }, -1);
    
    $def(self, '$%', function $String_$percent$2(data) {
      var self = this;

      if ($eqeqeq($$$('Array'), data)) {
        return $send(self, 'format', [self].concat($to_a(data)))
      } else {
        return self.$format(self, data)
      }
    });
    
    $def(self, '$*', function $String_$$3(count) {
      var self = this;

      
      count = $coerce_to(count, $$$('Integer'), 'to_int');

      if (count < 0) {
        $Kernel.$raise($$$('ArgumentError'), "negative argument")
      }

      if (count === 0) {
        return '';
      }

      var result = '',
          string = self.toString();

      // All credit for the bit-twiddling magic code below goes to Mozilla
      // polyfill implementation of String.prototype.repeat() posted here:
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat

      if (string.length * count >= 1 << 28) {
        $Kernel.$raise($$$('RangeError'), "multiply count must not overflow maximum string size")
      }

      for (;;) {
        if ((count & 1) === 1) {
          result += string;
        }
        count >>>= 1;
        if (count === 0) {
          break;
        }
        string += string;
      }

      return result;
    
    });
    
    $def(self, '$+', function $String_$plus$4(other) {
      var self = this;

      
      other = $coerce_to(other, $$$('String'), 'to_str');
      
      if (other == "" && self.$$class === Opal.String) return self;
      if (self == "" && other.$$class === Opal.String) return other;
      var out = self + other;
      if (self.encoding === out.encoding && other.encoding === out.encoding) return out;
      if (self.encoding.name === "UTF-8" || other.encoding.name === "UTF-8") return out;
      return Opal.enc(out, self.encoding);
    ;
    });
    
    $def(self, '$<=>', function $String_$lt_eq_gt$5(other) {
      var self = this;

      if ($truthy(other['$respond_to?']("to_str"))) {
        
        other = other.$to_str().$to_s();
        return self > other ? 1 : (self < other ? -1 : 0);;
      } else {
        
        var cmp = other['$<=>'](self);

        if (cmp === nil) {
          return nil;
        }
        else {
          return cmp > 0 ? -1 : (cmp < 0 ? 1 : 0);
        }
      
      }
    });
    
    $def(self, '$==', function $String_$eq_eq$6(other) {
      var self = this;

      
      if (other.$$is_string) {
        return self.toString() === other.toString();
      }
      if ($respond_to(other, '$to_str')) {
        return other['$=='](self);
      }
      return false;
    
    });
    
    $def(self, '$=~', function $String_$eq_tilde$7(other) {
      var self = this;

      
      if (other.$$is_string) {
        $Kernel.$raise($$$('TypeError'), "type mismatch: String given");
      }

      return other['$=~'](self);
    
    });
    
    $def(self, '$[]', function $String_$$$8(index, length) {
      var self = this;

      
      ;
      
      var size = self.length, exclude, range;

      if (index.$$is_range) {
        exclude = index.excl;
        range   = index;
        length  = index.end === nil ? -1 : $coerce_to(index.end, $$$('Integer'), 'to_int');
        index   = index.begin === nil ? 0 : $coerce_to(index.begin, $$$('Integer'), 'to_int');

        if (Math.abs(index) > size) {
          return nil;
        }

        if (index < 0) {
          index += size;
        }

        if (length < 0) {
          length += size;
        }

        if (!exclude || range.end === nil) {
          length += 1;
        }

        length = length - index;

        if (length < 0) {
          length = 0;
        }

        return self.substr(index, length);
      }


      if (index.$$is_string) {
        if (length != null) {
          $Kernel.$raise($$$('TypeError'))
        }
        return self.indexOf(index) !== -1 ? index : nil;
      }


      if (index.$$is_regexp) {
        var match = self.match(index);

        if (match === null) {
          ($gvars["~"] = nil)
          return nil;
        }

        ($gvars["~"] = $$$('MatchData').$new(index, match))

        if (length == null) {
          return match[0];
        }

        length = $coerce_to(length, $$$('Integer'), 'to_int');

        if (length < 0 && -length < match.length) {
          return match[length += match.length];
        }

        if (length >= 0 && length < match.length) {
          return match[length];
        }

        return nil;
      }


      index = $coerce_to(index, $$$('Integer'), 'to_int');

      if (index < 0) {
        index += size;
      }

      if (length == null) {
        if (index >= size || index < 0) {
          return nil;
        }
        return self.substr(index, 1);
      }

      length = $coerce_to(length, $$$('Integer'), 'to_int');

      if (length < 0) {
        return nil;
      }

      if (index > size || index < 0) {
        return nil;
      }

      return self.substr(index, length);
    ;
    }, -2);
    
    $def(self, '$b', function $$b() {
      var self = this;

      return (new String(self)).$force_encoding("binary")
    });
    
    $def(self, '$capitalize', function $$capitalize() {
      var self = this;

      return self.charAt(0).toUpperCase() + self.substr(1).toLowerCase();
    });
    
    $def(self, '$casecmp', function $$casecmp(other) {
      var self = this;

      
      if (!$truthy(other['$respond_to?']("to_str"))) {
        return nil
      };
      other = ($coerce_to(other, $$$('String'), 'to_str')).$to_s();
      
      var ascii_only = /^[\x00-\x7F]*$/;
      if (ascii_only.test(self) && ascii_only.test(other)) {
        self = self.toLowerCase();
        other = other.toLowerCase();
      }
    ;
      return self['$<=>'](other);
    });
    
    $def(self, '$casecmp?', function $String_casecmp$ques$9(other) {
      var self = this;

      
      var cmp = self.$casecmp(other);
      if (cmp === nil) {
        return nil;
      } else {
        return cmp === 0;
      }
    
    });
    
    $def(self, '$center', function $$center(width, padstr) {
      var self = this;

      
      if (padstr == null) padstr = " ";
      width = $coerce_to(width, $$$('Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$$('String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        $Kernel.$raise($$$('ArgumentError'), "zero width padding")
      };
      if ($truthy(width <= self.length)) {
        return self
      };
      
      var ljustified = self.$ljust($rb_divide($rb_plus(width, self.length), 2).$ceil(), padstr),
          rjustified = self.$rjust($rb_divide($rb_plus(width, self.length), 2).$floor(), padstr);

      return rjustified + ljustified.slice(self.length);
    ;
    }, -2);
    
    $def(self, '$chomp', function $$chomp(separator) {
      var self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      if (separator == null) separator = $gvars["/"];
      if ($truthy(separator === nil || self.length === 0)) {
        return self
      };
      separator = $Opal['$coerce_to!'](separator, $$$('String'), "to_str").$to_s();
      
      var result;

      if (separator === "\n") {
        result = self.replace(/\r?\n?$/, '');
      }
      else if (separator === "") {
        result = self.replace(/(\r?\n)+$/, '');
      }
      else if (self.length >= separator.length) {
        var tail = self.substr(self.length - separator.length, separator.length);

        if (tail === separator) {
          result = self.substr(0, self.length - separator.length);
        }
      }

      if (result != null) {
        return result;
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$chop', function $$chop() {
      var self = this;

      
      var length = self.length, result;

      if (length <= 1) {
        result = "";
      } else if (self.charAt(length - 1) === "\n" && self.charAt(length - 2) === "\r") {
        result = self.substr(0, length - 2);
      } else {
        result = self.substr(0, length - 1);
      }

      return result;
    
    });
    
    $def(self, '$chr', function $$chr() {
      var self = this;

      return self.charAt(0);
    });
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze, self = this, copy = nil;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $hash_get($kwargs, "freeze");if (freeze == null) freeze = nil;
      if (!(($truthy(freeze['$nil?']()) || ($eqeq(freeze, true))) || ($eqeq(freeze, false)))) {
        self.$raise($$('ArgumentError'), "unexpected value for freeze: " + (freeze.$class()))
      };
      copy = new String(self);
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self, (new Map([["freeze", freeze]])));
      if ($eqeq(freeze, true)) {
        if (!copy.$$frozen) { copy.$$frozen = true; }
      } else if ($truthy(freeze['$nil?']())) {
        if (self.$$frozen) { copy.$$frozen = true; }
      };
      return copy;
    }, -1);
    
    $def(self, '$dup', function $$dup() {
      var self = this, copy = nil;

      
      copy = new String(self);
      copy.$initialize_dup(self);
      return copy;
    });
    
    $def(self, '$count', function $$count($a) {
      var $post_args, sets, self = this;

      
      $post_args = $slice(arguments);
      sets = $post_args;
      
      if (sets.length === 0) {
        $Kernel.$raise($$$('ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)")
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return 0;
      }
      return self.length - self.replace(new RegExp(char_class, 'g'), '').length;
    ;
    }, -1);
    
    $def(self, '$delete', function $String_delete$10($a) {
      var $post_args, sets, self = this;

      
      $post_args = $slice(arguments);
      sets = $post_args;
      
      if (sets.length === 0) {
        $Kernel.$raise($$$('ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)")
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      return self.replace(new RegExp(char_class, 'g'), '');
    ;
    }, -1);
    
    $def(self, '$delete_prefix', function $$delete_prefix(prefix) {
      var self = this;

      
      if (!prefix.$$is_string) {
        prefix = $coerce_to(prefix, $$$('String'), 'to_str');
      }

      if (self.slice(0, prefix.length) === prefix) {
        return self.slice(prefix.length);
      } else {
        return self;
      }
    
    });
    
    $def(self, '$delete_suffix', function $$delete_suffix(suffix) {
      var self = this;

      
      if (!suffix.$$is_string) {
        suffix = $coerce_to(suffix, $$$('String'), 'to_str');
      }

      if (self.slice(self.length - suffix.length) === suffix) {
        return self.slice(0, self.length - suffix.length);
      } else {
        return self;
      }
    
    });
    
    $def(self, '$downcase', function $$downcase() {
      var self = this;

      return self.toLowerCase();
    });
    
    $def(self, '$each_line', function $$each_line($a, $b) {
      var block = $$each_line.$$p || nil, $post_args, $kwargs, separator, chomp, self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      $$each_line.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      
      if ($post_args.length > 0) separator = $post_args.shift();if (separator == null) separator = $gvars["/"];
      
      chomp = $hash_get($kwargs, "chomp");if (chomp == null) chomp = false;
      if (!(block !== nil)) {
        return self.$enum_for("each_line", separator, (new Map([["chomp", chomp]])))
      };
      
      if (separator === nil) {
        Opal.yield1(block, self);

        return self;
      }

      separator = $coerce_to(separator, $$$('String'), 'to_str');

      var a, i, n, length, chomped, trailing, splitted, value;

      if (separator.length === 0) {
        for (a = self.split(/((?:\r?\n){2})(?:(?:\r?\n)*)/), i = 0, n = a.length; i < n; i += 2) {
          if (a[i] || a[i + 1]) {
            value = (a[i] || "") + (a[i + 1] || "");
            if (chomp) {
              value = (value).$chomp("\n");
            }
            Opal.yield1(block, value);
          }
        }

        return self;
      }

      chomped  = self.$chomp(separator);
      trailing = self.length != chomped.length;
      splitted = chomped.split(separator);

      for (i = 0, length = splitted.length; i < length; i++) {
        value = splitted[i];
        if (i < length - 1 || trailing) {
          value += separator;
        }
        if (chomp) {
          value = (value).$chomp(separator);
        }
        Opal.yield1(block, value);
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$empty?', function $String_empty$ques$11() {
      var self = this;

      return self.length === 0;
    });
    
    $def(self, '$end_with?', function $String_end_with$ques$12($a) {
      var $post_args, suffixes, self = this;

      
      $post_args = $slice(arguments);
      suffixes = $post_args;
      
      for (var i = 0, length = suffixes.length; i < length; i++) {
        var suffix = $coerce_to(suffixes[i], $$$('String'), 'to_str').$to_s();

        if (self.length >= suffix.length &&
            self.substr(self.length - suffix.length, suffix.length) == suffix) {
          return true;
        }
      }
    ;
      return false;
    }, -1);
    
    $def(self, '$gsub', function $$gsub(pattern, replacement) {
      var block = $$gsub.$$p || nil, self = this;

      $$gsub.$$p = null;
      
      ;
      ;
      
      if (replacement === undefined && block === nil) {
        return self.$enum_for("gsub", pattern);
      }

      var result = '', match_data = nil, index = 0, match, _replacement;

      if (pattern.$$is_regexp) {
        pattern = $global_multiline_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$$('String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
      }

      var lastIndex;
      while (true) {
        match = pattern.exec(self);

        if (match === null) {
          ($gvars["~"] = nil)
          result += self.slice(index);
          break;
        }

        match_data = $$$('MatchData').$new(pattern, match);

        if (replacement === undefined) {
          lastIndex = pattern.lastIndex;
          _replacement = block(match[0]);
          pattern.lastIndex = lastIndex; // save and restore lastIndex
        }
        else if (replacement.$$is_hash) {
          _replacement = (replacement)['$[]'](match[0]).$to_s();
        }
        else {
          if (!replacement.$$is_string) {
            replacement = $coerce_to(replacement, $$$('String'), 'to_str');
          }
          _replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function (original, slashes, command) {
            if (slashes.length % 2 === 0) {
              return original;
            }
            switch (command) {
            case "+":
              for (var i = match.length - 1; i > 0; i--) {
                if (match[i] !== undefined) {
                  return slashes.slice(1) + match[i];
                }
              }
              return '';
            case "&": return slashes.slice(1) + match[0];
            case "`": return slashes.slice(1) + self.slice(0, match.index);
            case "'": return slashes.slice(1) + self.slice(match.index + match[0].length);
            default:  return slashes.slice(1) + (match[command] || '');
            }
          }).replace(/\\\\/g, '\\');
        }

        if (pattern.lastIndex === match.index) {
          result += (self.slice(index, match.index) + _replacement + (self[match.index] || ""));
          pattern.lastIndex += 1;
        }
        else {
          result += (self.slice(index, match.index) + _replacement)
        }
        index = pattern.lastIndex;
      }

      ($gvars["~"] = match_data)
      return result;
    ;
    }, -2);
    
    $def(self, '$hex', function $$hex() {
      var self = this;

      return self.$to_i(16)
    });
    
    $def(self, '$include?', function $String_include$ques$13(other) {
      var self = this;

      
      if (!other.$$is_string) {
        other = $coerce_to(other, $$$('String'), 'to_str');
      }
      return self.indexOf(other) !== -1;
    
    });
    
    $def(self, '$index', function $$index(search, offset) {
      var self = this;

      
      ;
      
      var index,
          match,
          regex;

      if (offset === undefined) {
        offset = 0;
      } else {
        offset = $coerce_to(offset, $$$('Integer'), 'to_int');
        if (offset < 0) {
          offset += self.length;
          if (offset < 0) {
            return nil;
          }
        }
      }

      if (search.$$is_regexp) {
        regex = $global_multiline_regexp(search);
        while (true) {
          match = regex.exec(self);
          if (match === null) {
            ($gvars["~"] = nil);
            index = -1;
            break;
          }
          if (match.index >= offset) {
            ($gvars["~"] = $$$('MatchData').$new(regex, match))
            index = match.index;
            break;
          }
          regex.lastIndex = match.index + 1;
        }
      } else {
        search = $coerce_to(search, $$$('String'), 'to_str');
        if (search.length === 0 && offset > self.length) {
          index = -1;
        } else {
          index = self.indexOf(search, offset);
        }
      }

      return index === -1 ? nil : index;
    ;
    }, -2);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      /* eslint-disable no-misleading-character-class */
      var escapable = /[\\\"\x00-\x1f\u007F-\u009F\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
          meta = {
            '\u0007': '\\a',
            '\u001b': '\\e',
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '\v': '\\v',
            '"' : '\\"',
            '\\': '\\\\'
          },
          escaped = self.replace(escapable, function (chr) {
            if (meta[chr]) return meta[chr];
            chr = chr.charCodeAt(0);
            if (chr <= 0xff && (self.encoding["$binary?"]() || self.internal_encoding["$binary?"]())) {
              return '\\x' + ('00' + chr.toString(16).toUpperCase()).slice(-2);
            } else {
              return '\\u' + ('0000' + chr.toString(16).toUpperCase()).slice(-4);
            }
          });
      return '"' + escaped.replace(/\#[\$\@\{]/g, '\\$&') + '"';
      /* eslint-enable no-misleading-character-class */
    
    });
    
    $def(self, '$intern', function $$intern() {
      var self = this;

      return self.toString();
    });
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.length;
    });
    $alias(self, "size", "length");
    
    $def(self, '$lines', function $$lines($a, $b) {
      var block = $$lines.$$p || nil, $post_args, $kwargs, separator, chomp, self = this, e = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      $$lines.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      
      if ($post_args.length > 0) separator = $post_args.shift();if (separator == null) separator = $gvars["/"];
      
      chomp = $hash_get($kwargs, "chomp");if (chomp == null) chomp = false;
      e = $send(self, 'each_line', [separator, (new Map([["chomp", chomp]]))], block.$to_proc());
      if ($truthy(block)) {
        return self
      } else {
        return e.$to_a()
      };
    }, -1);
    
    $def(self, '$ljust', function $$ljust(width, padstr) {
      var self = this;

      
      if (padstr == null) padstr = " ";
      width = $coerce_to(width, $$$('Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$$('String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        $Kernel.$raise($$$('ArgumentError'), "zero width padding")
      };
      if ($truthy(width <= self.length)) {
        return self
      };
      
      var index  = -1,
          result = "";

      width -= self.length;

      while (++index < width) {
        result += padstr;
      }

      return self + result.slice(0, width);
    ;
    }, -2);
    
    $def(self, '$lstrip', function $$lstrip() {
      var self = this;

      return self.replace(/^[\x00\x09\x0a-\x0d\x20]*/, '');
    });
    
    $def(self, '$ascii_only?', function $String_ascii_only$ques$14() {
      var self = this;

      
      if (!self.encoding.ascii) return false;
      return /^[\x00-\x7F]*$/.test(self);
    
    });
    
    $def(self, '$match', function $$match(pattern, pos) {
      var block = $$match.$$p || nil, self = this;

      $$match.$$p = null;
      
      ;
      ;
      if (($eqeqeq($$('String'), pattern) || ($truthy(pattern['$respond_to?']("to_str"))))) {
        pattern = $$$('Regexp').$new(pattern.$to_str())
      };
      if (!$eqeqeq($$$('Regexp'), pattern)) {
        $Kernel.$raise($$$('TypeError'), "wrong argument type " + (pattern.$class()) + " (expected Regexp)")
      };
      return $send(pattern, 'match', [self, pos], block.$to_proc());
    }, -2);
    
    $def(self, '$match?', function $String_match$ques$15(pattern, pos) {
      var self = this;

      
      ;
      if (($eqeqeq($$('String'), pattern) || ($truthy(pattern['$respond_to?']("to_str"))))) {
        pattern = $$$('Regexp').$new(pattern.$to_str())
      };
      if (!$eqeqeq($$$('Regexp'), pattern)) {
        $Kernel.$raise($$$('TypeError'), "wrong argument type " + (pattern.$class()) + " (expected Regexp)")
      };
      return pattern['$match?'](self, pos);
    }, -2);
    
    $def(self, '$next', function $$next() {
      var self = this;

      
      var i = self.length;
      if (i === 0) {
        return '';
      }
      var result = self;
      var first_alphanum_char_index = self.search(/[a-zA-Z0-9]/);
      var carry = false;
      var code;
      while (i--) {
        code = self.charCodeAt(i);
        if ((code >= 48 && code <= 57) ||
          (code >= 65 && code <= 90) ||
          (code >= 97 && code <= 122)) {
          switch (code) {
          case 57:
            carry = true;
            code = 48;
            break;
          case 90:
            carry = true;
            code = 65;
            break;
          case 122:
            carry = true;
            code = 97;
            break;
          default:
            carry = false;
            code += 1;
          }
        } else {
          if (first_alphanum_char_index === -1) {
            if (code === 255) {
              carry = true;
              code = 0;
            } else {
              carry = false;
              code += 1;
            }
          } else {
            carry = true;
          }
        }
        result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i + 1);
        if (carry && (i === 0 || i === first_alphanum_char_index)) {
          switch (code) {
          case 65:
            break;
          case 97:
            break;
          default:
            code += 1;
          }
          if (i === 0) {
            result = String.fromCharCode(code) + result;
          } else {
            result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i);
          }
          carry = false;
        }
        if (!carry) {
          break;
        }
      }
      return result;
    
    });
    
    $def(self, '$oct', function $$oct() {
      var self = this;

      
      var result,
          string = self,
          radix = 8;

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/i, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case '+':
        case '-':
          return original;
        case '0':
          if (tail.charAt(1) === 'x' && flag === '0x') {
            return original;
          }
        }
        switch (flag) {
        case '0b':
          radix = 2;
          break;
        case '0':
        case '0o':
          radix = 8;
          break;
        case '0d':
          radix = 10;
          break;
        case '0x':
          radix = 16;
          break;
        }
        return head + tail;
      });

      result = parseInt(string.replace(/_(?!_)/g, ''), radix);
      return isNaN(result) ? 0 : result;
    
    });
    
    $def(self, '$ord', function $$ord() {
      var self = this;

      
      if (typeof self.codePointAt === "function") {
        return self.codePointAt(0);
      }
      else {
        return self.charCodeAt(0);
      }
    
    });
    
    $def(self, '$partition', function $$partition(sep) {
      var self = this;

      
      var i, m;

      if (sep.$$is_regexp) {
        m = sep.exec(self);
        if (m === null) {
          i = -1;
        } else {
          $$$('MatchData').$new(sep, m);
          sep = m[0];
          i = m.index;
        }
      } else {
        sep = $coerce_to(sep, $$$('String'), 'to_str');
        i = self.indexOf(sep);
      }

      if (i === -1) {
        return [self, '', ''];
      }

      return [
        self.slice(0, i),
        self.slice(i, i + sep.length),
        self.slice(i + sep.length)
      ];
    
    });
    
    $def(self, '$reverse', function $$reverse() {
      var self = this;

      return self.split('').reverse().join('');
    });
    
    $def(self, '$rindex', function $$rindex(search, offset) {
      var self = this;

      
      ;
      
      var i, m, r, _m;

      if (offset === undefined) {
        offset = self.length;
      } else {
        offset = $coerce_to(offset, $$$('Integer'), 'to_int');
        if (offset < 0) {
          offset += self.length;
          if (offset < 0) {
            return nil;
          }
        }
      }

      if (search.$$is_regexp) {
        m = null;
        r = $global_multiline_regexp(search);
        while (true) {
          _m = r.exec(self);
          if (_m === null || _m.index > offset) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }
        if (m === null) {
          ($gvars["~"] = nil)
          i = -1;
        } else {
          $$$('MatchData').$new(r, m);
          i = m.index;
        }
      } else {
        search = $coerce_to(search, $$$('String'), 'to_str');
        i = self.lastIndexOf(search, offset);
      }

      return i === -1 ? nil : i;
    ;
    }, -2);
    
    $def(self, '$rjust', function $$rjust(width, padstr) {
      var self = this;

      
      if (padstr == null) padstr = " ";
      width = $coerce_to(width, $$$('Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$$('String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        $Kernel.$raise($$$('ArgumentError'), "zero width padding")
      };
      if ($truthy(width <= self.length)) {
        return self
      };
      
      var chars     = Math.floor(width - self.length),
          patterns  = Math.floor(chars / padstr.length),
          result    = Array(patterns + 1).join(padstr),
          remaining = chars - result.length;

      return result + padstr.slice(0, remaining) + self;
    ;
    }, -2);
    
    $def(self, '$rpartition', function $$rpartition(sep) {
      var self = this;

      
      var i, m, r, _m;

      if (sep.$$is_regexp) {
        m = null;
        r = $global_multiline_regexp(sep);

        while (true) {
          _m = r.exec(self);
          if (_m === null) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }

        if (m === null) {
          i = -1;
        } else {
          $$$('MatchData').$new(r, m);
          sep = m[0];
          i = m.index;
        }

      } else {
        sep = $coerce_to(sep, $$$('String'), 'to_str');
        i = self.lastIndexOf(sep);
      }

      if (i === -1) {
        return ['', '', self];
      }

      return [
        self.slice(0, i),
        self.slice(i, i + sep.length),
        self.slice(i + sep.length)
      ];
    
    });
    
    $def(self, '$rstrip', function $$rstrip() {
      var self = this;

      return self.replace(/[\x00\x09\x0a-\x0d\x20]*$/, '');
    });
    
    $def(self, '$scan', function $$scan(pattern, $kwargs) {
      var block = $$scan.$$p || nil, no_matchdata, self = this;

      $$scan.$$p = null;
      
      ;
      $kwargs = $ensure_kwargs($kwargs);
      
      no_matchdata = $hash_get($kwargs, "no_matchdata");if (no_matchdata == null) no_matchdata = false;
      
      var result = [],
          match_data = nil,
          match;

      if (pattern.$$is_regexp) {
        pattern = $global_multiline_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$$('String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
      }

      while ((match = pattern.exec(self)) != null) {
        match_data = $$$('MatchData').$new(pattern, match, (new Map([["no_matchdata", no_matchdata]])));
        if (block === nil) {
          match.length == 1 ? result.push(match[0]) : result.push((match_data).$captures());
        } else {
          match.length == 1 ? Opal.yield1(block, match[0]) : Opal.yield1(block, (match_data).$captures());
        }
        if (pattern.lastIndex === match.index) {
          pattern.lastIndex += 1;
        }
      }

      if (!no_matchdata) ($gvars["~"] = match_data);

      return (block !== nil ? self : result);
    ;
    }, -2);
    
    $def(self, '$singleton_class', function $$singleton_class() {
      var self = this;

      return Opal.get_singleton_class(self);
    });
    
    $def(self, '$split', function $$split(pattern, limit) {
      var self = this, $ret_or_1 = nil;
      if ($gvars[";"] == null) $gvars[";"] = nil;

      
      ;
      ;
      
      if (self.length === 0) {
        return [];
      }

      if (limit === undefined) {
        limit = 0;
      } else {
        limit = $Opal['$coerce_to!'](limit, $$$('Integer'), "to_int");
        if (limit === 1) {
          return [self];
        }
      }

      if (pattern === undefined || pattern === nil) {
        pattern = ($truthy(($ret_or_1 = $gvars[";"])) ? ($ret_or_1) : (" "));
      }

      var result = [],
          string = self.toString(),
          index = 0,
          match,
          match_count = 0,
          valid_result_length = 0,
          i, max;

      if (pattern.$$is_regexp) {
        pattern = $global_multiline_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$$('String'), 'to_str').$to_s();

        if (pattern === ' ') {
          pattern = /\s+/gm;
          string = string.replace(/^\s+/, '');
        }
      }

      result = string.split(pattern);

      if (result.length === 1 && result[0] === string) {
        return [result[0]];
      }

      while ((i = result.indexOf(undefined)) !== -1) {
        result.splice(i, 1);
      }

      if (limit === 0) {
        while (result[result.length - 1] === '') {
          result.pop();
        }
        return result;
      }

      if (!pattern.$$is_regexp) {
        pattern = Opal.escape_regexp(pattern)
        pattern = new RegExp(pattern, 'gm');
      }

      match = pattern.exec(string);

      if (limit < 0) {
        if (match !== null && match[0] === '' && pattern.source.indexOf('(?=') === -1) {
          for (i = 0, max = match.length; i < max; i++) {
            result.push('');
          }
        }
        return result;
      }

      if (match !== null && match[0] === '') {
        valid_result_length = (match.length - 1) * (limit - 1) + limit
        result.splice(valid_result_length - 1, result.length - 1, result.slice(valid_result_length - 1).join(''));
        return result;
      }

      if (limit >= result.length) {
        return result;
      }

      while (match !== null) {
        match_count++;
        index = pattern.lastIndex;
        valid_result_length += match.length
        if (match_count + 1 === limit) {
          break;
        }
        match = pattern.exec(string);
      }
      result.splice(valid_result_length, result.length - 1, string.slice(index));
      return result;
    ;
    }, -1);
    
    $def(self, '$squeeze', function $$squeeze($a) {
      var $post_args, sets, self = this;

      
      $post_args = $slice(arguments);
      sets = $post_args;
      
      if (sets.length === 0) {
        return self.replace(/(.)\1+/g, '$1');
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      return self.replace(new RegExp('(' + char_class + ')\\1+', 'g'), '$1');
    ;
    }, -1);
    
    $def(self, '$start_with?', function $String_start_with$ques$16($a) {
      var $post_args, prefixes, self = this;

      
      $post_args = $slice(arguments);
      prefixes = $post_args;
      
      for (var i = 0, length = prefixes.length; i < length; i++) {
        if (prefixes[i].$$is_regexp) {
          var regexp = prefixes[i];
          var match = regexp.exec(self);

          if (match != null && match.index === 0) {
            ($gvars["~"] = $$$('MatchData').$new(regexp, match));
            return true;
          } else {
            ($gvars["~"] = nil)
          }
        } else {
          var prefix = $coerce_to(prefixes[i], $$$('String'), 'to_str').$to_s();

          if (self.length >= prefix.length && self.startsWith(prefix)) {
            return true;
          }
        }
      }

      return false;
    ;
    }, -1);
    
    $def(self, '$strip', function $$strip() {
      var self = this;

      return self.replace(/^[\x00\x09\x0a-\x0d\x20]*|[\x00\x09\x0a-\x0d\x20]*$/g, '');
    });
    
    $def(self, '$sub', function $$sub(pattern, replacement) {
      var block = $$sub.$$p || nil, self = this;

      $$sub.$$p = null;
      
      ;
      ;
      
      if (!pattern.$$is_regexp) {
        pattern = $coerce_to(pattern, $$$('String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
      }

      var result, match = pattern.exec(self);

      if (match === null) {
        ($gvars["~"] = nil)
        result = self.toString();
      } else {
        $$$('MatchData').$new(pattern, match)

        if (replacement === undefined) {

          if (block === nil) {
            $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (1 for 2)")
          }
          result = self.slice(0, match.index) + block(match[0]) + self.slice(match.index + match[0].length);

        } else if (replacement.$$is_hash) {

          result = self.slice(0, match.index) + (replacement)['$[]'](match[0]).$to_s() + self.slice(match.index + match[0].length);

        } else {

          replacement = $coerce_to(replacement, $$$('String'), 'to_str');

          replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function (original, slashes, command) {
            if (slashes.length % 2 === 0) {
              return original;
            }
            switch (command) {
            case "+":
              for (var i = match.length - 1; i > 0; i--) {
                if (match[i] !== undefined) {
                  return slashes.slice(1) + match[i];
                }
              }
              return '';
            case "&": return slashes.slice(1) + match[0];
            case "`": return slashes.slice(1) + self.slice(0, match.index);
            case "'": return slashes.slice(1) + self.slice(match.index + match[0].length);
            default:  return slashes.slice(1) + (match[command] || '');
            }
          }).replace(/\\\\/g, '\\');

          result = self.slice(0, match.index) + replacement + self.slice(match.index + match[0].length);
        }
      }

      return result;
    ;
    }, -2);
    
    $def(self, '$sum', function $$sum(n) {
      var self = this;

      
      if (n == null) n = 16;
      
      n = $coerce_to(n, $$$('Integer'), 'to_int');

      var result = 0,
          length = self.length,
          i = 0;

      for (; i < length; i++) {
        result += self.charCodeAt(i);
      }

      if (n <= 0) {
        return result;
      }

      return result & (Math.pow(2, n) - 1);
    ;
    }, -1);
    
    $def(self, '$swapcase', function $$swapcase() {
      var self = this;

      
      var str = self.replace(/([a-z]+)|([A-Z]+)/g, function($0,$1,$2) {
        return $1 ? $0.toUpperCase() : $0.toLowerCase();
      });

      return str;
    
    });
    
    $def(self, '$to_f', function $$to_f() {
      var self = this;

      
      if (self.charAt(0) === '_') {
        return 0;
      }

      var result = parseFloat(self.replace(/_/g, ''));

      if (isNaN(result) || result == Infinity || result == -Infinity) {
        return 0;
      }
      else {
        return result;
      }
    
    });
    
    $def(self, '$to_i', function $$to_i(base) {
      var self = this;

      
      if (base == null) base = 10;
      
      var result,
          string = self.toLowerCase(),
          radix = $coerce_to(base, $$$('Integer'), 'to_int');

      if (radix === 1 || radix < 0 || radix > 36) {
        $Kernel.$raise($$$('ArgumentError'), "invalid radix " + (radix))
      }

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case '+':
        case '-':
          return original;
        case '0':
          if (tail.charAt(1) === 'x' && flag === '0x' && (radix === 0 || radix === 16)) {
            return original;
          }
        }
        switch (flag) {
        case '0b':
          if (radix === 0 || radix === 2) {
            radix = 2;
            return head + tail;
          }
          break;
        case '0':
        case '0o':
          if (radix === 0 || radix === 8) {
            radix = 8;
            return head + tail;
          }
          break;
        case '0d':
          if (radix === 0 || radix === 10) {
            radix = 10;
            return head + tail;
          }
          break;
        case '0x':
          if (radix === 0 || radix === 16) {
            radix = 16;
            return head + tail;
          }
          break;
        }
        return original
      });

      result = parseInt(string.replace(/_(?!_)/g, ''), radix);
      return isNaN(result) ? 0 : result;
    ;
    }, -1);
    
    $def(self, '$to_proc', function $$to_proc() {
      var $yield = $$to_proc.$$p || nil, self = this, method_name = nil, jsid = nil, proc = nil;

      $$to_proc.$$p = null;
      
      method_name = self.valueOf();
      jsid = Opal.jsid(method_name);
      proc = $send($Kernel, 'proc', [], function $$17($a){var block = $$17.$$p || nil, $post_args, args;

        $$17.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        args = $post_args;
        
        if (args.length === 0) {
          $Kernel.$raise($$$('ArgumentError'), "no receiver given")
        }

        var recv = args[0];

        if (recv == null) recv = nil;

        var body = recv[jsid];

        if (!body) {
          body = recv.$method_missing;
          args[0] = method_name;
        } else {
          args = args.slice(1);
        }

        if (typeof block === 'function') {
          body.$$p = block;
        }

        if (args.length === 0) {
          return body.call(recv);
        } else {
          return body.apply(recv, args);
        }
      ;}, -1);
      proc.$$source_location = nil;
      return proc;
    });
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return self.toString();
    });
    
    $def(self, '$tr', function $$tr(from, to) {
      var self = this;

      
      from = $coerce_to(from, $$$('String'), 'to_str').$to_s();
      to = $coerce_to(to, $$$('String'), 'to_str').$to_s();

      if (from.length == 0 || from === to) {
        return self;
      }

      var i, in_range, c, ch, start, end, length;
      var subs = {};
      var from_chars = from.split('');
      var from_length = from_chars.length;
      var to_chars = to.split('');
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] === '^' && from_chars.length > 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      var from_chars_expanded = [];
      var last_from = null;
      in_range = false;
      for (i = 0; i < from_length; i++) {
        ch = from_chars[i];
        if (last_from == null) {
          last_from = ch;
          from_chars_expanded.push(ch);
        }
        else if (ch === '-') {
          if (last_from === '-') {
            from_chars_expanded.push('-');
            from_chars_expanded.push('-');
          }
          else if (i == from_length - 1) {
            from_chars_expanded.push('-');
          }
          else {
            in_range = true;
          }
        }
        else if (in_range) {
          start = last_from.charCodeAt(0);
          end = ch.charCodeAt(0);
          if (start > end) {
            $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
          }
          for (c = start + 1; c < end; c++) {
            from_chars_expanded.push(String.fromCharCode(c));
          }
          from_chars_expanded.push(ch);
          in_range = null;
          last_from = null;
        }
        else {
          from_chars_expanded.push(ch);
        }
      }

      from_chars = from_chars_expanded;
      from_length = from_chars.length;

      if (inverse) {
        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = true;
        }
      }
      else {
        if (to_length > 0) {
          var to_chars_expanded = [];
          var last_to = null;
          in_range = false;
          for (i = 0; i < to_length; i++) {
            ch = to_chars[i];
            if (last_to == null) {
              last_to = ch;
              to_chars_expanded.push(ch);
            }
            else if (ch === '-') {
              if (last_to === '-') {
                to_chars_expanded.push('-');
                to_chars_expanded.push('-');
              }
              else if (i == to_length - 1) {
                to_chars_expanded.push('-');
              }
              else {
                in_range = true;
              }
            }
            else if (in_range) {
              start = last_to.charCodeAt(0);
              end = ch.charCodeAt(0);
              if (start > end) {
                $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
              }
              for (c = start + 1; c < end; c++) {
                to_chars_expanded.push(String.fromCharCode(c));
              }
              to_chars_expanded.push(ch);
              in_range = null;
              last_to = null;
            }
            else {
              to_chars_expanded.push(ch);
            }
          }

          to_chars = to_chars_expanded;
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff > 0) {
          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');
          for (i = 0; i < length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }

      var new_str = ''
      for (i = 0, length = self.length; i < length; i++) {
        ch = self.charAt(i);
        var sub = subs[ch];
        if (inverse) {
          new_str += (sub == null ? global_sub : ch);
        }
        else {
          new_str += (sub != null ? sub : ch);
        }
      }
      return new_str;
    
    });
    
    $def(self, '$tr_s', function $$tr_s(from, to) {
      var self = this;

      
      from = $coerce_to(from, $$$('String'), 'to_str').$to_s();
      to = $coerce_to(to, $$$('String'), 'to_str').$to_s();

      if (from.length == 0) {
        return self;
      }

      var i, in_range, c, ch, start, end, length;
      var subs = {};
      var from_chars = from.split('');
      var from_length = from_chars.length;
      var to_chars = to.split('');
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] === '^' && from_chars.length > 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      var from_chars_expanded = [];
      var last_from = null;
      in_range = false;
      for (i = 0; i < from_length; i++) {
        ch = from_chars[i];
        if (last_from == null) {
          last_from = ch;
          from_chars_expanded.push(ch);
        }
        else if (ch === '-') {
          if (last_from === '-') {
            from_chars_expanded.push('-');
            from_chars_expanded.push('-');
          }
          else if (i == from_length - 1) {
            from_chars_expanded.push('-');
          }
          else {
            in_range = true;
          }
        }
        else if (in_range) {
          start = last_from.charCodeAt(0);
          end = ch.charCodeAt(0);
          if (start > end) {
            $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
          }
          for (c = start + 1; c < end; c++) {
            from_chars_expanded.push(String.fromCharCode(c));
          }
          from_chars_expanded.push(ch);
          in_range = null;
          last_from = null;
        }
        else {
          from_chars_expanded.push(ch);
        }
      }

      from_chars = from_chars_expanded;
      from_length = from_chars.length;

      if (inverse) {
        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = true;
        }
      }
      else {
        if (to_length > 0) {
          var to_chars_expanded = [];
          var last_to = null;
          in_range = false;
          for (i = 0; i < to_length; i++) {
            ch = to_chars[i];
            if (last_from == null) {
              last_from = ch;
              to_chars_expanded.push(ch);
            }
            else if (ch === '-') {
              if (last_to === '-') {
                to_chars_expanded.push('-');
                to_chars_expanded.push('-');
              }
              else if (i == to_length - 1) {
                to_chars_expanded.push('-');
              }
              else {
                in_range = true;
              }
            }
            else if (in_range) {
              start = last_from.charCodeAt(0);
              end = ch.charCodeAt(0);
              if (start > end) {
                $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
              }
              for (c = start + 1; c < end; c++) {
                to_chars_expanded.push(String.fromCharCode(c));
              }
              to_chars_expanded.push(ch);
              in_range = null;
              last_from = null;
            }
            else {
              to_chars_expanded.push(ch);
            }
          }

          to_chars = to_chars_expanded;
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff > 0) {
          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');
          for (i = 0; i < length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }
      var new_str = ''
      var last_substitute = null
      for (i = 0, length = self.length; i < length; i++) {
        ch = self.charAt(i);
        var sub = subs[ch]
        if (inverse) {
          if (sub == null) {
            if (last_substitute == null) {
              new_str += global_sub;
              last_substitute = true;
            }
          }
          else {
            new_str += ch;
            last_substitute = null;
          }
        }
        else {
          if (sub != null) {
            if (last_substitute == null || last_substitute !== sub) {
              new_str += sub;
              last_substitute = sub;
            }
          }
          else {
            new_str += ch;
            last_substitute = null;
          }
        }
      }
      return new_str;
    
    });
    
    $def(self, '$upcase', function $$upcase() {
      var self = this;

      return self.toUpperCase();
    });
    
    $def(self, '$upto', function $$upto(stop, excl) {
      var block = $$upto.$$p || nil, self = this;

      $$upto.$$p = null;
      
      ;
      if (excl == null) excl = false;
      if (!(block !== nil)) {
        return self.$enum_for("upto", stop, excl)
      };
      
      var a, b, s = self.toString();

      stop = $coerce_to(stop, $$$('String'), 'to_str');

      if (s.length === 1 && stop.length === 1) {

        a = s.charCodeAt(0);
        b = stop.charCodeAt(0);

        while (a <= b) {
          if (excl && a === b) {
            break;
          }

          block(String.fromCharCode(a));

          a += 1;
        }

      } else if (parseInt(s, 10).toString() === s && parseInt(stop, 10).toString() === stop) {

        a = parseInt(s, 10);
        b = parseInt(stop, 10);

        while (a <= b) {
          if (excl && a === b) {
            break;
          }

          block(a.toString());

          a += 1;
        }

      } else {

        while (s.length <= stop.length && s <= stop) {
          if (excl && s === stop) {
            break;
          }

          block(s);

          s = (s).$succ();
        }

      }
      return self;
    ;
    }, -2);
    
    function char_class_from_char_sets(sets) {
      function explode_sequences_in_character_set(set) {
        var result = '',
            i, len = set.length,
            curr_char,
            skip_next_dash,
            char_code_from,
            char_code_upto,
            char_code;
        for (i = 0; i < len; i++) {
          curr_char = set.charAt(i);
          if (curr_char === '-' && i > 0 && i < (len - 1) && !skip_next_dash) {
            char_code_from = set.charCodeAt(i - 1);
            char_code_upto = set.charCodeAt(i + 1);
            if (char_code_from > char_code_upto) {
              $Kernel.$raise($$$('ArgumentError'), "invalid range \"" + (char_code_from) + "-" + (char_code_upto) + "\" in string transliteration")
            }
            for (char_code = char_code_from + 1; char_code < char_code_upto + 1; char_code++) {
              result += String.fromCharCode(char_code);
            }
            skip_next_dash = true;
            i++;
          } else {
            skip_next_dash = (curr_char === '\\');
            result += curr_char;
          }
        }
        return result;
      }

      function intersection(setA, setB) {
        if (setA.length === 0) {
          return setB;
        }
        var result = '',
            i, len = setA.length,
            chr;
        for (i = 0; i < len; i++) {
          chr = setA.charAt(i);
          if (setB.indexOf(chr) !== -1) {
            result += chr;
          }
        }
        return result;
      }

      var i, len, set, neg, chr, tmp,
          pos_intersection = '',
          neg_intersection = '';

      for (i = 0, len = sets.length; i < len; i++) {
        set = $coerce_to(sets[i], $$$('String'), 'to_str');
        neg = (set.charAt(0) === '^' && set.length > 1);
        set = explode_sequences_in_character_set(neg ? set.slice(1) : set);
        if (neg) {
          neg_intersection = intersection(neg_intersection, set);
        } else {
          pos_intersection = intersection(pos_intersection, set);
        }
      }

      if (pos_intersection.length > 0 && neg_intersection.length > 0) {
        tmp = '';
        for (i = 0, len = pos_intersection.length; i < len; i++) {
          chr = pos_intersection.charAt(i);
          if (neg_intersection.indexOf(chr) === -1) {
            tmp += chr;
          }
        }
        pos_intersection = tmp;
        neg_intersection = '';
      }

      if (pos_intersection.length > 0) {
        return '[' + $$$('Regexp').$escape(pos_intersection) + ']';
      }

      if (neg_intersection.length > 0) {
        return '[^' + $$$('Regexp').$escape(neg_intersection) + ']';
      }

      return null;
    }
  ;
    
    $def(self, '$instance_variables', function $$instance_variables() {
      
      return []
    });
    $defs(self, '$_load', function $$_load($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return $send(self, 'new', $to_a(args));
    }, -1);
    
    $def(self, '$unicode_normalize', function $$unicode_normalize(form) {
      var self = this;

      
      if (form == null) form = "nfc";
      if (!$truthy(["nfc", "nfd", "nfkc", "nfkd"]['$include?'](form))) {
        $Kernel.$raise($$$('ArgumentError'), "Invalid normalization form " + (form))
      };
      return self.normalize(form.$upcase());
    }, -1);
    
    $def(self, '$unicode_normalized?', function $String_unicode_normalized$ques$18(form) {
      var self = this;

      
      if (form == null) form = "nfc";
      return self.$unicode_normalize(form)['$=='](self);
    }, -1);
    
    $def(self, '$unpack', function $$unpack(format) {
      
      return $Kernel.$raise("To use String#unpack, you must first require 'corelib/string/unpack'.")
    });
    
    $def(self, '$unpack1', function $$unpack1(format) {
      
      return $Kernel.$raise("To use String#unpack1, you must first require 'corelib/string/unpack'.")
    });
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if (typeof self === 'string') { return self; }
      $prop(self, "$$frozen", true);
      return self;
    
    });
    
    $def(self, '$-@', function $String_$minus$$19() {
      var self = this;

      
      if (typeof self === 'string') return self;
      if (self.$$frozen) return self;
      if (self.encoding.name == 'UTF-8' && self.internal_encoding.name == 'UTF-8') return self.toString();
      return self.$dup().$freeze();
    
    });
    
    $def(self, '$frozen?', function $String_frozen$ques$20() {
      var self = this;

      return typeof self === 'string' || self.$$frozen === true;
    });
    $alias(self, "+@", "dup");
    $alias(self, "===", "==");
    $alias(self, "byteslice", "[]");
    $alias(self, "eql?", "==");
    $alias(self, "equal?", "===");
    $alias(self, "object_id", "__id__");
    $alias(self, "slice", "[]");
    $alias(self, "succ", "next");
    $alias(self, "to_str", "to_s");
    $alias(self, "to_sym", "intern");
    return $Opal.$pristine(self, "initialize");
  })('::', String, $nesting);
  return $const_set($nesting[0], 'Symbol', $$('String'));
};

Opal.modules["corelib/enumerable"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $yield1 = Opal.yield1, $yieldX = Opal.yieldX, $deny_frozen_access = Opal.deny_frozen_access, $module = Opal.module, $send = Opal.send, $slice = Opal.slice, $to_a = Opal.to_a, $Opal = Opal.Opal, $thrower = Opal.thrower, $def = Opal.def, $Kernel = Opal.Kernel, $return_val = Opal.return_val, $rb_gt = Opal.rb_gt, $rb_times = Opal.rb_times, $rb_lt = Opal.rb_lt, $eqeq = Opal.eqeq, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $rb_divide = Opal.rb_divide, $rb_le = Opal.rb_le, $lambda = Opal.lambda, $not = Opal.not, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('each,public_send,destructure,to_enum,enumerator_size,new,yield,raise,slice_when,!,enum_for,flatten,map,to_proc,compact,to_a,warn,proc,==,nil?,respond_to?,coerce_to!,>,*,try_convert,<,+,-,ceil,/,size,select,__send__,length,<=,[],push,<<,[]=,===,inspect,<=>,first,reverse,sort,take,sort_by,compare,call,dup,sort!,map!,include?,-@,key?,values,transform_values,group_by,fetch,to_h,coerce_to?,class,zip,detect,find_all,collect_concat,collect,inject,entries');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Enumerable');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    function comparableForPattern(value) {
      if (value.length === 0) {
        value = [nil];
      }

      if (value.length > 1) {
        value = [value];
      }

      return value;
    }
  ;
    
    $def(self, '$all?', function $Enumerable_all$ques$1(pattern) {try { var $t_return = $thrower('return'); 
      var block = $Enumerable_all$ques$1.$$p || nil, self = this;

      $Enumerable_all$ques$1.$$p = null;
      
      ;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], function $$2($a){var $post_args, value, comparable = nil;

          
          $post_args = $slice(arguments);
          value = $post_args;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat($to_a(comparable))))) {
            return nil
          } else {
            $t_return.$throw(false, $$2.$$is_lambda)
          };}, {$$arity: -1, $$ret: $t_return})
      } else if ((block !== nil)) {
        $send(self, 'each', [], function $$3($a){var $post_args, value;

          
          $post_args = $slice(arguments);
          value = $post_args;
          if ($truthy(Opal.yieldX(block, $to_a(value)))) {
            return nil
          } else {
            $t_return.$throw(false, $$3.$$is_lambda)
          };}, {$$arity: -1, $$ret: $t_return})
      } else {
        $send(self, 'each', [], function $$4($a){var $post_args, value;

          
          $post_args = $slice(arguments);
          value = $post_args;
          if ($truthy($Opal.$destructure(value))) {
            return nil
          } else {
            $t_return.$throw(false, $$4.$$is_lambda)
          };}, {$$arity: -1, $$ret: $t_return})
      };
      return true;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      } finally {$t_return.is_orphan = true;}
    }, -1);
    
    $def(self, '$any?', function $Enumerable_any$ques$5(pattern) {try { var $t_return = $thrower('return'); 
      var block = $Enumerable_any$ques$5.$$p || nil, self = this;

      $Enumerable_any$ques$5.$$p = null;
      
      ;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], function $$6($a){var $post_args, value, comparable = nil;

          
          $post_args = $slice(arguments);
          value = $post_args;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat($to_a(comparable))))) {
            $t_return.$throw(true, $$6.$$is_lambda)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      } else if ((block !== nil)) {
        $send(self, 'each', [], function $$7($a){var $post_args, value;

          
          $post_args = $slice(arguments);
          value = $post_args;
          if ($truthy(Opal.yieldX(block, $to_a(value)))) {
            $t_return.$throw(true, $$7.$$is_lambda)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      } else {
        $send(self, 'each', [], function $$8($a){var $post_args, value;

          
          $post_args = $slice(arguments);
          value = $post_args;
          if ($truthy($Opal.$destructure(value))) {
            $t_return.$throw(true, $$8.$$is_lambda)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      };
      return false;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      } finally {$t_return.is_orphan = true;}
    }, -1);
    
    $def(self, '$chunk', function $$chunk() {
      var block = $$chunk.$$p || nil, self = this;

      $$chunk.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'to_enum', ["chunk"], function $$9(){var self = $$9.$$s == null ? this : $$9.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      return $send($$$('Enumerator'), 'new', [], function $$10(yielder){var self = $$10.$$s == null ? this : $$10.$$s;

        
        if (yielder == null) yielder = nil;
        
        var previous = nil, accumulate = [];

        function releaseAccumulate() {
          if (accumulate.length > 0) {
            yielder.$yield(previous, accumulate)
          }
        }

        self.$each.$$p = function(value) {
          var key = $yield1(block, value);

          if (key === nil) {
            releaseAccumulate();
            accumulate = [];
            previous = nil;
          } else {
            if (previous === nil || previous === key) {
              accumulate.push(value);
            } else {
              releaseAccumulate();
              accumulate = [value];
            }

            previous = key;
          }
        }

        self.$each();

        releaseAccumulate();
      ;}, {$$s: self});
    });
    
    $def(self, '$chunk_while', function $$chunk_while() {
      var block = $$chunk_while.$$p || nil, self = this;

      $$chunk_while.$$p = null;
      
      ;
      if (!(block !== nil)) {
        $Kernel.$raise($$$('ArgumentError'), "no block given")
      };
      return $send(self, 'slice_when', [], function $$11(before, after){
        
        if (before == null) before = nil;
        if (after == null) after = nil;
        return Opal.yieldX(block, [before, after])['$!']();});
    });
    
    $def(self, '$collect', function $$collect() {
      var block = $$collect.$$p || nil, self = this;

      $$collect.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["collect"], function $$12(){var self = $$12.$$s == null ? this : $$12.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      
      var result = [];

      self.$each.$$p = function() {
        var value = $yieldX(block, arguments);

        result.push(value);
      };

      self.$each();

      return result;
    ;
    });
    
    $def(self, '$collect_concat', function $$collect_concat() {
      var block = $$collect_concat.$$p || nil, self = this;

      $$collect_concat.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["collect_concat"], function $$13(){var self = $$13.$$s == null ? this : $$13.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      return $send(self, 'map', [], block.$to_proc()).$flatten(1);
    });
    
    $def(self, '$compact', function $$compact() {
      var self = this;

      return self.$to_a().$compact()
    });
    
    $def(self, '$count', function $$count(object) {
      var block = $$count.$$p || nil, self = this, result = nil;

      $$count.$$p = null;
      
      ;
      ;
      result = 0;
      
      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }
    ;
      if ($truthy(object != null)) {
        block = $send($Kernel, 'proc', [], function $$14($a){var $post_args, args;

          
          $post_args = $slice(arguments);
          args = $post_args;
          return $Opal.$destructure(args)['$=='](object);}, -1)
      } else if ($truthy(block['$nil?']())) {
        block = $send($Kernel, 'proc', [], $return_val(true))
      };
      $send(self, 'each', [], function $$15($a){var $post_args, args;

        
        $post_args = $slice(arguments);
        args = $post_args;
        if ($truthy($yieldX(block, args))) {
          return result++;
        } else {
          return nil
        };}, -1);
      return result;
    }, -1);
    
    $def(self, '$cycle', function $$cycle(n) {
      var block = $$cycle.$$p || nil, self = this;

      $$cycle.$$p = null;
      
      ;
      if (n == null) n = nil;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["cycle", n], function $$16(){var self = $$16.$$s == null ? this : $$16.$$s;

          if ($truthy(n['$nil?']())) {
            if ($truthy(self['$respond_to?']("size"))) {
              return $$$($$$('Float'), 'INFINITY')
            } else {
              return nil
            }
          } else {
            
            n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
            if ($truthy($rb_gt(n, 0))) {
              return $rb_times(self.$enumerator_size(), n)
            } else {
              return 0
            };
          }}, {$$s: self})
      };
      if (!$truthy(n['$nil?']())) {
        
        n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
        if ($truthy(n <= 0)) {
          return nil
        };
      };
      
      var all = [], i, length, value;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        all.push(param);
      }

      self.$each();

      if (all.length === 0) {
        return nil;
      }

      if (n === nil) {
        while (true) {
          for (i = 0, length = all.length; i < length; i++) {
            value = $yield1(block, all[i]);
          }
        }
      }
      else {
        while (n > 1) {
          for (i = 0, length = all.length; i < length; i++) {
            value = $yield1(block, all[i]);
          }

          n--;
        }
      }
    ;
    }, -1);
    
    $def(self, '$detect', function $$detect(ifnone) {try { var $t_return = $thrower('return'); 
      var block = $$detect.$$p || nil, self = this;

      $$detect.$$p = null;
      
      ;
      ;
      if (!(block !== nil)) {
        return self.$enum_for("detect", ifnone)
      };
      $send(self, 'each', [], function $$17($a){var $post_args, args, value = nil;

        
        $post_args = $slice(arguments);
        args = $post_args;
        value = $Opal.$destructure(args);
        if ($truthy(Opal.yield1(block, value))) {
          $t_return.$throw(value, $$17.$$is_lambda)
        } else {
          return nil
        };}, {$$arity: -1, $$ret: $t_return});
      
      if (ifnone !== undefined) {
        if (typeof(ifnone) === 'function') {
          return ifnone();
        } else {
          return ifnone;
        }
      }
    ;
      return nil;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      } finally {$t_return.is_orphan = true;}
    }, -1);
    
    $def(self, '$drop', function $$drop(number) {
      var self = this;

      
      number = $coerce_to(number, $$$('Integer'), 'to_int');
      if ($truthy(number < 0)) {
        $Kernel.$raise($$$('ArgumentError'), "attempt to drop negative size")
      };
      
      var result  = [],
          current = 0;

      self.$each.$$p = function() {
        if (number <= current) {
          result.push($Opal.$destructure(arguments));
        }

        current++;
      };

      self.$each()

      return result;
    ;
    });
    
    $def(self, '$drop_while', function $$drop_while() {
      var block = $$drop_while.$$p || nil, self = this;

      $$drop_while.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("drop_while")
      };
      
      var result   = [],
          dropping = true;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);

        if (dropping) {
          var value = $yield1(block, param);

          if (!$truthy(value)) {
            dropping = false;
            result.push(param);
          }
        }
        else {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    });
    
    $def(self, '$each_cons', function $$each_cons(n) {
      var block = $$each_cons.$$p || nil, self = this;

      $$each_cons.$$p = null;
      
      ;
      if ($truthy(arguments.length != 1)) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " for 1)")
      };
      n = $Opal.$try_convert(n, $$$('Integer'), "to_int");
      if ($truthy(n <= 0)) {
        $Kernel.$raise($$$('ArgumentError'), "invalid size")
      };
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_cons", n], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s, enum_size = nil;

          
          enum_size = self.$enumerator_size();
          if ($truthy(enum_size['$nil?']())) {
            return nil
          } else if (($eqeq(enum_size, 0) || ($truthy($rb_lt(enum_size, n))))) {
            return 0
          } else {
            return $rb_plus($rb_minus(enum_size, n), 1)
          };}, {$$s: self})
      };
      
      var buffer = [];

      self.$each.$$p = function() {
        var element = $Opal.$destructure(arguments);
        buffer.push(element);
        if (buffer.length > n) {
          buffer.shift();
        }
        if (buffer.length == n) {
          $yield1(block, buffer.slice(0, n));
        }
      }

      self.$each();

      return self;
    ;
    });
    
    $def(self, '$each_entry', function $$each_entry($a) {
      var block = $$each_entry.$$p || nil, $post_args, data, self = this;

      $$each_entry.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      data = $post_args;
      if (!(block !== nil)) {
        return $send(self, 'to_enum', ["each_entry"].concat($to_a(data)), function $$19(){var self = $$19.$$s == null ? this : $$19.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      
      self.$each.$$p = function() {
        var item = $Opal.$destructure(arguments);

        $yield1(block, item);
      }

      self.$each.apply(self, data);

      return self;
    ;
    }, -1);
    
    $def(self, '$each_slice', function $$each_slice(n) {
      var block = $$each_slice.$$p || nil, self = this;

      $$each_slice.$$p = null;
      
      ;
      n = $coerce_to(n, $$$('Integer'), 'to_int');
      if ($truthy(n <= 0)) {
        $Kernel.$raise($$$('ArgumentError'), "invalid slice size")
      };
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_slice", n], function $$20(){var self = $$20.$$s == null ? this : $$20.$$s;

          if ($truthy(self['$respond_to?']("size"))) {
            return $rb_divide(self.$size(), n).$ceil()
          } else {
            return nil
          }}, {$$s: self})
      };
      
      var slice = []

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);

        slice.push(param);

        if (slice.length === n) {
          $yield1(block, slice);
          slice = [];
        }
      };

      self.$each();

      // our "last" group, if smaller than n then won't have been yielded
      if (slice.length > 0) {
        $yield1(block, slice);
      }
    ;
      return self;
    });
    
    $def(self, '$each_with_index', function $$each_with_index($a) {
      var block = $$each_with_index.$$p || nil, $post_args, args, self = this;

      $$each_with_index.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_with_index"].concat($to_a(args)), function $$21(){var self = $$21.$$s == null ? this : $$21.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      
      var index = 0;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);

        block(param, index);

        index++;
      };

      self.$each.apply(self, args);
    ;
      return self;
    }, -1);
    
    $def(self, '$each_with_object', function $$each_with_object(object) {
      var block = $$each_with_object.$$p || nil, self = this;

      $$each_with_object.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_with_object", object], function $$22(){var self = $$22.$$s == null ? this : $$22.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      
      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);

        block(param, object);
      };

      self.$each();
    ;
      return object;
    });
    
    $def(self, '$entries', function $$entries($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      
      var result = [];

      self.$each.$$p = function() {
        result.push($Opal.$destructure(arguments));
      };

      self.$each.apply(self, args);

      return result;
    ;
    }, -1);
    
    $def(self, '$filter_map', function $$filter_map() {
      var block = $$filter_map.$$p || nil, self = this;

      $$filter_map.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["filter_map"], function $$23(){var self = $$23.$$s == null ? this : $$23.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      return $send($send(self, 'map', [], block.$to_proc()), 'select', [], "itself".$to_proc());
    });
    
    $def(self, '$find_all', function $$find_all() {
      var block = $$find_all.$$p || nil, self = this;

      $$find_all.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["find_all"], function $$24(){var self = $$24.$$s == null ? this : $$24.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      
      var result = [];

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if ($truthy(value)) {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    });
    
    $def(self, '$find_index', function $$find_index(object) {try { var $t_return = $thrower('return'); 
      var block = $$find_index.$$p || nil, self = this, index = nil;

      $$find_index.$$p = null;
      
      ;
      ;
      if ($truthy(object === undefined && block === nil)) {
        return self.$enum_for("find_index")
      };
      
      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }
    ;
      index = 0;
      if ($truthy(object != null)) {
        $send(self, 'each', [], function $$25($a){var $post_args, value;

          
          $post_args = $slice(arguments);
          value = $post_args;
          if ($eqeq($Opal.$destructure(value), object)) {
            $t_return.$throw(index, $$25.$$is_lambda)
          };
          return index += 1;;}, {$$arity: -1, $$ret: $t_return})
      } else {
        $send(self, 'each', [], function $$26($a){var $post_args, value;

          
          $post_args = $slice(arguments);
          value = $post_args;
          if ($truthy(Opal.yieldX(block, $to_a(value)))) {
            $t_return.$throw(index, $$26.$$is_lambda)
          };
          return index += 1;;}, {$$arity: -1, $$ret: $t_return})
      };
      return nil;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      } finally {$t_return.is_orphan = true;}
    }, -1);
    
    $def(self, '$first', function $$first(number) {try { var $t_return = $thrower('return'); 
      var self = this, result = nil, current = nil;

      
      ;
      if ($truthy(number === undefined)) {
        return $send(self, 'each', [], function $$27(value){
          
          if (value == null) value = nil;
          $t_return.$throw(value, $$27.$$is_lambda);}, {$$ret: $t_return})
      } else {
        
        result = [];
        number = $coerce_to(number, $$$('Integer'), 'to_int');
        if ($truthy(number < 0)) {
          $Kernel.$raise($$$('ArgumentError'), "attempt to take negative size")
        };
        if ($truthy(number == 0)) {
          return []
        };
        current = 0;
        $send(self, 'each', [], function $$28($a){var $post_args, args;

          
          $post_args = $slice(arguments);
          args = $post_args;
          result.push($Opal.$destructure(args));
          if ($truthy(number <= ++current)) {
            $t_return.$throw(result, $$28.$$is_lambda)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return});
        return result;
      };} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      } finally {$t_return.is_orphan = true;}
    }, -1);
    
    $def(self, '$grep', function $$grep(pattern) {
      var block = $$grep.$$p || nil, self = this, result = nil;

      $$grep.$$p = null;
      
      ;
      result = [];
      $send(self, 'each', [], function $$29($a){var $post_args, value, cmp = nil;

        
        $post_args = $slice(arguments);
        value = $post_args;
        cmp = comparableForPattern(value);
        if (!$truthy($send(pattern, '__send__', ["==="].concat($to_a(cmp))))) {
          return nil
        };
        if ((block !== nil)) {
          
          if ($truthy($rb_gt(value.$length(), 1))) {
            value = [value]
          };
          value = Opal.yieldX(block, $to_a(value));
        } else if ($truthy($rb_le(value.$length(), 1))) {
          value = value['$[]'](0)
        };
        return result.$push(value);}, -1);
      return result;
    });
    
    $def(self, '$grep_v', function $$grep_v(pattern) {
      var block = $$grep_v.$$p || nil, self = this, result = nil;

      $$grep_v.$$p = null;
      
      ;
      result = [];
      $send(self, 'each', [], function $$30($a){var $post_args, value, cmp = nil;

        
        $post_args = $slice(arguments);
        value = $post_args;
        cmp = comparableForPattern(value);
        if ($truthy($send(pattern, '__send__', ["==="].concat($to_a(cmp))))) {
          return nil
        };
        if ((block !== nil)) {
          
          if ($truthy($rb_gt(value.$length(), 1))) {
            value = [value]
          };
          value = Opal.yieldX(block, $to_a(value));
        } else if ($truthy($rb_le(value.$length(), 1))) {
          value = value['$[]'](0)
        };
        return result.$push(value);}, -1);
      return result;
    });
    
    $def(self, '$group_by', function $$group_by() {
      var block = $$group_by.$$p || nil, $a, self = this, hash = nil, $ret_or_1 = nil;

      $$group_by.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["group_by"], function $$31(){var self = $$31.$$s == null ? this : $$31.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      hash = (new Map());
      
      var result;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        ($truthy(($ret_or_1 = hash['$[]'](value))) ? ($ret_or_1) : (($a = [value, []], $send(hash, '[]=', $a), $a[$a.length - 1])))['$<<'](param);
      }

      self.$each();

      if (result !== undefined) {
        return result;
      }
    ;
      return hash;
    });
    
    $def(self, '$include?', function $Enumerable_include$ques$32(obj) {try { var $t_return = $thrower('return'); 
      var self = this;

      
      $send(self, 'each', [], function $$33($a){var $post_args, args;

        
        $post_args = $slice(arguments);
        args = $post_args;
        if ($eqeq($Opal.$destructure(args), obj)) {
          $t_return.$throw(true, $$33.$$is_lambda)
        } else {
          return nil
        };}, {$$arity: -1, $$ret: $t_return});
      return false;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      } finally {$t_return.is_orphan = true;}
    });
    
    $def(self, '$inject', function $$inject(object, sym) {
      var block = $$inject.$$p || nil, self = this;

      $$inject.$$p = null;
      
      ;
      ;
      ;
      
      var result = object;

      if (block !== nil && sym === undefined) {
        self.$each.$$p = function() {
          var value = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = value;
            return;
          }

          value = $yieldX(block, [result, value]);

          result = value;
        };
      }
      else {
        if (sym === undefined) {
          if (!$$$('Symbol')['$==='](object)) {
            $Kernel.$raise($$$('TypeError'), "" + (object.$inspect()) + " is not a Symbol");
          }

          sym    = object;
          result = undefined;
        }

        self.$each.$$p = function() {
          var value = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = value;
            return;
          }

          result = (result).$__send__(sym, value);
        };
      }

      self.$each();

      return result == undefined ? nil : result;
    ;
    }, -1);
    
    $def(self, '$lazy', function $$lazy() {
      var self = this;

      return $send($$$($$$('Enumerator'), 'Lazy'), 'new', [self, self.$enumerator_size()], function $$34(enum$, $a){var $post_args, args;

        
        if (enum$ == null) enum$ = nil;
        $post_args = $slice(arguments, 1);
        args = $post_args;
        return $send(enum$, 'yield', $to_a(args));}, -2)
    });
    
    $def(self, '$enumerator_size', function $$enumerator_size() {
      var self = this;

      if ($truthy(self['$respond_to?']("size"))) {
        return self.$size()
      } else {
        return nil
      }
    });
    
    $def(self, '$max', function $$max(n) {
      var block = $$max.$$p || nil, self = this;

      $$max.$$p = null;
      
      ;
      ;
      
      if (n === undefined || n === nil) {
        var result, value;

        self.$each.$$p = function() {
          var item = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = item;
            return;
          }

          if (block !== nil) {
            value = $yieldX(block, [item, result]);
          } else {
            value = (item)['$<=>'](result);
          }

          if (value === nil) {
            $Kernel.$raise($$$('ArgumentError'), "comparison failed");
          }

          if (value > 0) {
            result = item;
          }
        }

        self.$each();

        if (result === undefined) {
          return nil;
        } else {
          return result;
        }
      }

      n = $coerce_to(n, $$$('Integer'), 'to_int');
    ;
      return $send(self, 'sort', [], block.$to_proc()).$reverse().$first(n);
    }, -1);
    
    $def(self, '$max_by', function $$max_by(n) {
      var block = $$max_by.$$p || nil, self = this;

      $$max_by.$$p = null;
      
      ;
      if (n == null) n = nil;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["max_by", n], function $$35(){var self = $$35.$$s == null ? this : $$35.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      if (!$truthy(n['$nil?']())) {
        return $send(self, 'sort_by', [], block.$to_proc()).$reverse().$take(n)
      };
      
      var result,
          by;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if (result === undefined) {
          result = param;
          by     = value;
          return;
        }

        if ((value)['$<=>'](by) > 0) {
          result = param
          by     = value;
        }
      };

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, -1);
    
    $def(self, '$min', function $$min(n) {
      var block = $$min.$$p || nil, self = this;

      $$min.$$p = null;
      
      ;
      if (n == null) n = nil;
      if (!$truthy(n['$nil?']())) {
        if ((block !== nil)) {
          return $send(self, 'sort', [], function $$36(a, b){
            
            if (a == null) a = nil;
            if (b == null) b = nil;
            return Opal.yieldX(block, [a, b]);;}).$take(n)
        } else {
          return self.$sort().$take(n)
        }
      };
      
      var result;

      if (block !== nil) {
        self.$each.$$p = function() {
          var param = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = param;
            return;
          }

          var value = block(param, result);

          if (value === nil) {
            $Kernel.$raise($$$('ArgumentError'), "comparison failed");
          }

          if (value < 0) {
            result = param;
          }
        };
      }
      else {
        self.$each.$$p = function() {
          var param = $Opal.$destructure(arguments);

          if (result === undefined) {
            result = param;
            return;
          }

          if ($Opal.$compare(param, result) < 0) {
            result = param;
          }
        };
      }

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, -1);
    
    $def(self, '$min_by', function $$min_by(n) {
      var block = $$min_by.$$p || nil, self = this;

      $$min_by.$$p = null;
      
      ;
      if (n == null) n = nil;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["min_by", n], function $$37(){var self = $$37.$$s == null ? this : $$37.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      if (!$truthy(n['$nil?']())) {
        return $send(self, 'sort_by', [], block.$to_proc()).$take(n)
      };
      
      var result,
          by;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if (result === undefined) {
          result = param;
          by     = value;
          return;
        }

        if ((value)['$<=>'](by) < 0) {
          result = param
          by     = value;
        }
      };

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, -1);
    
    $def(self, '$minmax', function $$minmax() {
      var block = $$minmax.$$p || nil, self = this, $ret_or_1 = nil;

      $$minmax.$$p = null;
      
      ;
      block = ($truthy(($ret_or_1 = block)) ? ($ret_or_1) : ($send($Kernel, 'proc', [], function $$38(a, b){
        
        if (a == null) a = nil;
        if (b == null) b = nil;
        return a['$<=>'](b);})));
      
      var min = nil, max = nil, first_time = true;

      self.$each.$$p = function() {
        var element = $Opal.$destructure(arguments);
        if (first_time) {
          min = max = element;
          first_time = false;
        } else {
          var min_cmp = block.$call(min, element);

          if (min_cmp === nil) {
            $Kernel.$raise($$$('ArgumentError'), "comparison failed")
          } else if (min_cmp > 0) {
            min = element;
          }

          var max_cmp = block.$call(max, element);

          if (max_cmp === nil) {
            $Kernel.$raise($$$('ArgumentError'), "comparison failed")
          } else if (max_cmp < 0) {
            max = element;
          }
        }
      }

      self.$each();

      return [min, max];
    ;
    });
    
    $def(self, '$minmax_by', function $$minmax_by() {
      var block = $$minmax_by.$$p || nil, self = this;

      $$minmax_by.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["minmax_by"], function $$39(){var self = $$39.$$s == null ? this : $$39.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      
      var min_result = nil,
          max_result = nil,
          min_by,
          max_by;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if ((min_by === undefined) || (value)['$<=>'](min_by) < 0) {
          min_result = param;
          min_by     = value;
        }

        if ((max_by === undefined) || (value)['$<=>'](max_by) > 0) {
          max_result = param;
          max_by     = value;
        }
      };

      self.$each();

      return [min_result, max_result];
    ;
    });
    
    $def(self, '$none?', function $Enumerable_none$ques$40(pattern) {try { var $t_return = $thrower('return'); 
      var block = $Enumerable_none$ques$40.$$p || nil, self = this;

      $Enumerable_none$ques$40.$$p = null;
      
      ;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], function $$41($a){var $post_args, value, comparable = nil;

          
          $post_args = $slice(arguments);
          value = $post_args;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat($to_a(comparable))))) {
            $t_return.$throw(false, $$41.$$is_lambda)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      } else if ((block !== nil)) {
        $send(self, 'each', [], function $$42($a){var $post_args, value;

          
          $post_args = $slice(arguments);
          value = $post_args;
          if ($truthy(Opal.yieldX(block, $to_a(value)))) {
            $t_return.$throw(false, $$42.$$is_lambda)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      } else {
        $send(self, 'each', [], function $$43($a){var $post_args, value, item = nil;

          
          $post_args = $slice(arguments);
          value = $post_args;
          item = $Opal.$destructure(value);
          if ($truthy(item)) {
            $t_return.$throw(false, $$43.$$is_lambda)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      };
      return true;} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      } finally {$t_return.is_orphan = true;}
    }, -1);
    
    $def(self, '$one?', function $Enumerable_one$ques$44(pattern) {try { var $t_return = $thrower('return'); 
      var block = $Enumerable_one$ques$44.$$p || nil, self = this, count = nil;

      $Enumerable_one$ques$44.$$p = null;
      
      ;
      ;
      count = 0;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], function $$45($a){var $post_args, value, comparable = nil;

          
          $post_args = $slice(arguments);
          value = $post_args;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat($to_a(comparable))))) {
            
            count = $rb_plus(count, 1);
            if ($truthy($rb_gt(count, 1))) {
              $t_return.$throw(false, $$45.$$is_lambda)
            } else {
              return nil
            };
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      } else if ((block !== nil)) {
        $send(self, 'each', [], function $$46($a){var $post_args, value;

          
          $post_args = $slice(arguments);
          value = $post_args;
          if (!$truthy(Opal.yieldX(block, $to_a(value)))) {
            return nil
          };
          count = $rb_plus(count, 1);
          if ($truthy($rb_gt(count, 1))) {
            $t_return.$throw(false, $$46.$$is_lambda)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      } else {
        $send(self, 'each', [], function $$47($a){var $post_args, value;

          
          $post_args = $slice(arguments);
          value = $post_args;
          if (!$truthy($Opal.$destructure(value))) {
            return nil
          };
          count = $rb_plus(count, 1);
          if ($truthy($rb_gt(count, 1))) {
            $t_return.$throw(false, $$47.$$is_lambda)
          } else {
            return nil
          };}, {$$arity: -1, $$ret: $t_return})
      };
      return count['$=='](1);} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      } finally {$t_return.is_orphan = true;}
    }, -1);
    
    $def(self, '$partition', function $$partition() {
      var block = $$partition.$$p || nil, self = this;

      $$partition.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["partition"], function $$48(){var self = $$48.$$s == null ? this : $$48.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      
      var truthy = [], falsy = [], result;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if ($truthy(value)) {
          truthy.push(param);
        }
        else {
          falsy.push(param);
        }
      };

      self.$each();

      return [truthy, falsy];
    ;
    });
    
    $def(self, '$reject', function $$reject() {
      var block = $$reject.$$p || nil, self = this;

      $$reject.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reject"], function $$49(){var self = $$49.$$s == null ? this : $$49.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      
      var result = [];

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = $yield1(block, param);

        if (!$truthy(value)) {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    });
    
    $def(self, '$reverse_each', function $$reverse_each() {
      var block = $$reverse_each.$$p || nil, self = this;

      $$reverse_each.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reverse_each"], function $$50(){var self = $$50.$$s == null ? this : $$50.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      
      var result = [];

      self.$each.$$p = function() {
        result.push(arguments);
      };

      self.$each();

      for (var i = result.length - 1; i >= 0; i--) {
        $yieldX(block, result[i]);
      }

      return result;
    ;
    });
    
    $def(self, '$slice_before', function $$slice_before(pattern) {
      var block = $$slice_before.$$p || nil, self = this;

      $$slice_before.$$p = null;
      
      ;
      ;
      if ($truthy(pattern === undefined && block === nil)) {
        $Kernel.$raise($$$('ArgumentError'), "both pattern and block are given")
      };
      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " expected 1)")
      };
      return $send($$$('Enumerator'), 'new', [], function $$51(e){var self = $$51.$$s == null ? this : $$51.$$s;

        
        if (e == null) e = nil;
        
        var slice = [];

        if (block !== nil) {
          if (pattern === undefined) {
            self.$each.$$p = function() {
              var param = $Opal.$destructure(arguments),
                  value = $yield1(block, param);

              if ($truthy(value) && slice.length > 0) {
                e['$<<'](slice);
                slice = [];
              }

              slice.push(param);
            };
          }
          else {
            self.$each.$$p = function() {
              var param = $Opal.$destructure(arguments),
                  value = block(param, pattern.$dup());

              if ($truthy(value) && slice.length > 0) {
                e['$<<'](slice);
                slice = [];
              }

              slice.push(param);
            };
          }
        }
        else {
          self.$each.$$p = function() {
            var param = $Opal.$destructure(arguments),
                value = pattern['$==='](param);

            if ($truthy(value) && slice.length > 0) {
              e['$<<'](slice);
              slice = [];
            }

            slice.push(param);
          };
        }

        self.$each();

        if (slice.length > 0) {
          e['$<<'](slice);
        }
      ;}, {$$s: self});
    }, -1);
    
    $def(self, '$slice_after', function $$slice_after(pattern) {
      var block = $$slice_after.$$p || nil, self = this;

      $$slice_after.$$p = null;
      
      ;
      ;
      if ($truthy(pattern === undefined && block === nil)) {
        $Kernel.$raise($$$('ArgumentError'), "both pattern and block are given")
      };
      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " expected 1)")
      };
      if ($truthy(pattern !== undefined)) {
        block = $send($Kernel, 'proc', [], function $$52(e){
          
          if (e == null) e = nil;
          return pattern['$==='](e);})
      };
      return $send($$$('Enumerator'), 'new', [], function $$53(yielder){var self = $$53.$$s == null ? this : $$53.$$s;

        
        if (yielder == null) yielder = nil;
        
        var accumulate;

        self.$each.$$p = function() {
          var element = $Opal.$destructure(arguments),
              end_chunk = $yield1(block, element);

          if (accumulate == null) {
            accumulate = [];
          }

          if ($truthy(end_chunk)) {
            accumulate.push(element);
            yielder.$yield(accumulate);
            accumulate = null;
          } else {
            accumulate.push(element)
          }
        }

        self.$each();

        if (accumulate != null) {
          yielder.$yield(accumulate);
        }
      ;}, {$$s: self});
    }, -1);
    
    $def(self, '$slice_when', function $$slice_when() {
      var block = $$slice_when.$$p || nil, self = this;

      $$slice_when.$$p = null;
      
      ;
      if (!(block !== nil)) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (0 for 1)")
      };
      return $send($$$('Enumerator'), 'new', [], function $$54(yielder){var self = $$54.$$s == null ? this : $$54.$$s;

        
        if (yielder == null) yielder = nil;
        
        var slice = nil, last_after = nil;

        self.$each_cons.$$p = function() {
          var params = $Opal.$destructure(arguments),
              before = params[0],
              after = params[1],
              match = $yieldX(block, [before, after]);

          last_after = after;

          if (slice === nil) {
            slice = [];
          }

          if ($truthy(match)) {
            slice.push(before);
            yielder.$yield(slice);
            slice = [];
          } else {
            slice.push(before);
          }
        }

        self.$each_cons(2);

        if (slice !== nil) {
          slice.push(last_after);
          yielder.$yield(slice);
        }
      ;}, {$$s: self});
    });
    
    $def(self, '$sort', function $$sort() {
      var block = $$sort.$$p || nil, self = this, ary = nil;

      $$sort.$$p = null;
      
      ;
      ary = self.$to_a();
      if (!(block !== nil)) {
        block = $lambda(function $$55(a, b){
          
          if (a == null) a = nil;
          if (b == null) b = nil;
          return a['$<=>'](b);})
      };
      return $send(ary, 'sort', [], block.$to_proc());
    });
    
    $def(self, '$sort_by', function $$sort_by() {
      var block = $$sort_by.$$p || nil, self = this, dup = nil;

      $$sort_by.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["sort_by"], function $$56(){var self = $$56.$$s == null ? this : $$56.$$s;

          return self.$enumerator_size()}, {$$s: self})
      };
      dup = $send(self, 'map', [], function $$57(){var arg = nil;

        
        arg = $Opal.$destructure(arguments);
        return [Opal.yield1(block, arg), arg];});
      $send(dup, 'sort!', [], function $$58(a, b){
        
        if (a == null) a = nil;
        if (b == null) b = nil;
        return (a[0])['$<=>'](b[0]);});
      return $send(dup, 'map!', [], function $$59(i){
        
        if (i == null) i = nil;
        return i[1];;});
    });
    
    $def(self, '$sum', function $$sum(initial) {
      var $yield = $$sum.$$p || nil, self = this, result = nil, compensation = nil;

      $$sum.$$p = null;
      
      if (initial == null) initial = 0;
      result = initial;
      compensation = 0;
      $send(self, 'each', [], function $$60($a){var $post_args, args, item = nil, y = nil, t = nil;

        
        $post_args = $slice(arguments);
        args = $post_args;
        item = (($yield !== nil) ? (Opal.yieldX($yield, $to_a(args))) : ($Opal.$destructure(args)));
        if (($not([$$$($$$('Float'), 'INFINITY'), $$$($$$('Float'), 'INFINITY')['$-@']()]['$include?'](item)) && ($truthy(item['$respond_to?']("-"))))) {
          
          y = $rb_minus(item, compensation);
          t = $rb_plus(result, y);
          compensation = $rb_minus($rb_minus(t, result), y);
          return (result = t);
        } else {
          return (result = $rb_plus(result, item))
        };}, -1);
      return result;
    }, -1);
    
    $def(self, '$take', function $$take(num) {
      var self = this;

      return self.$first(num)
    });
    
    $def(self, '$take_while', function $$take_while() {try { var $t_return = $thrower('return'); 
      var block = $$take_while.$$p || nil, self = this, result = nil;

      $$take_while.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return self.$enum_for("take_while")
      };
      result = [];
      return $send(self, 'each', [], function $$61($a){var $post_args, args, value = nil;

        
        $post_args = $slice(arguments);
        args = $post_args;
        value = $Opal.$destructure(args);
        if (!$truthy(Opal.yield1(block, value))) {
          $t_return.$throw(result, $$61.$$is_lambda)
        };
        return result.push(value);;}, {$$arity: -1, $$ret: $t_return});} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      } finally {$t_return.is_orphan = true;}
    });
    
    $def(self, '$uniq', function $$uniq() {
      var block = $$uniq.$$p || nil, self = this, hash = nil;

      $$uniq.$$p = null;
      
      ;
      hash = (new Map());
      $send(self, 'each', [], function $$62($a){var $post_args, args, $b, value = nil, produced = nil;

        
        $post_args = $slice(arguments);
        args = $post_args;
        value = $Opal.$destructure(args);
        produced = ((block !== nil) ? (Opal.yield1(block, value)) : (value));
        if ($truthy(hash['$key?'](produced))) {
          return nil
        } else {
          return ($b = [produced, value], $send(hash, '[]=', $b), $b[$b.length - 1])
        };}, -1);
      return hash.$values();
    });
    
    $def(self, '$tally', function $$tally(hash) {
      var self = this, out = nil;

      
      ;
      if (hash && hash !== nil) { $deny_frozen_access(hash); };
      out = $send($send(self, 'group_by', [], "itself".$to_proc()), 'transform_values', [], "count".$to_proc());
      if ($truthy(hash)) {
        
        $send(out, 'each', [], function $$63(k, v){var $a;

          
          if (k == null) k = nil;
          if (v == null) v = nil;
          return ($a = [k, $rb_plus(hash.$fetch(k, 0), v)], $send(hash, '[]=', $a), $a[$a.length - 1]);});
        return hash;
      } else {
        return out
      };
    }, -1);
    
    $def(self, '$to_h', function $$to_h($a) {
      var block = $$to_h.$$p || nil, $post_args, args, self = this;

      $$to_h.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      if ((block !== nil)) {
        return $send($send(self, 'map', [], block.$to_proc()), 'to_h', $to_a(args))
      };
      
      var hash = (new Map());

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments);
        var ary = $Opal['$coerce_to?'](param, $$$('Array'), "to_ary"), key, val;
        if (!ary.$$is_array) {
          $Kernel.$raise($$$('TypeError'), "wrong element type " + ((param).$class()) + " (expected array)")
        }
        if (ary.length !== 2) {
          $Kernel.$raise($$$('ArgumentError'), "element has wrong array length (expected 2, was " + ((ary).$length()) + ")")
        }
        key = ary[0];
        val = ary[1];

        Opal.hash_put(hash, key, val);
      };

      self.$each.apply(self, args);

      return hash;
    ;
    }, -1);
    
    $def(self, '$to_set', function $$to_set($a, $b) {
      var block = $$to_set.$$p || nil, $post_args, klass, args, self = this;

      $$to_set.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      
      if ($post_args.length > 0) klass = $post_args.shift();if (klass == null) klass = $$('Set');
      args = $post_args;
      return $send(klass, 'new', [self].concat($to_a(args)), block.$to_proc());
    }, -1);
    
    $def(self, '$zip', function $$zip($a) {
      var block = $$zip.$$p || nil, $post_args, others, self = this;

      $$zip.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      others = $post_args;
      return $send(self.$to_a(), 'zip', $to_a(others));
    }, -1);
    $alias(self, "find", "detect");
    $alias(self, "filter", "find_all");
    $alias(self, "flat_map", "collect_concat");
    $alias(self, "map", "collect");
    $alias(self, "member?", "include?");
    $alias(self, "reduce", "inject");
    $alias(self, "select", "find_all");
    return $alias(self, "to_a", "entries");
  })('::', $nesting)
};

Opal.modules["corelib/enumerator/arithmetic_sequence"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $to_a = Opal.to_a, $eqeq = Opal.eqeq, $Kernel = Opal.Kernel, $def = Opal.def, $rb_gt = Opal.rb_gt, $rb_lt = Opal.rb_lt, $rb_le = Opal.rb_le, $rb_ge = Opal.rb_ge, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $eqeqeq = Opal.eqeqeq, $not = Opal.not, $rb_times = Opal.rb_times, $rb_divide = Opal.rb_divide, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('is_a?,==,raise,respond_to?,class,attr_reader,begin,end,exclude_end?,>,step,<,<=,>=,-@,_lesser_than_end?,<<,+,-,===,%,_greater_than_begin?,reverse,!,include?,*,to_i,abs,/,hash,inspect');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'ArithmeticSequence');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.step_arg2 = $proto.receiver_num = $proto.step_arg1 = $proto.step = $proto.range = $proto.topfx = $proto.bypfx = $proto.creation_method = $proto.skipped_arg = nil;
      
      Opal.prop(self.$$prototype, '$$is_arithmetic_seq', true);
      var inf = Infinity;
      
      $def(self, '$initialize', function $$initialize(range, step, creation_method) {
        var $a, self = this, $ret_or_1 = nil;

        
        ;
        if (creation_method == null) creation_method = "step";
        self.creation_method = creation_method;
        if ($truthy(range['$is_a?']($$$('Array')))) {
          
          $a = [].concat($to_a(range)), (self.step_arg1 = ($a[0] == null ? nil : $a[0])), (self.step_arg2 = ($a[1] == null ? nil : $a[1])), (self.topfx = ($a[2] == null ? nil : $a[2])), (self.bypfx = ($a[3] == null ? nil : $a[3])), $a;
          self.receiver_num = step;
          self.step = 1;
          self.range = ($truthy(self.step_arg2) ? (((self.step = self.step_arg2), Opal.Range.$new(self.receiver_num, self.step_arg1, false))) : ($truthy(self.step_arg1) ? (Opal.Range.$new(self.receiver_num, self.step_arg1, false)) : (Opal.Range.$new(self.receiver_num, nil, false))));
        } else {
          
          if (!$truthy(step)) {
            self.skipped_arg = true
          };
          $a = [range, ($truthy(($ret_or_1 = step)) ? ($ret_or_1) : (1))], (self.range = $a[0]), (self.step = $a[1]), $a;
        };
        self.object = self;
        if ($eqeq(self.step, 0)) {
          $Kernel.$raise($$('ArgumentError'), "step can't be 0")
        };
        if ($truthy(self.step['$respond_to?']("to_int"))) {
          return nil
        } else {
          return $Kernel.$raise($$('ArgumentError'), "" + ("no implicit conversion of " + (self.step.$class()) + " ") + "into Integer")
        };
      }, -2);
      self.$attr_reader("step");
      
      $def(self, '$begin', function $$begin() {
        var self = this;

        return self.range.$begin()
      });
      
      $def(self, '$end', function $$end() {
        var self = this;

        return self.range.$end()
      });
      
      $def(self, '$exclude_end?', function $ArithmeticSequence_exclude_end$ques$1() {
        var self = this;

        return self.range['$exclude_end?']()
      });
      
      $def(self, '$_lesser_than_end?', function $ArithmeticSequence__lesser_than_end$ques$2(val) {
        var self = this, end_ = nil, $ret_or_1 = nil;

        
        end_ = ($truthy(($ret_or_1 = self.$end())) ? ($ret_or_1) : (inf));
        if ($truthy($rb_gt(self.$step(), 0))) {
          if ($truthy(self['$exclude_end?']())) {
            return $rb_lt(val, end_)
          } else {
            return $rb_le(val, end_)
          }
        } else if ($truthy(self['$exclude_end?']())) {
          return $rb_gt(val, end_)
        } else {
          return $rb_ge(val, end_)
        };
      });
      
      $def(self, '$_greater_than_begin?', function $ArithmeticSequence__greater_than_begin$ques$3(val) {
        var self = this, begin_ = nil, $ret_or_1 = nil;

        
        begin_ = ($truthy(($ret_or_1 = self.$begin())) ? ($ret_or_1) : ((inf)['$-@']()));
        if ($truthy($rb_gt(self.$step(), 0))) {
          return $rb_gt(val, begin_)
        } else {
          return $rb_lt(val, begin_)
        };
      });
      
      $def(self, '$first', function $$first(count) {
        var self = this, iter = nil, $ret_or_1 = nil, out = nil;

        
        ;
        iter = ($truthy(($ret_or_1 = self.$begin())) ? ($ret_or_1) : ((inf)['$-@']()));
        if (!$truthy(count)) {
          return ($truthy(self['$_lesser_than_end?'](iter)) ? (iter) : (nil))
        };
        out = [];
        while ($truthy(($truthy(($ret_or_1 = self['$_lesser_than_end?'](iter))) ? ($rb_gt(count, 0)) : ($ret_or_1)))) {
        
          out['$<<'](iter);
          iter = $rb_plus(iter, self.$step());
          count = $rb_minus(count, 1);
        };
        return out;
      }, -1);
      
      $def(self, '$each', function $$each() {
        var block = $$each.$$p || nil, self = this, $ret_or_1 = nil, iter = nil;

        $$each.$$p = null;
        
        ;
        if (!(block !== nil)) {
          return self
        };
        if ($eqeqeq(nil, ($ret_or_1 = self.$begin()))) {
          $Kernel.$raise($$('TypeError'), "nil can't be coerced into Integer")
        } else {
          nil
        };
        iter = ($truthy(($ret_or_1 = self.$begin())) ? ($ret_or_1) : ((inf)['$-@']()));
        while ($truthy(self['$_lesser_than_end?'](iter))) {
        
          Opal.yield1(block, iter);
          iter = $rb_plus(iter, self.$step());
        };
        return self;
      });
      
      $def(self, '$last', function $$last(count) {
        var self = this, $ret_or_1 = nil, iter = nil, out = nil;

        
        ;
        if (($eqeqeq(inf, ($ret_or_1 = self.$end())) || ($eqeqeq((inf)['$-@'](), $ret_or_1)))) {
          $Kernel.$raise($$$('FloatDomainError'), self.$end())
        } else if ($eqeqeq(nil, $ret_or_1)) {
          $Kernel.$raise($$$('RangeError'), "cannot get the last element of endless arithmetic sequence")
        } else {
          nil
        };
        iter = $rb_minus(self.$end(), $rb_minus(self.$end(), self.$begin())['$%'](self.$step()));
        if (!$truthy(self['$_lesser_than_end?'](iter))) {
          iter = $rb_minus(iter, self.$step())
        };
        if (!$truthy(count)) {
          return ($truthy(self['$_greater_than_begin?'](iter)) ? (iter) : (nil))
        };
        out = [];
        while ($truthy(($truthy(($ret_or_1 = self['$_greater_than_begin?'](iter))) ? ($rb_gt(count, 0)) : ($ret_or_1)))) {
        
          out['$<<'](iter);
          iter = $rb_minus(iter, self.$step());
          count = $rb_minus(count, 1);
        };
        return out.$reverse();
      }, -1);
      
      $def(self, '$size', function $$size() {
        var self = this, step_sign = nil, iter = nil;

        
        step_sign = ($truthy($rb_gt(self.$step(), 0)) ? (1) : (-1));
        if ($not(self['$_lesser_than_end?'](self.$begin()))) {
          return 0
        } else if ($truthy([(inf)['$-@'](), inf]['$include?'](self.$step()))) {
          return 1
        } else if (($truthy([$rb_times((inf)['$-@'](), step_sign), nil]['$include?'](self.$begin())) || ($truthy([$rb_times(inf, step_sign), nil]['$include?'](self.$end()))))) {
          return inf;
        } else {
          
          iter = $rb_minus(self.$end(), $rb_minus(self.$end(), self.$begin())['$%'](self.$step()));
          if (!$truthy(self['$_lesser_than_end?'](iter))) {
            iter = $rb_minus(iter, self.$step())
          };
          return $rb_plus($rb_divide($rb_minus(iter, self.$begin()), self.$step()).$abs().$to_i(), 1);
        };
      });
      
      $def(self, '$==', function $ArithmeticSequence_$eq_eq$4(other) {
        var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil;

        if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = ($truthy(($ret_or_4 = self.$class()['$=='](other.$class()))) ? (self.$begin()['$=='](other.$begin())) : ($ret_or_4)))) ? (self.$end()['$=='](other.$end())) : ($ret_or_3)))) ? (self.$step()['$=='](other.$step())) : ($ret_or_2))))) {
          return self['$exclude_end?']()['$=='](other['$exclude_end?']())
        } else {
          return $ret_or_1
        }
      });
      
      $def(self, '$hash', function $$hash() {
        var self = this;

        return [$$('ArithmeticSequence'), self.$begin(), self.$end(), self.$step(), self['$exclude_end?']()].$hash()
      });
      
      $def(self, '$inspect', function $$inspect() {
        var self = this, args = nil;

        if ($truthy(self.receiver_num)) {
          
          args = ($truthy(self.step_arg2) ? ("(" + (self.topfx) + (self.step_arg1.$inspect()) + ", " + (self.bypfx) + (self.step_arg2.$inspect()) + ")") : ($truthy(self.step_arg1) ? ("(" + (self.topfx) + (self.step_arg1.$inspect()) + ")") : nil));
          return "(" + (self.receiver_num.$inspect()) + "." + (self.creation_method) + (args) + ")";
        } else {
          
          args = ($truthy(self.skipped_arg) ? (nil) : ("(" + (self.step) + ")"));
          return "((" + (self.range.$inspect()) + ")." + (self.creation_method) + (args) + ")";
        }
      });
      $alias(self, "===", "==");
      return $alias(self, "eql?", "==");
    })(self, self, $nesting)
  })('::', null, $nesting)
};

Opal.modules["corelib/enumerator/chain"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $deny_frozen_access = Opal.deny_frozen_access, $klass = Opal.klass, $slice = Opal.slice, $def = Opal.def, $send = Opal.send, $to_a = Opal.to_a, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $thrower = Opal.thrower, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('to_enum,size,each,<<,to_proc,include?,+,reverse_each,respond_to?,rewind,inspect');
  return (function($base, $super) {
    var self = $klass($base, $super, 'Enumerator');

    
    return (function($base, $super) {
      var self = $klass($base, $super, 'Chain');

      var $proto = self.$$prototype;

      $proto.enums = $proto.iterated = nil;
      
      
      $def(self, '$initialize', function $$initialize($a) {
        var $post_args, enums, self = this;

        
        $post_args = $slice(arguments);
        enums = $post_args;
        $deny_frozen_access(self);
        self.enums = enums;
        self.iterated = [];
        return (self.object = self);
      }, -1);
      
      $def(self, '$each', function $$each($a) {
        var block = $$each.$$p || nil, $post_args, args, self = this;

        $$each.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        args = $post_args;
        if (!(block !== nil)) {
          return $send(self, 'to_enum', ["each"].concat($to_a(args)), function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

            return self.$size()}, {$$s: self})
        };
        $send(self.enums, 'each', [], function $$2(enum$){var self = $$2.$$s == null ? this : $$2.$$s;
          if (self.iterated == null) self.iterated = nil;

          
          if (enum$ == null) enum$ = nil;
          self.iterated['$<<'](enum$);
          return $send(enum$, 'each', $to_a(args), block.$to_proc());}, {$$s: self});
        return self;
      }, -1);
      
      $def(self, '$size', function $$size($a) {try { var $t_return = $thrower('return'); 
        var $post_args, args, self = this, accum = nil;

        
        $post_args = $slice(arguments);
        args = $post_args;
        accum = 0;
        $send(self.enums, 'each', [], function $$3(enum$){var size = nil;

          
          if (enum$ == null) enum$ = nil;
          size = $send(enum$, 'size', $to_a(args));
          if ($truthy([nil, $$$($$$('Float'), 'INFINITY')]['$include?'](size))) {
            $t_return.$throw(size, $$3.$$is_lambda)
          };
          return (accum = $rb_plus(accum, size));}, {$$ret: $t_return});
        return accum;} catch($e) {
          if ($e === $t_return) return $e.$v;
          throw $e;
        } finally {$t_return.is_orphan = true;}
      }, -1);
      
      $def(self, '$rewind', function $$rewind() {
        var self = this;

        
        $send(self.iterated, 'reverse_each', [], function $$4(enum$){
          
          if (enum$ == null) enum$ = nil;
          if ($truthy(enum$['$respond_to?']("rewind"))) {
            return enum$.$rewind()
          } else {
            return nil
          };});
        self.iterated = [];
        return self;
      });
      return $def(self, '$inspect', function $$inspect() {
        var self = this;

        return "#<Enumerator::Chain: " + (self.enums.$inspect()) + ">"
      });
    })(self, self)
  })('::', null)
};

Opal.modules["corelib/enumerator/generator"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $deny_frozen_access = Opal.deny_frozen_access, $klass = Opal.klass, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $def = Opal.def, $slice = Opal.slice, $send = Opal.send, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,raise,new,to_proc');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Generator');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.block = nil;
      
      self.$include($$$('Enumerable'));
      
      $def(self, '$initialize', function $$initialize() {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        $deny_frozen_access(self);
        if (!$truthy(block)) {
          $Kernel.$raise($$$('LocalJumpError'), "no block given")
        };
        return (self.block = block);
      });
      return $def(self, '$each', function $$each($a) {
        var block = $$each.$$p || nil, $post_args, args, self = this, yielder = nil;

        $$each.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        args = $post_args;
        yielder = $send($$('Yielder'), 'new', [], block.$to_proc());
        
        try {
          args.unshift(yielder);

          Opal.yieldX(self.block, args);
        }
        catch (e) {
          if (e && e.$thrower_type == "breaker") {
            return e.$v;
          }
          else {
            throw e;
          }
        }
      ;
        return self;
      }, -1);
    })($nesting[0], null, $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["corelib/enumerator/lazy"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $yield1 = Opal.yield1, $yieldX = Opal.yieldX, $deny_frozen_access = Opal.deny_frozen_access, $klass = Opal.klass, $slice = Opal.slice, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $defs = Opal.defs, $Kernel = Opal.Kernel, $send = Opal.send, $def = Opal.def, $return_self = Opal.return_self, $Opal = Opal.Opal, $rb_lt = Opal.rb_lt, $eqeqeq = Opal.eqeqeq, $rb_plus = Opal.rb_plus, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('raise,each,new,enumerator_size,yield,respond_to?,try_convert,<,===,+,for,class,to_proc,destructure,inspect,to_a,find_all,collect_concat,collect,enum_for');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Lazy');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.enumerator = nil;
      
      $klass(self, $$$('Exception'), 'StopLazyError');
      $defs(self, '$for', function $Lazy_for$1(object, $a) {
        var $post_args, $fwd_rest, $yield = $Lazy_for$1.$$p || nil, self = this, lazy = nil;

        $Lazy_for$1.$$p = null;
        
        $post_args = $slice(arguments, 1);
        $fwd_rest = $post_args;
        lazy = $send2(self, $find_super(self, 'for', $Lazy_for$1, false, true), 'for', [object].concat($to_a($fwd_rest)), $yield);
        lazy.enumerator = object;
        return lazy;
      }, -2);
      
      $def(self, '$initialize', function $$initialize(object, size) {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        if (size == null) size = nil;
        $deny_frozen_access(self);
        if (!(block !== nil)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy new without a block")
        };
        self.enumerator = object;
        return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [size], function $$2(yielder, $a){var $post_args, each_args;

          
          if (yielder == null) yielder = nil;
          $post_args = $slice(arguments, 1);
          each_args = $post_args;
          try {
            return $send(object, 'each', $to_a(each_args), function $$3($b){var $post_args, args;

              
              $post_args = $slice(arguments);
              args = $post_args;
              
            args.unshift(yielder);

            $yieldX(block, args);
          ;}, -1)
          } catch ($err) {
            if (Opal.rescue($err, [$$('StopLazyError')])) {
              try {
                return nil
              } finally { Opal.pop_exception($err); }
            } else { throw $err; }
          };}, -2);
      }, -2);
      
      $def(self, '$lazy', $return_self);
      
      $def(self, '$collect', function $$collect() {
        var block = $$collect.$$p || nil, self = this;

        $$collect.$$p = null;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy map without a block")
        };
        return $send($$('Lazy'), 'new', [self, self.$enumerator_size()], function $$4(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          
          var value = $yieldX(block, args);

          enum$.$yield(value);
        ;}, -2);
      });
      
      $def(self, '$collect_concat', function $$collect_concat() {
        var block = $$collect_concat.$$p || nil, self = this;

        $$collect_concat.$$p = null;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy map without a block")
        };
        return $send($$('Lazy'), 'new', [self, nil], function $$5(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          
          var value = $yieldX(block, args);

          if ((value)['$respond_to?']("force") && (value)['$respond_to?']("each")) {
            $send((value), 'each', [], function $$6(v){
            
            if (v == null) v = nil;
            return enum$.$yield(v);})
          }
          else {
            var array = $Opal.$try_convert(value, $$$('Array'), "to_ary");

            if (array === nil) {
              enum$.$yield(value);
            }
            else {
              $send((value), 'each', [], function $$7(v){
            
            if (v == null) v = nil;
            return enum$.$yield(v);});
            }
          }
        ;}, -2);
      });
      
      $def(self, '$drop', function $$drop(n) {
        var self = this, current_size = nil, set_size = nil, dropped = nil;

        
        n = $coerce_to(n, $$$('Integer'), 'to_int');
        if ($truthy($rb_lt(n, 0))) {
          $Kernel.$raise($$$('ArgumentError'), "attempt to drop negative size")
        };
        current_size = self.$enumerator_size();
        set_size = ($eqeqeq($$$('Integer'), current_size) ? (($truthy($rb_lt(n, current_size)) ? (n) : (current_size))) : (current_size));
        dropped = 0;
        return $send($$('Lazy'), 'new', [self, set_size], function $$8(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          if ($truthy($rb_lt(dropped, n))) {
            return (dropped = $rb_plus(dropped, 1))
          } else {
            return $send(enum$, 'yield', $to_a(args))
          };}, -2);
      });
      
      $def(self, '$drop_while', function $$drop_while() {
        var block = $$drop_while.$$p || nil, self = this, succeeding = nil;

        $$drop_while.$$p = null;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy drop_while without a block")
        };
        succeeding = true;
        return $send($$('Lazy'), 'new', [self, nil], function $$9(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          if ($truthy(succeeding)) {
            
            var value = $yieldX(block, args);

            if (!$truthy(value)) {
              succeeding = false;

              $send(enum$, 'yield', $to_a(args));
            }
          
          } else {
            return $send(enum$, 'yield', $to_a(args))
          };}, -2);
      });
      
      $def(self, '$enum_for', function $$enum_for($a, $b) {
        var block = $$enum_for.$$p || nil, $post_args, method, args, self = this;

        $$enum_for.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        
        if ($post_args.length > 0) method = $post_args.shift();if (method == null) method = "each";
        args = $post_args;
        return $send(self.$class(), 'for', [self, method].concat($to_a(args)), block.$to_proc());
      }, -1);
      
      $def(self, '$find_all', function $$find_all() {
        var block = $$find_all.$$p || nil, self = this;

        $$find_all.$$p = null;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy select without a block")
        };
        return $send($$('Lazy'), 'new', [self, nil], function $$10(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          
          var value = $yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', $to_a(args));
          }
        ;}, -2);
      });
      
      $def(self, '$grep', function $$grep(pattern) {
        var block = $$grep.$$p || nil, self = this;

        $$grep.$$p = null;
        
        ;
        if ($truthy(block)) {
          return $send($$('Lazy'), 'new', [self, nil], function $$11(enum$, $a){var $post_args, args;

            
            if (enum$ == null) enum$ = nil;
            $post_args = $slice(arguments, 1);
            args = $post_args;
            
            var param = $Opal.$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              value = $yield1(block, param);

              enum$.$yield($yield1(block, param));
            }
          ;}, -2)
        } else {
          return $send($$('Lazy'), 'new', [self, nil], function $$12(enum$, $a){var $post_args, args;

            
            if (enum$ == null) enum$ = nil;
            $post_args = $slice(arguments, 1);
            args = $post_args;
            
            var param = $Opal.$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              enum$.$yield(param);
            }
          ;}, -2)
        };
      });
      
      $def(self, '$reject', function $$reject() {
        var block = $$reject.$$p || nil, self = this;

        $$reject.$$p = null;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy reject without a block")
        };
        return $send($$('Lazy'), 'new', [self, nil], function $$13(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          
          var value = $yieldX(block, args);

          if (!$truthy(value)) {
            $send(enum$, 'yield', $to_a(args));
          }
        ;}, -2);
      });
      
      $def(self, '$take', function $$take(n) {
        var self = this, current_size = nil, set_size = nil, taken = nil;

        
        n = $coerce_to(n, $$$('Integer'), 'to_int');
        if ($truthy($rb_lt(n, 0))) {
          $Kernel.$raise($$$('ArgumentError'), "attempt to take negative size")
        };
        current_size = self.$enumerator_size();
        set_size = ($eqeqeq($$$('Integer'), current_size) ? (($truthy($rb_lt(n, current_size)) ? (n) : (current_size))) : (current_size));
        taken = 0;
        return $send($$('Lazy'), 'new', [self, set_size], function $$14(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          if ($truthy($rb_lt(taken, n))) {
            
            $send(enum$, 'yield', $to_a(args));
            return (taken = $rb_plus(taken, 1));
          } else {
            return $Kernel.$raise($$('StopLazyError'))
          };}, -2);
      });
      
      $def(self, '$take_while', function $$take_while() {
        var block = $$take_while.$$p || nil, self = this;

        $$take_while.$$p = null;
        
        ;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "tried to call lazy take_while without a block")
        };
        return $send($$('Lazy'), 'new', [self, nil], function $$15(enum$, $a){var $post_args, args;

          
          if (enum$ == null) enum$ = nil;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          
          var value = $yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', $to_a(args));
          }
          else {
            $Kernel.$raise($$('StopLazyError'));
          }
        ;}, -2);
      });
      
      $def(self, '$inspect', function $$inspect() {
        var self = this;

        return "#<" + (self.$class()) + ": " + (self.enumerator.$inspect()) + ">"
      });
      $alias(self, "force", "to_a");
      $alias(self, "filter", "find_all");
      $alias(self, "flat_map", "collect_concat");
      $alias(self, "map", "collect");
      $alias(self, "select", "find_all");
      return $alias(self, "to_enum", "enum_for");
    })(self, self, $nesting)
  })('::', null, $nesting)
};

Opal.modules["corelib/enumerator/yielder"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $def = Opal.def, $slice = Opal.slice, $send = Opal.send, $to_a = Opal.to_a, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('yield,proc');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super) {
      var self = $klass($base, $super, 'Yielder');

      var $proto = self.$$prototype;

      $proto.block = nil;
      
      
      $def(self, '$initialize', function $$initialize() {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        self.block = block;
        return self;
      });
      
      $def(self, '$yield', function $Yielder_yield$1($a) {
        var $post_args, values, self = this;

        
        $post_args = $slice(arguments);
        values = $post_args;
        
        var value = Opal.yieldX(self.block, values);

        if (value && value.$thrower_type == "break") {
          throw value;
        }

        return value;
      ;
      }, -1);
      
      $def(self, '$<<', function $Yielder_$lt$lt$2(value) {
        var self = this;

        
        self.$yield(value);
        return self;
      });
      return $def(self, '$to_proc', function $$to_proc() {
        var self = this;

        return $send(self, 'proc', [], function $$3($a){var $post_args, values, self = $$3.$$s == null ? this : $$3.$$s;

          
          $post_args = $slice(arguments);
          values = $post_args;
          return $send(self, 'yield', $to_a(values));}, {$$arity: -1, $$s: self})
      });
    })($nesting[0], null)
  })($nesting[0], null, $nesting)
};

Opal.modules["corelib/enumerator"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $slice = Opal.slice, $coerce_to = Opal.coerce_to, $deny_frozen_access = Opal.deny_frozen_access, $klass = Opal.klass, $defs = Opal.defs, $truthy = Opal.truthy, $send = Opal.send, $not = Opal.not, $def = Opal.def, $rb_plus = Opal.rb_plus, $to_a = Opal.to_a, $Opal = Opal.Opal, $send2 = Opal.send2, $find_super = Opal.find_super, $rb_ge = Opal.rb_ge, $Kernel = Opal.Kernel, $rb_le = Opal.rb_le, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,allocate,new,to_proc,!,respond_to?,empty?,nil?,+,class,__send__,call,enum_for,size,destructure,map,>=,length,raise,[],peek_values,<=,next_values,inspect,any?,each_with_object,autoload');
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.size = $proto.args = $proto.object = $proto.method = $proto.values = $proto.cursor = nil;
    
    self.$include($$$('Enumerable'));
    self.$$prototype.$$is_enumerator = true;
    $defs(self, '$for', function $Enumerator_for$1(object, $a, $b) {
      var block = $Enumerator_for$1.$$p || nil, $post_args, method, args, self = this;

      $Enumerator_for$1.$$p = null;
      
      ;
      $post_args = $slice(arguments, 1);
      
      if ($post_args.length > 0) method = $post_args.shift();if (method == null) method = "each";
      args = $post_args;
      
      var obj = self.$allocate();

      obj.object = object;
      obj.size   = block;
      obj.method = method;
      obj.args   = args;
      obj.cursor = 0;

      return obj;
    ;
    }, -2);
    
    $def(self, '$initialize', function $$initialize($a) {
      var block = $$initialize.$$p || nil, $post_args, $fwd_rest, self = this;

      $$initialize.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      $deny_frozen_access(self);
      self.cursor = 0;
      if ($truthy(block)) {
        
        self.object = $send($$('Generator'), 'new', [], block.$to_proc());
        self.method = "each";
        self.args = [];
        self.size = arguments[0] || nil;
        if (($truthy(self.size) && ($not(self.size['$respond_to?']("call"))))) {
          return (self.size = $coerce_to(self.size, $$$('Integer'), 'to_int'))
        } else {
          return nil
        };
      } else {
        
        self.object = arguments[0];
        self.method = arguments[1] || "each";
        self.args = $slice(arguments, 2);
        return (self.size = nil);
      };
    }, -1);
    
    $def(self, '$each', function $$each($a) {
      var block = $$each.$$p || nil, $post_args, args, self = this;

      $$each.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      if (($truthy(block['$nil?']()) && ($truthy(args['$empty?']())))) {
        return self
      };
      args = $rb_plus(self.args, args);
      if ($truthy(block['$nil?']())) {
        return $send(self.$class(), 'new', [self.object, self.method].concat($to_a(args)))
      };
      return $send(self.object, '__send__', [self.method].concat($to_a(args)), block.$to_proc());
    }, -1);
    
    $def(self, '$size', function $$size() {
      var self = this;

      if ($truthy(self.size['$respond_to?']("call"))) {
        return $send(self.size, 'call', $to_a(self.args))
      } else {
        return self.size
      }
    });
    
    $def(self, '$with_index', function $$with_index(offset) {
      var block = $$with_index.$$p || nil, self = this;

      $$with_index.$$p = null;
      
      ;
      if (offset == null) offset = 0;
      offset = ($truthy(offset) ? ($coerce_to(offset, $$$('Integer'), 'to_int')) : (0));
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["with_index", offset], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var result, index = offset;

      self.$each.$$p = function() {
        var param = $Opal.$destructure(arguments),
            value = block(param, index);

        index++;

        return value;
      }

      return self.$each();
    ;
    }, -1);
    
    $def(self, '$each_with_index', function $$each_with_index() {
      var block = $$each_with_index.$$p || nil, self = this;

      $$each_with_index.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_with_index"], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

          return self.$size()}, {$$s: self})
      };
      $send2(self, $find_super(self, 'each_with_index', $$each_with_index, false, true), 'each_with_index', [], block);
      return self.object;
    });
    
    $def(self, '$rewind', function $$rewind() {
      var self = this;

      
      self.cursor = 0;
      return self;
    });
    
    $def(self, '$peek_values', function $$peek_values() {
      var self = this, $ret_or_1 = nil;

      
      self.values = ($truthy(($ret_or_1 = self.values)) ? ($ret_or_1) : ($send(self, 'map', [], function $$4($a){var $post_args, i;

        
        $post_args = $slice(arguments);
        i = $post_args;
        return i;}, -1)));
      if ($truthy($rb_ge(self.cursor, self.values.$length()))) {
        $Kernel.$raise($$$('StopIteration'), "iteration reached an end")
      };
      return self.values['$[]'](self.cursor);
    });
    
    $def(self, '$peek', function $$peek() {
      var self = this, values = nil;

      
      values = self.$peek_values();
      if ($truthy($rb_le(values.$length(), 1))) {
        return values['$[]'](0)
      } else {
        return values
      };
    });
    
    $def(self, '$next_values', function $$next_values() {
      var self = this, out = nil;

      
      out = self.$peek_values();
      self.cursor = $rb_plus(self.cursor, 1);
      return out;
    });
    
    $def(self, '$next', function $$next() {
      var self = this, values = nil;

      
      values = self.$next_values();
      if ($truthy($rb_le(values.$length(), 1))) {
        return values['$[]'](0)
      } else {
        return values
      };
    });
    
    $def(self, '$feed', function $$feed(arg) {
      var self = this;

      return self.$raise($$('NotImplementedError'), "Opal doesn't support Enumerator#feed")
    });
    
    $def(self, '$+', function $Enumerator_$plus$5(other) {
      var self = this;

      return $$$($$$('Enumerator'), 'Chain').$new(self, other)
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, result = nil;

      
      result = "#<" + (self.$class()) + ": " + (self.object.$inspect()) + ":" + (self.method);
      if ($truthy(self.args['$any?']())) {
        result = $rb_plus(result, "(" + (self.args.$inspect()['$[]']($$$('Range').$new(1, -2))) + ")")
      };
      return $rb_plus(result, ">");
    });
    $alias(self, "with_object", "each_with_object");
    self.$autoload("ArithmeticSequence", "corelib/enumerator/arithmetic_sequence");
    self.$autoload("Chain", "corelib/enumerator/chain");
    self.$autoload("Generator", "corelib/enumerator/generator");
    self.$autoload("Lazy", "corelib/enumerator/lazy");
    return self.$autoload("Yielder", "corelib/enumerator/yielder");
  })('::', null, $nesting);
};

Opal.modules["corelib/numeric"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $def = Opal.def, $to_ary = Opal.to_ary, $return_self = Opal.return_self, $rb_minus = Opal.rb_minus, $rb_times = Opal.rb_times, $rb_lt = Opal.rb_lt, $eqeq = Opal.eqeq, $rb_divide = Opal.rb_divide, $return_val = Opal.return_val, $Opal = Opal.Opal, $slice = Opal.slice, $extract_kwargs = Opal.extract_kwargs, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $not = Opal.not, $send = Opal.send, $rb_ge = Opal.rb_ge, $rb_le = Opal.rb_le, $rb_plus = Opal.rb_plus, $rb_gt = Opal.rb_gt, $alias = Opal.alias, self = Opal.top, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,instance_of?,class,Float,respond_to?,coerce,__send__,raise,equal?,-,*,div,<,-@,ceil,to_f,denominator,to_r,==,floor,/,%,Complex,zero?,numerator,abs,arg,coerce_to!,round,<=>,compare,is_a?,!,new,enum_for,to_proc,negative?,>=,<=,+,to_i,truncate,>,angle,conj,imag,rect');
  
  self.$require("corelib/comparable");
  return (function($base, $super) {
    var self = $klass($base, $super, 'Numeric');

    
    
    self.$include($$$('Comparable'));
    
    $def(self, '$coerce', function $$coerce(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
        return [other, self]
      };
      return [$Kernel.$Float(other), $Kernel.$Float(self)];
    });
    
    $def(self, '$__coerced__', function $$__coerced__(method, other) {
      var $a, $b, self = this, a = nil, b = nil;

      if ($truthy(other['$respond_to?']("coerce"))) {
        
        $b = other.$coerce(self), $a = $to_ary($b), (a = ($a[0] == null ? nil : $a[0])), (b = ($a[1] == null ? nil : $a[1])), $b;
        return a.$__send__(method, b);
      } else 
      switch (method.valueOf()) {
        case "+":
        case "-":
        case "*":
        case "/":
        case "%":
        case "&":
        case "|":
        case "^":
        case "**":
          return $Kernel.$raise($$$('TypeError'), "" + (other.$class()) + " can't be coerced into Numeric")
        case ">":
        case ">=":
        case "<":
        case "<=":
        case "<=>":
          return $Kernel.$raise($$$('ArgumentError'), "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")
        default:
          return nil
      }
    });
    
    $def(self, '$<=>', function $Numeric_$lt_eq_gt$1(other) {
      var self = this;

      
      if ($truthy(self['$equal?'](other))) {
        return 0
      };
      return nil;
    });
    
    $def(self, '$+@', $return_self);
    
    $def(self, '$-@', function $Numeric_$minus$$2() {
      var self = this;

      return $rb_minus(0, self)
    });
    
    $def(self, '$%', function $Numeric_$percent$3(other) {
      var self = this;

      return $rb_minus(self, $rb_times(other, self.$div(other)))
    });
    
    $def(self, '$abs', function $$abs() {
      var self = this;

      if ($truthy($rb_lt(self, 0))) {
        return self['$-@']()
      } else {
        return self
      }
    });
    
    $def(self, '$abs2', function $$abs2() {
      var self = this;

      return $rb_times(self, self)
    });
    
    $def(self, '$angle', function $$angle() {
      var self = this;

      if ($truthy($rb_lt(self, 0))) {
        return $$$($$$('Math'), 'PI')
      } else {
        return 0
      }
    });
    
    $def(self, '$ceil', function $$ceil(ndigits) {
      var self = this;

      
      if (ndigits == null) ndigits = 0;
      return self.$to_f().$ceil(ndigits);
    }, -1);
    
    $def(self, '$conj', $return_self);
    
    $def(self, '$denominator', function $$denominator() {
      var self = this;

      return self.$to_r().$denominator()
    });
    
    $def(self, '$div', function $$div(other) {
      var self = this;

      
      if ($eqeq(other, 0)) {
        $Kernel.$raise($$$('ZeroDivisionError'), "divided by o")
      };
      return $rb_divide(self, other).$floor();
    });
    
    $def(self, '$divmod', function $$divmod(other) {
      var self = this;

      return [self.$div(other), self['$%'](other)]
    });
    
    $def(self, '$fdiv', function $$fdiv(other) {
      var self = this;

      return $rb_divide(self.$to_f(), other)
    });
    
    $def(self, '$floor', function $$floor(ndigits) {
      var self = this;

      
      if (ndigits == null) ndigits = 0;
      return self.$to_f().$floor(ndigits);
    }, -1);
    
    $def(self, '$i', function $$i() {
      var self = this;

      return $Kernel.$Complex(0, self)
    });
    
    $def(self, '$imag', $return_val(0));
    
    $def(self, '$integer?', $return_val(false));
    
    $def(self, '$nonzero?', function $Numeric_nonzero$ques$4() {
      var self = this;

      if ($truthy(self['$zero?']())) {
        return nil
      } else {
        return self
      }
    });
    
    $def(self, '$numerator', function $$numerator() {
      var self = this;

      return self.$to_r().$numerator()
    });
    
    $def(self, '$polar', function $$polar() {
      var self = this;

      return [self.$abs(), self.$arg()]
    });
    
    $def(self, '$quo', function $$quo(other) {
      var self = this;

      return $rb_divide($Opal['$coerce_to!'](self, $$$('Rational'), "to_r"), other)
    });
    
    $def(self, '$real', $return_self);
    
    $def(self, '$real?', $return_val(true));
    
    $def(self, '$rect', function $$rect() {
      var self = this;

      return [self, 0]
    });
    
    $def(self, '$round', function $$round(digits) {
      var self = this;

      
      ;
      return self.$to_f().$round(digits);
    }, -1);
    
    $def(self, '$step', function $$step($a, $b, $c) {
      var block = $$step.$$p || nil, $post_args, $kwargs, limit, step, to, by, self = this, counter = nil;

      $$step.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      
      if ($post_args.length > 0) limit = $post_args.shift();;
      
      if ($post_args.length > 0) step = $post_args.shift();;
      
      to = $hash_get($kwargs, "to");;
      
      by = $hash_get($kwargs, "by");;
      
      if (limit !== undefined && to !== undefined) {
        $Kernel.$raise($$$('ArgumentError'), "to is given twice")
      }

      if (step !== undefined && by !== undefined) {
        $Kernel.$raise($$$('ArgumentError'), "step is given twice")
      }

      if (to !== undefined) {
        limit = to;
      }

      if (by !== undefined) {
        step = by;
      }

      if (limit === undefined) {
        limit = nil;
      }

      function validateParameters() {
        if (step === nil) {
          $Kernel.$raise($$$('TypeError'), "step must be numeric")
        }

        if (step != null && step['$=='](0)) {
          $Kernel.$raise($$$('ArgumentError'), "step can't be 0")
        }

        if (step === nil || step == null) {
          step = 1;
        }

        var sign = step['$<=>'](0);

        if (sign === nil) {
          $Kernel.$raise($$$('ArgumentError'), "0 can't be coerced into " + (step.$class()))
        }

        if (limit === nil || limit == null) {
          limit = sign > 0 ? $$$($$$('Float'), 'INFINITY') : $$$($$$('Float'), 'INFINITY')['$-@']();
        }

        $Opal.$compare(self, limit)
      }

      function stepFloatSize() {
        if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
          return 0;
        } else if (step === Infinity || step === -Infinity) {
          return 1;
        } else {
          var abs = Math.abs, floor = Math.floor,
              err = (abs(self) + abs(limit) + abs(limit - self)) / abs(step) * $$$($$$('Float'), 'EPSILON');

          if (err === Infinity || err === -Infinity) {
            return 0;
          } else {
            if (err > 0.5) {
              err = 0.5;
            }

            return floor((limit - self) / step + err) + 1
          }
        }
      }

      function stepSize() {
        validateParameters();

        if (step === 0) {
          return Infinity;
        }

        if (step % 1 !== 0) {
          return stepFloatSize();
        } else if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
          return 0;
        } else {
          var ceil = Math.ceil, abs = Math.abs,
              lhs = abs(self - limit) + 1,
              rhs = abs(step);

          return ceil(lhs / rhs);
        }
      }

    ;
      if (!(block !== nil)) {
        if ((($not(limit) || ($truthy(limit['$is_a?']($$$('Numeric'))))) && (($not(step) || ($truthy(step['$is_a?']($$$('Numeric')))))))) {
          return $$$($$$('Enumerator'), 'ArithmeticSequence').$new([limit, step, ($truthy(to) ? ("to: ") : nil), ($truthy(by) ? ("by: ") : nil)], self)
        } else {
          return $send(self, 'enum_for', ["step", limit, step], (stepSize).$to_proc())
        }
      };
      
      validateParameters();

      var isDesc = step['$negative?'](),
          isInf = step['$=='](0) ||
                  (limit === Infinity && !isDesc) ||
                  (limit === -Infinity && isDesc);

      if (self.$$is_number && step.$$is_number && limit.$$is_number) {
        if (self % 1 === 0 && (isInf || limit % 1 === 0) && step % 1 === 0) {
          var value = self;

          if (isInf) {
            for (;; value += step) {
              block(value);
            }
          } else if (isDesc) {
            for (; value >= limit; value += step) {
              block(value);
            }
          } else {
            for (; value <= limit; value += step) {
              block(value);
            }
          }

          return self;
        } else {
          var begin = self.$to_f().valueOf();
          step = step.$to_f().valueOf();
          limit = limit.$to_f().valueOf();

          var n = stepFloatSize();

          if (!isFinite(step)) {
            if (n !== 0) block(begin);
          } else if (step === 0) {
            while (true) {
              block(begin);
            }
          } else {
            for (var i = 0; i < n; i++) {
              var d = i * step + self;
              if (step >= 0 ? limit < d : limit > d) {
                d = limit;
              }
              block(d);
            }
          }

          return self;
        }
      }
    ;
      counter = self;
      while ($truthy(isDesc ? $rb_ge(counter, limit) : $rb_le(counter, limit))) {
      
        Opal.yield1(block, counter);
        counter = $rb_plus(counter, step);
      };
    }, -1);
    
    $def(self, '$to_c', function $$to_c() {
      var self = this;

      return $Kernel.$Complex(self, 0)
    });
    
    $def(self, '$to_int', function $$to_int() {
      var self = this;

      return self.$to_i()
    });
    
    $def(self, '$truncate', function $$truncate(ndigits) {
      var self = this;

      
      if (ndigits == null) ndigits = 0;
      return self.$to_f().$truncate(ndigits);
    }, -1);
    
    $def(self, '$zero?', function $Numeric_zero$ques$5() {
      var self = this;

      return self['$=='](0)
    });
    
    $def(self, '$positive?', function $Numeric_positive$ques$6() {
      var self = this;

      return $rb_gt(self, 0)
    });
    
    $def(self, '$negative?', function $Numeric_negative$ques$7() {
      var self = this;

      return $rb_lt(self, 0)
    });
    
    $def(self, '$dup', $return_self);
    
    $def(self, '$clone', function $$clone($kwargs) {
      var freeze, self = this;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      freeze = $hash_get($kwargs, "freeze");if (freeze == null) freeze = true;
      return self;
    }, -1);
    
    $def(self, '$finite?', $return_val(true));
    
    $def(self, '$infinite?', $return_val(nil));
    $alias(self, "arg", "angle");
    $alias(self, "conjugate", "conj");
    $alias(self, "imaginary", "imag");
    $alias(self, "magnitude", "abs");
    $alias(self, "modulo", "%");
    $alias(self, "phase", "arg");
    return $alias(self, "rectangular", "rect");
  })('::', null);
};

Opal.modules["corelib/array"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $truthy = Opal.truthy, $falsy = Opal.falsy, $yield1 = Opal.yield1, $hash_get = Opal.hash_get, $hash_put = Opal.hash_put, $hash_delete = Opal.hash_delete, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $deny_frozen_access = Opal.deny_frozen_access, $freeze = Opal.freeze, $opal32_init = Opal.opal32_init, $opal32_add = Opal.opal32_add, $klass = Opal.klass, $slice = Opal.slice, $defs = Opal.defs, $Kernel = Opal.Kernel, $def = Opal.def, $Opal = Opal.Opal, $eqeqeq = Opal.eqeqeq, $send2 = Opal.send2, $find_super = Opal.find_super, $send = Opal.send, $rb_gt = Opal.rb_gt, $rb_times = Opal.rb_times, $eqeq = Opal.eqeq, $rb_minus = Opal.rb_minus, $to_a = Opal.to_a, $to_ary = Opal.to_ary, $gvars = Opal.gvars, $rb_ge = Opal.rb_ge, $assign_ivar = Opal.assign_ivar, $rb_lt = Opal.rb_lt, $return_self = Opal.return_self, $neqeq = Opal.neqeq, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,to_a,warn,raise,replace,respond_to?,to_ary,coerce_to?,join,to_str,===,<=>,==,object_id,inspect,enum_for,class,bsearch_index,to_proc,nil?,coerce_to!,>,*,enumerator_size,empty?,size,map,equal?,dup,each,reduce,-,[],dig,eql?,length,exclude_end?,flatten,frozen?,__id__,sort_by,&,to_s,new,item,max,min,!,>=,**,delete_if,rotate,rand,at,keep_if,shuffle!,<,sort,!=,times,[]=,<<,uniq,|,values,is_a?,end,begin,upto,reject,push,select,select!,collect,collect!,unshift,pristine,singleton_class');
  
  self.$require("corelib/enumerable");
  self.$require("corelib/numeric");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Enumerable'));
    Opal.prop(self.$$prototype, '$$is_array', true);
    
    // Recent versions of V8 (> 7.1) only use an optimized implementation when Array.prototype is unmodified.
    // For instance, "array-splice.tq" has a "fast path" (ExtractFastJSArray, defined in "src/codegen/code-stub-assembler.cc")
    // but it's only enabled when "IsPrototypeInitialArrayPrototype()" is true.
    //
    // Older versions of V8 were using relatively fast JS-with-extensions code even when Array.prototype is modified:
    // https://github.com/v8/v8/blob/7.0.1/src/js/array.js#L599-L642
    //
    // In short, Array operations are slow in recent versions of V8 when the Array.prototype has been tampered.
    // So, when possible, we are using faster open-coded version to boost the performance.

    // As of V8 8.4, depending on the size of the array, this is up to ~25x times faster than Array#shift()
    // Implementation is heavily inspired by: https://github.com/nodejs/node/blob/ba684805b6c0eded76e5cd89ee00328ac7a59365/lib/internal/util.js#L341-L347
    function shiftNoArg(list) {
      var r = list[0];
      var index = 1;
      var length = list.length;
      for (; index < length; index++) {
        list[index - 1] = list[index];
      }
      list.pop();
      return r;
    }

    function toArraySubclass(obj, klass) {
      if (klass.$$name === Opal.Array) {
        return obj;
      } else {
        return klass.$allocate().$replace((obj).$to_a());
      }
    }

    // A helper for keep_if and delete_if, filter is either Opal.truthy
    // or Opal.falsy.
    function filterIf(self, filter, block) {
      var value, raised = null, updated = new Array(self.length);

      for (var i = 0, i2 = 0; i < self.length; i++) {
        if (!raised) {
          try {
            value = $yield1(block, self[i])
          } catch(error) {
            raised = error;
          }
        }

        if (raised || filter(value)) {
          updated[i2] = self[i]
          i2 += 1;
        }
      }

      if (i2 !== i) {
        self.splice.apply(self, [0, updated.length].concat(updated));
        self.splice(i2, updated.length);
      }

      if (raised) throw raised;
    }

    function convertToArray(array) {
      if (!array.$$is_array) {
        array = $coerce_to(array, $$$('Array'), 'to_ary');
      }
      return (array).$to_a();
    }

    function fast_push(arr, objects) {
      // push.apply() for arrays longer than 32767 may cause various argument errors in browsers
      // but it is significantly faster than a for loop, which pushes each element separately
      // but apply() has a overhead by itself, for a small number of elements
      // the for loop is significantly faster
      // this is using the best option depending on objects.length
      var length = objects.length;
      if (length > 6 && length < 32767) {
        arr.push.apply(arr, objects);
      } else {
        for (var i = 0; i < length; i++) {
          arr.push(objects[i]);
        }
      }
    }
  ;
    $defs(self, '$[]', function $Array_$$$1($a) {
      var $post_args, objects, self = this;

      
      $post_args = $slice(arguments);
      objects = $post_args;
      return toArraySubclass(objects, self);;
    }, -1);
    
    $def(self, '$initialize', function $$initialize(size, obj) {
      var block = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      ;
      if (size == null) size = nil;
      if (obj == null) obj = nil;
      
      $deny_frozen_access(self);

      if (obj !== nil && block !== nil) {
        $Kernel.$warn("warning: block supersedes default value argument")
      }

      if (size > $$$($$$('Integer'), 'MAX')) {
        $Kernel.$raise($$$('ArgumentError'), "array size too big")
      }

      if (arguments.length > 2) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " for 0..2)")
      }

      if (arguments.length === 0) {
        if (self.length > 0) self.splice(0, self.length);
        return self;
      }

      if (arguments.length === 1) {
        if (size.$$is_array) {
          self.$replace(size.$to_a())
          return self;
        } else if (size['$respond_to?']("to_ary")) {
          self.$replace(size.$to_ary())
          return self;
        }
      }

      size = $coerce_to(size, $$$('Integer'), 'to_int');

      if (size < 0) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size")
      }

      self.splice(0, self.length);
      var i, value;

      if (block === nil) {
        for (i = 0; i < size; i++) {
          self.push(obj);
        }
      }
      else {
        for (i = 0, value; i < size; i++) {
          value = block(i);
          self[i] = value;
        }
      }

      return self;
    ;
    }, -1);
    $defs(self, '$try_convert', function $$try_convert(obj) {
      
      return $Opal['$coerce_to?'](obj, $$$('Array'), "to_ary")
    });
    
    $def(self, '$&', function $Array_$$2(other) {
      var self = this;

      
      other = convertToArray(other)

      if (self.length === 0 || other.length === 0) {
        return [];
      }

      var result = [], hash = (new Map()), i, length, item;

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];
        if ($hash_delete(hash, item) !== undefined) {
          result.push(item);
        }
      }

      return result;
    
    });
    
    $def(self, '$|', function $Array_$$3(other) {
      var self = this;

      
      other = convertToArray(other);
      
      var hash = (new Map()), i, length, item;

      for (i = 0, length = self.length; i < length; i++) {
        $hash_put(hash, self[i], true);
      }

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      return hash.$keys();
    ;
    });
    
    $def(self, '$*', function $Array_$$4(other) {
      var self = this;

      
      if ($truthy(other['$respond_to?']("to_str"))) {
        return self.$join(other.$to_str())
      };
      other = $coerce_to(other, $$$('Integer'), 'to_int');
      if ($truthy(other < 0)) {
        $Kernel.$raise($$$('ArgumentError'), "negative argument")
      };
      
      var result = [],
          converted = self.$to_a();

      for (var i = 0; i < other; i++) {
        result = result.concat(converted);
      }

      return result;
    ;
    });
    
    $def(self, '$+', function $Array_$plus$5(other) {
      var self = this;

      
      other = convertToArray(other);
      return self.concat(other);;
    });
    
    $def(self, '$-', function $Array_$minus$6(other) {
      var self = this;

      
      other = convertToArray(other);
      if ($truthy(self.length === 0)) {
        return []
      };
      if ($truthy(other.length === 0)) {
        return self.slice()
      };
      
      var result = [], hash = (new Map()), i, length, item;

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];
        if ($hash_get(hash, item) === undefined) {
          result.push(item);
        }
      }

      return result;
    ;
    });
    
    $def(self, '$<<', function $Array_$lt$lt$7(object) {
      var self = this;

      
      $deny_frozen_access(self);
      self.push(object);
      return self;
    });
    
    $def(self, '$<=>', function $Array_$lt_eq_gt$8(other) {
      var self = this;

      
      if ($eqeqeq($$$('Array'), other)) {
        other = other.$to_a()
      } else if ($truthy(other['$respond_to?']("to_ary"))) {
        other = other.$to_ary().$to_a()
      } else {
        return nil
      };
      
      if (self === other) {
        return 0;
      }

      var count = Math.min(self.length, other.length);

      for (var i = 0; i < count; i++) {
        var tmp = (self[i])['$<=>'](other[i]);

        if (tmp !== 0) {
          return tmp;
        }
      }

      return (self.length)['$<=>'](other.length);
    ;
    });
    
    $def(self, '$==', function $Array_$eq_eq$9(other) {
      var self = this;

      
      var recursed = {};

      function _eqeq(array, other) {
        var i, length, a, b;

        if (array === other)
          return true;

        if (!other.$$is_array) {
          if ($respond_to(other, '$to_ary')) {
            return (other)['$=='](array);
          } else {
            return false;
          }
        }

        if (array.$$constructor !== Array)
          array = (array).$to_a();
        if (other.$$constructor !== Array)
          other = (other).$to_a();

        if (array.length !== other.length) {
          return false;
        }

        recursed[(array).$object_id()] = true;

        for (i = 0, length = array.length; i < length; i++) {
          a = array[i];
          b = other[i];
          if (a.$$is_array) {
            if (b.$$is_array && b.length !== a.length) {
              return false;
            }
            if (!recursed.hasOwnProperty((a).$object_id())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$=='](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    
    });
    
    function $array_slice_range(self, index) {
      var size = self.length,
          exclude, from, to, result;

      exclude = index.excl;
      from    = index.begin === nil ? 0 : $coerce_to(index.begin, Opal.Integer, 'to_int');
      to      = index.end === nil ? -1 : $coerce_to(index.end, Opal.Integer, 'to_int');

      if (from < 0) {
        from += size;

        if (from < 0) {
          return nil;
        }
      }

      if (index.excl_rev && index.begin !== nil) {
        from += 1;
      }

      if (from > size) {
        return nil;
      }

      if (to < 0) {
        to += size;

        if (to < 0) {
          return [];
        }
      }

      if (!exclude || index.end === nil) {
        to += 1;
      }

      result = self.slice(from, to);
      return result;
    }

    function $array_slice_arithmetic_seq(self, index) {
      var array, out = [], i = 0, pseudorange;

      if (index.step < 0) {
        pseudorange = {
          begin: index.range.end,
          end: index.range.begin,
          excl: false,
          excl_rev: index.range.excl
        };
        array = $array_slice_range(self, pseudorange).$reverse();
      }
      else {
        array = $array_slice_range(self, index.range);
      }

      while (i < array.length) {
        out.push(array[i]);
        i += Math.abs(index.step);
      }

      return out;
    }

    function $array_slice_index_length(self, index, length) {
      var size = self.length,
          exclude, from, to, result;

      index = $coerce_to(index, Opal.Integer, 'to_int');

      if (index < 0) {
        index += size;

        if (index < 0) {
          return nil;
        }
      }

      if (length === undefined) {
        if (index >= size || index < 0) {
          return nil;
        }

        return self[index];
      }
      else {
        length = $coerce_to(length, Opal.Integer, 'to_int');

        if (length < 0 || index > size || index < 0) {
          return nil;
        }

        result = self.slice(index, index + length);
      }
      return result;
    }
  ;
    
    $def(self, '$[]', function $Array_$$$10(index, length) {
      var self = this;

      
      ;
      
      if (index.$$is_range) {
        return $array_slice_range(self, index);
      }
      else if (index.$$is_arithmetic_seq) {
        return $array_slice_arithmetic_seq(self, index);
      }
      else {
        return $array_slice_index_length(self, index, length);
      }
    ;
    }, -2);
    
    $def(self, '$[]=', function $Array_$$$eq$11(index, value, extra) {
      var self = this, data = nil, length = nil;

      
      ;
      $deny_frozen_access(self);
      data = nil;
      
      var i, size = self.length;

      if (index.$$is_range) {
        if (value.$$is_array)
          data = value.$to_a();
        else if (value['$respond_to?']("to_ary"))
          data = value.$to_ary().$to_a();
        else
          data = [value];

        var exclude = index.excl,
            from    = index.begin === nil ? 0 : $coerce_to(index.begin, Opal.Integer, 'to_int'),
            to      = index.end === nil ? -1 : $coerce_to(index.end, Opal.Integer, 'to_int');

        if (from < 0) {
          from += size;

          if (from < 0) {
            $Kernel.$raise($$$('RangeError'), "" + (index.$inspect()) + " out of range");
          }
        }

        if (to < 0) {
          to += size;
        }

        if (!exclude || index.end === nil) {
          to += 1;
        }

        if (from > size) {
          for (i = size; i < from; i++) {
            self[i] = nil;
          }
        }

        if (to < 0) {
          self.splice.apply(self, [from, 0].concat(data));
        }
        else {
          self.splice.apply(self, [from, to - from].concat(data));
        }

        return value;
      } else {
        if (extra === undefined) {
          (length = 1)
        } else {
          length = value;
          value  = extra;

          if (value.$$is_array)
            data = value.$to_a();
          else if (value['$respond_to?']("to_ary"))
            data = value.$to_ary().$to_a();
          else
            data = [value];
        }

        var old;

        index  = $coerce_to(index, $$$('Integer'), 'to_int');
        length = $coerce_to(length, $$$('Integer'), 'to_int');

        if (index < 0) {
          old    = index;
          index += size;

          if (index < 0) {
            $Kernel.$raise($$$('IndexError'), "index " + (old) + " too small for array; minimum " + (-self.length));
          }
        }

        if (length < 0) {
          $Kernel.$raise($$$('IndexError'), "negative length (" + (length) + ")")
        }

        if (index > size) {
          for (i = size; i < index; i++) {
            self[i] = nil;
          }
        }

        if (extra === undefined) {
          self[index] = value;
        }
        else {
          self.splice.apply(self, [index, length].concat(data));
        }

        return value;
      }
    ;
    }, -3);
    
    $def(self, '$any?', function $Array_any$ques$12(pattern) {
      var block = $Array_any$ques$12.$$p || nil, self = this;

      $Array_any$ques$12.$$p = null;
      
      ;
      ;
      if (self.length === 0) return false;
      return $send2(self, $find_super(self, 'any?', $Array_any$ques$12, false, true), 'any?', [pattern], block);
    }, -1);
    
    $def(self, '$assoc', function $$assoc(object) {
      var self = this;

      
      for (var i = 0, length = self.length, item; i < length; i++) {
        if (item = self[i], item.length && (item[0])['$=='](object)) {
          return item;
        }
      }

      return nil;
    
    });
    
    $def(self, '$at', function $$at(index) {
      var self = this;

      
      index = $coerce_to(index, $$$('Integer'), 'to_int')

      if (index < 0) {
        index += self.length;
      }

      if (index < 0 || index >= self.length) {
        return nil;
      }

      return self[index];
    
    });
    
    $def(self, '$bsearch_index', function $$bsearch_index() {
      var block = $$bsearch_index.$$p || nil, self = this;

      $$bsearch_index.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("bsearch_index")
      };
      
      var min = 0,
          max = self.length,
          mid,
          val,
          ret,
          smaller = false,
          satisfied = nil;

      while (min < max) {
        mid = min + Math.floor((max - min) / 2);
        val = self[mid];
        ret = $yield1(block, val);

        if (ret === true) {
          satisfied = mid;
          smaller = true;
        }
        else if (ret === false || ret === nil) {
          smaller = false;
        }
        else if (ret.$$is_number) {
          if (ret === 0) { return mid; }
          smaller = (ret < 0);
        }
        else {
          $Kernel.$raise($$$('TypeError'), "wrong argument type " + ((ret).$class()) + " (must be numeric, true, false or nil)")
        }

        if (smaller) { max = mid; } else { min = mid + 1; }
      }

      return satisfied;
    ;
    });
    
    $def(self, '$bsearch', function $$bsearch() {
      var block = $$bsearch.$$p || nil, self = this, index = nil;

      $$bsearch.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("bsearch")
      };
      index = $send(self, 'bsearch_index', [], block.$to_proc());
      
      if (index != null && index.$$is_number) {
        return self[index];
      } else {
        return index;
      }
    ;
    });
    
    $def(self, '$cycle', function $$cycle(n) {
      var block = $$cycle.$$p || nil, self = this;

      $$cycle.$$p = null;
      
      ;
      if (n == null) n = nil;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["cycle", n], function $$13(){var self = $$13.$$s == null ? this : $$13.$$s;

          if ($truthy(n['$nil?']())) {
            return $$$($$$('Float'), 'INFINITY')
          } else {
            
            n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
            if ($truthy($rb_gt(n, 0))) {
              return $rb_times(self.$enumerator_size(), n)
            } else {
              return 0
            };
          }}, {$$s: self})
      };
      if (($truthy(self['$empty?']()) || ($eqeq(n, 0)))) {
        return nil
      };
      
      var i, length, value;

      if (n === nil) {
        while (true) {
          for (i = 0, length = self.length; i < length; i++) {
            value = $yield1(block, self[i]);
          }
        }
      }
      else {
        n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
        if (n <= 0) {
          return self;
        }

        while (n > 0) {
          for (i = 0, length = self.length; i < length; i++) {
            value = $yield1(block, self[i]);
          }

          n--;
        }
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$clear', function $$clear() {
      var self = this;

      
      $deny_frozen_access(self);
      self.splice(0, self.length);
      return self;
    });
    
    $def(self, '$count', function $$count(object) {
      var block = $$count.$$p || nil, self = this;

      $$count.$$p = null;
      
      ;
      ;
      if (($truthy(object !== undefined) || ($truthy(block)))) {
        return $send2(self, $find_super(self, 'count', $$count, false, true), 'count', [object], block)
      } else {
        return self.$size()
      };
    }, -1);
    
    $def(self, '$initialize_copy', function $$initialize_copy(other) {
      var self = this;

      return self.$replace(other)
    });
    
    $def(self, '$collect', function $$collect() {
      var block = $$collect.$$p || nil, self = this;

      $$collect.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["collect"], function $$14(){var self = $$14.$$s == null ? this : $$14.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var result = [];

      for (var i = 0; i < self.length; i++) {
        var value = $yield1(block, self[i]);
        result[i] = value;
      }

      return result;
    ;
    });
    
    $def(self, '$collect!', function $Array_collect$excl$15() {
      var block = $Array_collect$excl$15.$$p || nil, self = this;

      $Array_collect$excl$15.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["collect!"], function $$16(){var self = $$16.$$s == null ? this : $$16.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      for (var i = 0; i < self.length; i++) {
        var value = $yield1(block, self[i]);
        self[i] = value;
      }
    ;
      return self;
    });
    
    function binomial_coefficient(n, k) {
      if (n === k || k === 0) {
        return 1;
      }

      if (k > 0 && n > k) {
        return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k);
      }

      return 0;
    }
  ;
    
    $def(self, '$combination', function $$combination(n) {
      var $yield = $$combination.$$p || nil, self = this, num = nil;

      $$combination.$$p = null;
      
      num = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["combination", num], function $$17(){var self = $$17.$$s == null ? this : $$17.$$s;

          return binomial_coefficient(self.length, num)}, {$$s: self})
      };
      
      var i, length, stack, chosen, lev, done, next;

      if (num === 0) {
        Opal.yield1($yield, [])
      } else if (num === 1) {
        for (i = 0, length = self.length; i < length; i++) {
          Opal.yield1($yield, [self[i]])
        }
      }
      else if (num === self.length) {
        Opal.yield1($yield, self.slice())
      }
      else if (num >= 0 && num < self.length) {
        stack = [];
        for (i = 0; i <= num + 1; i++) {
          stack.push(0);
        }

        chosen = [];
        lev = 0;
        done = false;
        stack[0] = -1;

        while (!done) {
          chosen[lev] = self[stack[lev+1]];
          while (lev < num - 1) {
            lev++;
            next = stack[lev+1] = stack[lev] + 1;
            chosen[lev] = self[next];
          }
          Opal.yield1($yield, chosen.slice())
          lev++;
          do {
            done = (lev === 0);
            stack[lev]++;
            lev--;
          } while ( stack[lev+1] + num === self.length + lev + 1 );
        }
      }
    ;
      return self;
    });
    
    $def(self, '$repeated_combination', function $$repeated_combination(n) {
      var $yield = $$repeated_combination.$$p || nil, self = this, num = nil;

      $$repeated_combination.$$p = null;
      
      num = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["repeated_combination", num], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s;

          return binomial_coefficient(self.length + num - 1, num);}, {$$s: self})
      };
      
      function iterate(max, from, buffer, self) {
        if (buffer.length == max) {
          var copy = buffer.slice();
          Opal.yield1($yield, copy)
          return;
        }
        for (var i = from; i < self.length; i++) {
          buffer.push(self[i]);
          iterate(max, i, buffer, self);
          buffer.pop();
        }
      }

      if (num >= 0) {
        iterate(num, 0, [], self);
      }
    ;
      return self;
    });
    
    $def(self, '$compact', function $$compact() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length, item; i < length; i++) {
        if ((item = self[i]) !== nil) {
          result.push(item);
        }
      }

      return result;
    
    });
    
    $def(self, '$compact!', function $Array_compact$excl$19() {
      var self = this;

      
      $deny_frozen_access(self);

      var original = self.length;

      for (var i = 0, length = self.length; i < length; i++) {
        if (self[i] === nil) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }

      return self.length === original ? nil : self;
    
    });
    
    $def(self, '$concat', function $$concat($a) {
      var $post_args, others, self = this;

      
      $post_args = $slice(arguments);
      others = $post_args;
      $deny_frozen_access(self);
      others = $send(others, 'map', [], function $$20(other){var self = $$20.$$s == null ? this : $$20.$$s;

        
        if (other == null) other = nil;
        other = convertToArray(other);
        if ($truthy(other['$equal?'](self))) {
          other = other.$dup()
        };
        return other;}, {$$s: self});
      $send(others, 'each', [], function $$21(other){var self = $$21.$$s == null ? this : $$21.$$s;

        
        if (other == null) other = nil;
        
        for (var i = 0, length = other.length; i < length; i++) {
          self.push(other[i]);
        }
      ;}, {$$s: self});
      return self;
    }, -1);
    
    $def(self, '$delete', function $Array_delete$22(object) {
      var $yield = $Array_delete$22.$$p || nil, self = this;

      $Array_delete$22.$$p = null;
      
      var original = self.length;

      for (var i = 0, length = original; i < length; i++) {
        if ((self[i])['$=='](object)) {
          $deny_frozen_access(self);

          self.splice(i, 1);

          length--;
          i--;
        }
      }

      if (self.length === original) {
        if (($yield !== nil)) {
          return Opal.yieldX($yield, []);
        }
        return nil;
      }
      return object;
    
    });
    
    $def(self, '$delete_at', function $$delete_at(index) {
      var self = this;

      
      $deny_frozen_access(self);

      index = $coerce_to(index, $$$('Integer'), 'to_int');

      if (index < 0) {
        index += self.length;
      }

      if (index < 0 || index >= self.length) {
        return nil;
      }

      var result = self[index];

      self.splice(index, 1);

      return result;
    
    });
    
    $def(self, '$delete_if', function $$delete_if() {
      var block = $$delete_if.$$p || nil, self = this;

      $$delete_if.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["delete_if"], function $$23(){var self = $$23.$$s == null ? this : $$23.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      filterIf(self, $falsy, block)
    ;
      return self;
    });
    
    $def(self, '$difference', function $$difference($a) {
      var $post_args, arrays, self = this;

      
      $post_args = $slice(arguments);
      arrays = $post_args;
      return $send(arrays, 'reduce', [self.$to_a().$dup()], function $$24(a, b){
        
        if (a == null) a = nil;
        if (b == null) b = nil;
        return $rb_minus(a, b);});
    }, -1);
    
    $def(self, '$dig', function $$dig(idx, $a) {
      var $post_args, idxs, self = this, item = nil;

      
      $post_args = $slice(arguments, 1);
      idxs = $post_args;
      item = self['$[]'](idx);
      
      if (item === nil || idxs.length === 0) {
        return item;
      }
    ;
      if (!$truthy(item['$respond_to?']("dig"))) {
        $Kernel.$raise($$$('TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', $to_a(idxs));
    }, -2);
    
    $def(self, '$drop', function $$drop(number) {
      var self = this;

      
      number = $coerce_to(number, $$$('Integer'), 'to_int');

      if (number < 0) {
        $Kernel.$raise($$$('ArgumentError'))
      }

      return self.slice(number);
    
    });
    
    $def(self, '$dup', function $$dup() {
      var $yield = $$dup.$$p || nil, self = this;

      $$dup.$$p = null;
      
      
      if (self.$$class === Opal.Array &&
          self.$$class.$allocate.$$pristine &&
          self.$copy_instance_variables.$$pristine &&
          self.$initialize_dup.$$pristine) {
        return self.slice(0);
      }
    ;
      return $send2(self, $find_super(self, 'dup', $$dup, false, true), 'dup', [], $yield);
    });
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, self = this;

      $$each.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each"], function $$25(){var self = $$25.$$s == null ? this : $$25.$$s;

          return self.$size()}, {$$s: self})
      };
      
      for (var i = 0; i < self.length; i++) {
        $yield1(block, self[i]);
      }
    ;
      return self;
    });
    
    $def(self, '$each_index', function $$each_index() {
      var block = $$each_index.$$p || nil, self = this;

      $$each_index.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_index"], function $$26(){var self = $$26.$$s == null ? this : $$26.$$s;

          return self.$size()}, {$$s: self})
      };
      
      for (var i = 0; i < self.length; i++) {
        $yield1(block, i);
      }
    ;
      return self;
    });
    
    $def(self, '$empty?', function $Array_empty$ques$27() {
      var self = this;

      return self.length === 0;
    });
    
    $def(self, '$eql?', function $Array_eql$ques$28(other) {
      var self = this;

      
      var recursed = {};

      function _eql(array, other) {
        var i, length, a, b;

        if (!other.$$is_array) {
          return false;
        }

        other = other.$to_a();

        if (array.length !== other.length) {
          return false;
        }

        recursed[(array).$object_id()] = true;

        for (i = 0, length = array.length; i < length; i++) {
          a = array[i];
          b = other[i];
          if (a.$$is_array) {
            if (b.$$is_array && b.length !== a.length) {
              return false;
            }
            if (!recursed.hasOwnProperty((a).$object_id())) {
              if (!_eql(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$eql?'](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eql(self, other);
    
    });
    
    $def(self, '$fetch', function $$fetch(index, defaults) {
      var block = $$fetch.$$p || nil, self = this;

      $$fetch.$$p = null;
      
      ;
      ;
      
      var original = index;

      index = $coerce_to(index, $$$('Integer'), 'to_int');

      if (index < 0) {
        index += self.length;
      }

      if (index >= 0 && index < self.length) {
        return self[index];
      }

      if (block !== nil && defaults != null) {
        self.$warn("warning: block supersedes default value argument")
      }

      if (block !== nil) {
        return block(original);
      }

      if (defaults != null) {
        return defaults;
      }

      if (self.length === 0) {
        $Kernel.$raise($$$('IndexError'), "index " + (original) + " outside of array bounds: 0...0")
      }
      else {
        $Kernel.$raise($$$('IndexError'), "index " + (original) + " outside of array bounds: -" + (self.length) + "..." + (self.length));
      }
    ;
    }, -2);
    
    $def(self, '$fill', function $$fill($a) {
      var block = $$fill.$$p || nil, $post_args, args, $b, $c, self = this, one = nil, two = nil, obj = nil, left = nil, right = nil;

      $$fill.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      
      $deny_frozen_access(self);

      var i, length, value;
    ;
      if ($truthy(block)) {
        
        if ($truthy(args.length > 2)) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (args.$length()) + " for 0..2)")
        };
        $c = args, $b = $to_ary($c), (one = ($b[0] == null ? nil : $b[0])), (two = ($b[1] == null ? nil : $b[1])), $c;
      } else {
        
        if ($truthy(args.length == 0)) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (0 for 1..3)")
        } else if ($truthy(args.length > 3)) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (args.$length()) + " for 1..3)")
        };
        $c = args, $b = $to_ary($c), (obj = ($b[0] == null ? nil : $b[0])), (one = ($b[1] == null ? nil : $b[1])), (two = ($b[2] == null ? nil : $b[2])), $c;
      };
      if ($eqeqeq($$$('Range'), one)) {
        
        if ($truthy(two)) {
          $Kernel.$raise($$$('TypeError'), "length invalid with range")
        };
        left = one.begin === nil ? 0 : $coerce_to(one.begin, $$$('Integer'), 'to_int');
        if ($truthy(left < 0)) {
          left += this.length
        };
        if ($truthy(left < 0)) {
          $Kernel.$raise($$$('RangeError'), "" + (one.$inspect()) + " out of range")
        };
        right = one.end === nil ? -1 : $coerce_to(one.end, $$$('Integer'), 'to_int');
        if ($truthy(right < 0)) {
          right += this.length
        };
        if (!$truthy(one['$exclude_end?']())) {
          right += 1
        };
        if ($truthy(right <= left)) {
          return self
        };
      } else if ($truthy(one)) {
        
        left = $coerce_to(one, $$$('Integer'), 'to_int');
        if ($truthy(left < 0)) {
          left += this.length
        };
        if ($truthy(left < 0)) {
          left = 0
        };
        if ($truthy(two)) {
          
          right = $coerce_to(two, $$$('Integer'), 'to_int');
          if ($truthy(right == 0)) {
            return self
          };
          right += left;
        } else {
          right = this.length
        };
      } else {
        
        left = 0;
        right = this.length;
      };
      if ($truthy(left > this.length)) {
        
        for (i = this.length; i < right; i++) {
          self[i] = nil;
        }
      
      };
      if ($truthy(right > this.length)) {
        this.length = right
      };
      if ($truthy(block)) {
        
        for (length = this.length; left < right; left++) {
          value = block(left);
          self[left] = value;
        }
      
      } else {
        
        for (length = this.length; left < right; left++) {
          self[left] = obj;
        }
      
      };
      return self;
    }, -1);
    
    $def(self, '$first', function $$first(count) {
      var self = this;

      
      ;
      
      if (count == null) {
        return self.length === 0 ? nil : self[0];
      }

      count = $coerce_to(count, $$$('Integer'), 'to_int');

      if (count < 0) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size");
      }

      return self.slice(0, count);
    ;
    }, -1);
    
    $def(self, '$flatten', function $$flatten(level) {
      var self = this;

      
      ;
      
      function _flatten(array, level) {
        var result = [],
            i, length,
            item, ary;

        array = (array).$to_a();

        for (i = 0, length = array.length; i < length; i++) {
          item = array[i];

          if (!$respond_to(item, '$to_ary', true)) {
            result.push(item);
            continue;
          }

          ary = (item).$to_ary();

          if (ary === nil) {
            result.push(item);
            continue;
          }

          if (!ary.$$is_array) {
            $Kernel.$raise($$$('TypeError'));
          }

          if (ary === self) {
            $Kernel.$raise($$$('ArgumentError'));
          }

          switch (level) {
          case undefined:
            result = result.concat(_flatten(ary));
            break;
          case 0:
            result.push(ary);
            break;
          default:
            fast_push(result, _flatten(ary, level - 1));
          }
        }
        return result;
      }

      if (level !== undefined) {
        level = $coerce_to(level, $$$('Integer'), 'to_int');
      }

      return _flatten(self, level);
    ;
    }, -1);
    
    $def(self, '$flatten!', function $Array_flatten$excl$29(level) {
      var self = this;

      
      ;
      
      $deny_frozen_access(self);

      var flattened = self.$flatten(level);

      if (self.length == flattened.length) {
        for (var i = 0, length = self.length; i < length; i++) {
          if (self[i] !== flattened[i]) {
            break;
          }
        }

        if (i == length) {
          return nil;
        }
      }

      self.$replace(flattened);
    ;
      return self;
    }, -1);
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if ($truthy(self['$frozen?']())) {
        return self
      };
      return $freeze(self);;
    });
    var $hash_ids;
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      
      var top = ($hash_ids === undefined),
          result = $opal32_init(),
          hash_id = self.$object_id(),
          item, i, key;

      result = $opal32_add(result, 0xA);
      result = $opal32_add(result, self.length);

      if (top) {
        $hash_ids = Object.create(null);
      }
      // return early for recursive structures
      else if ($hash_ids[hash_id]) {
        return $opal32_add(result, 0x01010101);
      }

      try {
        for (key in $hash_ids) {
          item = $hash_ids[key];
          if (self['$eql?'](item)) {
            return $opal32_add(result, 0x01010101);
          }
        }

        $hash_ids[hash_id] = self;

        for (i = 0; i < self.length; i++) {
          item = self[i];
          result = $opal32_add(result, item.$hash());
        }

        return result;
      } finally {
        if (top) {
          $hash_ids = undefined;
        }
      }
    
    });
    
    $def(self, '$include?', function $Array_include$ques$30(member) {
      var self = this;

      
      for (var i = 0, length = self.length; i < length; i++) {
        if ((self[i])['$=='](member)) {
          return true;
        }
      }

      return false;
    
    });
    
    $def(self, '$index', function $$index(object) {
      var block = $$index.$$p || nil, self = this;

      $$index.$$p = null;
      
      ;
      ;
      
      var i, length, value;

      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }

      if (object != null) {
        for (i = 0, length = self.length; i < length; i++) {
          if ((self[i])['$=='](object)) {
            return i;
          }
        }
      }
      else if (block !== nil) {
        for (i = 0; i < self.length; i++) {
          value = block(self[i]);

          if (value !== false && value !== nil) {
            return i;
          }
        }
      }
      else {
        return self.$enum_for("index");
      }

      return nil;
    ;
    }, -1);
    
    $def(self, '$insert', function $$insert(index, $a) {
      var $post_args, objects, self = this;

      
      $post_args = $slice(arguments, 1);
      objects = $post_args;
      
      $deny_frozen_access(self);

      index = $coerce_to(index, $$$('Integer'), 'to_int');

      if (objects.length > 0) {
        if (index < 0) {
          index += self.length + 1;

          if (index < 0) {
            $Kernel.$raise($$$('IndexError'), "" + (index) + " is out of bounds");
          }
        }
        if (index > self.length) {
          for (var i = self.length; i < index; i++) {
            self.push(nil);
          }
        }

        self.splice.apply(self, [index, 0].concat(objects));
      }
    ;
      return self;
    }, -2);
    var inspect_stack = [];
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      
      var result = [],
      id = self.$__id__(),
      pushed = true;
    ;
      
      return (function() { try {
      
      
        if (inspect_stack.indexOf(id) !== -1) {
          pushed = false;
          return '[...]';
        }
        inspect_stack.push(id)

        for (var i = 0, length = self.length; i < length; i++) {
          var item = self['$[]'](i);

          result.push($$('Opal').$inspect(item));
        }

        return '[' + result.join(', ') + ']';
      ;
      return nil;
      } finally {
        if (pushed) inspect_stack.pop()
      }; })();;
    });
    
    $def(self, '$intersection', function $$intersection($a) {
      var $post_args, arrays, self = this, largest = nil, intersection_of_args = nil;

      
      $post_args = $slice(arguments);
      arrays = $post_args;
      
      if (arrays.length === 0) {
        return self.$to_a().$dup();
      }
      arrays = arrays.map(convertToArray);
      if (self.length === 0) {
        return [];
      }
    ;
      arrays = $send(arrays, 'sort_by', [], "length".$to_proc());
      if ($truthy(self.length < arrays[0].length)) {
        return $send(arrays, 'reduce', [self], "&".$to_proc())
      };
      largest = arrays.pop();
      intersection_of_args = $send(arrays, 'reduce', [largest], "&".$to_proc());
      return self['$&'](intersection_of_args);
    }, -1);
    
    $def(self, '$intersect?', function $Array_intersect$ques$31(other) {
      var self = this;

      
      var small, large, hash = (new Map()), i, length;
      if (self.length < other.length) {
        small = self;
        large = other;
      } else {
        small = other;
        large = self;
      }

      for (i = 0, length = small.length; i < length; i++) {
        $hash_put(hash, small[i], true);
      }

      for (i = 0, length = large.length; i < length; i++) {
        if ($hash_get(hash, large[i])) {
          return true;
        }
      }
      return false;
    
    });
    
    $def(self, '$join', function $$join(sep) {
      var self = this;
      if ($gvars[","] == null) $gvars[","] = nil;

      
      if (sep == null) sep = nil;
      if ($truthy(self.length === 0)) {
        return ""
      };
      if ($truthy(sep === nil)) {
        sep = $gvars[","]
      };
      
      var result = [];
      var i, length, item, tmp;

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];

        if ($respond_to(item, '$to_str')) {
          tmp = (item).$to_str();

          if (tmp !== nil) {
            result.push((tmp).$to_s());

            continue;
          }
        }

        if ($respond_to(item, '$to_ary')) {
          tmp = (item).$to_ary();

          if (tmp === self) {
            $Kernel.$raise($$$('ArgumentError'));
          }

          if (tmp !== nil) {
            result.push((tmp).$join(sep));

            continue;
          }
        }

        if ($respond_to(item, '$to_s')) {
          tmp = (item).$to_s();

          if (tmp !== nil) {
            result.push(tmp);

            continue;
          }
        }

        $Kernel.$raise($$$('NoMethodError').$new("" + ($$('Opal').$inspect(self.$item())) + " doesn't respond to #to_str, #to_ary or #to_s", "to_str"));
      }

      if (sep === nil) {
        return result.join('');
      }
      else {
        return result.join($Opal['$coerce_to!'](sep, $$$('String'), "to_str").$to_s());
      }
    ;
    }, -1);
    
    $def(self, '$keep_if', function $$keep_if() {
      var block = $$keep_if.$$p || nil, self = this;

      $$keep_if.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["keep_if"], function $$32(){var self = $$32.$$s == null ? this : $$32.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      filterIf(self, $truthy, block)
    ;
      return self;
    });
    
    $def(self, '$last', function $$last(count) {
      var self = this;

      
      ;
      
      if (count == null) {
        return self.length === 0 ? nil : self[self.length - 1];
      }

      count = $coerce_to(count, $$$('Integer'), 'to_int');

      if (count < 0) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size");
      }

      if (count > self.length) {
        count = self.length;
      }

      return self.slice(self.length - count, self.length);
    ;
    }, -1);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.length;
    });
    
    $def(self, '$max', function $$max(n) {
      var block = $$max.$$p || nil, self = this;

      $$max.$$p = null;
      
      ;
      ;
      return $send(self.$each(), 'max', [n], block.$to_proc());
    }, -1);
    
    $def(self, '$min', function $$min() {
      var block = $$min.$$p || nil, self = this;

      $$min.$$p = null;
      
      ;
      return $send(self.$each(), 'min', [], block.$to_proc());
    });
    
    // Returns the product of from, from-1, ..., from - how_many + 1.
    function descending_factorial(from, how_many) {
      var count = how_many >= 0 ? 1 : 0;
      while (how_many) {
        count *= from;
        from--;
        how_many--;
      }
      return count;
    }
  ;
    
    $def(self, '$permutation', function $$permutation(num) {
      var block = $$permutation.$$p || nil, self = this, perm = nil, used = nil;

      $$permutation.$$p = null;
      
      ;
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["permutation", num], function $$33(){var self = $$33.$$s == null ? this : $$33.$$s;

          return descending_factorial(self.length, num === undefined ? self.length : num);}, {$$s: self})
      };
      
      var permute, offensive, output;

      if (num === undefined) {
        num = self.length;
      }
      else {
        num = $coerce_to(num, $$$('Integer'), 'to_int');
      }

      if (num < 0 || self.length < num) {
        // no permutations, yield nothing
      }
      else if (num === 0) {
        // exactly one permutation: the zero-length array
        Opal.yield1(block, [])
      }
      else if (num === 1) {
        // this is a special, easy case
        for (var i = 0; i < self.length; i++) {
          Opal.yield1(block, [self[i]])
        }
      }
      else {
        // this is the general case
        (perm = $$('Array').$new(num));
        (used = $$('Array').$new(self.length, false));

        permute = function(num, perm, index, used, blk) {
          self = this;
          for(var i = 0; i < self.length; i++){
            if(used['$[]'](i)['$!']()) {
              perm[index] = i;
              if(index < num - 1) {
                used[i] = true;
                permute.call(self, num, perm, index + 1, used, blk);
                used[i] = false;
              }
              else {
                output = [];
                for (var j = 0; j < perm.length; j++) {
                  output.push(self[perm[j]]);
                }
                $yield1(blk, output);
              }
            }
          }
        }

        if ((block !== nil)) {
          // offensive (both definitions) copy.
          offensive = self.slice();
          permute.call(offensive, num, perm, 0, used, block);
        }
        else {
          permute.call(self, num, perm, 0, used, block);
        }
      }
    ;
      return self;
    }, -1);
    
    $def(self, '$repeated_permutation', function $$repeated_permutation(n) {
      var $yield = $$repeated_permutation.$$p || nil, self = this, num = nil;

      $$repeated_permutation.$$p = null;
      
      num = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["repeated_permutation", num], function $$34(){var self = $$34.$$s == null ? this : $$34.$$s;

          if ($truthy($rb_ge(num, 0))) {
            return self.$size()['$**'](num)
          } else {
            return 0
          }}, {$$s: self})
      };
      
      function iterate(max, buffer, self) {
        if (buffer.length == max) {
          var copy = buffer.slice();
          Opal.yield1($yield, copy)
          return;
        }
        for (var i = 0; i < self.length; i++) {
          buffer.push(self[i]);
          iterate(max, buffer, self);
          buffer.pop();
        }
      }

      iterate(num, [], self.slice());
    ;
      return self;
    });
    
    $def(self, '$pop', function $$pop(count) {
      var self = this;

      
      ;
      $deny_frozen_access(self);
      if ($truthy(count === undefined)) {
        
        if ($truthy(self.length === 0)) {
          return nil
        };
        return self.pop();
      };
      count = $coerce_to(count, $$$('Integer'), 'to_int');
      if ($truthy(count < 0)) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size")
      };
      if ($truthy(self.length === 0)) {
        return []
      };
      if ($truthy(count === 1)) {
        return [self.pop()];
      } else if ($truthy(count > self.length)) {
        return self.splice(0, self.length);
      } else {
        return self.splice(self.length - count, self.length);
      };
    }, -1);
    
    $def(self, '$product', function $$product($a) {
      var block = $$product.$$p || nil, $post_args, args, self = this;

      $$product.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      
      var result = (block !== nil) ? null : [],
          n = args.length + 1,
          counters = new Array(n),
          lengths  = new Array(n),
          arrays   = new Array(n),
          i, m, subarray, len, resultlen = 1;

      arrays[0] = self;
      for (i = 1; i < n; i++) {
        arrays[i] = $coerce_to(args[i - 1], $$$('Array'), 'to_ary');
      }

      for (i = 0; i < n; i++) {
        len = arrays[i].length;
        if (len === 0) {
          return result || self;
        }
        resultlen *= len;
        if (resultlen > 2147483647) {
          $Kernel.$raise($$$('RangeError'), "too big to product")
        }
        lengths[i] = len;
        counters[i] = 0;
      }

      outer_loop: for (;;) {
        subarray = [];
        for (i = 0; i < n; i++) {
          subarray.push(arrays[i][counters[i]]);
        }
        if (result) {
          result.push(subarray);
        } else {
          Opal.yield1(block, subarray)
        }
        m = n - 1;
        counters[m]++;
        while (counters[m] === lengths[m]) {
          counters[m] = 0;
          if (--m < 0) break outer_loop;
          counters[m]++;
        }
      }

      return result || self;
    ;
    }, -1);
    
    $def(self, '$push', function $$push($a) {
      var $post_args, objects, self = this;

      
      $post_args = $slice(arguments);
      objects = $post_args;
      
      $deny_frozen_access(self);

      fast_push(self, objects);
    ;
      return self;
    }, -1);
    
    $def(self, '$rassoc', function $$rassoc(object) {
      var self = this;

      
      for (var i = 0, length = self.length, item; i < length; i++) {
        item = self[i];

        if (item.length && item[1] !== undefined) {
          if ((item[1])['$=='](object)) {
            return item;
          }
        }
      }

      return nil;
    
    });
    
    $def(self, '$reject', function $$reject() {
      var block = $$reject.$$p || nil, self = this;

      $$reject.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reject"], function $$35(){var self = $$35.$$s == null ? this : $$35.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var result = [];

      for (var i = 0, value; i < self.length; i++) {
        value = block(self[i]);

        if (value === false || value === nil) {
          result.push(self[i]);
        }
      }
      return result;
    ;
    });
    
    $def(self, '$reject!', function $Array_reject$excl$36() {
      var block = $Array_reject$excl$36.$$p || nil, self = this, original = nil;

      $Array_reject$excl$36.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reject!"], function $$37(){var self = $$37.$$s == null ? this : $$37.$$s;

          return self.$size()}, {$$s: self})
      };
      $deny_frozen_access(self);
      original = self.$length();
      $send(self, 'delete_if', [], block.$to_proc());
      if ($eqeq(self.$length(), original)) {
        return nil
      } else {
        return self
      };
    });
    
    $def(self, '$replace', function $$replace(other) {
      var self = this;

      
      $deny_frozen_access(self);
      other = convertToArray(other);
      
      if (self.length > 0) self.splice(0, self.length);
      fast_push(self, other);
    ;
      return self;
    });
    
    $def(self, '$reverse', function $$reverse() {
      var self = this;

      return self.slice(0).reverse();
    });
    
    $def(self, '$reverse!', function $Array_reverse$excl$38() {
      var self = this;

      
      $deny_frozen_access(self);
      return self.reverse();;
    });
    
    $def(self, '$reverse_each', function $$reverse_each() {
      var block = $$reverse_each.$$p || nil, self = this;

      $$reverse_each.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["reverse_each"], function $$39(){var self = $$39.$$s == null ? this : $$39.$$s;

          return self.$size()}, {$$s: self})
      };
      
      for (var i = self.length - 1; i >= 0; i--) {
        $yield1(block, self[i]);
      }
    ;
      return self;
    });
    
    $def(self, '$rindex', function $$rindex(object) {
      var block = $$rindex.$$p || nil, self = this;

      $$rindex.$$p = null;
      
      ;
      ;
      
      var i, value;

      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }

      if (object != null) {
        for (i = self.length - 1; i >= 0; i--) {
          if (i >= self.length) {
            break;
          }
          if ((self[i])['$=='](object)) {
            return i;
          }
        }
      }
      else if (block !== nil) {
        for (i = self.length - 1; i >= 0; i--) {
          if (i >= self.length) {
            break;
          }

          value = block(self[i]);

          if (value !== false && value !== nil) {
            return i;
          }
        }
      }
      else if (object == null) {
        return self.$enum_for("rindex");
      }

      return nil;
    ;
    }, -1);
    
    $def(self, '$rotate', function $$rotate(n) {
      var self = this;

      
      if (n == null) n = 1;
      
      var ary, idx, firstPart, lastPart;

      n = $coerce_to(n, $$$('Integer'), 'to_int')

      if (self.length === 1) {
        return self.slice();
      }
      if (self.length === 0) {
        return [];
      }

      ary = self.slice();
      idx = n % ary.length;

      firstPart = ary.slice(idx);
      lastPart = ary.slice(0, idx);
      return firstPart.concat(lastPart);
    ;
    }, -1);
    
    $def(self, '$rotate!', function $Array_rotate$excl$40(cnt) {
      var self = this, ary = nil;

      
      if (cnt == null) cnt = 1;
      
      $deny_frozen_access(self);

      if (self.length === 0 || self.length === 1) {
        return self;
      }
      cnt = $coerce_to(cnt, $$$('Integer'), 'to_int');
    ;
      ary = self.$rotate(cnt);
      return self.$replace(ary);
    }, -1);
    (function($base, $super) {
      var self = $klass($base, $super, 'SampleRandom');

      var $proto = self.$$prototype;

      $proto.rng = nil;
      
      
      $def(self, '$initialize', $assign_ivar("rng"));
      return $def(self, '$rand', function $$rand(size) {
        var self = this, random = nil;

        
        random = $coerce_to(self.rng.$rand(size), $$$('Integer'), 'to_int');
        if ($truthy(random < 0)) {
          $Kernel.$raise($$$('RangeError'), "random value must be >= 0")
        };
        if (!$truthy(random < size)) {
          $Kernel.$raise($$$('RangeError'), "random value must be less than Array size")
        };
        return random;
      });
    })(self, null);
    
    $def(self, '$sample', function $$sample(count, options) {
      var self = this, o = nil, rng = nil;

      
      ;
      ;
      if ($truthy(count === undefined)) {
        return self.$at($Kernel.$rand(self.length))
      };
      if ($truthy(options === undefined)) {
        if ($truthy((o = $Opal['$coerce_to?'](count, $$$('Hash'), "to_hash")))) {
          
          options = o;
          count = nil;
        } else {
          
          options = nil;
          count = $coerce_to(count, $$$('Integer'), 'to_int');
        }
      } else {
        
        count = $coerce_to(count, $$$('Integer'), 'to_int');
        options = $coerce_to(options, $$$('Hash'), 'to_hash');
      };
      if (($truthy(count) && ($truthy(count < 0)))) {
        $Kernel.$raise($$$('ArgumentError'), "count must be greater than 0")
      };
      if ($truthy(options)) {
        rng = options['$[]']("random")
      };
      rng = (($truthy(rng) && ($truthy(rng['$respond_to?']("rand")))) ? ($$('SampleRandom').$new(rng)) : ($Kernel));
      if (!$truthy(count)) {
        return self[rng.$rand(self.length)]
      };
      

      var abandon, spin, result, i, j, k, targetIndex, oldValue;

      if (count > self.length) {
        count = self.length;
      }

      switch (count) {
        case 0:
          return [];
          break;
        case 1:
          return [self[rng.$rand(self.length)]];
          break;
        case 2:
          i = rng.$rand(self.length);
          j = rng.$rand(self.length - 1);
          if (i <= j) {
            j++;
          }
          return [self[i], self[j]];
          break;
        default:
          if (self.length / count > 3) {
            abandon = false;
            spin = 0;

            result = $$('Array').$new(count);
            i = 1;

            result[0] = rng.$rand(self.length);
            while (i < count) {
              k = rng.$rand(self.length);
              j = 0;

              while (j < i) {
                while (k === result[j]) {
                  spin++;
                  if (spin > 100) {
                    abandon = true;
                    break;
                  }
                  k = rng.$rand(self.length);
                }
                if (abandon) { break; }

                j++;
              }

              if (abandon) { break; }

              result[i] = k;

              i++;
            }

            if (!abandon) {
              i = 0;
              while (i < count) {
                result[i] = self[result[i]];
                i++;
              }

              return result;
            }
          }

          result = self.slice();

          for (var c = 0; c < count; c++) {
            targetIndex = rng.$rand(self.length - c) + c;
            oldValue = result[c];
            result[c] = result[targetIndex];
            result[targetIndex] = oldValue;
          }

          return count === self.length ? result : (result)['$[]'](0, count);
      }
    ;
    }, -1);
    
    $def(self, '$select', function $$select() {
      var block = $$select.$$p || nil, self = this;

      $$select.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["select"], function $$41(){var self = $$41.$$s == null ? this : $$41.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var result = [];

      for (var i = 0, item, value; i < self.length; i++) {
        item = self[i];

        value = $yield1(block, item);

        if ($truthy(value)) {
          result.push(item);
        }
      }

      return result;
    ;
    });
    
    $def(self, '$select!', function $Array_select$excl$42() {
      var block = $Array_select$excl$42.$$p || nil, self = this;

      $Array_select$excl$42.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["select!"], function $$43(){var self = $$43.$$s == null ? this : $$43.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self)

      var original = self.length;
      $send(self, 'keep_if', [], block.$to_proc());
      return self.length === original ? nil : self;
    ;
    });
    
    $def(self, '$shift', function $$shift(count) {
      var self = this;

      
      ;
      $deny_frozen_access(self);
      if ($truthy(count === undefined)) {
        
        if ($truthy(self.length === 0)) {
          return nil
        };
        return shiftNoArg(self);
      };
      count = $coerce_to(count, $$$('Integer'), 'to_int');
      if ($truthy(count < 0)) {
        $Kernel.$raise($$$('ArgumentError'), "negative array size")
      };
      if ($truthy(self.length === 0)) {
        return []
      };
      return self.splice(0, count);;
    }, -1);
    
    $def(self, '$shuffle', function $$shuffle(rng) {
      var self = this;

      
      ;
      return self.$dup().$to_a()['$shuffle!'](rng);
    }, -1);
    
    $def(self, '$shuffle!', function $Array_shuffle$excl$44(rng) {
      var self = this;

      
      ;
      
      $deny_frozen_access(self);

      var randgen, i = self.length, j, tmp;

      if (rng !== undefined) {
        rng = $Opal['$coerce_to?'](rng, $$$('Hash'), "to_hash");

        if (rng !== nil) {
          rng = rng['$[]']("random");

          if (rng !== nil && rng['$respond_to?']("rand")) {
            randgen = rng;
          }
        }
      }

      while (i) {
        if (randgen) {
          j = randgen.$rand(i).$to_int();

          if (j < 0) {
            $Kernel.$raise($$$('RangeError'), "random number too small " + (j))
          }

          if (j >= i) {
            $Kernel.$raise($$$('RangeError'), "random number too big " + (j))
          }
        }
        else {
          j = self.$rand(i);
        }

        tmp = self[--i];
        self[i] = self[j];
        self[j] = tmp;
      }

      return self;
    ;
    }, -1);
    
    $def(self, '$slice!', function $Array_slice$excl$45(index, length) {
      var self = this, result = nil, range = nil, range_start = nil, range_end = nil, start = nil;

      
      ;
      $deny_frozen_access(self);
      result = nil;
      if ($truthy(length === undefined)) {
        if ($eqeqeq($$$('Range'), index)) {
          
          range = index;
          result = self['$[]'](range);
          range_start = range.begin === nil ? 0 : $coerce_to(range.begin, $$$('Integer'), 'to_int');
          range_end = range.end === nil ? -1 : $coerce_to(range.end, $$$('Integer'), 'to_int');
          
          if (range_start < 0) {
            range_start += self.length;
          }

          if (range_end < 0) {
            range_end += self.length;
          } else if (range_end >= self.length) {
            range_end = self.length - 1;
            if (range.excl) {
              range_end += 1;
            }
          }

          var range_length = range_end - range_start;
          if (range.excl && range.end !== nil) {
            range_end -= 1;
          } else {
            range_length += 1;
          }

          if (range_start < self.length && range_start >= 0 && range_end < self.length && range_end >= 0 && range_length > 0) {
            self.splice(range_start, range_length);
          }
        ;
        } else {
          
          start = $coerce_to(index, $$$('Integer'), 'to_int');
          
          if (start < 0) {
            start += self.length;
          }

          if (start < 0 || start >= self.length) {
            return nil;
          }

          result = self[start];

          if (start === 0) {
            self.shift();
          } else {
            self.splice(start, 1);
          }
        ;
        }
      } else {
        
        start = $coerce_to(index, $$$('Integer'), 'to_int');
        length = $coerce_to(length, $$$('Integer'), 'to_int');
        
        if (length < 0) {
          return nil;
        }

        var end = start + length;

        result = self['$[]'](start, length);

        if (start < 0) {
          start += self.length;
        }

        if (start + length > self.length) {
          length = self.length - start;
        }

        if (start < self.length && start >= 0) {
          self.splice(start, length);
        }
      ;
      };
      return result;
    }, -2);
    
    $def(self, '$sort', function $$sort() {
      var block = $$sort.$$p || nil, self = this;

      $$sort.$$p = null;
      
      ;
      if (!$truthy(self.length > 1)) {
        return self
      };
      
      if (block === nil) {
        block = function(a, b) {
          return (a)['$<=>'](b);
        };
      }

      return self.slice().sort(function(x, y) {
        var ret = block(x, y);

        if (ret === nil) {
          $Kernel.$raise($$$('ArgumentError'), "comparison of " + ((x).$inspect()) + " with " + ((y).$inspect()) + " failed");
        }

        return $rb_gt(ret, 0) ? 1 : ($rb_lt(ret, 0) ? -1 : 0);
      });
    ;
    });
    
    $def(self, '$sort!', function $Array_sort$excl$46() {
      var block = $Array_sort$excl$46.$$p || nil, self = this;

      $Array_sort$excl$46.$$p = null;
      
      ;
      
      $deny_frozen_access(self)

      var result;

      if ((block !== nil)) {
        result = $send((self.slice()), 'sort', [], block.$to_proc());
      }
      else {
        result = (self.slice()).$sort();
      }

      self.length = 0;
      for(var i = 0, length = result.length; i < length; i++) {
        self.push(result[i]);
      }

      return self;
    ;
    });
    
    $def(self, '$sort_by!', function $Array_sort_by$excl$47() {
      var block = $Array_sort_by$excl$47.$$p || nil, self = this;

      $Array_sort_by$excl$47.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["sort_by!"], function $$48(){var self = $$48.$$s == null ? this : $$48.$$s;

          return self.$size()}, {$$s: self})
      };
      $deny_frozen_access(self);
      return self.$replace($send(self, 'sort_by', [], block.$to_proc()));
    });
    
    $def(self, '$take', function $$take(count) {
      var self = this;

      
      if (count < 0) {
        $Kernel.$raise($$$('ArgumentError'));
      }

      return self.slice(0, count);
    
    });
    
    $def(self, '$take_while', function $$take_while() {
      var block = $$take_while.$$p || nil, self = this;

      $$take_while.$$p = null;
      
      ;
      
      var result = [];

      for (var i = 0, item, value; i < self.length; i++) {
        item = self[i];

        value = block(item);

        if (value === false || value === nil) {
          return result;
        }

        result.push(item);
      }

      return result;
    ;
    });
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      
      if (self.$$class === Opal.Array) {
        return self;
      }
      else {
        return Opal.Array.$new(self);
      }
    
    });
    
    $def(self, '$to_ary', $return_self);
    
    $def(self, '$to_h', function $$to_h() {
      var block = $$to_h.$$p || nil, self = this, array = nil;

      $$to_h.$$p = null;
      
      ;
      array = self;
      if ((block !== nil)) {
        array = $send(array, 'map', [], block.$to_proc())
      };
      
      var i, len = array.length, ary, key, val, hash = (new Map());

      for (i = 0; i < len; i++) {
        ary = $Opal['$coerce_to?'](array[i], $$$('Array'), "to_ary");
        if (!ary.$$is_array) {
          $Kernel.$raise($$$('TypeError'), "wrong element type " + ((array[i]).$class()) + " at " + (i) + " (expected array)")
        }
        if (ary.length !== 2) {
          $Kernel.$raise($$$('ArgumentError'), "element has wrong array length at " + (i) + " (expected 2, was " + ((ary).$length()) + ")")
        }
        key = ary[0];
        val = ary[1];
        $hash_put(hash, key, val);
      }

      return hash;
    ;
    });
    
    $def(self, '$transpose', function $$transpose() {
      var self = this, result = nil, max = nil;

      
      if ($truthy(self['$empty?']())) {
        return []
      };
      result = [];
      max = nil;
      $send(self, 'each', [], function $$49(row){var $ret_or_1 = nil;

        
        if (row == null) row = nil;
        row = convertToArray(row);
        max = ($truthy(($ret_or_1 = max)) ? ($ret_or_1) : (row.length));
        if ($neqeq(row.length, max)) {
          $Kernel.$raise($$$('IndexError'), "element size differs (" + (row.length) + " should be " + (max) + ")")
        };
        return $send((row.length), 'times', [], function $$50(i){var $a, entry = nil;

          
          if (i == null) i = nil;
          entry = ($truthy(($ret_or_1 = result['$[]'](i))) ? ($ret_or_1) : (($a = [i, []], $send(result, '[]=', $a), $a[$a.length - 1])));
          return entry['$<<'](row.$at(i));});});
      return result;
    });
    
    $def(self, '$union', function $$union($a) {
      var $post_args, arrays, self = this;

      
      $post_args = $slice(arguments);
      arrays = $post_args;
      return $send(arrays, 'reduce', [self.$uniq()], function $$51(a, b){
        
        if (a == null) a = nil;
        if (b == null) b = nil;
        return a['$|'](b);});
    }, -1);
    
    $def(self, '$uniq', function $$uniq() {
      var block = $$uniq.$$p || nil, self = this;

      $$uniq.$$p = null;
      
      ;
      
      var hash = (new Map()), i, length, item, key;

      if (block === nil) {
        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];
          if ($hash_get(hash, item) === undefined) {
            $hash_put(hash, item, item);
          }
        }
      }
      else {
        for (i = 0; i < self.length; i++) {
          item = self[i];
          key = $yield1(block, item);
          if ($hash_get(hash, key) === undefined) {
            $hash_put(hash, key, item);
          }
        }
      }

      return (hash).$values();
    ;
    });
    
    $def(self, '$uniq!', function $Array_uniq$excl$52() {
      var block = $Array_uniq$excl$52.$$p || nil, self = this;

      $Array_uniq$excl$52.$$p = null;
      
      ;
      
      $deny_frozen_access(self);

      var hash = (new Map()), i, item, key, delete_indexes = [];

      for (i = 0; i < self.length; i++) {
        item = self[i];
        key = (block === nil ? item : $yield1(block, item));

        if ($hash_get(hash, key) === undefined) {
          $hash_put(hash, key, item);
        } else {
          delete_indexes.push(i);
        }
      }

      for (i = delete_indexes.length - 1; i >= 0; i--) {
        self.splice(delete_indexes[i], 1);
      }

      return delete_indexes.length === 0 ? nil : self;
    ;
    });
    
    $def(self, '$unshift', function $$unshift($a) {
      var $post_args, objects, self = this;

      
      $post_args = $slice(arguments);
      objects = $post_args;
      
      $deny_frozen_access(self);

      var selfLength = self.length
      var objectsLength = objects.length
      if (objectsLength == 0) return self;
      var index = selfLength - objectsLength
      for (var i = 0; i < objectsLength; i++) {
        self.push(self[index + i])
      }
      var len = selfLength - 1
      while (len - objectsLength >= 0) {
        self[len] = self[len - objectsLength]
        len--
      }
      for (var j = 0; j < objectsLength; j++) {
        self[j] = objects[j]
      }
      return self;
    ;
    }, -1);
    
    $def(self, '$values_at', function $$values_at($a) {
      var $post_args, args, self = this, out = nil;

      
      $post_args = $slice(arguments);
      args = $post_args;
      out = [];
      $send(args, 'each', [], function $$53(elem){var self = $$53.$$s == null ? this : $$53.$$s, finish = nil, start = nil, i = nil;

        
        if (elem == null) elem = nil;
        if ($truthy(elem['$is_a?']($$$('Range')))) {
          
          finish = elem.$end() === nil ? -1 : $coerce_to(elem.$end(), $$$('Integer'), 'to_int');
          start = elem.$begin() === nil ? 0 : $coerce_to(elem.$begin(), $$$('Integer'), 'to_int');
          
          if (start < 0) {
            start = start + self.length;
            return nil;
          }
        ;
          
          if (finish < 0) {
            finish = finish + self.length;
          }
          if (elem['$exclude_end?']() && elem.$end() !== nil) {
            finish--;
          }
          if (finish < start) {
            return nil;
          }
        ;
          return $send(start, 'upto', [finish], function $$54(i){var self = $$54.$$s == null ? this : $$54.$$s;

            
            if (i == null) i = nil;
            return out['$<<'](self.$at(i));}, {$$s: self});
        } else {
          
          i = $coerce_to(elem, $$$('Integer'), 'to_int');
          return out['$<<'](self.$at(i));
        };}, {$$s: self});
      return out;
    }, -1);
    
    $def(self, '$zip', function $$zip($a) {
      var block = $$zip.$$p || nil, $post_args, others, self = this, $ret_or_1 = nil;

      $$zip.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      others = $post_args;
      
      var result = [], size = self.length, part, o, i, j, jj;

      for (j = 0, jj = others.length; j < jj; j++) {
        o = others[j];
        if (o.$$is_array) {
          continue;
        }
        if (o.$$is_range || o.$$is_enumerator) {
          others[j] = o.$take(size);
          continue;
        }
        others[j] = ($truthy(($ret_or_1 = $Opal['$coerce_to?'](o, $$$('Array'), "to_ary"))) ? ($ret_or_1) : ($Opal['$coerce_to!'](o, $$$('Enumerator'), "to_enum", "each"))).$to_a();
      }

      for (i = 0; i < size; i++) {
        part = [self[i]];

        for (j = 0, jj = others.length; j < jj; j++) {
          o = others[j][i];

          if (o == null) {
            o = nil;
          }

          part[j + 1] = o;
        }

        result[i] = part;
      }

      if (block !== nil) {
        for (i = 0; i < size; i++) {
          Opal.yield1(block, result[i]);
        }

        return nil;
      }

      return result;
    ;
    }, -1);
    $defs(self, '$inherited', function $$inherited(klass) {
      
      
      klass.$$prototype.$to_a = function() {
        return this.slice(0, this.length);
      }
    
    });
    
    $def(self, '$instance_variables', function $$instance_variables() {
      var $yield = $$instance_variables.$$p || nil, self = this;

      $$instance_variables.$$p = null;
      return $send($send2(self, $find_super(self, 'instance_variables', $$instance_variables, false, true), 'instance_variables', [], $yield), 'reject', [], function $$55(ivar){var $ret_or_1 = nil;

        
        if (ivar == null) ivar = nil;
        if ($truthy(($ret_or_1 = /^@\d+$/.test(ivar)))) {
          return $ret_or_1
        } else {
          return ivar['$==']("@length")
        };})
    });
    
    $def(self, '$pack', function $$pack($a) {
      var $post_args, args;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return $Kernel.$raise("To use Array#pack, you must first require 'corelib/array/pack'.");
    }, -1);
    $alias(self, "append", "push");
    $alias(self, "filter", "select");
    $alias(self, "filter!", "select!");
    $alias(self, "map", "collect");
    $alias(self, "map!", "collect!");
    $alias(self, "prepend", "unshift");
    $alias(self, "size", "length");
    $alias(self, "slice", "[]");
    $alias(self, "to_s", "inspect");
    $Opal.$pristine(self.$singleton_class(), "allocate");
    return $Opal.$pristine(self, "copy_instance_variables", "initialize_dup");
  })('::', Array, $nesting);
};

Opal.modules["corelib/hash"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $yield1 = Opal.yield1, $hash_clone = Opal.hash_clone, $hash_delete = Opal.hash_delete, $hash_each = Opal.hash_each, $hash_get = Opal.hash_get, $hash_put = Opal.hash_put, $deny_frozen_access = Opal.deny_frozen_access, $freeze = Opal.freeze, $opal32_init = Opal.opal32_init, $opal32_add = Opal.opal32_add, $klass = Opal.klass, $slice = Opal.slice, $Opal = Opal.Opal, $Kernel = Opal.Kernel, $defs = Opal.defs, $def = Opal.def, $send = Opal.send, $rb_ge = Opal.rb_ge, $rb_gt = Opal.rb_gt, $truthy = Opal.truthy, $to_a = Opal.to_a, $return_self = Opal.return_self, $not = Opal.not, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,coerce_to?,[],merge!,allocate,raise,inspect,coerce_to!,each,fetch,>=,>,==,lambda?,abs,arity,enum_for,size,respond_to?,class,dig,except!,dup,delete,new,map,to_proc,flatten,frozen?,eql?,default,default_proc,default_proc=,default=,to_h,proc,!,select,select!,has_key?,indexes,index,length,[]=,has_value?');
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Hash');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Enumerable'));
    self.$$prototype.$$is_hash = true;
    $defs(self, '$[]', function $Hash_$$$1($a) {
      var $post_args, argv, self = this;

      
      $post_args = $slice(arguments);
      argv = $post_args;
      
      var hash, argc = argv.length, arg, i;

      if (argc === 1) {
        hash = $Opal['$coerce_to?'](argv['$[]'](0), $$$('Hash'), "to_hash");
        if (hash !== nil) {
          return self.$allocate()['$merge!'](hash);
        }

        argv = $Opal['$coerce_to?'](argv['$[]'](0), $$$('Array'), "to_ary");
        if (argv === nil) {
          $Kernel.$raise($$$('ArgumentError'), "odd number of arguments for Hash");
        }

        argc = argv.length;
        hash = self.$allocate();

        for (i = 0; i < argc; i++) {
          arg = argv[i];
          if (!arg.$$is_array)
            $Kernel.$raise($$$('ArgumentError'), "invalid element " + ((arg).$inspect()) + " for Hash");
          if (arg.length === 1) {
            hash.$store(arg[0], nil);
          } else if (arg.length === 2) {
            hash.$store(arg[0], arg[1]);
          } else {
            $Kernel.$raise($$$('ArgumentError'), "invalid number of elements (" + (arg.length) + " for " + ((arg).$inspect()) + "), must be 1..2");
          }
        }

        return hash;
      }

      if (argc % 2 !== 0) {
        $Kernel.$raise($$$('ArgumentError'), "odd number of arguments for Hash")
      }

      hash = self.$allocate();

      for (i = 0; i < argc; i += 2) {
        hash.$store(argv[i], argv[i + 1]);
      }

      return hash;
    ;
    }, -1);
    $defs(self, '$allocate', function $$allocate() {
      var self = this;

      
      var hash = new self.$$constructor();

      hash.$$none = nil;
      hash.$$proc = nil;

      return hash;
    
    });
    $defs(self, '$try_convert', function $$try_convert(obj) {
      
      return $Opal['$coerce_to?'](obj, $$$('Hash'), "to_hash")
    });
    
    $def(self, '$initialize', function $$initialize(defaults) {
      var block = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      ;
      ;
      
      $deny_frozen_access(self);

      if (defaults !== undefined && block !== nil) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (1 for 0)")
      }
      self.$$none = (defaults === undefined ? nil : defaults);
      self.$$proc = block;

      return self;
    ;
    }, -1);
    
    $def(self, '$==', function $Hash_$eq_eq$2(other) {
      var self = this;

      
      if (self === other) {
        return true;
      }

      if (!other.$$is_hash) {
        return false;
      }

      if (self.size !== other.size) {
        return false;
      }

      return $hash_each(self, true, function(key, value) {
        var other_value = $hash_get(other, key);
        if (other_value === undefined || !value['$eql?'](other_value)) {
          return [true, false];
        }
        return [false, true];
      });
    
    });
    
    $def(self, '$>=', function $Hash_$gt_eq$3(other) {
      var self = this, result = nil;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      
      if (self.size < other.size) {
        return false;
      }
    ;
      result = true;
      $send(other, 'each', [], function $$4(other_key, other_val){var self = $$4.$$s == null ? this : $$4.$$s, val = nil;

        
        if (other_key == null) other_key = nil;
        if (other_val == null) other_val = nil;
        val = self.$fetch(other_key, null);
        
        if (val == null || val !== other_val) {
          result = false;
          return;
        }
      ;}, {$$s: self});
      return result;
    });
    
    $def(self, '$>', function $Hash_$gt$5(other) {
      var self = this;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      
      if (self.size <= other.size) {
        return false;
      }
    ;
      return $rb_ge(self, other);
    });
    
    $def(self, '$<', function $Hash_$lt$6(other) {
      var self = this;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      return $rb_gt(other, self);
    });
    
    $def(self, '$<=', function $Hash_$lt_eq$7(other) {
      var self = this;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      return $rb_ge(other, self);
    });
    
    $def(self, '$[]', function $Hash_$$$8(key) {
      var self = this;

      
      var value = $hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      return self.$default(key);
    
    });
    
    $def(self, '$[]=', function $Hash_$$$eq$9(key, value) {
      var self = this;

      
      $deny_frozen_access(self);

      $hash_put(self, key, value);
      return value;
    
    });
    
    $def(self, '$assoc', function $$assoc(object) {
      var self = this;

      
      return $hash_each(self, nil, function(key, value) {
        if ((key)['$=='](object)) {
          return [true, [key, value]];
        }
        return [false, nil];
      });
    
    });
    
    $def(self, '$clear', function $$clear() {
      var self = this;

      
      $deny_frozen_access(self);

      self.clear();
      if (self.$$keys)
        self.$$keys.clear();

      return self;
    
    });
    
    $def(self, '$clone', function $$clone() {
      var self = this;

      
      var hash = self.$class().$new();
      $hash_clone(self, hash);
      return self["$frozen?"]() ? hash.$freeze() : hash;
    
    });
    
    $def(self, '$compact', function $$compact() {
      var self = this;

      
      var hash = new Map();

      return $hash_each(self, hash, function(key, value) {
        if (value !== nil) {
          $hash_put(hash, key, value);
        }
        return [false, hash];
      });
    
    });
    
    $def(self, '$compact!', function $Hash_compact$excl$10() {
      var self = this;

      
      $deny_frozen_access(self);

      var result = nil;

      return $hash_each(self, result, function(key, value) {
        if (value === nil) {
          $hash_delete(self, key);
          result = self;
        }
        return [false, result];
      });
    
    });
    
    $def(self, '$compare_by_identity', function $$compare_by_identity() {
      var self = this;

      
      $deny_frozen_access(self);

      if (!self.$$by_identity) {
        self.$$by_identity = true;

        if (self.size !== 0)
          Opal.hash_rehash(self);
      }

      return self;
    
    });
    
    $def(self, '$compare_by_identity?', function $Hash_compare_by_identity$ques$11() {
      var self = this;

      return self.$$by_identity === true;
    });
    
    $def(self, '$default', function $Hash_default$12(key) {
      var self = this;

      
      ;
      
      if (key !== undefined && self.$$proc !== nil && self.$$proc !== undefined) {
        return self.$$proc.$call(self, key);
      }
      if (self.$$none === undefined) {
        return nil;
      }
      return self.$$none;
    ;
    }, -1);
    
    $def(self, '$default=', function $Hash_default$eq$13(object) {
      var self = this;

      
      $deny_frozen_access(self);

      self.$$proc = nil;
      self.$$none = object;

      return object;
    
    });
    
    $def(self, '$default_proc', function $$default_proc() {
      var self = this;

      
      if (self.$$proc !== undefined) {
        return self.$$proc;
      }
      return nil;
    
    });
    
    $def(self, '$default_proc=', function $Hash_default_proc$eq$14(default_proc) {
      var self = this;

      
      $deny_frozen_access(self);

      var proc = default_proc;

      if (proc !== nil) {
        proc = $Opal['$coerce_to!'](proc, $$$('Proc'), "to_proc");

        if ((proc)['$lambda?']() && (proc).$arity().$abs() !== 2) {
          $Kernel.$raise($$$('TypeError'), "default_proc takes two arguments");
        }
      }

      self.$$none = nil;
      self.$$proc = proc;

      return default_proc;
    
    });
    
    $def(self, '$delete', function $Hash_delete$15(key) {
      var block = $Hash_delete$15.$$p || nil, self = this;

      $Hash_delete$15.$$p = null;
      
      ;
      
      $deny_frozen_access(self);
      var value = $hash_delete(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return Opal.yield1(block, key);
      }

      return nil;
    ;
    });
    
    $def(self, '$delete_if', function $$delete_if() {
      var block = $$delete_if.$$p || nil, self = this;

      $$delete_if.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["delete_if"], function $$16(){var self = $$16.$$s == null ? this : $$16.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      return $hash_each(self, self, function(key, value) {
        var obj = block(key, value);

        if (obj !== false && obj !== nil) {
          $hash_delete(self, key);
        }
        return [false, self];
      });
    ;
    });
    
    $def(self, '$dig', function $$dig(key, $a) {
      var $post_args, keys, self = this, item = nil;

      
      $post_args = $slice(arguments, 1);
      keys = $post_args;
      item = self['$[]'](key);
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if (!$truthy(item['$respond_to?']("dig"))) {
        $Kernel.$raise($$$('TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', $to_a(keys));
    }, -2);
    
    $def(self, '$dup', function $$dup() {
      var self = this;

      return $hash_clone(self, self.$class().$new());
    });
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, self = this;

      $$each.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["each"], function $$17(){var self = $$17.$$s == null ? this : $$17.$$s;

          return self.$size()}, {$$s: self})
      };
      
      return $hash_each(self, self, function(key, value) {
        $yield1(block, [key, value]);
        return [false, self];
      });
    ;
    });
    
    $def(self, '$each_key', function $$each_key() {
      var block = $$each_key.$$p || nil, self = this;

      $$each_key.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["each_key"], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s;

          return self.$size()}, {$$s: self})
      };
      
      return $hash_each(self, self, function(key, value) {
        block(key);
        return [false, self];
      });
    ;
    });
    
    $def(self, '$each_value', function $$each_value() {
      var block = $$each_value.$$p || nil, self = this;

      $$each_value.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["each_value"], function $$19(){var self = $$19.$$s == null ? this : $$19.$$s;

          return self.$size()}, {$$s: self})
      };
      
      return $hash_each(self, self, function(key, value) {
        block(value);
        return [false, self];
      });
    ;
    });
    
    $def(self, '$empty?', function $Hash_empty$ques$20() {
      var self = this;

      return self.size === 0;
    });
    
    $def(self, '$except', function $$except($a) {
      var $post_args, keys, self = this;

      
      $post_args = $slice(arguments);
      keys = $post_args;
      return $send(self.$dup(), 'except!', $to_a(keys));
    }, -1);
    
    $def(self, '$except!', function $Hash_except$excl$21($a) {
      var $post_args, keys, self = this;

      
      $post_args = $slice(arguments);
      keys = $post_args;
      $send(keys, 'each', [], function $$22(key){var self = $$22.$$s == null ? this : $$22.$$s;

        
        if (key == null) key = nil;
        return self.$delete(key);}, {$$s: self});
      return self;
    }, -1);
    
    $def(self, '$fetch', function $$fetch(key, defaults) {
      var block = $$fetch.$$p || nil, self = this;

      $$fetch.$$p = null;
      
      ;
      ;
      
      var value = $hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return block(key);
      }

      if (defaults !== undefined) {
        return defaults;
      }
    ;
      return $Kernel.$raise($$$('KeyError').$new("key not found: " + (key.$inspect()), (new Map([["key", key], ["receiver", self]]))));
    }, -2);
    
    $def(self, '$fetch_values', function $$fetch_values($a) {
      var block = $$fetch_values.$$p || nil, $post_args, keys, self = this;

      $$fetch_values.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      keys = $post_args;
      return $send(keys, 'map', [], function $$23(key){var self = $$23.$$s == null ? this : $$23.$$s;

        
        if (key == null) key = nil;
        return $send(self, 'fetch', [key], block.$to_proc());}, {$$s: self});
    }, -1);
    
    $def(self, '$flatten', function $$flatten(level) {
      var self = this;

      
      if (level == null) level = 1;
      level = $Opal['$coerce_to!'](level, $$$('Integer'), "to_int");
      
      var result = [];

      return $hash_each(self, result, function(key, value) {
        result.push(key);

        if (value.$$is_array) {
          if (level === 1) {
            result.push(value);
            return [false, result];
          }

          result = result.concat((value).$flatten(level - 2));
          return [false, result];
        }

        result.push(value);
        return [false, result];
      });
    ;
    }, -1);
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if ($truthy(self['$frozen?']())) {
        return self
      };
      return $freeze(self);;
    });
    
    $def(self, '$has_key?', function $Hash_has_key$ques$24(key) {
      var self = this;

      return $hash_get(self, key) !== undefined;
    });
    
    $def(self, '$has_value?', function $Hash_has_value$ques$25(value) {
      var self = this;

      
      return $hash_each(self, false, function(key, val) {
        if ((val)['$=='](value)) {
          return [true, true];
        }
        return [false, false];
      });
    
    });
    var $hash_ids;
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      
      var top = ($hash_ids === undefined),
          hash_id = self.$object_id(),
          result = $opal32_init(),
          key, item, i,
          size = self.size, ary = new Int32Array(size);

      result = $opal32_add(result, 0x4);
      result = $opal32_add(result, size);

      if (top) {
        $hash_ids = Object.create(null);
      }
      else if ($hash_ids[hash_id]) {
        return $opal32_add(result, 0x01010101);
      }

      try {
        for (key in $hash_ids) {
          item = $hash_ids[key];
          if (self['$eql?'](item)) {
            return $opal32_add(result, 0x01010101);
          }
        }

        $hash_ids[hash_id] = self;
        i = 0

        $hash_each(self, false, function(key, value) {
          ary[i] = [0x70414952, key, value].$hash();
          i++;
          return [false, false];
        });

        ary = ary.sort();

        for (i = 0; i < ary.length; i++) {
          result = $opal32_add(result, ary[i]);
        }

        return result;
      } finally {
        if (top) {
          $hash_ids = undefined;
        }
      }
    
    });
    
    $def(self, '$index', function $$index(object) {
      var self = this;

      
      return $hash_each(self, nil, function(key, value) {
        if ((value)['$=='](object)) {
          return [true, key];
        }
        return [false, nil];
      });
    
    });
    
    $def(self, '$indexes', function $$indexes($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      
      var result = [];

      for (var i = 0, length = args.length, key, value; i < length; i++) {
        key = args[i];
        value = $hash_get(self, key);

        if (value === undefined) {
          result.push(self.$default());
          continue;
        }

        result.push(value);
      }

      return result;
    ;
    }, -1);
    var inspect_ids;
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      
      var top = (inspect_ids === undefined),
          hash_id = self.$object_id(),
          result = [];
    ;
      
      return (function() { try {
      
      
        if (top) {
          inspect_ids = {};
        }

        if (inspect_ids.hasOwnProperty(hash_id)) {
          return '{...}';
        }

        inspect_ids[hash_id] = true;

        $hash_each(self, false, function(key, value) {
          value = $$('Opal').$inspect(value)
          key = $$('Opal').$inspect(key)

          result.push(key + '=>' + value);
          return [false, false];
        })

        return '{' + result.join(', ') + '}';
      ;
      return nil;
      } finally {
        if (top) inspect_ids = undefined
      }; })();;
    });
    
    $def(self, '$invert', function $$invert() {
      var self = this;

      
      var hash = new Map();

      return $hash_each(self, hash, function(key, value) {
        $hash_put(hash, value, key);
        return [false, hash];
      });
    
    });
    
    $def(self, '$keep_if', function $$keep_if() {
      var block = $$keep_if.$$p || nil, self = this;

      $$keep_if.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["keep_if"], function $$26(){var self = $$26.$$s == null ? this : $$26.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      return $hash_each(self, self, function(key, value) {
        var obj = block(key, value);

        if (obj === false || obj === nil) {
          $hash_delete(self, key);
        }
        return [false, self];
      });
    ;
    });
    
    $def(self, '$keys', function $$keys() {
      var self = this;

      return Array.from(self.keys());
    });
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.size;
    });
    
    $def(self, '$merge', function $$merge($a) {
      var block = $$merge.$$p || nil, $post_args, others, self = this;

      $$merge.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      others = $post_args;
      return $send(self.$dup(), 'merge!', $to_a(others), block.$to_proc());
    }, -1);
    
    $def(self, '$merge!', function $Hash_merge$excl$27($a) {
      var block = $Hash_merge$excl$27.$$p || nil, $post_args, others, self = this;

      $Hash_merge$excl$27.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      others = $post_args;
      
      $deny_frozen_access(self);

      var i, j, other;
      for (i = 0; i < others.length; ++i) {
        other = $Opal['$coerce_to!'](others[i], $$$('Hash'), "to_hash");

        if (block === nil) {
          $hash_each(other, false, function(key, value) {
            $hash_put(self, key, value);
            return [false, false];
          });
        } else {
          $hash_each(other, false, function(key, value) {
            var val = $hash_get(self, key);

            if (val === undefined) {
              $hash_put(self, key, value);
              return [false, false];
            }

            $hash_put(self, key, block(key, val, value));
            return [false, false];
          });
        }
      }

      return self;
    ;
    }, -1);
    
    $def(self, '$rassoc', function $$rassoc(object) {
      var self = this;

      
      return $hash_each(self, nil, function(key, value) {
        if ((value)['$=='](object)) {
          return [true, [key, value]];
        }
        return [false, nil];
      });
    
    });
    
    $def(self, '$rehash', function $$rehash() {
      var self = this;

      
      $deny_frozen_access(self);
      return Opal.hash_rehash(self);
    
    });
    
    $def(self, '$reject', function $$reject() {
      var block = $$reject.$$p || nil, self = this;

      $$reject.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["reject"], function $$28(){var self = $$28.$$s == null ? this : $$28.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var hash = new Map();

      return $hash_each(self, hash, function(key, value) {
        var obj = block(key, value);

        if (obj === false || obj === nil) {
          $hash_put(hash, key, value);
        }
        return [false, hash]
      });
    ;
    });
    
    $def(self, '$reject!', function $Hash_reject$excl$29() {
      var block = $Hash_reject$excl$29.$$p || nil, self = this;

      $Hash_reject$excl$29.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["reject!"], function $$30(){var self = $$30.$$s == null ? this : $$30.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      var result = nil;

      return $hash_each(self, result, function(key, value) {
        var obj = block(key, value);

        if (obj !== false && obj !== nil) {
          $hash_delete(self, key);
          result = self;
        }
        return [false, result];
      });
    ;
    });
    
    $def(self, '$replace', function $$replace(other) {
      var self = this;

      
      $deny_frozen_access(self);;
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      
      self.$clear();

      $hash_each(other, false, function(key, value) {
        $hash_put(self, key, value);
        return [false, false];
      });
    ;
      if ($truthy(other.$default_proc())) {
        self['$default_proc='](other.$default_proc())
      } else {
        self['$default='](other.$default())
      };
      return self;
    });
    
    $def(self, '$select', function $$select() {
      var block = $$select.$$p || nil, self = this;

      $$select.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["select"], function $$31(){var self = $$31.$$s == null ? this : $$31.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var hash = new Map();

      return $hash_each(self, hash, function(key, value) {
        var obj = block(key, value);

        if (obj !== false && obj !== nil) {
          $hash_put(hash, key, value);
        }
        return [false, hash];
      });
    ;
    });
    
    $def(self, '$select!', function $Hash_select$excl$32() {
      var block = $Hash_select$excl$32.$$p || nil, self = this;

      $Hash_select$excl$32.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["select!"], function $$33(){var self = $$33.$$s == null ? this : $$33.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      var result = nil;

      return $hash_each(self, result, function(key, value) {
        var obj = block(key, value);

        if (obj === false || obj === nil) {
          $hash_delete(self, key);
          result = self;
        }
        return [false, result];
      });
    ;
    });
    
    $def(self, '$shift', function $$shift() {
      var self = this;

      
      $deny_frozen_access(self);

      return $hash_each(self, nil, function(key, value) {
        return [true, [key, $hash_delete(self, key)]];
      });
    
    });
    
    $def(self, '$slice', function $$slice($a) {
      var $post_args, keys, self = this;

      
      $post_args = $slice(arguments);
      keys = $post_args;
      
      var result = new Map();

      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i], value = $hash_get(self, key);

        if (value !== undefined) {
          $hash_put(result, key, value);
        }
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      
      var result = [];

      return $hash_each(self, result, function(key, value) {
        result.push([key, value]);
        return [false, result];
      });
    
    });
    
    $def(self, '$to_h', function $$to_h() {
      var block = $$to_h.$$p || nil, self = this;

      $$to_h.$$p = null;
      
      ;
      if ((block !== nil)) {
        return $send(self, 'map', [], block.$to_proc()).$to_h()
      };
      
      if (self.$$class === Opal.Hash) {
        return self;
      }

      var hash = new Map();

      $hash_clone(self, hash);

      return hash;
    ;
    });
    
    $def(self, '$to_hash', $return_self);
    
    $def(self, '$to_proc', function $$to_proc() {
      var self = this;

      return $send(self, 'proc', [], function $$34(key){var self = $$34.$$s == null ? this : $$34.$$s;

        
        ;
        
        if (key == null) {
          $Kernel.$raise($$$('ArgumentError'), "no key given")
        }
      ;
        return self['$[]'](key);}, {$$arity: -1, $$s: self})
    });
    
    $def(self, '$transform_keys', function $$transform_keys(keys_hash) {
      var block = $$transform_keys.$$p || nil, self = this;

      $$transform_keys.$$p = null;
      
      ;
      if (keys_hash == null) keys_hash = nil;
      if (($not(block) && ($not(keys_hash)))) {
        return $send(self, 'enum_for', ["transform_keys"], function $$35(){var self = $$35.$$s == null ? this : $$35.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var result = new Map();

      return $hash_each(self, result, function(key, value) {
        var new_key;
        if (keys_hash !== nil)
          new_key = $hash_get(keys_hash, key);
        if (new_key === undefined && block && block !== nil)
          new_key = block(key);
        if (new_key === undefined)
          new_key = key // key not modified
        $hash_put(result, new_key, value);
        return [false, result];
      });
    ;
    }, -1);
    
    $def(self, '$transform_keys!', function $Hash_transform_keys$excl$36(keys_hash) {
      var block = $Hash_transform_keys$excl$36.$$p || nil, self = this;

      $Hash_transform_keys$excl$36.$$p = null;
      
      ;
      if (keys_hash == null) keys_hash = nil;
      if (($not(block) && ($not(keys_hash)))) {
        return $send(self, 'enum_for', ["transform_keys!"], function $$37(){var self = $$37.$$s == null ? this : $$37.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      var modified_keys = new Map();

      return $hash_each(self, self, function(key, value) {
        var new_key;
        if (keys_hash !== nil)
          new_key = $hash_get(keys_hash, key);
        if (new_key === undefined && block && block !== nil)
          new_key = block(key);
        if (new_key === undefined)
          return [false, self]; // key not modified
        if (!$hash_get(modified_keys, key))
          $hash_delete(self, key);
        $hash_put(self, new_key, value);
        $hash_put(modified_keys, new_key, true)
        return [false, self];
      });
    ;
    }, -1);
    
    $def(self, '$transform_values', function $$transform_values() {
      var block = $$transform_values.$$p || nil, self = this;

      $$transform_values.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["transform_values"], function $$38(){var self = $$38.$$s == null ? this : $$38.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var result = new Map();

      return $hash_each(self, result, function(key, value) {
        $hash_put(result, key, block(value));
        return [false, result];
      });
    ;
    });
    
    $def(self, '$transform_values!', function $Hash_transform_values$excl$39() {
      var block = $Hash_transform_values$excl$39.$$p || nil, self = this;

      $Hash_transform_values$excl$39.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["transform_values!"], function $$40(){var self = $$40.$$s == null ? this : $$40.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      return $hash_each(self, self, function(key, value) {
        $hash_put(self, key, block(value));
        return [false, self];
      });
    ;
    });
    
    $def(self, '$values', function $$values() {
      var self = this;

      return Array.from(self.values());
    });
    $alias(self, "each_pair", "each");
    $alias(self, "eql?", "==");
    $alias(self, "filter", "select");
    $alias(self, "filter!", "select!");
    $alias(self, "include?", "has_key?");
    $alias(self, "indices", "indexes");
    $alias(self, "key", "index");
    $alias(self, "key?", "has_key?");
    $alias(self, "member?", "has_key?");
    $alias(self, "size", "length");
    $alias(self, "store", "[]=");
    $alias(self, "to_s", "inspect");
    $alias(self, "update", "merge!");
    $alias(self, "value?", "has_value?");
    return $alias(self, "values_at", "indexes");
  })('::', Map, $nesting);
};

Opal.modules["corelib/number"] = function(Opal) {/* Generated by Opal 1.8.2 */
  "use strict";
  var $klass = Opal.klass, $Opal = Opal.Opal, $Kernel = Opal.Kernel, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $truthy = Opal.truthy, $rb_gt = Opal.rb_gt, $not = Opal.not, $rb_lt = Opal.rb_lt, $alias = Opal.alias, $send2 = Opal.send2, $find_super = Opal.find_super, $send = Opal.send, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $eqeq = Opal.eqeq, $return_self = Opal.return_self, $rb_divide = Opal.rb_divide, $to_ary = Opal.to_ary, $rb_times = Opal.rb_times, $rb_le = Opal.rb_le, $rb_ge = Opal.rb_ge, $return_val = Opal.return_val, $const_set = Opal.const_set, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,bridge,raise,name,class,Float,respond_to?,coerce_to!,__id__,__coerced__,===,>,!,**,new,<,to_f,==,nan?,infinite?,enum_for,+,-,gcd,lcm,%,/,frexp,to_i,ldexp,rationalize,*,<<,to_r,truncate,-@,size,<=,>=,inspect,angle,to_s,is_a?,abs,next,coerce_to?');
  
  self.$require("corelib/numeric");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Number');

    var $nesting = [self].concat($parent_nesting);

    
    $Opal.$bridge(Number, self);
    Opal.prop(self.$$prototype, '$$is_number', true);
    self.$$is_number_class = true;
    var number_id_map = new Map();
    (function(self, $parent_nesting) {
      
      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + (self.$name()))
      });
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    $def(self, '$coerce', function $$coerce(other) {
      var self = this;

      
      if (other === nil) {
        $Kernel.$raise($$$('TypeError'), "can't convert " + (other.$class()) + " into Float");
      }
      else if (other.$$is_string) {
        return [$Kernel.$Float(other), self];
      }
      else if (other['$respond_to?']("to_f")) {
        return [$Opal['$coerce_to!'](other, $$$('Float'), "to_f"), self];
      }
      else if (other.$$is_number) {
        return [other, self];
      }
      else {
        $Kernel.$raise($$$('TypeError'), "can't convert " + (other.$class()) + " into Float");
      }
    
    });
    
    $def(self, '$__id__', function $$__id__() {
      var self = this;

      
      // Binary-safe integers
      if (self|0 === self) {
        return (self * 2) + 1;
      }
      else {
        if (number_id_map.has(self)) {
          return number_id_map.get(self);
        }
        var id = Opal.uid();
        number_id_map.set(self, id);
        return id;
      }
    
    });
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      
      // Binary-safe integers
      if (self|0 === self) {
        return self.$__id__()
      }
      else {
        return self.toString().$hash();
      }
    
    });
    
    $def(self, '$+', function $Number_$plus$1(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self + other;
      }
      else {
        return self.$__coerced__("+", other);
      }
    
    });
    
    $def(self, '$-', function $Number_$minus$2(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self - other;
      }
      else {
        return self.$__coerced__("-", other);
      }
    
    });
    
    $def(self, '$*', function $Number_$$3(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self * other;
      }
      else {
        return self.$__coerced__("*", other);
      }
    
    });
    
    $def(self, '$/', function $Number_$slash$4(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self / other;
      }
      else {
        return self.$__coerced__("/", other);
      }
    
    });
    
    $def(self, '$%', function $Number_$percent$5(other) {
      var self = this;

      
      if (other.$$is_number) {
        if (other == -Infinity) {
          return other;
        }
        else if (other == 0) {
          $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0");
        }
        else if (other < 0 || self < 0) {
          return (self % other + other) % other;
        }
        else {
          return self % other;
        }
      }
      else {
        return self.$__coerced__("%", other);
      }
    
    });
    
    $def(self, '$&', function $Number_$$6(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self & other;
      }
      else {
        return self.$__coerced__("&", other);
      }
    
    });
    
    $def(self, '$|', function $Number_$$7(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self | other;
      }
      else {
        return self.$__coerced__("|", other);
      }
    
    });
    
    $def(self, '$^', function $Number_$$8(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self ^ other;
      }
      else {
        return self.$__coerced__("^", other);
      }
    
    });
    
    $def(self, '$<', function $Number_$lt$9(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self < other;
      }
      else {
        return self.$__coerced__("<", other);
      }
    
    });
    
    $def(self, '$<=', function $Number_$lt_eq$10(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self <= other;
      }
      else {
        return self.$__coerced__("<=", other);
      }
    
    });
    
    $def(self, '$>', function $Number_$gt$11(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self > other;
      }
      else {
        return self.$__coerced__(">", other);
      }
    
    });
    
    $def(self, '$>=', function $Number_$gt_eq$12(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self >= other;
      }
      else {
        return self.$__coerced__(">=", other);
      }
    
    });
    
    var spaceship_operator = function(self, other) {
      if (other.$$is_number) {
        if (isNaN(self) || isNaN(other)) {
          return nil;
        }

        if (self > other) {
          return 1;
        } else if (self < other) {
          return -1;
        } else {
          return 0;
        }
      }
      else {
        return self.$__coerced__("<=>", other);
      }
    }
  ;
    
    $def(self, '$<=>', function $Number_$lt_eq_gt$13(other) {
      var self = this;

      try {
        return spaceship_operator(self, other);
      } catch ($err) {
        if (Opal.rescue($err, [$$$('ArgumentError')])) {
          try {
            return nil
          } finally { Opal.pop_exception($err); }
        } else { throw $err; }
      }
    });
    
    $def(self, '$<<', function $Number_$lt$lt$14(count) {
      var self = this;

      
      count = $Opal['$coerce_to!'](count, $$$('Integer'), "to_int");
      return count > 0 ? self << count : self >> -count;
    });
    
    $def(self, '$>>', function $Number_$gt$gt$15(count) {
      var self = this;

      
      count = $Opal['$coerce_to!'](count, $$$('Integer'), "to_int");
      return count > 0 ? self >> count : self << -count;
    });
    
    $def(self, '$[]', function $Number_$$$16(bit) {
      var self = this;

      
      bit = $Opal['$coerce_to!'](bit, $$$('Integer'), "to_int");
      
      if (bit < 0) {
        return 0;
      }
      if (bit >= 32) {
        return self < 0 ? 1 : 0;
      }
      return (self >> bit) & 1;
    ;
    });
    
    $def(self, '$+@', function $Number_$plus$$17() {
      var self = this;

      return +self;
    });
    
    $def(self, '$-@', function $Number_$minus$$18() {
      var self = this;

      return -self;
    });
    
    $def(self, '$~', function $Number_$$19() {
      var self = this;

      return ~self;
    });
    
    $def(self, '$**', function $Number_$$$20(other) {
      var self = this;

      if ($eqeqeq($$$('Integer'), other)) {
        if (($not($$$('Integer')['$==='](self)) || ($truthy($rb_gt(other, 0))))) {
          return Math.pow(self, other);
        } else {
          return $$$('Rational').$new(self, 1)['$**'](other)
        }
      } else if (($truthy($rb_lt(self, 0)) && (($eqeqeq($$$('Float'), other) || ($eqeqeq($$$('Rational'), other)))))) {
        return $$$('Complex').$new(self, 0)['$**'](other.$to_f())
      } else if ($truthy(other.$$is_number != null)) {
        return Math.pow(self, other);
      } else {
        return self.$__coerced__("**", other)
      }
    });
    
    $def(self, '$==', function $Number_$eq_eq$21(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self.valueOf() === other.valueOf();
      }
      else if (other['$respond_to?']("==")) {
        return other['$=='](self);
      }
      else {
        return false;
      }
    
    });
    $alias(self, "===", "==");
    
    $def(self, '$abs', function $$abs() {
      var self = this;

      return Math.abs(self);
    });
    
    $def(self, '$abs2', function $$abs2() {
      var self = this;

      return Math.abs(self * self);
    });
    
    $def(self, '$allbits?', function $Number_allbits$ques$22(mask) {
      var self = this;

      
      mask = $Opal['$coerce_to!'](mask, $$$('Integer'), "to_int");
      return (self & mask) == mask;;
    });
    
    $def(self, '$anybits?', function $Number_anybits$ques$23(mask) {
      var self = this;

      
      mask = $Opal['$coerce_to!'](mask, $$$('Integer'), "to_int");
      return (self & mask) !== 0;;
    });
    
    $def(self, '$angle', function $$angle() {
      var self = this;

      
      if ($truthy(self['$nan?']())) {
        return self
      };
      
      if (self == 0) {
        if (1 / self > 0) {
          return 0;
        }
        else {
          return Math.PI;
        }
      }
      else if (self < 0) {
        return Math.PI;
      }
      else {
        return 0;
      }
    ;
    });
    
    $def(self, '$bit_length', function $$bit_length() {
      var self = this;

      
      if (!$eqeqeq($$$('Integer'), self)) {
        $Kernel.$raise($$$('NoMethodError').$new("undefined method `bit_length` for " + (self) + ":Float", "bit_length"))
      };
      
      if (self === 0 || self === -1) {
        return 0;
      }

      var result = 0,
          value  = self < 0 ? ~self : self;

      while (value != 0) {
        result   += 1;
        value  >>>= 1;
      }

      return result;
    ;
    });
    
    $def(self, '$ceil', function $$ceil(ndigits) {
      var self = this;

      
      if (ndigits == null) ndigits = 0;
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = Math.ceil(f * factor) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$chr', function $$chr(encoding) {
      var self = this;

      
      ;
      return Opal.enc(String.fromCharCode(self), encoding || "BINARY");;
    }, -1);
    
    $def(self, '$denominator', function $$denominator() {
      var $yield = $$denominator.$$p || nil, self = this;

      $$denominator.$$p = null;
      if (($truthy(self['$nan?']()) || ($truthy(self['$infinite?']())))) {
        return 1
      } else {
        return $send2(self, $find_super(self, 'denominator', $$denominator, false, true), 'denominator', [], $yield)
      }
    });
    
    $def(self, '$downto', function $$downto(stop) {
      var block = $$downto.$$p || nil, self = this;

      $$downto.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["downto", stop], function $$24(){var self = $$24.$$s == null ? this : $$24.$$s;

          
          if (!$eqeqeq($$$('Numeric'), stop)) {
            $Kernel.$raise($$$('ArgumentError'), "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
          };
          if ($truthy($rb_gt(stop, self))) {
            return 0
          } else {
            return $rb_plus($rb_minus(self, stop), 1)
          };}, {$$s: self})
      };
      
      if (!stop.$$is_number) {
        $Kernel.$raise($$$('ArgumentError'), "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
      }
      for (var i = self; i >= stop; i--) {
        block(i);
      }
    ;
      return self;
    });
    
    $def(self, '$equal?', function $Number_equal$ques$25(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self['$=='](other)))) {
        return $ret_or_1
      } else {
        return isNaN(self) && isNaN(other);
      }
    });
    
    $def(self, '$even?', function $Number_even$ques$26() {
      var self = this;

      return self % 2 === 0;
    });
    
    $def(self, '$floor', function $$floor(ndigits) {
      var self = this;

      
      if (ndigits == null) ndigits = 0;
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = Math.floor(f * factor) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$gcd', function $$gcd(other) {
      var self = this;

      
      if (!$eqeqeq($$$('Integer'), other)) {
        $Kernel.$raise($$$('TypeError'), "not an integer")
      };
      
      var min = Math.abs(self),
          max = Math.abs(other);

      while (min > 0) {
        var tmp = min;

        min = max % min;
        max = tmp;
      }

      return max;
    ;
    });
    
    $def(self, '$gcdlcm', function $$gcdlcm(other) {
      var self = this;

      return [self.$gcd(other), self.$lcm(other)]
    });
    
    $def(self, '$integer?', function $Number_integer$ques$27() {
      var self = this;

      return self % 1 === 0;
    });
    
    $def(self, '$is_a?', function $Number_is_a$ques$28(klass) {
      var $yield = $Number_is_a$ques$28.$$p || nil, self = this;

      $Number_is_a$ques$28.$$p = null;
      
      if (($eqeq(klass, $$$('Integer')) && ($eqeqeq($$$('Integer'), self)))) {
        return true
      };
      if (($eqeq(klass, $$$('Integer')) && ($eqeqeq($$$('Integer'), self)))) {
        return true
      };
      if (($eqeq(klass, $$$('Float')) && ($eqeqeq($$$('Float'), self)))) {
        return true
      };
      return $send2(self, $find_super(self, 'is_a?', $Number_is_a$ques$28, false, true), 'is_a?', [klass], $yield);
    });
    
    $def(self, '$instance_of?', function $Number_instance_of$ques$29(klass) {
      var $yield = $Number_instance_of$ques$29.$$p || nil, self = this;

      $Number_instance_of$ques$29.$$p = null;
      
      if (($eqeq(klass, $$$('Integer')) && ($eqeqeq($$$('Integer'), self)))) {
        return true
      };
      if (($eqeq(klass, $$$('Integer')) && ($eqeqeq($$$('Integer'), self)))) {
        return true
      };
      if (($eqeq(klass, $$$('Float')) && ($eqeqeq($$$('Float'), self)))) {
        return true
      };
      return $send2(self, $find_super(self, 'instance_of?', $Number_instance_of$ques$29, false, true), 'instance_of?', [klass], $yield);
    });
    
    $def(self, '$lcm', function $$lcm(other) {
      var self = this;

      
      if (!$eqeqeq($$$('Integer'), other)) {
        $Kernel.$raise($$$('TypeError'), "not an integer")
      };
      
      if (self == 0 || other == 0) {
        return 0;
      }
      else {
        return Math.abs(self * other / self.$gcd(other));
      }
    ;
    });
    
    $def(self, '$next', function $$next() {
      var self = this;

      return self + 1;
    });
    
    $def(self, '$nobits?', function $Number_nobits$ques$30(mask) {
      var self = this;

      
      mask = $Opal['$coerce_to!'](mask, $$$('Integer'), "to_int");
      return (self & mask) == 0;;
    });
    
    $def(self, '$nonzero?', function $Number_nonzero$ques$31() {
      var self = this;

      return self == 0 ? nil : self;
    });
    
    $def(self, '$numerator', function $$numerator() {
      var $yield = $$numerator.$$p || nil, self = this;

      $$numerator.$$p = null;
      if (($truthy(self['$nan?']()) || ($truthy(self['$infinite?']())))) {
        return self
      } else {
        return $send2(self, $find_super(self, 'numerator', $$numerator, false, true), 'numerator', [], $yield)
      }
    });
    
    $def(self, '$odd?', function $Number_odd$ques$32() {
      var self = this;

      return self % 2 !== 0;
    });
    
    $def(self, '$ord', $return_self);
    
    $def(self, '$pow', function $$pow(b, m) {
      var self = this;

      
      ;
      
      if (self == 0) {
        $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0")
      }

      if (m === undefined) {
        return self['$**'](b);
      } else {
        if (!($$$('Integer')['$==='](b))) {
          $Kernel.$raise($$$('TypeError'), "Integer#pow() 2nd argument not allowed unless a 1st argument is integer")
        }

        if (b < 0) {
          $Kernel.$raise($$$('TypeError'), "Integer#pow() 1st argument cannot be negative when 2nd argument specified")
        }

        if (!($$$('Integer')['$==='](m))) {
          $Kernel.$raise($$$('TypeError'), "Integer#pow() 2nd argument not allowed unless all arguments are integers")
        }

        if (m === 0) {
          $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0")
        }

        return self['$**'](b)['$%'](m)
      }
    ;
    }, -2);
    
    $def(self, '$pred', function $$pred() {
      var self = this;

      return self - 1;
    });
    
    $def(self, '$quo', function $$quo(other) {
      var $yield = $$quo.$$p || nil, self = this;

      $$quo.$$p = null;
      if ($eqeqeq($$$('Integer'), self)) {
        return $send2(self, $find_super(self, 'quo', $$quo, false, true), 'quo', [other], $yield)
      } else {
        return $rb_divide(self, other)
      }
    });
    
    $def(self, '$rationalize', function $$rationalize(eps) {
      var $a, $b, self = this, f = nil, n = nil;

      
      ;
      
      if (arguments.length > 1) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }
    ;
      if ($eqeqeq($$$('Integer'), self)) {
        return $$$('Rational').$new(self, 1)
      } else if ($truthy(self['$infinite?']())) {
        return $Kernel.$raise($$$('FloatDomainError'), "Infinity")
      } else if ($truthy(self['$nan?']())) {
        return $Kernel.$raise($$$('FloatDomainError'), "NaN")
      } else if ($truthy(eps == null)) {
        
        $b = $$$('Math').$frexp(self), $a = $to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (n = ($a[1] == null ? nil : $a[1])), $b;
        f = $$$('Math').$ldexp(f, $$$($$$('Float'), 'MANT_DIG')).$to_i();
        n = $rb_minus(n, $$$($$$('Float'), 'MANT_DIG'));
        return $$$('Rational').$new($rb_times(2, f), (1)['$<<']($rb_minus(1, n))).$rationalize($$$('Rational').$new(1, (1)['$<<']($rb_minus(1, n))));
      } else {
        return self.$to_r().$rationalize(eps)
      };
    }, -1);
    
    $def(self, '$remainder', function $$remainder(y) {
      var self = this;

      return $rb_minus(self, $rb_times(y, $rb_divide(self, y).$truncate()))
    });
    
    $def(self, '$round', function $$round(ndigits) {
      var $a, $b, self = this, _ = nil, exp = nil;

      
      ;
      if ($eqeqeq($$$('Integer'), self)) {
        
        if ($truthy(ndigits == null)) {
          return self
        };
        if (($eqeqeq($$$('Float'), ndigits) && ($truthy(ndigits['$infinite?']())))) {
          $Kernel.$raise($$$('RangeError'), "Infinity")
        };
        ndigits = $Opal['$coerce_to!'](ndigits, $$$('Integer'), "to_int");
        if ($truthy($rb_lt(ndigits, $$$($$$('Integer'), 'MIN')))) {
          $Kernel.$raise($$$('RangeError'), "out of bounds")
        };
        if ($truthy(ndigits >= 0)) {
          return self
        };
        ndigits = ndigits['$-@']();
        
        if (0.415241 * ndigits - 0.125 > self.$size()) {
          return 0;
        }

        var f = Math.pow(10, ndigits),
            x = Math.floor((Math.abs(self) + f / 2) / f) * f;

        return self < 0 ? -x : x;
      ;
      } else {
        
        if (($truthy(self['$nan?']()) && ($truthy(ndigits == null)))) {
          $Kernel.$raise($$$('FloatDomainError'), "NaN")
        };
        ndigits = $Opal['$coerce_to!'](ndigits || 0, $$$('Integer'), "to_int");
        if ($truthy($rb_le(ndigits, 0))) {
          if ($truthy(self['$nan?']())) {
            $Kernel.$raise($$$('RangeError'), "NaN")
          } else if ($truthy(self['$infinite?']())) {
            $Kernel.$raise($$$('FloatDomainError'), "Infinity")
          }
        } else if ($eqeq(ndigits, 0)) {
          return Math.round(self)
        } else if (($truthy(self['$nan?']()) || ($truthy(self['$infinite?']())))) {
          return self
        };
        $b = $$$('Math').$frexp(self), $a = $to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (exp = ($a[1] == null ? nil : $a[1])), $b;
        if ($truthy($rb_ge(ndigits, $rb_minus($rb_plus($$$($$$('Float'), 'DIG'), 2), ($truthy($rb_gt(exp, 0)) ? ($rb_divide(exp, 4)) : ($rb_minus($rb_divide(exp, 3), 1))))))) {
          return self
        };
        if ($truthy($rb_lt(ndigits, ($truthy($rb_gt(exp, 0)) ? ($rb_plus($rb_divide(exp, 3), 1)) : ($rb_divide(exp, 4)))['$-@']()))) {
          return 0
        };
        return Math.round(self * Math.pow(10, ndigits)) / Math.pow(10, ndigits);;
      };
    }, -1);
    
    $def(self, '$times', function $$times() {
      var block = $$times.$$p || nil, self = this;

      $$times.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["times"], function $$33(){var self = $$33.$$s == null ? this : $$33.$$s;

          return self}, {$$s: self})
      };
      
      for (var i = 0; i < self; i++) {
        block(i);
      }
    ;
      return self;
    });
    
    $def(self, '$to_f', $return_self);
    
    $def(self, '$to_i', function $$to_i() {
      var self = this;

      return self < 0 ? Math.ceil(self) : Math.floor(self);
    });
    
    $def(self, '$to_r', function $$to_r() {
      var $a, $b, self = this, f = nil, e = nil;

      if ($eqeqeq($$$('Integer'), self)) {
        return $$$('Rational').$new(self, 1)
      } else {
        
        $b = $$$('Math').$frexp(self), $a = $to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (e = ($a[1] == null ? nil : $a[1])), $b;
        f = $$$('Math').$ldexp(f, $$$($$$('Float'), 'MANT_DIG')).$to_i();
        e = $rb_minus(e, $$$($$$('Float'), 'MANT_DIG'));
        return $rb_times(f, $$$($$$('Float'), 'RADIX')['$**'](e)).$to_r();
      }
    });
    
    $def(self, '$to_s', function $$to_s(base) {
      var self = this;

      
      if (base == null) base = 10;
      base = $Opal['$coerce_to!'](base, $$$('Integer'), "to_int");
      if (($truthy($rb_lt(base, 2)) || ($truthy($rb_gt(base, 36))))) {
        $Kernel.$raise($$$('ArgumentError'), "invalid radix " + (base))
      };
      if (($eqeq(self, 0) && ($truthy(1/self === -Infinity)))) {
        return "-0.0"
      };
      return self.toString(base);;
    }, -1);
    
    $def(self, '$truncate', function $$truncate(ndigits) {
      var self = this;

      
      if (ndigits == null) ndigits = 0;
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = parseInt(f * factor, 10) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$digits', function $$digits(base) {
      var self = this;

      
      if (base == null) base = 10;
      if ($truthy($rb_lt(self, 0))) {
        $Kernel.$raise($$$($$$('Math'), 'DomainError'), "out of domain")
      };
      base = $Opal['$coerce_to!'](base, $$$('Integer'), "to_int");
      if ($truthy($rb_lt(base, 2))) {
        $Kernel.$raise($$$('ArgumentError'), "invalid radix " + (base))
      };
      
      if (self != parseInt(self)) $Kernel.$raise($$$('NoMethodError'), "undefined method `digits' for " + (self.$inspect()))

      var value = self, result = [];

      if (self == 0) {
        return [0];
      }

      while (value != 0) {
        result.push(value % base);
        value = parseInt(value / base, 10);
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$divmod', function $$divmod(other) {
      var $yield = $$divmod.$$p || nil, self = this;

      $$divmod.$$p = null;
      if (($truthy(self['$nan?']()) || ($truthy(other['$nan?']())))) {
        return $Kernel.$raise($$$('FloatDomainError'), "NaN")
      } else if ($truthy(self['$infinite?']())) {
        return $Kernel.$raise($$$('FloatDomainError'), "Infinity")
      } else {
        return $send2(self, $find_super(self, 'divmod', $$divmod, false, true), 'divmod', [other], $yield)
      }
    });
    
    $def(self, '$upto', function $$upto(stop) {
      var block = $$upto.$$p || nil, self = this;

      $$upto.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["upto", stop], function $$34(){var self = $$34.$$s == null ? this : $$34.$$s;

          
          if (!$eqeqeq($$$('Numeric'), stop)) {
            $Kernel.$raise($$$('ArgumentError'), "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
          };
          if ($truthy($rb_lt(stop, self))) {
            return 0
          } else {
            return $rb_plus($rb_minus(stop, self), 1)
          };}, {$$s: self})
      };
      
      if (!stop.$$is_number) {
        $Kernel.$raise($$$('ArgumentError'), "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
      }
      for (var i = self; i <= stop; i++) {
        block(i);
      }
    ;
      return self;
    });
    
    $def(self, '$zero?', function $Number_zero$ques$35() {
      var self = this;

      return self == 0;
    });
    
    $def(self, '$size', $return_val(4));
    
    $def(self, '$nan?', function $Number_nan$ques$36() {
      var self = this;

      return isNaN(self);
    });
    
    $def(self, '$finite?', function $Number_finite$ques$37() {
      var self = this;

      return self != Infinity && self != -Infinity && !isNaN(self);
    });
    
    $def(self, '$infinite?', function $Number_infinite$ques$38() {
      var self = this;

      
      if (self == Infinity) {
        return +1;
      }
      else if (self == -Infinity) {
        return -1;
      }
      else {
        return nil;
      }
    
    });
    
    $def(self, '$positive?', function $Number_positive$ques$39() {
      var self = this;

      return self != 0 && (self == Infinity || 1 / self > 0);
    });
    
    $def(self, '$negative?', function $Number_negative$ques$40() {
      var self = this;

      return self == -Infinity || 1 / self < 0;
    });
    
    function numberToUint8Array(num) {
      var uint8array = new Uint8Array(8);
      new DataView(uint8array.buffer).setFloat64(0, num, true);
      return uint8array;
    }

    function uint8ArrayToNumber(arr) {
      return new DataView(arr.buffer).getFloat64(0, true);
    }

    function incrementNumberBit(num) {
      var arr = numberToUint8Array(num);
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] === 0xff) {
          arr[i] = 0;
        } else {
          arr[i]++;
          break;
        }
      }
      return uint8ArrayToNumber(arr);
    }

    function decrementNumberBit(num) {
      var arr = numberToUint8Array(num);
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] === 0) {
          arr[i] = 0xff;
        } else {
          arr[i]--;
          break;
        }
      }
      return uint8ArrayToNumber(arr);
    }
  ;
    
    $def(self, '$next_float', function $$next_float() {
      var self = this;

      
      if ($eqeq(self, $$$($$$('Float'), 'INFINITY'))) {
        return $$$($$$('Float'), 'INFINITY')
      };
      if ($truthy(self['$nan?']())) {
        return $$$($$$('Float'), 'NAN')
      };
      if ($truthy($rb_ge(self, 0))) {
        return incrementNumberBit(Math.abs(self));
      } else {
        return decrementNumberBit(self);
      };
    });
    
    $def(self, '$prev_float', function $$prev_float() {
      var self = this;

      
      if ($eqeq(self, $$$($$$('Float'), 'INFINITY')['$-@']())) {
        return $$$($$$('Float'), 'INFINITY')['$-@']()
      };
      if ($truthy(self['$nan?']())) {
        return $$$($$$('Float'), 'NAN')
      };
      if ($truthy($rb_gt(self, 0))) {
        return decrementNumberBit(self);
      } else {
        return -incrementNumberBit(Math.abs(self));
      };
    });
    $alias(self, "arg", "angle");
    $alias(self, "eql?", "==");
    $alias(self, "fdiv", "/");
    $alias(self, "inspect", "to_s");
    $alias(self, "kind_of?", "is_a?");
    $alias(self, "magnitude", "abs");
    $alias(self, "modulo", "%");
    $alias(self, "object_id", "__id__");
    $alias(self, "phase", "angle");
    $alias(self, "succ", "next");
    return $alias(self, "to_int", "to_i");
  })('::', $$$('Numeric'), $nesting);
  $const_set('::', 'Fixnum', $$$('Number'));
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Integer');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$is_number_class = true;
    self.$$is_integer_class = true;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + (self.$name()))
      });
      
      Opal.udef(self, '$' + "new");;
      
      $def(self, '$sqrt', function $$sqrt(n) {
        
        
        n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
        
        if (n < 0) {
          $Kernel.$raise($$$($$$('Math'), 'DomainError'), "Numerical argument is out of domain - \"isqrt\"")
        }

        return parseInt(Math.sqrt(n), 10);
      ;
      });
      return $def(self, '$try_convert', function $$try_convert(object) {
        var self = this;

        return $$('Opal')['$coerce_to?'](object, self, "to_int")
      });
    })(Opal.get_singleton_class(self), $nesting);
    $const_set(self, 'MAX', Math.pow(2, 30) - 1);
    return $const_set(self, 'MIN', -Math.pow(2, 30));
  })('::', $$$('Numeric'), $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Float');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      
      
      
      $def(self, '$allocate', function $$allocate() {
        var self = this;

        return $Kernel.$raise($$$('TypeError'), "allocator undefined for " + (self.$name()))
      });
      
      Opal.udef(self, '$' + "new");;
      return $def(self, '$===', function $eq_eq_eq$41(other) {
        
        return !!other.$$is_number;
      });
    })(Opal.get_singleton_class(self), $nesting);
    $const_set(self, 'INFINITY', Infinity);
    $const_set(self, 'MAX', Number.MAX_VALUE);
    $const_set(self, 'MIN', Number.MIN_VALUE);
    $const_set(self, 'NAN', NaN);
    $const_set(self, 'DIG', 15);
    $const_set(self, 'MANT_DIG', 53);
    $const_set(self, 'RADIX', 2);
    return $const_set(self, 'EPSILON', Number.EPSILON || 2.2204460492503130808472633361816E-16);
  })('::', $$$('Numeric'), $nesting);
};

Opal.modules["corelib/range"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $def = Opal.def, $not = Opal.not, $send2 = Opal.send2, $find_super = Opal.find_super, $lambda = Opal.lambda, $send = Opal.send, $rb_ge = Opal.rb_ge, $rb_gt = Opal.rb_gt, $eqeq = Opal.eqeq, $rb_le = Opal.rb_le, $rb_lt = Opal.rb_lt, $eqeqeq = Opal.eqeqeq, $return_ivar = Opal.return_ivar, $rb_minus = Opal.rb_minus, $Opal = Opal.Opal, $rb_divide = Opal.rb_divide, $rb_plus = Opal.rb_plus, $rb_times = Opal.rb_times, $thrower = Opal.thrower, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,attr_reader,raise,nil?,<=>,cover?,!,begin,end,exclude_end?,then,call,>=,>,==,max,<=,<,enum_for,size,upto,to_proc,respond_to?,class,succ,===,eql?,try_convert,is_a?,any?,last,to_a,-,coerce_to!,ceil,/,new,loop,+,*,each_with_index,%,step,bsearch,inspect,[],hash,include?');
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Range');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.begin = $proto.end = $proto.excl = nil;
    
    self.$include($$$('Enumerable'));
    self.$$prototype.$$is_range = true;
    self.$attr_reader("begin", "end");
    
    $def(self, '$initialize', function $$initialize(first, last, exclude) {
      var self = this;

      
      if (exclude == null) exclude = false;
      if ($truthy(self.begin)) {
        $Kernel.$raise($$$('NameError'), "'initialize' called twice")
      };
      if (!(($truthy(first['$<=>'](last)) || ($truthy(first['$nil?']()))) || ($truthy(last['$nil?']())))) {
        $Kernel.$raise($$$('ArgumentError'), "bad value for range")
      };
      self.begin = first;
      self.end = last;
      return (self.excl = exclude);
    }, -3);
    
    $def(self, '$===', function $Range_$eq_eq_eq$1(value) {
      var self = this;

      
      if ($truthy(value.$$is_range)) {
        return false
      };
      return self['$cover?'](value);
    });
    
    function is_infinite(self) {
      if (self.begin === nil || self.end === nil ||
          self.begin === -Infinity || self.end === Infinity ||
          self.begin === Infinity || self.end === -Infinity) return true;
      return false;
    }
  ;
    
    $def(self, '$count', function $$count() {
      var block = $$count.$$p || nil, self = this;

      $$count.$$p = null;
      
      ;
      if (($not((block !== nil)) && ($truthy(is_infinite(self))))) {
        return $$$($$$('Float'), 'INFINITY')
      };
      return $send2(self, $find_super(self, 'count', $$count, false, true), 'count', [], block);
    });
    
    $def(self, '$to_a', function $$to_a() {
      var $yield = $$to_a.$$p || nil, self = this;

      $$to_a.$$p = null;
      
      if ($truthy(is_infinite(self))) {
        $Kernel.$raise($$$('TypeError'), "cannot convert endless range to an array")
      };
      return $send2(self, $find_super(self, 'to_a', $$to_a, false, true), 'to_a', [], $yield);
    });
    
    $def(self, '$cover?', function $Range_cover$ques$2(value) {
      var self = this, compare = nil, val_begin = nil, val_end = nil, val_excl = nil, cmp = nil, val_max = nil, $ret_or_1 = nil, end_cmp = nil;

      
      compare = $lambda(function $$3(a, b){var $ret_or_1 = nil;

        
        if (a == null) a = nil;
        if (b == null) b = nil;
        if ($truthy(($ret_or_1 = a['$<=>'](b)))) {
          return $ret_or_1
        } else {
          return 1
        };});
      if ($truthy(value.$$is_range)) {
        
        val_begin = value.$begin();
        val_end = value.$end();
        val_excl = value['$exclude_end?']();
        if ((((($truthy(self.begin) && ($truthy(val_begin['$nil?']()))) || (($truthy(self.end) && ($truthy(val_end['$nil?']()))))) || ((($truthy(val_begin) && ($truthy(val_end))) && ($truthy($send(compare.$call(val_begin, val_end), 'then', [], function $$4(c){
          
          if (c == null) c = nil;
          if ($truthy(val_excl)) {
            return $rb_ge(c, 0)
          } else {
            return $rb_gt(c, 0)
          };})))))) || (($truthy(val_begin) && ($not(self['$cover?'](val_begin))))))) {
          return false
        };
        cmp = compare.$call(self.end, val_end);
        if ($eqeq(self.excl, val_excl)) {
          return $rb_ge(cmp, 0)
        };
        if ($truthy(self.excl)) {
          return $rb_gt(cmp, 0)
        };
        if ($truthy($rb_ge(cmp, 0))) {
          return true
        };
        val_max = value.$max();
        return ($truthy(($ret_or_1 = val_max['$nil?']()['$!']())) ? ($rb_le(compare.$call(val_max, self.end), 0)) : ($ret_or_1));
      };
      if (($truthy(self.begin) && ($truthy($rb_gt(compare.$call(self.begin, value), 0))))) {
        return false
      };
      if ($truthy(self.end['$nil?']())) {
        return true
      };
      end_cmp = compare.$call(value, self.end);
      if ($truthy(self.excl)) {
        return $rb_lt(end_cmp, 0)
      } else {
        return $rb_le(end_cmp, 0)
      };
    });
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, self = this, current = nil, last = nil, $ret_or_1 = nil;

      $$each.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each"], function $$5(){var self = $$5.$$s == null ? this : $$5.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var i, limit;

      if (self.begin.$$is_number && self.end.$$is_number) {
        if (self.begin % 1 !== 0 || self.end % 1 !== 0) {
          $Kernel.$raise($$$('TypeError'), "can't iterate from Float")
        }

        for (i = self.begin, limit = self.end + ($truthy(self.excl) ? (0) : (1)); i < limit; i++) {
          block(i);
        }

        return self;
      }

      if (self.begin.$$is_string && self.end.$$is_string) {
        $send(self.begin, 'upto', [self.end, self.excl], block.$to_proc())
        return self;
      }
    ;
      current = self.begin;
      last = self.end;
      if (!$truthy(current['$respond_to?']("succ"))) {
        $Kernel.$raise($$$('TypeError'), "can't iterate from " + (current.$class()))
      };
      while ($truthy(($truthy(($ret_or_1 = self.end['$nil?']())) ? ($ret_or_1) : ($rb_lt(current['$<=>'](last), 0))))) {
      
        Opal.yield1(block, current);
        current = current.$succ();
      };
      if (($not(self.excl) && ($eqeq(current, last)))) {
        Opal.yield1(block, current)
      };
      return self;
    });
    
    $def(self, '$eql?', function $Range_eql$ques$6(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      
      if (!$eqeqeq($$$('Range'), other)) {
        return false
      };
      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.excl['$==='](other['$exclude_end?']()))) ? (self.begin['$eql?'](other.$begin())) : ($ret_or_2))))) {
        return self.end['$eql?'](other.$end())
      } else {
        return $ret_or_1
      };
    });
    
    $def(self, '$exclude_end?', $return_ivar("excl"));
    
    $def(self, '$first', function $$first(n) {
      var $yield = $$first.$$p || nil, self = this;

      $$first.$$p = null;
      
      ;
      if ($truthy(self.begin['$nil?']())) {
        $Kernel.$raise($$$('RangeError'), "cannot get the minimum of beginless range")
      };
      if ($truthy(n == null)) {
        return self.begin
      };
      return $send2(self, $find_super(self, 'first', $$first, false, true), 'first', [n], $yield);
    }, -1);
    
    $def(self, '$include?', function $Range_include$ques$7(val) {
      var $yield = $Range_include$ques$7.$$p || nil, self = this, cmp = nil, $ret_or_1 = nil;

      $Range_include$ques$7.$$p = null;
      
      if ((((($truthy(self.begin.$$is_number || self.end.$$is_number) || ($truthy(self.begin['$is_a?']($$$('Time'))))) || ($truthy(self.end['$is_a?']($$$('Time'))))) || ($truthy($$$('Integer').$try_convert(self.begin)))) || ($truthy($$$('Integer').$try_convert(self.end))))) {
        return self['$cover?'](val)
      };
      if ($truthy(self.begin.$$is_string || self.end.$$is_string)) {
        if ($truthy(self.begin.$$is_string && self.end.$$is_string)) {
          return $send(self.begin.$upto(self.end, self.excl), 'any?', [], function $$8(s){
            
            if (s == null) s = nil;
            return s['$=='](val);})
        } else if ($truthy(self.begin['$nil?']())) {
          
          cmp = val['$<=>'](self.end);
          return ($truthy(($ret_or_1 = cmp['$nil?']()['$!']())) ? (($truthy(self.excl) ? ($rb_lt(cmp, 0)) : ($rb_le(cmp, 0)))) : ($ret_or_1));
        } else if ($truthy(self.end['$nil?']())) {
          
          cmp = self.begin['$<=>'](val);
          return ($truthy(($ret_or_1 = cmp['$nil?']()['$!']())) ? ($rb_le(cmp, 0)) : ($ret_or_1));
        }
      };
      return $send2(self, $find_super(self, 'include?', $Range_include$ques$7, false, true), 'include?', [val], $yield);
    });
    
    $def(self, '$last', function $$last(n) {
      var self = this;

      
      ;
      if ($truthy(self.end['$nil?']())) {
        $Kernel.$raise($$$('RangeError'), "cannot get the maximum of endless range")
      };
      if ($truthy(n == null)) {
        return self.end
      };
      return self.$to_a().$last(n);
    }, -1);
    
    $def(self, '$max', function $$max() {
      var $yield = $$max.$$p || nil, self = this;

      $$max.$$p = null;
      if ($truthy(self.end['$nil?']())) {
        return $Kernel.$raise($$$('RangeError'), "cannot get the maximum of endless range")
      } else if (($yield !== nil)) {
        return $send2(self, $find_super(self, 'max', $$max, false, true), 'max', [], $yield)
      } else if (($not(self.begin['$nil?']()) && (($truthy($rb_gt(self.begin, self.end)) || (($truthy(self.excl) && ($eqeq(self.begin, self.end)))))))) {
        return nil
      } else {
        return self.excl ? self.end - 1 : self.end
      }
    });
    
    $def(self, '$min', function $$min() {
      var $yield = $$min.$$p || nil, self = this;

      $$min.$$p = null;
      if ($truthy(self.begin['$nil?']())) {
        return $Kernel.$raise($$$('RangeError'), "cannot get the minimum of beginless range")
      } else if (($yield !== nil)) {
        return $send2(self, $find_super(self, 'min', $$min, false, true), 'min', [], $yield)
      } else if (($not(self.end['$nil?']()) && (($truthy($rb_gt(self.begin, self.end)) || (($truthy(self.excl) && ($eqeq(self.begin, self.end)))))))) {
        return nil
      } else {
        return self.begin
      }
    });
    
    $def(self, '$size', function $$size() {
      
      
      var b = this.begin, e = this.end;

      // If begin is Numeric
      if ($$$('Numeric')['$==='](b)) {
        // If end is Numeric
        if ($$$('Numeric')['$==='](e)) {
          // Calculating size based on whether range is exclusive or inclusive
          var size = $rb_minus(e, b);
          if (size < 0) {
            return 0;
          }
          if (!this.excl) {
            size += 1;
          }
          return ($$$('Float')['$==='](b) || $$$('Float')['$==='](e)) ? Math.floor(size) : size;
        }
        // If end is nil
        else if (e === nil) {
          return Infinity;
        }
      }
      // If begin is nil
      else if (b === nil) {
        // If end is Numeric
        if ($$$('Numeric')['$==='](e)) {
          return Infinity;
        }
      }

      // If neither begin nor end is Numeric
      return nil;
    
    });
    
    $def(self, '$step', function $$step(n) {
      var $yield = $$step.$$p || nil, self = this, $ret_or_1 = nil, i = nil;

      $$step.$$p = null;
      
      ;
      
      function coerceStepSize() {
        if (n == null) {
          n = 1;
        }
        else if (!n.$$is_number) {
          n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int")
        }

        if (n < 0) {
          $Kernel.$raise($$$('ArgumentError'), "step can't be negative")
        } else if (n === 0) {
          $Kernel.$raise($$$('ArgumentError'), "step can't be 0")
        }
      }

      function enumeratorSize() {
        if (!self.begin['$respond_to?']("succ")) {
          return nil;
        }

        if (self.begin.$$is_string && self.end.$$is_string) {
          return nil;
        }

        if (n % 1 === 0) {
          return $rb_divide(self.$size(), n).$ceil();
        } else {
          // n is a float
          var begin = self.begin, end = self.end,
              abs = Math.abs, floor = Math.floor,
              err = (abs(begin) + abs(end) + abs(end - begin)) / abs(n) * $$$($$$('Float'), 'EPSILON'),
              size;

          if (err > 0.5) {
            err = 0.5;
          }

          if (self.excl) {
            size = floor((end - begin) / n - err);
            if (size * n + begin < end) {
              size++;
            }
          } else {
            size = floor((end - begin) / n + err) + 1
          }

          return size;
        }
      }
    ;
      if (!($yield !== nil)) {
        if (((($truthy(self.begin['$is_a?']($$('Numeric'))) || ($truthy(self.begin['$nil?']()))) && (($truthy(self.end['$is_a?']($$('Numeric'))) || ($truthy(self.end['$nil?']()))))) && ($not(($truthy(($ret_or_1 = self.begin['$nil?']())) ? (self.end['$nil?']()) : ($ret_or_1)))))) {
          return $$$($$$('Enumerator'), 'ArithmeticSequence').$new(self, n, "step")
        } else {
          return $send(self, 'enum_for', ["step", n], function $$9(){
            
            coerceStepSize();
            return enumeratorSize();
          })
        }
      };
      coerceStepSize();
      if ($truthy(self.begin.$$is_number && self.end.$$is_number)) {
        
        i = 0;
        (function(){try { var $t_break = $thrower('break'); return $send(self, 'loop', [], function $$10(){var self = $$10.$$s == null ? this : $$10.$$s, current = nil;
          if (self.begin == null) self.begin = nil;
          if (self.excl == null) self.excl = nil;
          if (self.end == null) self.end = nil;

          
          current = $rb_plus(self.begin, $rb_times(i, n));
          if ($truthy(self.excl)) {
            if ($truthy($rb_ge(current, self.end))) {
              $t_break.$throw(nil, $$10.$$is_lambda)
            }
          } else if ($truthy($rb_gt(current, self.end))) {
            $t_break.$throw(nil, $$10.$$is_lambda)
          };
          Opal.yield1($yield, current);
          return (i = $rb_plus(i, 1));}, {$$s: self})} catch($e) {
          if ($e === $t_break) return $e.$v;
          throw $e;
        } finally {$t_break.is_orphan = true;}})();
      } else {
        
        
        if (self.begin.$$is_string && self.end.$$is_string && n % 1 !== 0) {
          $Kernel.$raise($$$('TypeError'), "no implicit conversion to float from string")
        }
      ;
        $send(self, 'each_with_index', [], function $$11(value, idx){
          
          if (value == null) value = nil;
          if (idx == null) idx = nil;
          if ($eqeq(idx['$%'](n), 0)) {
            return Opal.yield1($yield, value);
          } else {
            return nil
          };});
      };
      return self;
    }, -1);
    
    $def(self, '$%', function $Range_$percent$12(n) {
      var self = this;

      if (($truthy(self.begin['$is_a?']($$('Numeric'))) && ($truthy(self.end['$is_a?']($$('Numeric')))))) {
        return $$$($$$('Enumerator'), 'ArithmeticSequence').$new(self, n, "%")
      } else {
        return self.$step(n)
      }
    });
    
    $def(self, '$bsearch', function $$bsearch() {
      var block = $$bsearch.$$p || nil, self = this;

      $$bsearch.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("bsearch")
      };
      if ($truthy(is_infinite(self) && (self.begin.$$is_number || self.end.$$is_number))) {
        $Kernel.$raise($$$('NotImplementedError'), "Can't #bsearch an infinite range")
      };
      if (!$truthy(self.begin.$$is_number && self.end.$$is_number)) {
        $Kernel.$raise($$$('TypeError'), "can't do binary search for " + (self.begin.$class()))
      };
      return $send(self.$to_a(), 'bsearch', [], block.$to_proc());
    });
    
    $def(self, '$to_s', function $$to_s() {
      var self = this, $ret_or_1 = nil;

      return "" + (($truthy(($ret_or_1 = self.begin)) ? ($ret_or_1) : (""))) + (($truthy(self.excl) ? ("...") : (".."))) + (($truthy(($ret_or_1 = self.end)) ? ($ret_or_1) : ("")))
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, $ret_or_1 = nil;

      return "" + (($truthy(($ret_or_1 = self.begin)) ? (self.begin.$inspect()) : ($ret_or_1))) + (($truthy(self.excl) ? ("...") : (".."))) + (($truthy(($ret_or_1 = self.end)) ? (self.end.$inspect()) : ($ret_or_1)))
    });
    
    $def(self, '$marshal_load', function $$marshal_load(args) {
      var self = this;

      
      self.begin = args['$[]']("begin");
      self.end = args['$[]']("end");
      return (self.excl = args['$[]']("excl"));
    });
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return [$$$('Range'), self.begin, self.end, self.excl].$hash()
    });
    $alias(self, "==", "eql?");
    return $alias(self, "member?", "include?");
  })('::', null, $nesting);
};

Opal.modules["corelib/proc"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $slice = Opal.slice, $each_ivar = Opal.each_ivar, $klass = Opal.klass, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $defs = Opal.defs, $def = Opal.def, $send = Opal.send, $to_a = Opal.to_a, $return_self = Opal.return_self, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $Opal = Opal.Opal, $alias = Opal.alias, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('raise,proc,call,to_proc,new,source_location,coerce_to!,dup');
  return (function($base, $super) {
    var self = $klass($base, $super, 'Proc');

    
    
    Opal.prop(self.$$prototype, '$$is_proc', true);
    Opal.prop(self.$$prototype, '$$is_lambda', false);
    $defs(self, '$new', function $Proc_new$1() {
      var block = $Proc_new$1.$$p || nil;

      $Proc_new$1.$$p = null;
      
      ;
      if (!$truthy(block)) {
        $Kernel.$raise($$$('ArgumentError'), "tried to create a Proc object without a block")
      };
      return block;
    });
    
    function $call_lambda(self, args) {
      if (self.$$ret) {
        try {
          return self.apply(null, args);
        } catch (err) {
          if (err === self.$$ret) {
            return err.$v;
          } else {
            throw err;
          }
        }
      } else {
        return self.apply(null, args);
      }
    }

    function $call_proc(self, args) {
      if (self.$$brk) {
        try {
          return Opal.yieldX(self, args);
        } catch (err) {
          if (err === self.$$brk) {
            return err.$v;
          } else {
            throw err;
          }
        }
      } else {
        return Opal.yieldX(self, args);
      }
    }
  ;
    
    $def(self, '$call', function $$call($a) {
      var block = $$call.$$p || nil, $post_args, args, self = this;

      $$call.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      
      if (block !== nil) self.$$p = block;
      if (self.$$is_lambda) return $call_lambda(self, args);
      return $call_proc(self, args);
    ;
    }, -1);
    
    $def(self, '$>>', function $Proc_$gt$gt$2(other) {
      var $yield = $Proc_$gt$gt$2.$$p || nil, self = this;

      $Proc_$gt$gt$2.$$p = null;
      return $send($Kernel, 'proc', [], function $$3($a){var block = $$3.$$p || nil, $post_args, args, self = $$3.$$s == null ? this : $$3.$$s, out = nil;

        $$3.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        args = $post_args;
        out = $send(self, 'call', $to_a(args), block.$to_proc());
        return other.$call(out);}, {$$arity: -1, $$s: self})
    });
    
    $def(self, '$<<', function $Proc_$lt$lt$4(other) {
      var $yield = $Proc_$lt$lt$4.$$p || nil, self = this;

      $Proc_$lt$lt$4.$$p = null;
      return $send($Kernel, 'proc', [], function $$5($a){var block = $$5.$$p || nil, $post_args, args, self = $$5.$$s == null ? this : $$5.$$s, out = nil;

        $$5.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        args = $post_args;
        out = $send(other, 'call', $to_a(args), block.$to_proc());
        return self.$call(out);}, {$$arity: -1, $$s: self})
    });
    
    $def(self, '$to_proc', $return_self);
    
    $def(self, '$lambda?', function $Proc_lambda$ques$6() {
      var self = this;

      return !!self.$$is_lambda;
    });
    
    $def(self, '$arity', function $$arity() {
      var self = this;

      
      if (self.$$is_curried) {
        return -1;
      } else if (self.$$arity != null) {
        return self.$$arity;
      } else {
        return self.length;
      }
    
    });
    
    $def(self, '$source_location', function $$source_location() {
      var self = this, $ret_or_1 = nil;

      
      if (self.$$is_curried) { return nil; };
      if ($truthy(($ret_or_1 = self.$$source_location))) {
        return $ret_or_1
      } else {
        return nil
      };
    });
    
    $def(self, '$binding', function $$binding() {
      var $a, self = this;

      
      if (self.$$is_curried) { $Kernel.$raise($$$('ArgumentError'), "Can't create Binding") };
      if ($truthy((($a = $$$('::', 'Binding', 'skip_raise')) ? 'constant' : nil))) {
        return $$$('Binding').$new(nil, [], self.$$s, self.$source_location())
      } else {
        return nil
      };
    });
    
    $def(self, '$parameters', function $$parameters($kwargs) {
      var lambda, self = this;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      lambda = $hash_get($kwargs, "lambda");;
      
      if (self.$$is_curried) {
        return [["rest"]];
      } else if (self.$$parameters) {
        if (lambda == null ? self.$$is_lambda : lambda) {
          return self.$$parameters;
        } else {
          var result = [], i, length;

          for (i = 0, length = self.$$parameters.length; i < length; i++) {
            var parameter = self.$$parameters[i];

            if (parameter[0] === 'req') {
              // required arguments always have name
              parameter = ['opt', parameter[1]];
            }

            result.push(parameter);
          }

          return result;
        }
      } else {
        return [];
      }
    ;
    }, -1);
    
    $def(self, '$curry', function $$curry(arity) {
      var self = this;

      
      ;
      
      if (arity === undefined) {
        arity = self.length;
      }
      else {
        arity = $Opal['$coerce_to!'](arity, $$$('Integer'), "to_int");
        if (self.$$is_lambda && arity !== self.length) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arity) + " for " + (self.length) + ")")
        }
      }

      function curried () {
        var args = $slice(arguments),
            length = args.length,
            result;

        if (length > arity && self.$$is_lambda && !self.$$is_curried) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (length) + " for " + (arity) + ")")
        }

        if (length >= arity) {
          return self.$call.apply(self, args);
        }

        result = function () {
          return curried.apply(null,
            args.concat($slice(arguments)));
        }
        result.$$is_lambda = self.$$is_lambda;
        result.$$is_curried = true;

        return result;
      };

      curried.$$is_lambda = self.$$is_lambda;
      curried.$$is_curried = true;
      return curried;
    ;
    }, -1);
    
    $def(self, '$dup', function $$dup() {
      var self = this;

      
      var original_proc = self.$$original_proc || self,
          proc = function () {
            return original_proc.apply(this, arguments);
          };

      $each_ivar(self, function(prop) {
        proc[prop] = self[prop];
      });

      return proc;
    
    });
    $alias(self, "===", "call");
    $alias(self, "clone", "dup");
    $alias(self, "yield", "call");
    return $alias(self, "[]", "call");
  })('::', Function)
};

Opal.modules["corelib/method"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $slice = Opal.slice, $alias = Opal.alias, $Kernel = Opal.Kernel, $send = Opal.send, $to_a = Opal.to_a, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('attr_reader,arity,curry,>>,<<,new,class,join,source_location,call,raise,bind,to_proc');
  
  (function($base, $super) {
    var self = $klass($base, $super, 'Method');

    var $proto = self.$$prototype;

    $proto.method = $proto.receiver = $proto.owner = $proto.name = nil;
    
    self.$attr_reader("owner", "receiver", "name");
    
    $def(self, '$initialize', function $$initialize(receiver, owner, method, name) {
      var self = this;

      
      self.receiver = receiver;
      self.owner = owner;
      self.name = name;
      return (self.method = method);
    });
    
    $def(self, '$arity', function $$arity() {
      var self = this;

      return self.method.$arity()
    });
    
    $def(self, '$parameters', function $$parameters() {
      var self = this;

      return self.method.$$parameters
    });
    
    $def(self, '$source_location', function $$source_location() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$source_location))) {
        return $ret_or_1
      } else {
        return ["(eval)", 0]
      }
    });
    
    $def(self, '$comments', function $$comments() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$comments))) {
        return $ret_or_1
      } else {
        return []
      }
    });
    
    $def(self, '$call', function $$call($a) {
      var block = $$call.$$p || nil, $post_args, args, self = this;

      $$call.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      
      self.method.$$p = block;

      return self.method.apply(self.receiver, args);
    ;
    }, -1);
    
    $def(self, '$curry', function $$curry(arity) {
      var self = this;

      
      ;
      return self.method.$curry(arity);
    }, -1);
    
    $def(self, '$>>', function $Method_$gt$gt$1(other) {
      var self = this;

      return self.method['$>>'](other)
    });
    
    $def(self, '$<<', function $Method_$lt$lt$2(other) {
      var self = this;

      return self.method['$<<'](other)
    });
    
    $def(self, '$unbind', function $$unbind() {
      var self = this;

      return $$$('UnboundMethod').$new(self.receiver.$class(), self.owner, self.method, self.name)
    });
    
    $def(self, '$to_proc', function $$to_proc() {
      var self = this;

      
      var proc = self.$call.bind(self);
      proc.$$unbound = self.method;
      proc.$$is_lambda = true;
      proc.$$arity = self.method.$$arity == null ? self.method.length : self.method.$$arity;
      proc.$$parameters = self.method.$$parameters;
      return proc;
    
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "#<" + (self.$class()) + ": " + (self.receiver.$class()) + "#" + (self.name) + " (defined in " + (self.owner) + " in " + (self.$source_location().$join(":")) + ")>"
    });
    $alias(self, "[]", "call");
    return $alias(self, "===", "call");
  })('::', null);
  return (function($base, $super) {
    var self = $klass($base, $super, 'UnboundMethod');

    var $proto = self.$$prototype;

    $proto.method = $proto.owner = $proto.name = $proto.source = nil;
    
    self.$attr_reader("source", "owner", "name");
    
    $def(self, '$initialize', function $$initialize(source, owner, method, name) {
      var self = this;

      
      self.source = source;
      self.owner = owner;
      self.method = method;
      self.name = name;
      return self.$$method = method;;
    });
    
    $def(self, '$arity', function $$arity() {
      var self = this;

      return self.method.$arity()
    });
    
    $def(self, '$parameters', function $$parameters() {
      var self = this;

      return self.method.$$parameters
    });
    
    $def(self, '$source_location', function $$source_location() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$source_location))) {
        return $ret_or_1
      } else {
        return ["(eval)", 0]
      }
    });
    
    $def(self, '$comments', function $$comments() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$comments))) {
        return $ret_or_1
      } else {
        return []
      }
    });
    
    $def(self, '$bind', function $$bind(object) {
      var self = this;

      
      if (self.owner.$$is_module || Opal.is_a(object, self.owner)) {
        return $$$('Method').$new(object, self.owner, self.method, self.name);
      }
      else {
        $Kernel.$raise($$$('TypeError'), "can't bind singleton method to a different class (expected " + (object) + ".kind_of?(" + (self.owner) + " to be true)");
      }
    
    });
    
    $def(self, '$bind_call', function $$bind_call(object, $a) {
      var block = $$bind_call.$$p || nil, $post_args, args, self = this;

      $$bind_call.$$p = null;
      
      ;
      $post_args = $slice(arguments, 1);
      args = $post_args;
      return $send(self.$bind(object), 'call', $to_a(args), block.$to_proc());
    }, -2);
    return $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "#<" + (self.$class()) + ": " + (self.source) + "#" + (self.name) + " (defined in " + (self.owner) + " in " + (self.$source_location().$join(":")) + ")>"
    });
  })('::', null);
};

Opal.modules["corelib/variables"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $gvars = Opal.gvars, $const_set = Opal.const_set, $Object = Opal.Object, nil = Opal.nil;

  Opal.add_stubs('new');
  
  $gvars['&'] = $gvars['~'] = $gvars['`'] = $gvars["'"] = nil;
  $gvars.LOADED_FEATURES = ($gvars["\""] = Opal.loaded_features);
  $gvars.LOAD_PATH = ($gvars[":"] = []);
  $gvars["/"] = "\n";
  $gvars[","] = nil;
  $const_set('::', 'ARGV', []);
  $const_set('::', 'ARGF', $Object.$new());
  $const_set('::', 'ENV', (new Map()));
  $gvars.VERBOSE = false;
  $gvars.DEBUG = false;
  return ($gvars.SAFE = 0);
};

Opal.modules["corelib/io"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $const_set = Opal.const_set, $not = Opal.not, $truthy = Opal.truthy, $def = Opal.def, $return_ivar = Opal.return_ivar, $return_val = Opal.return_val, $slice = Opal.slice, $Kernel = Opal.Kernel, $gvars = Opal.gvars, $send = Opal.send, $to_a = Opal.to_a, $rb_plus = Opal.rb_plus, $neqeq = Opal.neqeq, $range = Opal.range, $eqeq = Opal.eqeq, $to_ary = Opal.to_ary, $rb_gt = Opal.rb_gt, $assign_ivar_val = Opal.assign_ivar_val, $alias = Opal.alias, $a, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('attr_reader,attr_accessor,!,match?,include?,size,write,String,flatten,puts,sysread_noraise,+,!=,[],ord,getc,readchar,raise,gets,==,to_str,length,split,sub,sysread,>,to_a,each_line,enum_for,getbyte,closed_write?,closed_read?,each,eof,new,write_proc=,read_proc=');
  
  (function($base, $super) {
    var self = $klass($base, $super, 'IO');

    var $proto = self.$$prototype;

    $proto.read_buffer = $proto.closed = nil;
    
    $const_set(self, 'SEEK_SET', 0);
    $const_set(self, 'SEEK_CUR', 1);
    $const_set(self, 'SEEK_END', 2);
    $const_set(self, 'SEEK_DATA', 3);
    $const_set(self, 'SEEK_HOLE', 4);
    $const_set(self, 'READABLE', 1);
    $const_set(self, 'WRITABLE', 4);
    self.$attr_reader("eof");
    self.$attr_accessor("read_proc", "sync", "tty", "write_proc");
    
    $def(self, '$initialize', function $$initialize(fd, flags) {
      var self = this;

      
      if (flags == null) flags = "r";
      self.fd = fd;
      self.flags = flags;
      self.eof = false;
      if (($truthy(flags['$include?']("r")) && ($not(flags['$match?'](/[wa+]/))))) {
        return (self.closed = "write")
      } else if (($truthy(flags['$match?'](/[wa]/)) && ($not(flags['$match?'](/[r+]/))))) {
        return (self.closed = "read")
      } else {
        return nil
      };
    }, -2);
    
    $def(self, '$fileno', $return_ivar("fd"));
    
    $def(self, '$tty?', function $IO_tty$ques$1() {
      var self = this;

      return self.tty == true;
    });
    
    $def(self, '$write', function $$write(string) {
      var self = this;

      
      self.write_proc(string);
      return string.$size();
    });
    
    $def(self, '$flush', $return_val(nil));
    
    $def(self, '$<<', function $IO_$lt$lt$2(string) {
      var self = this;

      
      self.$write(string);
      return self;
    });
    
    $def(self, '$print', function $$print($a) {
      var $post_args, args, self = this;
      if ($gvars[","] == null) $gvars[","] = nil;

      
      $post_args = $slice(arguments);
      args = $post_args;
      
      for (var i = 0, ii = args.length; i < ii; i++) {
        args[i] = $Kernel.$String(args[i])
      }
      self.$write(args.join($gvars[","]));
    ;
      return nil;
    }, -1);
    
    $def(self, '$puts', function $$puts($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      
      var line
      if (args.length === 0) {
        self.$write("\n");
        return nil;
      } else {
        for (var i = 0, ii = args.length; i < ii; i++) {
          if (args[i].$$is_array){
            var ary = (args[i]).$flatten()
            if (ary.length > 0) $send(self, 'puts', $to_a((ary)))
          } else {
            if (args[i].$$is_string) {
              line = args[i].valueOf();
            } else {
              line = $Kernel.$String(args[i]);
            }
            if (!line.endsWith("\n")) line += "\n"
            self.$write(line)
          }
        }
      }
    ;
      return nil;
    }, -1);
    
    $def(self, '$getc', function $$getc() {
      var self = this, $ret_or_1 = nil, parts = nil, ret = nil;

      
      self.read_buffer = ($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : (""));
      parts = "";
      do {
      
        self.read_buffer = $rb_plus(self.read_buffer, parts);
        if ($neqeq(self.read_buffer, "")) {
          
          ret = self.read_buffer['$[]'](0);
          self.read_buffer = self.read_buffer['$[]']($range(1, -1, false));
          return ret;
        };
      } while ($truthy((parts = self.$sysread_noraise(1))));;
      return nil;
    });
    
    $def(self, '$getbyte', function $$getbyte() {
      var $a, self = this;

      return ($a = self.$getc(), ($a === nil || $a == null) ? nil : $a.$ord())
    });
    
    $def(self, '$readbyte', function $$readbyte() {
      var self = this;

      return self.$readchar().$ord()
    });
    
    $def(self, '$readchar', function $$readchar() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.$getc()))) {
        return $ret_or_1
      } else {
        return $Kernel.$raise($$$('EOFError'), "end of file reached")
      }
    });
    
    $def(self, '$readline', function $$readline($a) {
      var $post_args, args, self = this, $ret_or_1 = nil;

      
      $post_args = $slice(arguments);
      args = $post_args;
      if ($truthy(($ret_or_1 = $send(self, 'gets', $to_a(args))))) {
        return $ret_or_1
      } else {
        return $Kernel.$raise($$$('EOFError'), "end of file reached")
      };
    }, -1);
    
    $def(self, '$gets', function $$gets(sep, limit, opts) {
      var $a, $b, self = this, orig_sep = nil, $ret_or_1 = nil, seplen = nil, data = nil, ret = nil, orig_buffer = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      if (sep == null) sep = false;
      if (limit == null) limit = nil;
      if (opts == null) opts = (new Map());
      if (($truthy(sep.$$is_number) && ($not(limit)))) {
        $a = [false, sep, limit], (sep = $a[0]), (limit = $a[1]), (opts = $a[2]), $a
      };
      if ((($truthy(sep.$$is_hash) && ($not(limit))) && ($eqeq(opts, (new Map()))))) {
        $a = [false, nil, sep], (sep = $a[0]), (limit = $a[1]), (opts = $a[2]), $a
      } else if (($truthy(limit.$$is_hash) && ($eqeq(opts, (new Map()))))) {
        $a = [sep, nil, limit], (sep = $a[0]), (limit = $a[1]), (opts = $a[2]), $a
      };
      orig_sep = sep;
      if ($eqeq(sep, false)) {
        sep = $gvars["/"]
      };
      if ($eqeq(sep, "")) {
        sep = /\r?\n\r?\n/
      };
      sep = ($truthy(($ret_or_1 = sep)) ? ($ret_or_1) : (""));
      if (!$eqeq(orig_sep, "")) {
        sep = sep.$to_str()
      };
      seplen = ($eqeq(orig_sep, "") ? (2) : (sep.$length()));
      if ($eqeq(sep, " ")) {
        sep = / /
      };
      self.read_buffer = ($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : (""));
      data = "";
      ret = nil;
      do {
      
        self.read_buffer = $rb_plus(self.read_buffer, data);
        if (($neqeq(sep, "") && ($truthy(($truthy(sep.$$is_regexp) ? (self.read_buffer['$match?'](sep)) : (self.read_buffer['$include?'](sep))))))) {
          
          orig_buffer = self.read_buffer;
          $b = self.read_buffer.$split(sep, 2), $a = $to_ary($b), (ret = ($a[0] == null ? nil : $a[0])), (self.read_buffer = ($a[1] == null ? nil : $a[1])), $b;
          if ($neqeq(ret, orig_buffer)) {
            ret = $rb_plus(ret, orig_buffer['$[]'](ret.$length(), seplen))
          };
          break;
        };
      } while ($truthy((data = self.$sysread_noraise(($eqeq(sep, "") ? (65536) : (1))))));;
      if (!$truthy(ret)) {
        
        $a = [($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : ("")), ""], (ret = $a[0]), (self.read_buffer = $a[1]), $a;
        if ($eqeq(ret, "")) {
          ret = nil
        };
      };
      if ($truthy(ret)) {
        
        if ($truthy(limit)) {
          
          ret = ret['$[]'](Opal.Range.$new(0,limit, true));
          self.read_buffer = $rb_plus(ret['$[]'](Opal.Range.$new(limit, -1, false)), self.read_buffer);
        };
        if ($truthy(opts['$[]']("chomp"))) {
          ret = ret.$sub(/\r?\n$/, "")
        };
        if ($eqeq(orig_sep, "")) {
          ret = ret.$sub(/^[\r\n]+/, "")
        };
      };
      if ($eqeq(orig_sep, false)) {
        $gvars._ = ret
      };
      return ret;
    }, -1);
    
    $def(self, '$sysread', function $$sysread(integer) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.read_proc(integer)))) {
        return $ret_or_1
      } else {
        
        self.eof = true;
        return $Kernel.$raise($$$('EOFError'), "end of file reached");
      }
    });
    
    $def(self, '$sysread_noraise', function $$sysread_noraise(integer) {
      var self = this;

      try {
        return self.$sysread(integer)
      } catch ($err) {
        if (Opal.rescue($err, [$$$('EOFError')])) {
          try {
            return nil
          } finally { Opal.pop_exception($err); }
        } else { throw $err; }
      }
    });
    
    $def(self, '$readpartial', function $$readpartial(integer) {
      var $a, self = this, $ret_or_1 = nil, part = nil, ret = nil;

      
      self.read_buffer = ($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : (""));
      part = self.$sysread(integer);
      $a = [$rb_plus(self.read_buffer, ($truthy(($ret_or_1 = part)) ? ($ret_or_1) : (""))), ""], (ret = $a[0]), (self.read_buffer = $a[1]), $a;
      if ($eqeq(ret, "")) {
        ret = nil
      };
      return ret;
    });
    
    $def(self, '$read', function $$read(integer) {
      var $a, self = this, $ret_or_1 = nil, parts = nil, ret = nil;

      
      if (integer == null) integer = nil;
      self.read_buffer = ($truthy(($ret_or_1 = self.read_buffer)) ? ($ret_or_1) : (""));
      parts = "";
      ret = nil;
      do {
      
        self.read_buffer = $rb_plus(self.read_buffer, parts);
        if (($truthy(integer) && ($truthy($rb_gt(self.read_buffer.$length(), integer))))) {
          
          $a = [self.read_buffer['$[]'](Opal.Range.$new(0,integer, true)), self.read_buffer['$[]'](Opal.Range.$new(integer, -1, false))], (ret = $a[0]), (self.read_buffer = $a[1]), $a;
          return ret;
        };
      } while ($truthy((parts = self.$sysread_noraise(($truthy(($ret_or_1 = integer)) ? ($ret_or_1) : (65536))))));;
      $a = [self.read_buffer, ""], (ret = $a[0]), (self.read_buffer = $a[1]), $a;
      return ret;
    }, -1);
    
    $def(self, '$readlines', function $$readlines(separator) {
      var self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      if (separator == null) separator = $gvars["/"];
      return self.$each_line(separator).$to_a();
    }, -1);
    
    $def(self, '$each', function $$each($a, $b) {
      var block = $$each.$$p || nil, $post_args, sep, args, self = this, s = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      $$each.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      
      if ($post_args.length > 0) sep = $post_args.shift();if (sep == null) sep = $gvars["/"];
      args = $post_args;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each", sep].concat($to_a(args)))
      };
      while ($truthy((s = $send(self, 'gets', [sep].concat($to_a(args)))))) {
      Opal.yield1(block, s)
      };
      return self;
    }, -1);
    
    $def(self, '$each_byte', function $$each_byte() {
      var block = $$each_byte.$$p || nil, self = this, s = nil;

      $$each_byte.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("each_byte")
      };
      while ($truthy((s = self.$getbyte()))) {
      Opal.yield1(block, s)
      };
      return self;
    });
    
    $def(self, '$each_char', function $$each_char() {
      var block = $$each_char.$$p || nil, self = this, s = nil;

      $$each_char.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("each_char")
      };
      while ($truthy((s = self.$getc()))) {
      Opal.yield1(block, s)
      };
      return self;
    });
    
    $def(self, '$close', $assign_ivar_val("closed", "both"));
    
    $def(self, '$close_read', function $$close_read() {
      var self = this;

      if ($eqeq(self.closed, "write")) {
        return (self.closed = "both")
      } else {
        return (self.closed = "read")
      }
    });
    
    $def(self, '$close_write', function $$close_write() {
      var self = this;

      if ($eqeq(self.closed, "read")) {
        return (self.closed = "both")
      } else {
        return (self.closed = "write")
      }
    });
    
    $def(self, '$closed?', function $IO_closed$ques$3() {
      var self = this;

      return self.closed['$==']("both")
    });
    
    $def(self, '$closed_read?', function $IO_closed_read$ques$4() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.closed['$==']("read")))) {
        return $ret_or_1
      } else {
        return self.closed['$==']("both")
      }
    });
    
    $def(self, '$closed_write?', function $IO_closed_write$ques$5() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.closed['$==']("write")))) {
        return $ret_or_1
      } else {
        return self.closed['$==']("both")
      }
    });
    
    $def(self, '$check_writable', function $$check_writable() {
      var self = this;

      if ($truthy(self['$closed_write?']())) {
        return $Kernel.$raise($$$('IOError'), "not opened for writing")
      } else {
        return nil
      }
    });
    
    $def(self, '$check_readable', function $$check_readable() {
      var self = this;

      if ($truthy(self['$closed_read?']())) {
        return $Kernel.$raise($$$('IOError'), "not opened for reading")
      } else {
        return nil
      }
    });
    $alias(self, "each_line", "each");
    return $alias(self, "eof?", "eof");
  })('::', null);
  $const_set('::', 'STDIN', ($gvars.stdin = $$$('IO').$new(0, "r")));
  $const_set('::', 'STDOUT', ($gvars.stdout = $$$('IO').$new(1, "w")));
  $const_set('::', 'STDERR', ($gvars.stderr = $$$('IO').$new(2, "w")));
  var console = Opal.global.console;
  $$$('STDOUT')['$write_proc='](typeof(process) === 'object' && typeof(process.stdout) === 'object' ? function(s){process.stdout.write(s)} : function(s){console.log(s)});
  $$$('STDERR')['$write_proc='](typeof(process) === 'object' && typeof(process.stderr) === 'object' ? function(s){process.stderr.write(s)} : function(s){console.warn(s)});
  return ($a = [function(s) { var p = prompt(); if (p !== null) return p + "\n"; return nil; }], $send($$$('STDIN'), 'read_proc=', $a), $a[$a.length - 1]);
};

Opal.modules["opal/regexp_anchors"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $const_set = Opal.const_set, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('new');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $const_set(self, 'REGEXP_START', "^");
    $const_set(self, 'REGEXP_END', "$");
    $const_set(self, 'FORBIDDEN_STARTING_IDENTIFIER_CHARS', "\\u0001-\\u002F\\u003A-\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    $const_set(self, 'FORBIDDEN_ENDING_IDENTIFIER_CHARS', "\\u0001-\\u0020\\u0022-\\u002F\\u003A-\\u003E\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    $const_set(self, 'INLINE_IDENTIFIER_REGEXP', $$('Regexp').$new("[^" + ($$$(self, 'FORBIDDEN_STARTING_IDENTIFIER_CHARS')) + "]*[^" + ($$$(self, 'FORBIDDEN_ENDING_IDENTIFIER_CHARS')) + "]"));
    $const_set(self, 'FORBIDDEN_CONST_NAME_CHARS', "\\u0001-\\u0020\\u0021-\\u002F\\u003B-\\u003F\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    return $const_set(self, 'CONST_NAME_REGEXP', $$('Regexp').$new("" + ($$$(self, 'REGEXP_START')) + "(::)?[A-Z][^" + ($$$(self, 'FORBIDDEN_CONST_NAME_CHARS')) + "]*" + ($$$(self, 'REGEXP_END'))));
  })($nesting[0], $nesting)
};

Opal.modules["opal/mini"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $Object = Opal.Object, nil = Opal.nil;

  Opal.add_stubs('require');
  
  $Object.$require("opal/base");
  $Object.$require("corelib/nil");
  $Object.$require("corelib/boolean");
  $Object.$require("corelib/string");
  $Object.$require("corelib/comparable");
  $Object.$require("corelib/enumerable");
  $Object.$require("corelib/enumerator");
  $Object.$require("corelib/array");
  $Object.$require("corelib/hash");
  $Object.$require("corelib/number");
  $Object.$require("corelib/range");
  $Object.$require("corelib/proc");
  $Object.$require("corelib/method");
  $Object.$require("corelib/regexp");
  $Object.$require("corelib/variables");
  $Object.$require("corelib/io");
  return $Object.$require("opal/regexp_anchors");
};

Opal.modules["corelib/kernel/format"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $coerce_to = Opal.coerce_to, $module = Opal.module, $slice = Opal.slice, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $Opal = Opal.Opal, $Kernel = Opal.Kernel, $gvars = Opal.gvars, $def = Opal.def, $alias = Opal.alias, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('respond_to?,[],==,length,coerce_to?,nil?,to_a,raise,to_int,fetch,Integer,Float,to_ary,to_str,inspect,to_s,format');
  return (function($base) {
    var self = $module($base, 'Kernel');

    
    
    
    $def(self, '$format', function $$format(format_string, $a) {
      var $post_args, args, ary = nil;
      if ($gvars.DEBUG == null) $gvars.DEBUG = nil;

      
      $post_args = $slice(arguments, 1);
      args = $post_args;
      if (($eqeq(args.$length(), 1) && ($truthy(args['$[]'](0)['$respond_to?']("to_ary"))))) {
        
        ary = $Opal['$coerce_to?'](args['$[]'](0), $$$('Array'), "to_ary");
        if (!$truthy(ary['$nil?']())) {
          args = ary.$to_a()
        };
      };
      
      var result = '',
          //used for slicing:
          begin_slice = 0,
          end_slice,
          //used for iterating over the format string:
          i,
          len = format_string.length,
          //used for processing field values:
          arg,
          str,
          //used for processing %g and %G fields:
          exponent,
          //used for keeping track of width and precision:
          width,
          precision,
          //used for holding temporary values:
          tmp_num,
          //used for processing %{} and %<> fileds:
          hash_parameter_key,
          closing_brace_char,
          //used for processing %b, %B, %o, %x, and %X fields:
          base_number,
          base_prefix,
          base_neg_zero_regex,
          base_neg_zero_digit,
          //used for processing arguments:
          next_arg,
          seq_arg_num = 1,
          pos_arg_num = 0,
          //used for keeping track of flags:
          flags,
          FNONE  = 0,
          FSHARP = 1,
          FMINUS = 2,
          FPLUS  = 4,
          FZERO  = 8,
          FSPACE = 16,
          FWIDTH = 32,
          FPREC  = 64,
          FPREC0 = 128;

      function CHECK_FOR_FLAGS() {
        if (flags&FWIDTH) { $Kernel.$raise($$$('ArgumentError'), "flag after width") }
        if (flags&FPREC0) { $Kernel.$raise($$$('ArgumentError'), "flag after precision") }
      }

      function CHECK_FOR_WIDTH() {
        if (flags&FWIDTH) { $Kernel.$raise($$$('ArgumentError'), "width given twice") }
        if (flags&FPREC0) { $Kernel.$raise($$$('ArgumentError'), "width after precision") }
      }

      function GET_NTH_ARG(num) {
        if (num >= args.length) { $Kernel.$raise($$$('ArgumentError'), "too few arguments") }
        return args[num];
      }

      function GET_NEXT_ARG() {
        switch (pos_arg_num) {
        case -1: $Kernel.$raise($$$('ArgumentError'), "unnumbered(" + (seq_arg_num) + ") mixed with numbered") // raise
        case -2: $Kernel.$raise($$$('ArgumentError'), "unnumbered(" + (seq_arg_num) + ") mixed with named") // raise
        }
        pos_arg_num = seq_arg_num++;
        return GET_NTH_ARG(pos_arg_num - 1);
      }

      function GET_POS_ARG(num) {
        if (pos_arg_num > 0) {
          $Kernel.$raise($$$('ArgumentError'), "numbered(" + (num) + ") after unnumbered(" + (pos_arg_num) + ")")
        }
        if (pos_arg_num === -2) {
          $Kernel.$raise($$$('ArgumentError'), "numbered(" + (num) + ") after named")
        }
        if (num < 1) {
          $Kernel.$raise($$$('ArgumentError'), "invalid index - " + (num) + "$")
        }
        pos_arg_num = -1;
        return GET_NTH_ARG(num - 1);
      }

      function GET_ARG() {
        return (next_arg === undefined ? GET_NEXT_ARG() : next_arg);
      }

      function READ_NUM(label) {
        var num, str = '';
        for (;; i++) {
          if (i === len) {
            $Kernel.$raise($$$('ArgumentError'), "malformed format string - %*[0-9]")
          }
          if (format_string.charCodeAt(i) < 48 || format_string.charCodeAt(i) > 57) {
            i--;
            num = parseInt(str, 10) || 0;
            if (num > 2147483647) {
              $Kernel.$raise($$$('ArgumentError'), "" + (label) + " too big")
            }
            return num;
          }
          str += format_string.charAt(i);
        }
      }

      function READ_NUM_AFTER_ASTER(label) {
        var arg, num = READ_NUM(label);
        if (format_string.charAt(i + 1) === '$') {
          i++;
          arg = GET_POS_ARG(num);
        } else {
          arg = GET_NEXT_ARG();
        }
        return (arg).$to_int();
      }

      for (i = format_string.indexOf('%'); i !== -1; i = format_string.indexOf('%', i)) {
        str = undefined;

        flags = FNONE;
        width = -1;
        precision = -1;
        next_arg = undefined;

        end_slice = i;

        i++;

        switch (format_string.charAt(i)) {
        case '%':
          begin_slice = i;
          // no-break
        case '':
        case '\n':
        case '\0':
          i++;
          continue;
        }

        format_sequence: for (; i < len; i++) {
          switch (format_string.charAt(i)) {

          case ' ':
            CHECK_FOR_FLAGS();
            flags |= FSPACE;
            continue format_sequence;

          case '#':
            CHECK_FOR_FLAGS();
            flags |= FSHARP;
            continue format_sequence;

          case '+':
            CHECK_FOR_FLAGS();
            flags |= FPLUS;
            continue format_sequence;

          case '-':
            CHECK_FOR_FLAGS();
            flags |= FMINUS;
            continue format_sequence;

          case '0':
            CHECK_FOR_FLAGS();
            flags |= FZERO;
            continue format_sequence;

          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            tmp_num = READ_NUM('width');
            if (format_string.charAt(i + 1) === '$') {
              if (i + 2 === len) {
                str = '%';
                i++;
                break format_sequence;
              }
              if (next_arg !== undefined) {
                $Kernel.$raise($$$('ArgumentError'), "value given twice - %" + (tmp_num) + "$")
              }
              next_arg = GET_POS_ARG(tmp_num);
              i++;
            } else {
              CHECK_FOR_WIDTH();
              flags |= FWIDTH;
              width = tmp_num;
            }
            continue format_sequence;

          case '<':
          case '\{':
            closing_brace_char = (format_string.charAt(i) === '<' ? '>' : '\}');
            hash_parameter_key = '';

            i++;

            for (;; i++) {
              if (i === len) {
                $Kernel.$raise($$$('ArgumentError'), "malformed name - unmatched parenthesis")
              }
              if (format_string.charAt(i) === closing_brace_char) {

                if (pos_arg_num > 0) {
                  $Kernel.$raise($$$('ArgumentError'), "named " + (hash_parameter_key) + " after unnumbered(" + (pos_arg_num) + ")")
                }
                if (pos_arg_num === -1) {
                  $Kernel.$raise($$$('ArgumentError'), "named " + (hash_parameter_key) + " after numbered")
                }
                pos_arg_num = -2;

                if (args[0] === undefined || !args[0].$$is_hash) {
                  $Kernel.$raise($$$('ArgumentError'), "one hash required")
                }

                next_arg = (args[0]).$fetch(hash_parameter_key);

                if (closing_brace_char === '>') {
                  continue format_sequence;
                } else {
                  str = next_arg.toString();
                  if (precision !== -1) { str = str.slice(0, precision); }
                  if (flags&FMINUS) {
                    while (str.length < width) { str = str + ' '; }
                  } else {
                    while (str.length < width) { str = ' ' + str; }
                  }
                  break format_sequence;
                }
              }
              hash_parameter_key += format_string.charAt(i);
            }
            // raise

          case '*':
            i++;
            CHECK_FOR_WIDTH();
            flags |= FWIDTH;
            width = READ_NUM_AFTER_ASTER('width');
            if (width < 0) {
              flags |= FMINUS;
              width = -width;
            }
            continue format_sequence;

          case '.':
            if (flags&FPREC0) {
              $Kernel.$raise($$$('ArgumentError'), "precision given twice")
            }
            flags |= FPREC|FPREC0;
            precision = 0;
            i++;
            if (format_string.charAt(i) === '*') {
              i++;
              precision = READ_NUM_AFTER_ASTER('precision');
              if (precision < 0) {
                flags &= ~FPREC;
              }
              continue format_sequence;
            }
            precision = READ_NUM('precision');
            continue format_sequence;

          case 'd':
          case 'i':
          case 'u':
            arg = $Kernel.$Integer(GET_ARG());
            if (arg >= 0) {
              str = arg.toString();
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              str = (-arg).toString();
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                str = '-' + str;
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - 1) { str = '0' + str; }
                  str = '-' + str;
                } else {
                  str = '-' + str;
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            }
            break format_sequence;

          case 'b':
          case 'B':
          case 'o':
          case 'x':
          case 'X':
            switch (format_string.charAt(i)) {
            case 'b':
            case 'B':
              base_number = 2;
              base_prefix = '0b';
              base_neg_zero_regex = /^1+/;
              base_neg_zero_digit = '1';
              break;
            case 'o':
              base_number = 8;
              base_prefix = '0';
              base_neg_zero_regex = /^3?7+/;
              base_neg_zero_digit = '7';
              break;
            case 'x':
            case 'X':
              base_number = 16;
              base_prefix = '0x';
              base_neg_zero_regex = /^f+/;
              base_neg_zero_digit = 'f';
              break;
            }
            arg = $Kernel.$Integer(GET_ARG());
            if (arg >= 0) {
              str = arg.toString(base_number);
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0) - ((flags&FSHARP && arg !== 0) ? base_prefix.length : 0)) { str = '0' + str; }
                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              if (flags&FPLUS || flags&FSPACE) {
                str = (-arg).toString(base_number);
                while (str.length < precision) { str = '0' + str; }
                if (flags&FMINUS) {
                  if (flags&FSHARP) { str = base_prefix + str; }
                  str = '-' + str;
                  while (str.length < width) { str = str + ' '; }
                } else {
                  if (flags&FZERO && precision === -1) {
                    while (str.length < width - 1 - (flags&FSHARP ? 2 : 0)) { str = '0' + str; }
                    if (flags&FSHARP) { str = base_prefix + str; }
                    str = '-' + str;
                  } else {
                    if (flags&FSHARP) { str = base_prefix + str; }
                    str = '-' + str;
                    while (str.length < width) { str = ' ' + str; }
                  }
                }
              } else {
                str = (arg >>> 0).toString(base_number).replace(base_neg_zero_regex, base_neg_zero_digit);
                while (str.length < precision - 2) { str = base_neg_zero_digit + str; }
                if (flags&FMINUS) {
                  str = '..' + str;
                  if (flags&FSHARP) { str = base_prefix + str; }
                  while (str.length < width) { str = str + ' '; }
                } else {
                  if (flags&FZERO && precision === -1) {
                    while (str.length < width - 2 - (flags&FSHARP ? base_prefix.length : 0)) { str = base_neg_zero_digit + str; }
                    str = '..' + str;
                    if (flags&FSHARP) { str = base_prefix + str; }
                  } else {
                    str = '..' + str;
                    if (flags&FSHARP) { str = base_prefix + str; }
                    while (str.length < width) { str = ' ' + str; }
                  }
                }
              }
            }
            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase()) {
              str = str.toUpperCase();
            }
            break format_sequence;

          case 'f':
          case 'e':
          case 'E':
          case 'g':
          case 'G':
            arg = $Kernel.$Float(GET_ARG());
            if (arg >= 0 || isNaN(arg)) {
              if (arg === Infinity) {
                str = 'Inf';
              } else {
                switch (format_string.charAt(i)) {
                case 'f':
                  str = arg.toFixed(precision === -1 ? 6 : precision);
                  break;
                case 'e':
                case 'E':
                  str = arg.toExponential(precision === -1 ? 6 : precision);
                  break;
                case 'g':
                case 'G':
                  str = arg.toExponential();
                  exponent = parseInt(str.split('e')[1], 10);
                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                    str = arg.toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);
                  }
                  break;
                }
              }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && arg !== Infinity && !isNaN(arg)) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              if (arg === -Infinity) {
                str = 'Inf';
              } else {
                switch (format_string.charAt(i)) {
                case 'f':
                  str = (-arg).toFixed(precision === -1 ? 6 : precision);
                  break;
                case 'e':
                case 'E':
                  str = (-arg).toExponential(precision === -1 ? 6 : precision);
                  break;
                case 'g':
                case 'G':
                  str = (-arg).toExponential();
                  exponent = parseInt(str.split('e')[1], 10);
                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                    str = (-arg).toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);
                  }
                  break;
                }
              }
              if (flags&FMINUS) {
                str = '-' + str;
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && arg !== -Infinity) {
                  while (str.length < width - 1) { str = '0' + str; }
                  str = '-' + str;
                } else {
                  str = '-' + str;
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            }
            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase() && arg !== Infinity && arg !== -Infinity && !isNaN(arg)) {
              str = str.toUpperCase();
            }
            str = str.replace(/([eE][-+]?)([0-9])$/, '$10$2');
            break format_sequence;

          case 'a':
          case 'A':
            // Not implemented because there are no specs for this field type.
            $Kernel.$raise($$$('NotImplementedError'), "`A` and `a` format field types are not implemented in Opal yet")
            // raise

          case 'c':
            arg = GET_ARG();
            if ((arg)['$respond_to?']("to_ary")) { arg = (arg).$to_ary()[0]; }
            if ((arg)['$respond_to?']("to_str")) {
              str = (arg).$to_str();
            } else {
              str = String.fromCharCode($coerce_to(arg, $$$('Integer'), 'to_int'));
            }
            if (str.length !== 1) {
              $Kernel.$raise($$$('ArgumentError'), "%c requires a character")
            }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          case 'p':
            str = (GET_ARG()).$inspect();
            if (precision !== -1) { str = str.slice(0, precision); }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          case 's':
            str = (GET_ARG()).$to_s();
            if (precision !== -1) { str = str.slice(0, precision); }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          default:
            $Kernel.$raise($$$('ArgumentError'), "malformed format string - %" + (format_string.charAt(i)))
          }
        }

        if (str === undefined) {
          $Kernel.$raise($$$('ArgumentError'), "malformed format string - %")
        }

        result += format_string.slice(begin_slice, end_slice) + str;
        begin_slice = i + 1;
      }

      if ($gvars.DEBUG && pos_arg_num >= 0 && seq_arg_num < args.length) {
        $Kernel.$raise($$$('ArgumentError'), "too many arguments for format string")
      }

      return result + format_string.slice(begin_slice);
    ;
    }, -2);
    return $alias(self, "sprintf", "format");
  })('::')
};

Opal.modules["corelib/string/encoding"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $rb_plus = Opal.rb_plus, $truthy = Opal.truthy, $send = Opal.send, $defs = Opal.defs, $eqeq = Opal.eqeq, $def = Opal.def, $return_ivar = Opal.return_ivar, $return_val = Opal.return_val, $slice = Opal.slice, $Kernel = Opal.Kernel, $Opal = Opal.Opal, $rb_lt = Opal.rb_lt, $a, self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,+,[],clone,initialize,new,instance_eval,to_proc,each,const_set,tr,==,default_external,attr_accessor,singleton_class,attr_reader,raise,register,length,bytes,force_encoding,dup,bytesize,enum_for,each_byte,to_a,each_char,each_codepoint,coerce_to!,find,<,default_external=');
  
  self.$require("corelib/string");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Encoding');

    var $nesting = [self].concat($parent_nesting), $proto = self.$$prototype;

    $proto.name = $proto.dummy = nil;
    
    $defs(self, '$register', function $$register(name, options) {
      var block = $$register.$$p || nil, self = this, names = nil, $ret_or_1 = nil, ascii = nil, dummy = nil, encoding = nil, register = nil;

      $$register.$$p = null;
      
      ;
      if (options == null) options = (new Map());
      names = $rb_plus([name], ($truthy(($ret_or_1 = options['$[]']("aliases"))) ? ($ret_or_1) : ([])));
      ascii = ($truthy(($ret_or_1 = options['$[]']("ascii"))) && ($ret_or_1));
      dummy = ($truthy(($ret_or_1 = options['$[]']("dummy"))) && ($ret_or_1));
      if ($truthy(options['$[]']("inherits"))) {
        
        encoding = options['$[]']("inherits").$clone();
        encoding.$initialize(name, names, ascii, dummy);
      } else {
        encoding = self.$new(name, names, ascii, dummy)
      };
      if ((block !== nil)) {
        $send(encoding, 'instance_eval', [], block.$to_proc())
      };
      register = Opal.encodings;
      return $send(names, 'each', [], function $$1(encoding_name){var self = $$1.$$s == null ? this : $$1.$$s;

        
        if (encoding_name == null) encoding_name = nil;
        self.$const_set(encoding_name.$tr("-", "_"), encoding);
        return register[encoding_name] = encoding;}, {$$s: self});
    }, -2);
    $defs(self, '$find', function $$find(name) {
      var self = this;

      
      if ($eqeq(name, "default_external")) {
        return self.$default_external()
      };
      return Opal.find_encoding(name);;
    });
    self.$singleton_class().$attr_accessor("default_external");
    self.$attr_reader("name", "names");
    
    $def(self, '$initialize', function $$initialize(name, names, ascii, dummy) {
      var self = this;

      
      self.name = name;
      self.names = names;
      self.ascii = ascii;
      return (self.dummy = dummy);
    });
    
    $def(self, '$ascii_compatible?', $return_ivar("ascii"));
    
    $def(self, '$dummy?', $return_ivar("dummy"));
    
    $def(self, '$binary?', $return_val(false));
    
    $def(self, '$to_s', $return_ivar("name"));
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "#<Encoding:" + (self.name) + (($truthy(self.dummy) ? (" (dummy)") : nil)) + ">"
    });
    
    $def(self, '$charsize', function $$charsize(string) {
      
      
      var len = 0;
      for (var i = 0, length = string.length; i < length; i++) {
        var charcode = string.charCodeAt(i);
        if (!(charcode >= 0xD800 && charcode <= 0xDBFF)) {
          len++;
        }
      }
      return len;
    
    });
    
    $def(self, '$each_char', function $$each_char(string) {
      var block = $$each_char.$$p || nil;

      $$each_char.$$p = null;
      
      ;
      
      var low_surrogate = "";
      for (var i = 0, length = string.length; i < length; i++) {
        var charcode = string.charCodeAt(i);
        var chr = string.charAt(i);
        if (charcode >= 0xDC00 && charcode <= 0xDFFF) {
          low_surrogate = chr;
          continue;
        }
        else if (charcode >= 0xD800 && charcode <= 0xDBFF) {
          chr = low_surrogate + chr;
        }
        if (string.encoding.name != "UTF-8") {
          chr = new String(chr);
          chr.encoding = string.encoding;
        }
        Opal.yield1(block, chr);
      }
    ;
    });
    
    $def(self, '$each_byte', function $$each_byte($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return $Kernel.$raise($$$('NotImplementedError'));
    }, -1);
    
    $def(self, '$bytesize', function $$bytesize($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return $Kernel.$raise($$$('NotImplementedError'));
    }, -1);
    $klass('::', $$$('StandardError'), 'EncodingError');
    $klass('::', $$$('EncodingError'), 'CompatibilityError');
    return ($klass($nesting[0], $$$('EncodingError'), 'UndefinedConversionError'), nil);
  })('::', null, $nesting);
  $send($$$('Encoding'), 'register', ["UTF-8", (new Map([["aliases", ["CP65001"]], ["ascii", true]]))], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;

    
    
    $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      $$each_byte.$$p = null;
      
      ;
      
      // Taken from: https://github.com/feross/buffer/blob/f52dffd9df0445b93c0c9065c2f8f0f46b2c729a/index.js#L1954-L2032
      var units = Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);

        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) {
                Opal.yield1(block, 0xEF);
                Opal.yield1(block, 0xBF);
                Opal.yield1(block, 0xBD);
              }
              continue;
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) {
                Opal.yield1(block, 0xEF);
                Opal.yield1(block, 0xBF);
                Opal.yield1(block, 0xBD);
              }
              continue;
            }

            // valid lead
            leadSurrogate = codePoint;

            continue;
          }

          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) {
              Opal.yield1(block, 0xEF);
              Opal.yield1(block, 0xBF);
              Opal.yield1(block, 0xBD);
            }
            leadSurrogate = codePoint;
            continue;
          }

          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) {
            Opal.yield1(block, 0xEF);
            Opal.yield1(block, 0xBF);
            Opal.yield1(block, 0xBD);
          }
        }

        leadSurrogate = null;

        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break;
          Opal.yield1(block, codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break;
          Opal.yield1(block, codePoint >> 0x6 | 0xC0);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break;
          Opal.yield1(block, codePoint >> 0xC | 0xE0);
          Opal.yield1(block, codePoint >> 0x6 & 0x3F | 0x80);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break;
          Opal.yield1(block, codePoint >> 0x12 | 0xF0);
          Opal.yield1(block, codePoint >> 0xC & 0x3F | 0x80);
          Opal.yield1(block, codePoint >> 0x6 & 0x3F | 0x80);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else {
          // Invalid code point
        }
      }
    ;
    });
    return $def(self, '$bytesize', function $$bytesize(string) {
      
      return string.$bytes().$length()
    });}, {$$s: self});
  $send($$$('Encoding'), 'register', ["UTF-16LE"], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

    
    
    $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      $$each_byte.$$p = null;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
      }
    ;
    });
    return $def(self, '$bytesize', function $$bytesize(string) {
      
      return string.length * 2;
    });}, {$$s: self});
  $send($$$('Encoding'), 'register', ["UTF-16BE", (new Map([["inherits", $$$($$$('Encoding'), 'UTF_16LE')]]))], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

    return $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      $$each_byte.$$p = null;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code >> 8);
        Opal.yield1(block, code & 0xff);
      }
    ;
    })}, {$$s: self});
  $send($$$('Encoding'), 'register', ["UTF-32LE"], function $$5(){var self = $$5.$$s == null ? this : $$5.$$s;

    
    
    $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      $$each_byte.$$p = null;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
        Opal.yield1(block, 0);
        Opal.yield1(block, 0);
      }
    ;
    });
    return $def(self, '$bytesize', function $$bytesize(string) {
      
      return string.length * 4;
    });}, {$$s: self});
  $send($$$('Encoding'), 'register', ["UTF-32BE", (new Map([["inherits", $$$($$$('Encoding'), 'UTF_32LE')]]))], function $$6(){var self = $$6.$$s == null ? this : $$6.$$s;

    return $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      $$each_byte.$$p = null;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, 0);
        Opal.yield1(block, 0);
        Opal.yield1(block, code >> 8);
        Opal.yield1(block, code & 0xff);
      }
    ;
    })}, {$$s: self});
  $send($$$('Encoding'), 'register', ["ASCII-8BIT", (new Map([["aliases", ["BINARY"]], ["ascii", true]]))], function $$7(){var self = $$7.$$s == null ? this : $$7.$$s;

    
    
    $def(self, '$each_char', function $$each_char(string) {
      var block = $$each_char.$$p || nil;

      $$each_char.$$p = null;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var chr = new String(string.charAt(i));
        chr.encoding = string.encoding;
        Opal.yield1(block, chr);
      }
    ;
    });
    
    $def(self, '$charsize', function $$charsize(string) {
      
      return string.length;
    });
    
    $def(self, '$each_byte', function $$each_byte(string) {
      var block = $$each_byte.$$p || nil;

      $$each_byte.$$p = null;
      
      ;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);
        Opal.yield1(block, code & 0xff);
      }
    ;
    });
    
    $def(self, '$bytesize', function $$bytesize(string) {
      
      return string.length;
    });
    return $def(self, '$binary?', $return_val(true));}, {$$s: self});
  $$$('Encoding').$register("ISO-8859-1", (new Map([["aliases", ["ISO8859-1"]], ["ascii", true], ["inherits", $$$($$$('Encoding'), 'ASCII_8BIT')]])));
  $$$('Encoding').$register("US-ASCII", (new Map([["aliases", ["ASCII"]], ["ascii", true], ["inherits", $$$($$$('Encoding'), 'ASCII_8BIT')]])));
  (function($base, $super) {
    var self = $klass($base, $super, 'String');

    var $proto = self.$$prototype;

    $proto.internal_encoding = $proto.bytes = $proto.encoding = nil;
    
    self.$attr_reader("encoding");
    self.$attr_reader("internal_encoding");
    Opal.prop(String.prototype, 'bytes', nil);
    Opal.prop(String.prototype, 'encoding', $$$($$$('Encoding'), 'UTF_8'));
    Opal.prop(String.prototype, 'internal_encoding', $$$($$$('Encoding'), 'UTF_8'));
    
    $def(self, '$b', function $$b() {
      var self = this;

      return self.$dup().$force_encoding("binary")
    });
    
    $def(self, '$bytesize', function $$bytesize() {
      var self = this;

      return self.internal_encoding.$bytesize(self)
    });
    
    $def(self, '$each_byte', function $$each_byte() {
      var block = $$each_byte.$$p || nil, self = this;

      $$each_byte.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_byte"], function $$8(){var self = $$8.$$s == null ? this : $$8.$$s;

          return self.$bytesize()}, {$$s: self})
      };
      $send(self.internal_encoding, 'each_byte', [self], block.$to_proc());
      return self;
    });
    
    $def(self, '$bytes', function $$bytes() {
      var self = this, $ret_or_1 = nil;

      
      
      if (typeof self === 'string') {
        return (new String(self)).$each_byte().$to_a();
      }
    ;
      self.bytes = ($truthy(($ret_or_1 = self.bytes)) ? ($ret_or_1) : (self.$each_byte().$to_a()));
      return self.bytes.$dup();
    });
    
    $def(self, '$each_char', function $$each_char() {
      var block = $$each_char.$$p || nil, self = this;

      $$each_char.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return $send(self, 'enum_for', ["each_char"], function $$9(){var self = $$9.$$s == null ? this : $$9.$$s;

          return self.$length()}, {$$s: self})
      };
      $send(self.encoding, 'each_char', [self], block.$to_proc());
      return self;
    });
    
    $def(self, '$chars', function $$chars() {
      var block = $$chars.$$p || nil, self = this;

      $$chars.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return self.$each_char().$to_a()
      };
      return $send(self, 'each_char', [], block.$to_proc());
    });
    
    $def(self, '$each_codepoint', function $$each_codepoint() {
      var block = $$each_codepoint.$$p || nil, self = this;

      $$each_codepoint.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("each_codepoint")
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        Opal.yield1(block, self.codePointAt(i));
      }
    ;
      return self;
    });
    
    $def(self, '$codepoints', function $$codepoints() {
      var block = $$codepoints.$$p || nil, self = this;

      $$codepoints.$$p = null;
      
      ;
      if ((block !== nil)) {
        return $send(self, 'each_codepoint', [], block.$to_proc())
      };
      return self.$each_codepoint().$to_a();
    });
    
    $def(self, '$encode', function $$encode(encoding) {
      var self = this;

      return Opal.enc(self, encoding);
    });
    
    $def(self, '$force_encoding', function $$force_encoding(encoding) {
      var self = this;

      
      var str = self;

      if (encoding === str.encoding) { return str; }

      encoding = $Opal['$coerce_to!'](encoding, $$$('String'), "to_s");
      encoding = $$$('Encoding').$find(encoding);

      if (encoding === str.encoding) { return str; }

      str = Opal.set_encoding(str, encoding);

      return str;
    
    });
    
    $def(self, '$getbyte', function $$getbyte(idx) {
      var self = this, string_bytes = nil;

      
      string_bytes = self.$bytes();
      idx = $Opal['$coerce_to!'](idx, $$$('Integer'), "to_int");
      if ($truthy($rb_lt(string_bytes.$length(), idx))) {
        return nil
      };
      return string_bytes['$[]'](idx);
    });
    
    $def(self, '$initialize_copy', function $$initialize_copy(other) {
      
      return "\n" + "      self.encoding = other.encoding;\n" + "      self.internal_encoding = other.internal_encoding;\n" + "    "
    });
    return $def(self, '$valid_encoding?', $return_val(true));
  })('::', null);
  return ($a = [$$$($$('Encoding'), 'UTF_8')], $send($$$('Encoding'), 'default_external=', $a), $a[$a.length - 1]);
};

Opal.modules["corelib/math"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $type_error = Opal.type_error, $module = Opal.module, $const_set = Opal.const_set, $Class = Opal.Class, $slice = Opal.slice, $Kernel = Opal.Kernel, $defs = Opal.defs, $truthy = Opal.truthy, $send = Opal.send, $def = Opal.def, $rb_minus = Opal.rb_minus, $eqeqeq = Opal.eqeqeq, $rb_divide = Opal.rb_divide, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('new,raise,Float,Integer,module_function,each,define_method,checked,float!,===,gamma,-,integer!,/,infinite?');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Math');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $const_set(self, 'E', Math.E);
    $const_set(self, 'PI', Math.PI);
    $const_set(self, 'DomainError', $Class.$new($$$('StandardError')));
    $defs(self, '$checked', function $$checked(method, $a) {
      var $post_args, args;

      
      $post_args = $slice(arguments, 1);
      args = $post_args;
      
      if (isNaN(args[0]) || (args.length == 2 && isNaN(args[1]))) {
        return NaN;
      }

      var result = Math[method].apply(null, args);

      if (isNaN(result)) {
        $Kernel.$raise($$('DomainError'), "Numerical argument is out of domain - \"" + (method) + "\"");
      }

      return result;
    ;
    }, -2);
    $defs(self, '$float!', function $Math_float$excl$1(value) {
      
      try {
        return $Kernel.$Float(value)
      } catch ($err) {
        if (Opal.rescue($err, [$$$('ArgumentError')])) {
          try {
            return $Kernel.$raise($type_error(value, $$$('Float')))
          } finally { Opal.pop_exception($err); }
        } else { throw $err; }
      }
    });
    $defs(self, '$integer!', function $Math_integer$excl$2(value) {
      
      try {
        return $Kernel.$Integer(value)
      } catch ($err) {
        if (Opal.rescue($err, [$$$('ArgumentError')])) {
          try {
            return $Kernel.$raise($type_error(value, $$$('Integer')))
          } finally { Opal.pop_exception($err); }
        } else { throw $err; }
      }
    });
    self.$module_function();
    if (!$truthy((typeof(Math.erf) !== "undefined"))) {
      
      Opal.prop(Math, 'erf', function(x) {
        var A1 =  0.254829592,
            A2 = -0.284496736,
            A3 =  1.421413741,
            A4 = -1.453152027,
            A5 =  1.061405429,
            P  =  0.3275911;

        var sign = 1;

        if (x < 0) {
            sign = -1;
        }

        x = Math.abs(x);

        var t = 1.0 / (1.0 + P * x);
        var y = 1.0 - (((((A5 * t + A4) * t) + A3) * t + A2) * t + A1) * t * Math.exp(-x * x);

        return sign * y;
      });
    
    };
    if (!$truthy((typeof(Math.erfc) !== "undefined"))) {
      
      Opal.prop(Math, 'erfc', function(x) {
        var z = Math.abs(x),
            t = 1.0 / (0.5 * z + 1.0);

        var A1 = t * 0.17087277 + -0.82215223,
            A2 = t * A1 + 1.48851587,
            A3 = t * A2 + -1.13520398,
            A4 = t * A3 + 0.27886807,
            A5 = t * A4 + -0.18628806,
            A6 = t * A5 + 0.09678418,
            A7 = t * A6 + 0.37409196,
            A8 = t * A7 + 1.00002368,
            A9 = t * A8,
            A10 = -z * z - 1.26551223 + A9;

        var a = t * Math.exp(A10);

        if (x < 0.0) {
          return 2.0 - a;
        }
        else {
          return a;
        }
      });
    
    };
    $send(["acos", "acosh", "asin", "asinh", "atan", "atanh", "cbrt", "cos", "cosh", "erf", "erfc", "exp", "sin", "sinh", "sqrt", "tanh"], 'each', [], function $Math$3(method){var self = $Math$3.$$s == null ? this : $Math$3.$$s;

      
      if (method == null) method = nil;
      return $send(self, 'define_method', [method], function $$4(x){
        
        if (x == null) x = nil;
        return $$$('Math').$checked(method, $$$('Math')['$float!'](x));});}, {$$s: self});
    
    $def(self, '$atan2', function $$atan2(y, x) {
      
      return $$$('Math').$checked("atan2", $$$('Math')['$float!'](y), $$$('Math')['$float!'](x))
    });
    
    $def(self, '$hypot', function $$hypot(x, y) {
      
      return $$$('Math').$checked("hypot", $$$('Math')['$float!'](x), $$$('Math')['$float!'](y))
    });
    
    $def(self, '$frexp', function $$frexp(x) {
      
      
      x = $$('Math')['$float!'](x);
      
      if (isNaN(x)) {
        return [NaN, 0];
      }

      var ex   = Math.floor(Math.log(Math.abs(x)) / Math.log(2)) + 1,
          frac = x / Math.pow(2, ex);

      return [frac, ex];
    ;
    });
    
    $def(self, '$gamma', function $$gamma(n) {
      
      
      n = $$('Math')['$float!'](n);
      
      var i, t, x, value, result, twoN, threeN, fourN, fiveN;

      var G = 4.7421875;

      var P = [
         0.99999999999999709182,
         57.156235665862923517,
        -59.597960355475491248,
         14.136097974741747174,
        -0.49191381609762019978,
         0.33994649984811888699e-4,
         0.46523628927048575665e-4,
        -0.98374475304879564677e-4,
         0.15808870322491248884e-3,
        -0.21026444172410488319e-3,
         0.21743961811521264320e-3,
        -0.16431810653676389022e-3,
         0.84418223983852743293e-4,
        -0.26190838401581408670e-4,
         0.36899182659531622704e-5
      ];


      if (isNaN(n)) {
        return NaN;
      }

      if (n === 0 && 1 / n < 0) {
        return -Infinity;
      }

      if (n === -1 || n === -Infinity) {
        $Kernel.$raise($$('DomainError'), "Numerical argument is out of domain - \"gamma\"");
      }

      if ($$('Integer')['$==='](n)) {
        if (n <= 0) {
          return isFinite(n) ? Infinity : NaN;
        }

        if (n > 171) {
          return Infinity;
        }

        value  = n - 2;
        result = n - 1;

        while (value > 1) {
          result *= value;
          value--;
        }

        if (result == 0) {
          result = 1;
        }

        return result;
      }

      if (n < 0.5) {
        return Math.PI / (Math.sin(Math.PI * n) * $$$('Math').$gamma($rb_minus(1, n)));
      }

      if (n >= 171.35) {
        return Infinity;
      }

      if (n > 85.0) {
        twoN   = n * n;
        threeN = twoN * n;
        fourN  = threeN * n;
        fiveN  = fourN * n;

        return Math.sqrt(2 * Math.PI / n) * Math.pow((n / Math.E), n) *
          (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) -
          571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) +
          5246819 / (75246796800 * fiveN * n));
      }

      n -= 1;
      x  = P[0];

      for (i = 1; i < P.length; ++i) {
        x += P[i] / (n + i);
      }

      t = n + G + 0.5;

      return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
    ;
    });
    
    $def(self, '$ldexp', function $$ldexp(mantissa, exponent) {
      
      
      mantissa = $$('Math')['$float!'](mantissa);
      exponent = $$('Math')['$integer!'](exponent);
      
      if (isNaN(exponent)) {
        $Kernel.$raise($$$('RangeError'), "float NaN out of range of integer");
      }

      return mantissa * Math.pow(2, exponent);
    ;
    });
    
    $def(self, '$lgamma', function $$lgamma(n) {
      
      
      if (n == -1) {
        return [Infinity, 1];
      }
      else {
        return [Math.log(Math.abs($$$('Math').$gamma(n))), $$$('Math').$gamma(n) < 0 ? -1 : 1];
      }
    
    });
    
    $def(self, '$log', function $$log(x, base) {
      
      
      ;
      if ($eqeqeq($$$('String'), x)) {
        $Kernel.$raise($type_error(x, $$$('Float')))
      };
      if ($truthy(base == null)) {
        return $$$('Math').$checked("log", $$$('Math')['$float!'](x))
      } else {
        
        if ($eqeqeq($$$('String'), base)) {
          $Kernel.$raise($type_error(base, $$$('Float')))
        };
        return $rb_divide($$$('Math').$checked("log", $$$('Math')['$float!'](x)), $$$('Math').$checked("log", $$$('Math')['$float!'](base)));
      };
    }, -2);
    
    $def(self, '$log10', function $$log10(x) {
      
      
      if ($eqeqeq($$$('String'), x)) {
        $Kernel.$raise($type_error(x, $$$('Float')))
      };
      return $$$('Math').$checked("log10", $$$('Math')['$float!'](x));
    });
    
    $def(self, '$log2', function $$log2(x) {
      
      
      if ($eqeqeq($$$('String'), x)) {
        $Kernel.$raise($type_error(x, $$$('Float')))
      };
      return $$$('Math').$checked("log2", $$$('Math')['$float!'](x));
    });
    return $def(self, '$tan', function $$tan(x) {
      
      
      x = $$$('Math')['$float!'](x);
      if ($truthy(x['$infinite?']())) {
        return $$$($$$('Float'), 'NAN')
      };
      return $$$('Math').$checked("tan", $$$('Math')['$float!'](x));
    });
  })('::', $nesting)
};

Opal.modules["corelib/complex/base"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $truthy = Opal.truthy, $def = Opal.def, $klass = Opal.klass, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('new,from_string');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$Complex', function $$Complex(real, imag) {
      
      
      if (imag == null) imag = nil;
      if ($truthy(imag)) {
        return $$('Complex').$new(real, imag)
      } else {
        return $$('Complex').$new(real, 0)
      };
    }, -2)
  })('::', $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$to_c', function $$to_c() {
      var self = this;

      return $$('Complex').$from_string(self)
    })
  })('::', null, $nesting);
};

Opal.modules["corelib/complex"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $defs = Opal.defs, $rb_times = Opal.rb_times, $def = Opal.def, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $rb_divide = Opal.rb_divide, $eqeq = Opal.eqeq, $to_ary = Opal.to_ary, $rb_gt = Opal.rb_gt, $neqeq = Opal.neqeq, $return_val = Opal.return_val, $const_set = Opal.const_set, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,real?,===,raise,new,*,cos,sin,attr_reader,freeze,class,==,real,imag,Complex,-@,+,__coerced__,-,nan?,/,conj,abs2,quo,polar,exp,log,>,!=,divmod,**,hypot,atan2,lcm,denominator,finite?,hash,infinite?,numerator,abs,arg,rationalize,to_f,to_i,to_r,inspect,zero?,positive?,Rational,rect,angle');
  
  self.$require("corelib/numeric");
  self.$require("corelib/complex/base");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Complex');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.real = $proto.imag = nil;
    
    $defs(self, '$rect', function $$rect(real, imag) {
      var self = this;

      
      if (imag == null) imag = 0;
      if (!((($eqeqeq($$$('Numeric'), real) && ($truthy(real['$real?']()))) && ($eqeqeq($$$('Numeric'), imag))) && ($truthy(imag['$real?']())))) {
        $Kernel.$raise($$$('TypeError'), "not a real")
      };
      return self.$new(real, imag);
    }, -2);
    $defs(self, '$polar', function $$polar(r, theta) {
      var self = this;

      
      if (theta == null) theta = 0;
      if (!((($eqeqeq($$$('Numeric'), r) && ($truthy(r['$real?']()))) && ($eqeqeq($$$('Numeric'), theta))) && ($truthy(theta['$real?']())))) {
        $Kernel.$raise($$$('TypeError'), "not a real")
      };
      return self.$new($rb_times(r, $$$('Math').$cos(theta)), $rb_times(r, $$$('Math').$sin(theta)));
    }, -2);
    self.$attr_reader("real", "imag");
    
    $def(self, '$initialize', function $$initialize(real, imag) {
      var self = this;

      
      if (imag == null) imag = 0;
      self.real = real;
      self.imag = imag;
      return self.$freeze();
    }, -2);
    
    $def(self, '$coerce', function $$coerce(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        return [other, self]
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return [$$$('Complex').$new(other, 0), self]
      } else {
        return $Kernel.$raise($$$('TypeError'), "" + (other.$class()) + " can't be coerced into Complex")
      }
    });
    
    $def(self, '$==', function $Complex_$eq_eq$1(other) {
      var self = this, $ret_or_1 = nil;

      if ($eqeqeq($$$('Complex'), other)) {
        if ($truthy(($ret_or_1 = self.real['$=='](other.$real())))) {
          return self.imag['$=='](other.$imag())
        } else {
          return $ret_or_1
        }
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        if ($truthy(($ret_or_1 = self.real['$=='](other)))) {
          return self.imag['$=='](0)
        } else {
          return $ret_or_1
        }
      } else {
        return other['$=='](self)
      }
    });
    
    $def(self, '$-@', function $Complex_$minus$$2() {
      var self = this;

      return $Kernel.$Complex(self.real['$-@'](), self.imag['$-@']())
    });
    
    $def(self, '$+', function $Complex_$plus$3(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        return $Kernel.$Complex($rb_plus(self.real, other.$real()), $rb_plus(self.imag, other.$imag()))
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return $Kernel.$Complex($rb_plus(self.real, other), self.imag)
      } else {
        return self.$__coerced__("+", other)
      }
    });
    
    $def(self, '$-', function $Complex_$minus$4(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        return $Kernel.$Complex($rb_minus(self.real, other.$real()), $rb_minus(self.imag, other.$imag()))
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return $Kernel.$Complex($rb_minus(self.real, other), self.imag)
      } else {
        return self.$__coerced__("-", other)
      }
    });
    
    $def(self, '$*', function $Complex_$$5(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        return $Kernel.$Complex($rb_minus($rb_times(self.real, other.$real()), $rb_times(self.imag, other.$imag())), $rb_plus($rb_times(self.real, other.$imag()), $rb_times(self.imag, other.$real())))
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return $Kernel.$Complex($rb_times(self.real, other), $rb_times(self.imag, other))
      } else {
        return self.$__coerced__("*", other)
      }
    });
    
    $def(self, '$/', function $Complex_$slash$6(other) {
      var self = this;

      if ($eqeqeq($$$('Complex'), other)) {
        if ((((($eqeqeq($$$('Number'), self.real) && ($truthy(self.real['$nan?']()))) || (($eqeqeq($$$('Number'), self.imag) && ($truthy(self.imag['$nan?']()))))) || (($eqeqeq($$$('Number'), other.$real()) && ($truthy(other.$real()['$nan?']()))))) || (($eqeqeq($$$('Number'), other.$imag()) && ($truthy(other.$imag()['$nan?']())))))) {
          return $$$('Complex').$new($$$($$$('Float'), 'NAN'), $$$($$$('Float'), 'NAN'))
        } else {
          return $rb_divide($rb_times(self, other.$conj()), other.$abs2())
        }
      } else if (($eqeqeq($$$('Numeric'), other) && ($truthy(other['$real?']())))) {
        return $Kernel.$Complex(self.real.$quo(other), self.imag.$quo(other))
      } else {
        return self.$__coerced__("/", other)
      }
    });
    
    $def(self, '$**', function $Complex_$$$7(other) {
      var $a, $b, self = this, r = nil, theta = nil, ore = nil, oim = nil, nr = nil, ntheta = nil, x = nil, z = nil, n = nil, div = nil, mod = nil;

      
      if ($eqeq(other, 0)) {
        return $$$('Complex').$new(1, 0)
      };
      if ($eqeqeq($$$('Complex'), other)) {
        
        $b = self.$polar(), $a = $to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;
        ore = other.$real();
        oim = other.$imag();
        nr = $$$('Math').$exp($rb_minus($rb_times(ore, $$$('Math').$log(r)), $rb_times(oim, theta)));
        ntheta = $rb_plus($rb_times(theta, ore), $rb_times(oim, $$$('Math').$log(r)));
        return $$$('Complex').$polar(nr, ntheta);
      } else if ($eqeqeq($$$('Integer'), other)) {
        if ($truthy($rb_gt(other, 0))) {
          
          x = self;
          z = x;
          n = $rb_minus(other, 1);
          while ($neqeq(n, 0)) {
          
            $b = n.$divmod(2), $a = $to_ary($b), (div = ($a[0] == null ? nil : $a[0])), (mod = ($a[1] == null ? nil : $a[1])), $b;
            while ($eqeq(mod, 0)) {
            
              x = $Kernel.$Complex($rb_minus($rb_times(x.$real(), x.$real()), $rb_times(x.$imag(), x.$imag())), $rb_times($rb_times(2, x.$real()), x.$imag()));
              n = div;
              $b = n.$divmod(2), $a = $to_ary($b), (div = ($a[0] == null ? nil : $a[0])), (mod = ($a[1] == null ? nil : $a[1])), $b;
            };
            z = $rb_times(z, x);
            n = $rb_minus(n, 1);
          };
          return z;
        } else {
          return $rb_divide($$$('Rational').$new(1, 1), self)['$**'](other['$-@']())
        }
      } else if (($eqeqeq($$$('Float'), other) || ($eqeqeq($$$('Rational'), other)))) {
        
        $b = self.$polar(), $a = $to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;
        return $$$('Complex').$polar(r['$**'](other), $rb_times(theta, other));
      } else {
        return self.$__coerced__("**", other)
      };
    });
    
    $def(self, '$abs', function $$abs() {
      var self = this;

      return $$$('Math').$hypot(self.real, self.imag)
    });
    
    $def(self, '$abs2', function $$abs2() {
      var self = this;

      return $rb_plus($rb_times(self.real, self.real), $rb_times(self.imag, self.imag))
    });
    
    $def(self, '$angle', function $$angle() {
      var self = this;

      return $$$('Math').$atan2(self.imag, self.real)
    });
    
    $def(self, '$conj', function $$conj() {
      var self = this;

      return $Kernel.$Complex(self.real, self.imag['$-@']())
    });
    
    $def(self, '$denominator', function $$denominator() {
      var self = this;

      return self.real.$denominator().$lcm(self.imag.$denominator())
    });
    
    $def(self, '$eql?', function $Complex_eql$ques$8(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = $$('Complex')['$==='](other))) ? (self.real.$class()['$=='](self.imag.$class())) : ($ret_or_2))))) {
        return self['$=='](other)
      } else {
        return $ret_or_1
      }
    });
    
    $def(self, '$fdiv', function $$fdiv(other) {
      var self = this;

      
      if (!$eqeqeq($$$('Numeric'), other)) {
        $Kernel.$raise($$$('TypeError'), "" + (other.$class()) + " can't be coerced into Complex")
      };
      return $rb_divide(self, other);
    });
    
    $def(self, '$finite?', function $Complex_finite$ques$9() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.real['$finite?']()))) {
        return self.imag['$finite?']()
      } else {
        return $ret_or_1
      }
    });
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return [$$$('Complex'), self.real, self.imag].$hash()
    });
    
    $def(self, '$infinite?', function $Complex_infinite$ques$10() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.real['$infinite?']()))) {
        return $ret_or_1
      } else {
        return self.imag['$infinite?']()
      }
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "(" + (self) + ")"
    });
    
    $def(self, '$numerator', function $$numerator() {
      var self = this, d = nil;

      
      d = self.$denominator();
      return $Kernel.$Complex($rb_times(self.real.$numerator(), $rb_divide(d, self.real.$denominator())), $rb_times(self.imag.$numerator(), $rb_divide(d, self.imag.$denominator())));
    });
    
    $def(self, '$polar', function $$polar() {
      var self = this;

      return [self.$abs(), self.$arg()]
    });
    
    $def(self, '$rationalize', function $$rationalize(eps) {
      var self = this;

      
      ;
      
      if (arguments.length > 1) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }
    ;
      if ($neqeq(self.imag, 0)) {
        $Kernel.$raise($$$('RangeError'), "can't convert " + (self) + " into Rational")
      };
      return self.$real().$rationalize(eps);
    }, -1);
    
    $def(self, '$real?', $return_val(false));
    
    $def(self, '$rect', function $$rect() {
      var self = this;

      return [self.real, self.imag]
    });
    
    $def(self, '$to_f', function $$to_f() {
      var self = this;

      
      if (!$eqeq(self.imag, 0)) {
        $Kernel.$raise($$$('RangeError'), "can't convert " + (self) + " into Float")
      };
      return self.real.$to_f();
    });
    
    $def(self, '$to_i', function $$to_i() {
      var self = this;

      
      if (!$eqeq(self.imag, 0)) {
        $Kernel.$raise($$$('RangeError'), "can't convert " + (self) + " into Integer")
      };
      return self.real.$to_i();
    });
    
    $def(self, '$to_r', function $$to_r() {
      var self = this;

      
      if (!$eqeq(self.imag, 0)) {
        $Kernel.$raise($$$('RangeError'), "can't convert " + (self) + " into Rational")
      };
      return self.real.$to_r();
    });
    
    $def(self, '$to_s', function $$to_s() {
      var self = this, result = nil;

      
      result = self.real.$inspect();
      result = $rb_plus(result, (((($eqeqeq($$$('Number'), self.imag) && ($truthy(self.imag['$nan?']()))) || ($truthy(self.imag['$positive?']()))) || ($truthy(self.imag['$zero?']()))) ? ("+") : ("-")));
      result = $rb_plus(result, self.imag.$abs().$inspect());
      if (($eqeqeq($$$('Number'), self.imag) && (($truthy(self.imag['$nan?']()) || ($truthy(self.imag['$infinite?']())))))) {
        result = $rb_plus(result, "*")
      };
      return $rb_plus(result, "i");
    });
    $const_set($nesting[0], 'I', self.$new(0, 1));
    $defs(self, '$from_string', function $$from_string(str) {
      
      
      var re = /[+-]?[\d_]+(\.[\d_]+)?(e\d+)?/,
          match = str.match(re),
          real, imag, denominator;

      function isFloat() {
        return re.test(str);
      }

      function cutFloat() {
        var match = str.match(re);
        var number = match[0];
        str = str.slice(number.length);
        return number.replace(/_/g, '');
      }

      // handles both floats and rationals
      function cutNumber() {
        if (isFloat()) {
          var numerator = parseFloat(cutFloat());

          if (str[0] === '/') {
            // rational real part
            str = str.slice(1);

            if (isFloat()) {
              var denominator = parseFloat(cutFloat());
              return $Kernel.$Rational(numerator, denominator);
            } else {
              // reverting '/'
              str = '/' + str;
              return numerator;
            }
          } else {
            // float real part, no denominator
            return numerator;
          }
        } else {
          return null;
        }
      }

      real = cutNumber();

      if (!real) {
        if (str[0] === 'i') {
          // i => Complex(0, 1)
          return $Kernel.$Complex(0, 1);
        }
        if (str[0] === '-' && str[1] === 'i') {
          // -i => Complex(0, -1)
          return $Kernel.$Complex(0, -1);
        }
        if (str[0] === '+' && str[1] === 'i') {
          // +i => Complex(0, 1)
          return $Kernel.$Complex(0, 1);
        }
        // anything => Complex(0, 0)
        return $Kernel.$Complex(0, 0);
      }

      imag = cutNumber();
      if (!imag) {
        if (str[0] === 'i') {
          // 3i => Complex(0, 3)
          return $Kernel.$Complex(0, real);
        } else {
          // 3 => Complex(3, 0)
          return $Kernel.$Complex(real, 0);
        }
      } else {
        // 3+2i => Complex(3, 2)
        return $Kernel.$Complex(real, imag);
      }
    
    });
    (function(self, $parent_nesting) {
      
      return $alias(self, "rectangular", "rect")
    })(Opal.get_singleton_class(self), $nesting);
    $alias(self, "arg", "angle");
    $alias(self, "conjugate", "conj");
    $alias(self, "divide", "/");
    $alias(self, "imaginary", "imag");
    $alias(self, "magnitude", "abs");
    $alias(self, "phase", "arg");
    $alias(self, "quo", "/");
    $alias(self, "rectangular", "rect");
    
    Opal.udef(self, '$' + "negative?");;
    
    Opal.udef(self, '$' + "positive?");;
    
    
    Opal.udef(self, '$' + "step");;
    return nil;;
  })('::', $$$('Numeric'), $nesting);
};

Opal.modules["corelib/rational/base"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $def = Opal.def, $klass = Opal.klass, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('convert,from_string');
  
  (function($base) {
    var self = $module($base, 'Kernel');

    
    return $def(self, '$Rational', function $$Rational(numerator, denominator) {
      
      
      if (denominator == null) denominator = 1;
      return $$$('Rational').$convert(numerator, denominator);
    }, -2)
  })('::');
  return (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    return $def(self, '$to_r', function $$to_r() {
      var self = this;

      return $$$('Rational').$from_string(self)
    })
  })('::', null);
};

Opal.modules["corelib/rational"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $eqeq = Opal.eqeq, $Kernel = Opal.Kernel, $truthy = Opal.truthy, $rb_lt = Opal.rb_lt, $rb_divide = Opal.rb_divide, $defs = Opal.defs, $eqeqeq = Opal.eqeqeq, $not = Opal.not, $Opal = Opal.Opal, $def = Opal.def, $return_ivar = Opal.return_ivar, $rb_minus = Opal.rb_minus, $rb_times = Opal.rb_times, $rb_plus = Opal.rb_plus, $rb_gt = Opal.rb_gt, $rb_le = Opal.rb_le, $return_self = Opal.return_self, $alias = Opal.alias, self = Opal.top, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,to_i,==,raise,<,-@,new,gcd,/,nil?,===,reduce,to_r,!,equal?,coerce_to!,freeze,to_f,numerator,denominator,<=>,-,*,__coerced__,+,Rational,>,**,abs,ceil,with_precision,floor,hash,<=,truncate,send');
  
  self.$require("corelib/numeric");
  self.$require("corelib/rational/base");
  return (function($base, $super) {
    var self = $klass($base, $super, 'Rational');

    var $proto = self.$$prototype;

    $proto.num = $proto.den = nil;
    
    $defs(self, '$reduce', function $$reduce(num, den) {
      var self = this, gcd = nil;

      
      num = num.$to_i();
      den = den.$to_i();
      if ($eqeq(den, 0)) {
        $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0")
      } else if ($truthy($rb_lt(den, 0))) {
        
        num = num['$-@']();
        den = den['$-@']();
      } else if ($eqeq(den, 1)) {
        return self.$new(num, den)
      };
      gcd = num.$gcd(den);
      return self.$new($rb_divide(num, gcd), $rb_divide(den, gcd));
    });
    $defs(self, '$convert', function $$convert(num, den) {
      var self = this;

      
      if (($truthy(num['$nil?']()) || ($truthy(den['$nil?']())))) {
        $Kernel.$raise($$$('TypeError'), "cannot convert nil into Rational")
      };
      if (($eqeqeq($$$('Integer'), num) && ($eqeqeq($$$('Integer'), den)))) {
        return self.$reduce(num, den)
      };
      if ((($eqeqeq($$$('Float'), num) || ($eqeqeq($$$('String'), num))) || ($eqeqeq($$$('Complex'), num)))) {
        num = num.$to_r()
      };
      if ((($eqeqeq($$$('Float'), den) || ($eqeqeq($$$('String'), den))) || ($eqeqeq($$$('Complex'), den)))) {
        den = den.$to_r()
      };
      if (($truthy(den['$equal?'](1)) && ($not($$$('Integer')['$==='](num))))) {
        return $Opal['$coerce_to!'](num, $$$('Rational'), "to_r")
      } else if (($eqeqeq($$$('Numeric'), num) && ($eqeqeq($$$('Numeric'), den)))) {
        return $rb_divide(num, den)
      } else {
        return self.$reduce(num, den)
      };
    });
    
    $def(self, '$initialize', function $$initialize(num, den) {
      var self = this;

      
      self.num = num;
      self.den = den;
      return self.$freeze();
    });
    
    $def(self, '$numerator', $return_ivar("num"));
    
    $def(self, '$denominator', $return_ivar("den"));
    
    $def(self, '$coerce', function $$coerce(other) {
      var self = this, $ret_or_1 = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        return [other, self]
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return [other.$to_r(), self]
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return [other, self.$to_f()]
      } else {
        return nil
      }
    });
    
    $def(self, '$==', function $Rational_$eq_eq$1(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        if ($truthy(($ret_or_2 = self.num['$=='](other.$numerator())))) {
          return self.den['$=='](other.$denominator())
        } else {
          return $ret_or_2
        }
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        if ($truthy(($ret_or_2 = self.num['$=='](other)))) {
          return self.den['$=='](1)
        } else {
          return $ret_or_2
        }
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return self.$to_f()['$=='](other)
      } else {
        return other['$=='](self)
      }
    });
    
    $def(self, '$<=>', function $Rational_$lt_eq_gt$2(other) {
      var self = this, $ret_or_1 = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        return $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()))['$<=>'](0)
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return $rb_minus(self.num, $rb_times(self.den, other))['$<=>'](0)
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return self.$to_f()['$<=>'](other)
      } else {
        return self.$__coerced__("<=>", other)
      }
    });
    
    $def(self, '$+', function $Rational_$plus$3(other) {
      var self = this, $ret_or_1 = nil, num = nil, den = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        
        num = $rb_plus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));
        den = $rb_times(self.den, other.$denominator());
        return $Kernel.$Rational(num, den);
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return $Kernel.$Rational($rb_plus(self.num, $rb_times(other, self.den)), self.den)
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return $rb_plus(self.$to_f(), other)
      } else {
        return self.$__coerced__("+", other)
      }
    });
    
    $def(self, '$-', function $Rational_$minus$4(other) {
      var self = this, $ret_or_1 = nil, num = nil, den = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        
        num = $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));
        den = $rb_times(self.den, other.$denominator());
        return $Kernel.$Rational(num, den);
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return $Kernel.$Rational($rb_minus(self.num, $rb_times(other, self.den)), self.den)
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return $rb_minus(self.$to_f(), other)
      } else {
        return self.$__coerced__("-", other)
      }
    });
    
    $def(self, '$*', function $Rational_$$5(other) {
      var self = this, $ret_or_1 = nil, num = nil, den = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        
        num = $rb_times(self.num, other.$numerator());
        den = $rb_times(self.den, other.$denominator());
        return $Kernel.$Rational(num, den);
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        return $Kernel.$Rational($rb_times(self.num, other), self.den)
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return $rb_times(self.$to_f(), other)
      } else {
        return self.$__coerced__("*", other)
      }
    });
    
    $def(self, '$/', function $Rational_$slash$6(other) {
      var self = this, $ret_or_1 = nil, num = nil, den = nil;

      if ($eqeqeq($$$('Rational'), ($ret_or_1 = other))) {
        
        num = $rb_times(self.num, other.$denominator());
        den = $rb_times(self.den, other.$numerator());
        return $Kernel.$Rational(num, den);
      } else if ($eqeqeq($$$('Integer'), $ret_or_1)) {
        if ($eqeq(other, 0)) {
          return $rb_divide(self.$to_f(), 0.0)
        } else {
          return $Kernel.$Rational(self.num, $rb_times(self.den, other))
        }
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return $rb_divide(self.$to_f(), other)
      } else {
        return self.$__coerced__("/", other)
      }
    });
    
    $def(self, '$**', function $Rational_$$$7(other) {
      var self = this, $ret_or_1 = nil;

      if ($eqeqeq($$$('Integer'), ($ret_or_1 = other))) {
        if (($eqeq(self, 0) && ($truthy($rb_lt(other, 0))))) {
          return $$$($$$('Float'), 'INFINITY')
        } else if ($truthy($rb_gt(other, 0))) {
          return $Kernel.$Rational(self.num['$**'](other), self.den['$**'](other))
        } else if ($truthy($rb_lt(other, 0))) {
          return $Kernel.$Rational(self.den['$**'](other['$-@']()), self.num['$**'](other['$-@']()))
        } else {
          return $Kernel.$Rational(1, 1)
        }
      } else if ($eqeqeq($$$('Float'), $ret_or_1)) {
        return self.$to_f()['$**'](other)
      } else if ($eqeqeq($$$('Rational'), $ret_or_1)) {
        if ($eqeq(other, 0)) {
          return $Kernel.$Rational(1, 1)
        } else if ($eqeq(other.$denominator(), 1)) {
          if ($truthy($rb_lt(other, 0))) {
            return $Kernel.$Rational(self.den['$**'](other.$numerator().$abs()), self.num['$**'](other.$numerator().$abs()))
          } else {
            return $Kernel.$Rational(self.num['$**'](other.$numerator()), self.den['$**'](other.$numerator()))
          }
        } else if (($eqeq(self, 0) && ($truthy($rb_lt(other, 0))))) {
          return $Kernel.$raise($$$('ZeroDivisionError'), "divided by 0")
        } else {
          return self.$to_f()['$**'](other)
        }
      } else {
        return self.$__coerced__("**", other)
      }
    });
    
    $def(self, '$abs', function $$abs() {
      var self = this;

      return $Kernel.$Rational(self.num.$abs(), self.den.$abs())
    });
    
    $def(self, '$ceil', function $$ceil(precision) {
      var self = this;

      
      if (precision == null) precision = 0;
      if ($eqeq(precision, 0)) {
        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$ceil()
      } else {
        return self.$with_precision("ceil", precision)
      };
    }, -1);
    
    $def(self, '$floor', function $$floor(precision) {
      var self = this;

      
      if (precision == null) precision = 0;
      if ($eqeq(precision, 0)) {
        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$floor()
      } else {
        return self.$with_precision("floor", precision)
      };
    }, -1);
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return [$$$('Rational'), self.num, self.den].$hash()
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "(" + (self) + ")"
    });
    
    $def(self, '$rationalize', function $$rationalize(eps) {
      var self = this;

      
      ;
      
      if (arguments.length > 1) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }

      if (eps == null) {
        return self;
      }

      var e = eps.$abs(),
          a = $rb_minus(self, e),
          b = $rb_plus(self, e);

      var p0 = 0,
          p1 = 1,
          q0 = 1,
          q1 = 0,
          p2, q2;

      var c, k, t;

      while (true) {
        c = (a).$ceil();

        if ($rb_le(c, b)) {
          break;
        }

        k  = c - 1;
        p2 = k * p1 + p0;
        q2 = k * q1 + q0;
        t  = $rb_divide(1, $rb_minus(b, k));
        b  = $rb_divide(1, $rb_minus(a, k));
        a  = t;

        p0 = p1;
        q0 = q1;
        p1 = p2;
        q1 = q2;
      }

      return $Kernel.$Rational(c * p1 + p0, c * q1 + q0);
    ;
    }, -1);
    
    $def(self, '$round', function $$round(precision) {
      var self = this, num = nil, den = nil, approx = nil;

      
      if (precision == null) precision = 0;
      if (!$eqeq(precision, 0)) {
        return self.$with_precision("round", precision)
      };
      if ($eqeq(self.num, 0)) {
        return 0
      };
      if ($eqeq(self.den, 1)) {
        return self.num
      };
      num = $rb_plus($rb_times(self.num.$abs(), 2), self.den);
      den = $rb_times(self.den, 2);
      approx = $rb_divide(num, den).$truncate();
      if ($truthy($rb_lt(self.num, 0))) {
        return approx['$-@']()
      } else {
        return approx
      };
    }, -1);
    
    $def(self, '$to_f', function $$to_f() {
      var self = this;

      return $rb_divide(self.num, self.den)
    });
    
    $def(self, '$to_i', function $$to_i() {
      var self = this;

      return self.$truncate()
    });
    
    $def(self, '$to_r', $return_self);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return "" + (self.num) + "/" + (self.den)
    });
    
    $def(self, '$truncate', function $$truncate(precision) {
      var self = this;

      
      if (precision == null) precision = 0;
      if ($eqeq(precision, 0)) {
        if ($truthy($rb_lt(self.num, 0))) {
          return self.$ceil()
        } else {
          return self.$floor()
        }
      } else {
        return self.$with_precision("truncate", precision)
      };
    }, -1);
    
    $def(self, '$with_precision', function $$with_precision(method, precision) {
      var self = this, p = nil, s = nil;

      
      if (!$eqeqeq($$$('Integer'), precision)) {
        $Kernel.$raise($$$('TypeError'), "not an Integer")
      };
      p = (10)['$**'](precision);
      s = $rb_times(self, p);
      if ($truthy($rb_lt(precision, 1))) {
        return $rb_divide(s.$send(method), p).$to_i()
      } else {
        return $Kernel.$Rational(s.$send(method), p)
      };
    });
    $defs(self, '$from_string', function $$from_string(string) {
      
      
      var str = string.trimLeft(),
          re = /^[+-]?[\d_]+(\.[\d_]+)?/,
          match = str.match(re),
          numerator, denominator;

      function isFloat() {
        return re.test(str);
      }

      function cutFloat() {
        var match = str.match(re);
        var number = match[0];
        str = str.slice(number.length);
        return number.replace(/_/g, '');
      }

      if (isFloat()) {
        numerator = parseFloat(cutFloat());

        if (str[0] === '/') {
          // rational real part
          str = str.slice(1);

          if (isFloat()) {
            denominator = parseFloat(cutFloat());
            return $Kernel.$Rational(numerator, denominator);
          } else {
            return $Kernel.$Rational(numerator, 1);
          }
        } else {
          return $Kernel.$Rational(numerator, 1);
        }
      } else {
        return $Kernel.$Rational(0, 1);
      }
    
    });
    $alias(self, "divide", "/");
    return $alias(self, "quo", "/");
  })('::', $$$('Numeric'));
};

Opal.modules["corelib/time"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $slice = Opal.slice, $deny_frozen_access = Opal.deny_frozen_access, $klass = Opal.klass, $Kernel = Opal.Kernel, $Opal = Opal.Opal, $defs = Opal.defs, $eqeqeq = Opal.eqeqeq, $def = Opal.def, $truthy = Opal.truthy, $rb_gt = Opal.rb_gt, $rb_lt = Opal.rb_lt, $send = Opal.send, $rb_plus = Opal.rb_plus, $rb_divide = Opal.rb_divide, $rb_minus = Opal.rb_minus, $range = Opal.range, $neqeq = Opal.neqeq, $rb_le = Opal.rb_le, $eqeq = Opal.eqeq, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,===,raise,coerce_to!,respond_to?,to_str,to_i,_parse_offset,new,<=>,to_f,nil?,>,<,strftime,each,define_method,year,month,day,+,round,/,-,copy_instance_variables,initialize_dup,is_a?,zero?,wday,hash,utc?,mon,yday,hour,min,sec,rjust,ljust,zone,to_s,[],cweek_cyear,jd,to_date,format,isdst,!=,<=,==,ceil,local,gm,asctime,getgm,gmt_offset,inspect,usec,gmtime,gmt?');
  
  self.$require("corelib/comparable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Time');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Comparable'));
    
    var days_of_week = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
        short_days   = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        short_months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        long_months  = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  ;
    $defs(self, '$at', function $$at(seconds, frac) {
      
      
      ;
      
      var result;

      if ($$$('Time')['$==='](seconds)) {
        if (frac !== undefined) {
          $Kernel.$raise($$$('TypeError'), "can't convert Time into an exact number")
        }
        result = new Date(seconds.getTime());
        result.timezone = seconds.timezone;
        return result;
      }

      if (!seconds.$$is_number) {
        seconds = $Opal['$coerce_to!'](seconds, $$$('Integer'), "to_int");
      }

      if (frac === undefined) {
        return new Date(seconds * 1000);
      }

      if (!frac.$$is_number) {
        frac = $Opal['$coerce_to!'](frac, $$$('Integer'), "to_int");
      }

      return new Date(seconds * 1000 + (frac / 1000));
    ;
    }, -2);
    
    function time_params(year, month, day, hour, min, sec) {
      if (year.$$is_string) {
        year = parseInt(year, 10);
      } else {
        year = $Opal['$coerce_to!'](year, $$$('Integer'), "to_int");
      }

      if (month === nil) {
        month = 1;
      } else if (!month.$$is_number) {
        if ((month)['$respond_to?']("to_str")) {
          month = (month).$to_str();
          switch (month.toLowerCase()) {
          case 'jan': month =  1; break;
          case 'feb': month =  2; break;
          case 'mar': month =  3; break;
          case 'apr': month =  4; break;
          case 'may': month =  5; break;
          case 'jun': month =  6; break;
          case 'jul': month =  7; break;
          case 'aug': month =  8; break;
          case 'sep': month =  9; break;
          case 'oct': month = 10; break;
          case 'nov': month = 11; break;
          case 'dec': month = 12; break;
          default: month = (month).$to_i();
          }
        } else {
          month = $Opal['$coerce_to!'](month, $$$('Integer'), "to_int");
        }
      }

      if (month < 1 || month > 12) {
        $Kernel.$raise($$$('ArgumentError'), "month out of range: " + (month))
      }
      month = month - 1;

      if (day === nil) {
        day = 1;
      } else if (day.$$is_string) {
        day = parseInt(day, 10);
      } else {
        day = $Opal['$coerce_to!'](day, $$$('Integer'), "to_int");
      }

      if (day < 1 || day > 31) {
        $Kernel.$raise($$$('ArgumentError'), "day out of range: " + (day))
      }

      if (hour === nil) {
        hour = 0;
      } else if (hour.$$is_string) {
        hour = parseInt(hour, 10);
      } else {
        hour = $Opal['$coerce_to!'](hour, $$$('Integer'), "to_int");
      }

      if (hour < 0 || hour > 24) {
        $Kernel.$raise($$$('ArgumentError'), "hour out of range: " + (hour))
      }

      if (min === nil) {
        min = 0;
      } else if (min.$$is_string) {
        min = parseInt(min, 10);
      } else {
        min = $Opal['$coerce_to!'](min, $$$('Integer'), "to_int");
      }

      if (min < 0 || min > 59) {
        $Kernel.$raise($$$('ArgumentError'), "min out of range: " + (min))
      }

      if (sec === nil) {
        sec = 0;
      } else if (!sec.$$is_number) {
        if (sec.$$is_string) {
          sec = parseInt(sec, 10);
        } else {
          sec = $Opal['$coerce_to!'](sec, $$$('Integer'), "to_int");
        }
      }

      if (sec < 0 || sec > 60) {
        $Kernel.$raise($$$('ArgumentError'), "sec out of range: " + (sec))
      }

      return [year, month, day, hour, min, sec];
    }
  ;
    $defs(self, '$new', function $Time_new$1(year, month, day, hour, min, sec, utc_offset) {
      var self = this;

      
      ;
      if (month == null) month = nil;
      if (day == null) day = nil;
      if (hour == null) hour = nil;
      if (min == null) min = nil;
      if (sec == null) sec = nil;
      if (utc_offset == null) utc_offset = nil;
      
      var args, result, timezone, utc_date;

      if (year === undefined) {
        return new Date();
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      if (utc_offset === nil) {
        result = new Date(year, month, day, hour, min, 0, sec * 1000);
        if (year < 100) {
          result.setFullYear(year);
        }
        return result;
      }

      timezone = self.$_parse_offset(utc_offset);
      utc_date = new Date(Date.UTC(year, month, day, hour, min, 0, sec * 1000));
      if (year < 100) {
        utc_date.setUTCFullYear(year);
      }

      result = new Date(utc_date.getTime() - timezone * 3600000);
      result.timezone = timezone;

      return result;
    ;
    }, -1);
    $defs(self, '$_parse_offset', function $$_parse_offset(utc_offset) {
      
      
      var timezone;
      if (utc_offset.$$is_string) {
        if (utc_offset == 'UTC') {
          timezone = 0;
        }
        else if(/^[+-]\d\d:[0-5]\d$/.test(utc_offset)) {
          var sign, hours, minutes;
          sign = utc_offset[0];
          hours = +(utc_offset[1] + utc_offset[2]);
          minutes = +(utc_offset[4] + utc_offset[5]);

          timezone = (sign == '-' ? -1 : 1) * (hours + minutes / 60);
        }
        else {
          // Unsupported: "A".."I","K".."Z"
          $Kernel.$raise($$$('ArgumentError'), "\"+HH:MM\", \"-HH:MM\", \"UTC\" expected for utc_offset: " + (utc_offset))
        }
      }
      else if (utc_offset.$$is_number) {
        timezone = utc_offset / 3600;
      }
      else {
        $Kernel.$raise($$$('ArgumentError'), "Opal doesn't support other types for a timezone argument than Integer and String")
      }
      return timezone;
    
    });
    $defs(self, '$local', function $$local(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {
      
      
      if (month == null) month = nil;
      if (day == null) day = nil;
      if (hour == null) hour = nil;
      if (min == null) min = nil;
      if (sec == null) sec = nil;
      if (millisecond == null) millisecond = nil;
      if (_dummy1 == null) _dummy1 = nil;
      if (_dummy2 == null) _dummy2 = nil;
      if (_dummy3 == null) _dummy3 = nil;
      
      var args, result;

      if (arguments.length === 10) {
        args  = $slice(arguments);
        year  = args[5];
        month = args[4];
        day   = args[3];
        hour  = args[2];
        min   = args[1];
        sec   = args[0];
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(year, month, day, hour, min, 0, sec * 1000);
      if (year < 100) {
        result.setFullYear(year);
      }
      return result;
    ;
    }, -2);
    $defs(self, '$gm', function $$gm(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {
      
      
      if (month == null) month = nil;
      if (day == null) day = nil;
      if (hour == null) hour = nil;
      if (min == null) min = nil;
      if (sec == null) sec = nil;
      if (millisecond == null) millisecond = nil;
      if (_dummy1 == null) _dummy1 = nil;
      if (_dummy2 == null) _dummy2 = nil;
      if (_dummy3 == null) _dummy3 = nil;
      
      var args, result;

      if (arguments.length === 10) {
        args  = $slice(arguments);
        year  = args[5];
        month = args[4];
        day   = args[3];
        hour  = args[2];
        min   = args[1];
        sec   = args[0];
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(Date.UTC(year, month, day, hour, min, 0, sec * 1000));
      if (year < 100) {
        result.setUTCFullYear(year);
      }
      result.timezone = 0;
      return result;
    ;
    }, -2);
    $defs(self, '$now', function $$now() {
      var self = this;

      return self.$new()
    });
    
    $def(self, '$+', function $Time_$plus$2(other) {
      var self = this;

      
      if ($eqeqeq($$$('Time'), other)) {
        $Kernel.$raise($$$('TypeError'), "time + time?")
      };
      
      if (!other.$$is_number) {
        other = $Opal['$coerce_to!'](other, $$$('Integer'), "to_int");
      }
      var result = new Date(self.getTime() + (other * 1000));
      result.timezone = self.timezone;
      return result;
    ;
    });
    
    $def(self, '$-', function $Time_$minus$3(other) {
      var self = this;

      
      if ($eqeqeq($$$('Time'), other)) {
        return (self.getTime() - other.getTime()) / 1000
      };
      
      if (!other.$$is_number) {
        other = $Opal['$coerce_to!'](other, $$$('Integer'), "to_int");
      }
      var result = new Date(self.getTime() - (other * 1000));
      result.timezone = self.timezone;
      return result;
    ;
    });
    
    $def(self, '$<=>', function $Time_$lt_eq_gt$4(other) {
      var self = this, r = nil;

      if ($eqeqeq($$$('Time'), other)) {
        return self.$to_f()['$<=>'](other.$to_f())
      } else {
        
        r = other['$<=>'](self);
        if ($truthy(r['$nil?']())) {
          return nil
        } else if ($truthy($rb_gt(r, 0))) {
          return -1
        } else if ($truthy($rb_lt(r, 0))) {
          return 1
        } else {
          return 0
        };
      }
    });
    
    $def(self, '$==', function $Time_$eq_eq$5(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = $$$('Time')['$==='](other)))) {
        return self.$to_f() === other.$to_f()
      } else {
        return $ret_or_1
      }
    });
    
    $def(self, '$asctime', function $$asctime() {
      var self = this;

      return self.$strftime("%a %b %e %H:%M:%S %Y")
    });
    $send([["year", "getFullYear", "getUTCFullYear"], ["mon", "getMonth", "getUTCMonth", 1], ["wday", "getDay", "getUTCDay"], ["day", "getDate", "getUTCDate"], ["hour", "getHours", "getUTCHours"], ["min", "getMinutes", "getUTCMinutes"], ["sec", "getSeconds", "getUTCSeconds"]], 'each', [], function $Time$6(method, getter, utcgetter, difference){var self = $Time$6.$$s == null ? this : $Time$6.$$s;

      
      if (method == null) method = nil;
      if (getter == null) getter = nil;
      if (utcgetter == null) utcgetter = nil;
      if (difference == null) difference = 0;
      return $send(self, 'define_method', [method], function $$7(){var self = $$7.$$s == null ? this : $$7.$$s;

        
        return difference + ((self.timezone != null) ?
          (new Date(self.getTime() + self.timezone * 3600000))[utcgetter]() :
          self[getter]())
      }, {$$s: self});}, {$$arity: -4, $$s: self});
    
    $def(self, '$yday', function $$yday() {
      var self = this, start_of_year = nil, start_of_day = nil, one_day = nil;

      
      start_of_year = $$('Time').$new(self.$year()).$to_i();
      start_of_day = $$('Time').$new(self.$year(), self.$month(), self.$day()).$to_i();
      one_day = 86400;
      return $rb_plus($rb_divide($rb_minus(start_of_day, start_of_year), one_day).$round(), 1);
    });
    
    $def(self, '$isdst', function $$isdst() {
      var self = this;

      
      var jan = new Date(self.getFullYear(), 0, 1),
          jul = new Date(self.getFullYear(), 6, 1);
      return self.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
    
    });
    
    $def(self, '$dup', function $$dup() {
      var self = this, copy = nil;

      
      copy = new Date(self.getTime());
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    });
    
    $def(self, '$eql?', function $Time_eql$ques$8(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = other['$is_a?']($$$('Time'))))) {
        return self['$<=>'](other)['$zero?']()
      } else {
        return $ret_or_1
      }
    });
    $send([["sunday?", 0], ["monday?", 1], ["tuesday?", 2], ["wednesday?", 3], ["thursday?", 4], ["friday?", 5], ["saturday?", 6]], 'each', [], function $Time$9(method, weekday){var self = $Time$9.$$s == null ? this : $Time$9.$$s;

      
      if (method == null) method = nil;
      if (weekday == null) weekday = nil;
      return $send(self, 'define_method', [method], function $$10(){var self = $$10.$$s == null ? this : $$10.$$s;

        return self.$wday() === weekday}, {$$s: self});}, {$$s: self});
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return [$$$('Time'), self.getTime()].$hash()
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      if ($truthy(self['$utc?']())) {
        return self.$strftime("%Y-%m-%d %H:%M:%S UTC")
      } else {
        return self.$strftime("%Y-%m-%d %H:%M:%S %z")
      }
    });
    
    $def(self, '$succ', function $$succ() {
      var self = this;

      
      var result = new Date(self.getTime() + 1000);
      result.timezone = self.timezone;
      return result;
    
    });
    
    $def(self, '$usec', function $$usec() {
      var self = this;

      return self.getMilliseconds() * 1000;
    });
    
    $def(self, '$zone', function $$zone() {
      var self = this;

      
      if (self.timezone === 0) return "UTC";
      else if (self.timezone != null) return nil;

      var string = self.toString(),
          result;

      if (string.indexOf('(') == -1) {
        result = string.match(/[A-Z]{3,4}/)[0];
      }
      else {
        result = string.match(/\((.+)\)(?:\s|$)/)[1]
      }

      if (result == "GMT" && /(GMT\W*\d{4})/.test(string)) {
        return RegExp.$1;
      }
      else {
        return result;
      }
    
    });
    
    $def(self, '$getgm', function $$getgm() {
      var self = this;

      
      var result = new Date(self.getTime());
      result.timezone = 0;
      return result;
    
    });
    
    $def(self, '$gmtime', function $$gmtime() {
      var self = this;

      
      if (self.timezone !== 0) {
        $deny_frozen_access(self);
        self.timezone = 0;
      }
      return self;
    
    });
    
    $def(self, '$gmt?', function $Time_gmt$ques$11() {
      var self = this;

      return self.timezone === 0;
    });
    
    $def(self, '$gmt_offset', function $$gmt_offset() {
      var self = this;

      return (self.timezone != null) ? self.timezone * 60 : -self.getTimezoneOffset() * 60;
    });
    
    $def(self, '$strftime', function $$strftime(format) {
      var self = this;

      
      return format.replace(/%([\-_#^0]*:{0,2})(\d+)?([EO]*)(.)/g, function(full, flags, width, _, conv) {
        var result = "", jd, c, s,
            zero   = flags.indexOf('0') !== -1,
            pad    = flags.indexOf('-') === -1,
            blank  = flags.indexOf('_') !== -1,
            upcase = flags.indexOf('^') !== -1,
            invert = flags.indexOf('#') !== -1,
            colons = (flags.match(':') || []).length;

        width = parseInt(width, 10);

        if (zero && blank) {
          if (flags.indexOf('0') < flags.indexOf('_')) {
            zero = false;
          }
          else {
            blank = false;
          }
        }

        switch (conv) {
          case 'Y':
            result += self.$year();
            break;

          case 'C':
            zero    = !blank;
            result += Math.round(self.$year() / 100);
            break;

          case 'y':
            zero    = !blank;
            result += (self.$year() % 100);
            break;

          case 'm':
            zero    = !blank;
            result += self.$mon();
            break;

          case 'B':
            result += long_months[self.$mon() - 1];
            break;

          case 'b':
          case 'h':
            blank   = !zero;
            result += short_months[self.$mon() - 1];
            break;

          case 'd':
            zero    = !blank
            result += self.$day();
            break;

          case 'e':
            blank   = !zero
            result += self.$day();
            break;

          case 'j':
            zero    = !blank;
            width   = isNaN(width) ? 3 : width;
            result += self.$yday();
            break;

          case 'H':
            zero    = !blank;
            result += self.$hour();
            break;

          case 'k':
            blank   = !zero;
            result += self.$hour();
            break;

          case 'I':
            zero    = !blank;
            result += (self.$hour() % 12 || 12);
            break;

          case 'l':
            blank   = !zero;
            result += (self.$hour() % 12 || 12);
            break;

          case 'P':
            result += (self.$hour() >= 12 ? "pm" : "am");
            break;

          case 'p':
            result += (self.$hour() >= 12 ? "PM" : "AM");
            break;

          case 'M':
            zero    = !blank;
            result += self.$min();
            break;

          case 'S':
            zero    = !blank;
            result += self.$sec()
            break;

          case 'L':
            zero    = !blank;
            width   = isNaN(width) ? 3 : width;
            result += self.getMilliseconds();
            break;

          case 'N':
            width   = isNaN(width) ? 9 : width;
            result += (self.getMilliseconds().toString()).$rjust(3, "0");
            result  = (result).$ljust(width, "0");
            break;

          case 'z':
            var offset  = (self.timezone == null) ? self.getTimezoneOffset() : (-self.timezone * 60),
                hours   = Math.floor(Math.abs(offset) / 60),
                minutes = Math.abs(offset) % 60;

            result += offset < 0 ? "+" : "-";
            result += hours < 10 ? "0" : "";
            result += hours;

            if (colons > 0) {
              result += ":";
            }

            result += minutes < 10 ? "0" : "";
            result += minutes;

            if (colons > 1) {
              result += ":00";
            }

            break;

          case 'Z':
            result += self.$zone();
            break;

          case 'A':
            result += days_of_week[self.$wday()];
            break;

          case 'a':
            result += short_days[self.$wday()];
            break;

          case 'u':
            result += (self.$wday() + 1);
            break;

          case 'w':
            result += self.$wday();
            break;

          case 'V':
            result += self.$cweek_cyear()['$[]'](0).$to_s().$rjust(2, "0");
            break;

          case 'G':
            result += self.$cweek_cyear()['$[]'](1);
            break;

          case 'g':
            result += self.$cweek_cyear()['$[]'](1)['$[]']($range(-2, -1, false));
            break;

          case 's':
            result += self.$to_i();
            break;

          case 'n':
            result += "\n";
            break;

          case 't':
            result += "\t";
            break;

          case '%':
            result += "%";
            break;

          case 'c':
            result += self.$strftime("%a %b %e %T %Y");
            break;

          case 'D':
          case 'x':
            result += self.$strftime("%m/%d/%y");
            break;

          case 'F':
            result += self.$strftime("%Y-%m-%d");
            break;

          case 'v':
            result += self.$strftime("%e-%^b-%4Y");
            break;

          case 'r':
            result += self.$strftime("%I:%M:%S %p");
            break;

          case 'R':
            result += self.$strftime("%H:%M");
            break;

          case 'T':
          case 'X':
            result += self.$strftime("%H:%M:%S");
            break;

          // Non-standard: JIS X 0301 date format
          case 'J':
            jd = self.$to_date().$jd();
            if (jd < 2405160) {
              result += self.$strftime("%Y-%m-%d");
              break;
            }
            else if (jd < 2419614)
              c = 'M', s = 1867;
            else if (jd < 2424875)
              c = 'T', s = 1911;
            else if (jd < 2447535)
              c = 'S', s = 1925;
            else if (jd < 2458605)
              c = 'H', s = 1988;
            else
              c = 'R', s = 2018;

            result += self.$format("%c%02d", c, $rb_minus(self.$year(), s));
            result += self.$strftime("-%m-%d");
            break;

          default:
            return full;
        }

        if (upcase) {
          result = result.toUpperCase();
        }

        if (invert) {
          result = result.replace(/[A-Z]/, function(c) { c.toLowerCase() }).
                          replace(/[a-z]/, function(c) { c.toUpperCase() });
        }

        if (pad && (zero || blank)) {
          result = (result).$rjust(isNaN(width) ? 2 : width, blank ? " " : "0");
        }

        return result;
      });
    
    });
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      return [self.$sec(), self.$min(), self.$hour(), self.$day(), self.$month(), self.$year(), self.$wday(), self.$yday(), self.$isdst(), self.$zone()]
    });
    
    $def(self, '$to_f', function $$to_f() {
      var self = this;

      return self.getTime() / 1000;
    });
    
    $def(self, '$to_i', function $$to_i() {
      var self = this;

      return parseInt(self.getTime() / 1000, 10);
    });
    
    $def(self, '$cweek_cyear', function $$cweek_cyear() {
      var self = this, jan01 = nil, jan01_wday = nil, first_monday = nil, year = nil, offset = nil, week = nil, dec31 = nil, dec31_wday = nil;

      
      jan01 = $$$('Time').$new(self.$year(), 1, 1);
      jan01_wday = jan01.$wday();
      first_monday = 0;
      year = self.$year();
      if (($truthy($rb_le(jan01_wday, 4)) && ($neqeq(jan01_wday, 0)))) {
        offset = $rb_minus(jan01_wday, 1)
      } else {
        
        offset = $rb_minus($rb_minus(jan01_wday, 7), 1);
        if ($eqeq(offset, -8)) {
          offset = -1
        };
      };
      week = $rb_divide($rb_plus(self.$yday(), offset), 7.0).$ceil();
      if ($truthy($rb_le(week, 0))) {
        return $$$('Time').$new($rb_minus(self.$year(), 1), 12, 31).$cweek_cyear()
      } else if ($eqeq(week, 53)) {
        
        dec31 = $$$('Time').$new(self.$year(), 12, 31);
        dec31_wday = dec31.$wday();
        if (($truthy($rb_le(dec31_wday, 3)) && ($neqeq(dec31_wday, 0)))) {
          
          week = 1;
          year = $rb_plus(year, 1);
        };
      };
      return [week, year];
    });
    (function(self, $parent_nesting) {
      
      
      $alias(self, "mktime", "local");
      return $alias(self, "utc", "gm");
    })(Opal.get_singleton_class(self), $nesting);
    $alias(self, "ctime", "asctime");
    $alias(self, "dst?", "isdst");
    $alias(self, "getutc", "getgm");
    $alias(self, "gmtoff", "gmt_offset");
    $alias(self, "mday", "day");
    $alias(self, "month", "mon");
    $alias(self, "to_s", "inspect");
    $alias(self, "tv_sec", "to_i");
    $alias(self, "tv_usec", "usec");
    $alias(self, "utc", "gmtime");
    $alias(self, "utc?", "gmt?");
    return $alias(self, "utc_offset", "gmt_offset");
  })('::', Date, $nesting);
};

Opal.modules["corelib/struct"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $slice = Opal.slice, $extract_kwargs = Opal.extract_kwargs, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $truthy = Opal.truthy, $neqeq = Opal.neqeq, $eqeq = Opal.eqeq, $Opal = Opal.Opal, $send = Opal.send, $Class = Opal.Class, $to_a = Opal.to_a, $def = Opal.def, $defs = Opal.defs, $Kernel = Opal.Kernel, $rb_gt = Opal.rb_gt, $rb_minus = Opal.rb_minus, $eqeqeq = Opal.eqeqeq, $rb_lt = Opal.rb_lt, $rb_ge = Opal.rb_ge, $rb_plus = Opal.rb_plus, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,!=,upcase,[],==,class,unshift,const_name!,map,coerce_to!,new,each,define_struct_attribute,allocate,initialize,alias_method,module_eval,to_proc,const_set,raise,<<,members,define_method,instance_eval,last,>,length,-,keys,any?,join,[]=,each_with_index,hash,to_a,===,<,-@,size,>=,include?,to_sym,instance_of?,__id__,eql?,enum_for,+,name,each_pair,inspect,to_h,each_with_object,flatten,respond_to?,dig');
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Struct');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Enumerable'));
    $defs(self, '$new', function $Struct_new$1(const_name, $a, $b) {
      var block = $Struct_new$1.$$p || nil, $post_args, $kwargs, args, keyword_init, self = this, klass = nil;

      $Struct_new$1.$$p = null;
      
      ;
      $post_args = $slice(arguments, 1);
      $kwargs = $extract_kwargs($post_args);
      $kwargs = $ensure_kwargs($kwargs);
      args = $post_args;
      
      keyword_init = $hash_get($kwargs, "keyword_init");if (keyword_init == null) keyword_init = false;
      if ($truthy(const_name)) {
        if (($eqeq(const_name.$class(), $$$('String')) && ($neqeq(const_name['$[]'](0).$upcase(), const_name['$[]'](0))))) {
          
          args.$unshift(const_name);
          const_name = nil;
        } else {
          
          try {
            const_name = $Opal['$const_name!'](const_name)
          } catch ($err) {
            if (Opal.rescue($err, [$$$('TypeError'), $$$('NameError')])) {
              try {
                
                args.$unshift(const_name);
                const_name = nil;
              } finally { Opal.pop_exception($err); }
            } else { throw $err; }
          };
        }
      };
      $send(args, 'map', [], function $$2(arg){
        
        if (arg == null) arg = nil;
        return $Opal['$coerce_to!'](arg, $$$('String'), "to_str");});
      klass = $send($Class, 'new', [self], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

        
        $send(args, 'each', [], function $$4(arg){var self = $$4.$$s == null ? this : $$4.$$s;

          
          if (arg == null) arg = nil;
          return self.$define_struct_attribute(arg);}, {$$s: self});
        return (function(self, $parent_nesting) {
          
          
          
          $def(self, '$new', function $new$5($a) {
            var $post_args, args, self = this, instance = nil;

            
            $post_args = $slice(arguments);
            args = $post_args;
            instance = self.$allocate();
            instance.$$data = {};
            $send(instance, 'initialize', $to_a(args));
            return instance;
          }, -1);
          return self.$alias_method("[]", "new");
        })(Opal.get_singleton_class(self), $nesting);}, {$$s: self});
      if ($truthy(block)) {
        $send(klass, 'module_eval', [], block.$to_proc())
      };
      klass.$$keyword_init = keyword_init;
      if ($truthy(const_name)) {
        $$$('Struct').$const_set(const_name, klass)
      };
      return klass;
    }, -2);
    $defs(self, '$define_struct_attribute', function $$define_struct_attribute(name) {
      var self = this;

      
      if ($eqeq(self, $$$('Struct'))) {
        $Kernel.$raise($$$('ArgumentError'), "you cannot define attributes to the Struct class")
      };
      self.$members()['$<<'](name);
      $send(self, 'define_method', [name], function $$6(){var self = $$6.$$s == null ? this : $$6.$$s;

        return self.$$data[name];}, {$$s: self});
      return $send(self, 'define_method', ["" + (name) + "="], function $$7(value){var self = $$7.$$s == null ? this : $$7.$$s;

        
        if (value == null) value = nil;
        return self.$$data[name] = value;;}, {$$s: self});
    });
    $defs(self, '$members', function $$members() {
      var self = this, $ret_or_1 = nil;
      if (self.members == null) self.members = nil;

      
      if ($eqeq(self, $$$('Struct'))) {
        $Kernel.$raise($$$('ArgumentError'), "the Struct class has no members")
      };
      return (self.members = ($truthy(($ret_or_1 = self.members)) ? ($ret_or_1) : ([])));
    });
    $defs(self, '$inherited', function $$inherited(klass) {
      var self = this, members = nil;
      if (self.members == null) self.members = nil;

      
      members = self.members;
      return $send(klass, 'instance_eval', [], function $$8(){var self = $$8.$$s == null ? this : $$8.$$s;

        return (self.members = members)}, {$$s: self});
    });
    
    $def(self, '$initialize', function $$initialize($a) {
      var $post_args, args, self = this, kwargs = nil, $ret_or_1 = nil, extra = nil;

      
      $post_args = $slice(arguments);
      args = $post_args;
      if ($truthy(self.$class().$$keyword_init)) {
        
        kwargs = ($truthy(($ret_or_1 = args.$last())) ? ($ret_or_1) : ((new Map())));
        if (($truthy($rb_gt(args.$length(), 1)) || ($truthy((args.length === 1 && !kwargs.$$is_hash))))) {
          $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (given " + (args.$length()) + ", expected 0)")
        };
        extra = $rb_minus(kwargs.$keys(), self.$class().$members());
        if ($truthy(extra['$any?']())) {
          $Kernel.$raise($$$('ArgumentError'), "unknown keywords: " + (extra.$join(", ")))
        };
        return $send(self.$class().$members(), 'each', [], function $$9(name){var $b, self = $$9.$$s == null ? this : $$9.$$s;

          
          if (name == null) name = nil;
          return ($b = [name, kwargs['$[]'](name)], $send(self, '[]=', $b), $b[$b.length - 1]);}, {$$s: self});
      } else {
        
        if ($truthy($rb_gt(args.$length(), self.$class().$members().$length()))) {
          $Kernel.$raise($$$('ArgumentError'), "struct size differs")
        };
        return $send(self.$class().$members(), 'each_with_index', [], function $$10(name, index){var $b, self = $$10.$$s == null ? this : $$10.$$s;

          
          if (name == null) name = nil;
          if (index == null) index = nil;
          return ($b = [name, args['$[]'](index)], $send(self, '[]=', $b), $b[$b.length - 1]);}, {$$s: self});
      };
    }, -1);
    
    $def(self, '$initialize_copy', function $$initialize_copy(from) {
      var self = this;

      
      self.$$data = {}
      var keys = Object.keys(from.$$data), i, max, name;
      for (i = 0, max = keys.length; i < max; i++) {
        name = keys[i];
        self.$$data[name] = from.$$data[name];
      }
    
    });
    $defs(self, '$keyword_init?', function $Struct_keyword_init$ques$11() {
      var self = this;

      return self.$$keyword_init;
    });
    
    $def(self, '$members', function $$members() {
      var self = this;

      return self.$class().$members()
    });
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return [self.$class(), self.$to_a()].$hash()
    });
    
    $def(self, '$[]', function $Struct_$$$12(name) {
      var self = this;

      
      if ($eqeqeq($$$('Integer'), name)) {
        
        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {
          $Kernel.$raise($$$('IndexError'), "offset " + (name) + " too small for struct(size:" + (self.$class().$members().$size()) + ")")
        };
        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
          $Kernel.$raise($$$('IndexError'), "offset " + (name) + " too large for struct(size:" + (self.$class().$members().$size()) + ")")
        };
        name = self.$class().$members()['$[]'](name);
      } else if ($eqeqeq($$$('String'), name)) {
        
        if(!self.$$data.hasOwnProperty(name)) {
          $Kernel.$raise($$$('NameError').$new("no member '" + (name) + "' in struct", name))
        }
      
      } else {
        $Kernel.$raise($$$('TypeError'), "no implicit conversion of " + (name.$class()) + " into Integer")
      };
      name = $Opal['$coerce_to!'](name, $$$('String'), "to_str");
      return self.$$data[name];;
    });
    
    $def(self, '$[]=', function $Struct_$$$eq$13(name, value) {
      var self = this;

      
      if ($eqeqeq($$$('Integer'), name)) {
        
        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {
          $Kernel.$raise($$$('IndexError'), "offset " + (name) + " too small for struct(size:" + (self.$class().$members().$size()) + ")")
        };
        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
          $Kernel.$raise($$$('IndexError'), "offset " + (name) + " too large for struct(size:" + (self.$class().$members().$size()) + ")")
        };
        name = self.$class().$members()['$[]'](name);
      } else if ($eqeqeq($$$('String'), name)) {
        if (!$truthy(self.$class().$members()['$include?'](name.$to_sym()))) {
          $Kernel.$raise($$$('NameError').$new("no member '" + (name) + "' in struct", name))
        }
      } else {
        $Kernel.$raise($$$('TypeError'), "no implicit conversion of " + (name.$class()) + " into Integer")
      };
      name = $Opal['$coerce_to!'](name, $$$('String'), "to_str");
      return self.$$data[name] = value;;
    });
    
    $def(self, '$==', function $Struct_$eq_eq$14(other) {
      var self = this;

      
      if (!$truthy(other['$instance_of?'](self.$class()))) {
        return false
      };
      
      var recursed1 = {}, recursed2 = {};

      function _eqeq(struct, other) {
        var key, a, b;

        recursed1[(struct).$__id__()] = true;
        recursed2[(other).$__id__()] = true;

        for (key in struct.$$data) {
          a = struct.$$data[key];
          b = other.$$data[key];

          if ($$$('Struct')['$==='](a)) {
            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$=='](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    ;
    });
    
    $def(self, '$eql?', function $Struct_eql$ques$15(other) {
      var self = this;

      
      if (!$truthy(other['$instance_of?'](self.$class()))) {
        return false
      };
      
      var recursed1 = {}, recursed2 = {};

      function _eqeq(struct, other) {
        var key, a, b;

        recursed1[(struct).$__id__()] = true;
        recursed2[(other).$__id__()] = true;

        for (key in struct.$$data) {
          a = struct.$$data[key];
          b = other.$$data[key];

          if ($$$('Struct')['$==='](a)) {
            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$eql?'](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    ;
    });
    
    $def(self, '$each', function $$each() {
      var $yield = $$each.$$p || nil, self = this;

      $$each.$$p = null;
      
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["each"], function $$16(){var self = $$16.$$s == null ? this : $$16.$$s;

          return self.$size()}, {$$s: self})
      };
      $send(self.$class().$members(), 'each', [], function $$17(name){var self = $$17.$$s == null ? this : $$17.$$s;

        
        if (name == null) name = nil;
        return Opal.yield1($yield, self['$[]'](name));;}, {$$s: self});
      return self;
    });
    
    $def(self, '$each_pair', function $$each_pair() {
      var $yield = $$each_pair.$$p || nil, self = this;

      $$each_pair.$$p = null;
      
      if (!($yield !== nil)) {
        return $send(self, 'enum_for', ["each_pair"], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s;

          return self.$size()}, {$$s: self})
      };
      $send(self.$class().$members(), 'each', [], function $$19(name){var self = $$19.$$s == null ? this : $$19.$$s;

        
        if (name == null) name = nil;
        return Opal.yield1($yield, [name, self['$[]'](name)]);;}, {$$s: self});
      return self;
    });
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.$class().$members().$length()
    });
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      return $send(self.$class().$members(), 'map', [], function $$20(name){var self = $$20.$$s == null ? this : $$20.$$s;

        
        if (name == null) name = nil;
        return self['$[]'](name);}, {$$s: self})
    });
    var inspect_stack = [];
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, result = nil, pushed = nil;

      return (function() { try {
      
      result = "#<struct ";
      if ($truthy((inspect_stack)['$include?'](self.$__id__()))) {
        return $rb_plus(result, ":...>")
      } else {
        
        (inspect_stack)['$<<'](self.$__id__());
        pushed = true;
        if (($eqeqeq($$$('Struct'), self) && ($truthy(self.$class().$name())))) {
          result = $rb_plus(result, "" + (self.$class()) + " ")
        };
        result = $rb_plus(result, $send(self.$each_pair(), 'map', [], function $$21(name, value){
          
          if (name == null) name = nil;
          if (value == null) value = nil;
          return "" + (name) + "=" + ($$('Opal').$inspect(value));}).$join(", "));
        result = $rb_plus(result, ">");
        return result;
      };
      } finally {
        ($truthy(pushed) ? (inspect_stack.pop()) : nil)
      }; })()
    });
    
    $def(self, '$to_h', function $$to_h($a) {
      var block = $$to_h.$$p || nil, $post_args, args, self = this;

      $$to_h.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      if ((block !== nil)) {
        return $send($send(self, 'map', [], block.$to_proc()), 'to_h', $to_a(args))
      };
      return $send(self.$class().$members(), 'each_with_object', [(new Map())], function $$22(name, h){var $b, self = $$22.$$s == null ? this : $$22.$$s;

        
        if (name == null) name = nil;
        if (h == null) h = nil;
        return ($b = [name, self['$[]'](name)], $send(h, '[]=', $b), $b[$b.length - 1]);}, {$$s: self});
    }, -1);
    
    $def(self, '$values_at', function $$values_at($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      args = $send(args, 'map', [], function $$23(arg){
        
        if (arg == null) arg = nil;
        return arg.$$is_range ? arg.$to_a() : arg;}).$flatten();
      
      var result = [];
      for (var i = 0, len = args.length; i < len; i++) {
        if (!args[i].$$is_number) {
          $Kernel.$raise($$$('TypeError'), "no implicit conversion of " + ((args[i]).$class()) + " into Integer")
        }
        result.push(self['$[]'](args[i]));
      }
      return result;
    ;
    }, -1);
    
    $def(self, '$dig', function $$dig(key, $a) {
      var $post_args, keys, self = this, item = nil;

      
      $post_args = $slice(arguments, 1);
      keys = $post_args;
      item = ($truthy(key.$$is_string && self.$$data.hasOwnProperty(key)) ? (self.$$data[key] || nil) : nil);
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if (!$truthy(item['$respond_to?']("dig"))) {
        $Kernel.$raise($$$('TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', $to_a(keys));
    }, -2);
    $alias(self, "size", "length");
    $alias(self, "to_s", "inspect");
    return $alias(self, "values", "to_a");
  })('::', null, $nesting);
};

Opal.modules["corelib/set"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $freeze = Opal.freeze, $klass = Opal.klass, $slice = Opal.slice, $defs = Opal.defs, $truthy = Opal.truthy, $eqeqeq = Opal.eqeqeq, $Kernel = Opal.Kernel, $send = Opal.send, $def = Opal.def, $eqeq = Opal.eqeq, $rb_lt = Opal.rb_lt, $rb_le = Opal.rb_le, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,new,nil?,===,raise,each,add,merge,class,respond_to?,subtract,dup,join,to_a,equal?,instance_of?,==,instance_variable_get,size,is_a?,all?,include?,[]=,enum_for,[],<<,replace,compare_by_identity,name,compare_by_identity?,delete,select,frozen?,freeze,reject,delete_if,to_proc,keep_if,each_key,empty?,eql?,instance_eval,clear,<,<=,any?,!,intersect?,keys,|,proper_subset?,subset?,proper_superset?,superset?,-,select!,collect!');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Set');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $ret_or_1 = nil, $proto = self.$$prototype;

    $proto.hash = nil;
    
    self.$include($$$('Enumerable'));
    $defs(self, '$[]', function $Set_$$$1($a) {
      var $post_args, ary, self = this;

      
      $post_args = $slice(arguments);
      ary = $post_args;
      return self.$new(ary);
    }, -1);
    
    $def(self, '$initialize', function $$initialize(enum$) {
      var block = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      ;
      if (enum$ == null) enum$ = nil;
      self.hash = (new Map());
      if ($truthy(enum$['$nil?']())) {
        return nil
      };
      if (!$eqeqeq($$$('Enumerable'), enum$)) {
        $Kernel.$raise($$$('ArgumentError'), "value must be enumerable")
      };
      if ($truthy(block)) {
        return $send(enum$, 'each', [], function $$2(item){var self = $$2.$$s == null ? this : $$2.$$s;

          
          if (item == null) item = nil;
          return self.$add(Opal.yield1(block, item));}, {$$s: self})
      } else {
        return self.$merge(enum$)
      };
    }, -1);
    
    $def(self, '$dup', function $$dup() {
      var self = this, result = nil;

      
      result = self.$class().$new();
      return result.$merge(self);
    });
    
    $def(self, '$-', function $Set_$minus$3(enum$) {
      var self = this;

      
      if (!$truthy(enum$['$respond_to?']("each"))) {
        $Kernel.$raise($$$('ArgumentError'), "value must be enumerable")
      };
      return self.$dup().$subtract(enum$);
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "#<Set: {" + (self.$to_a().$join(",")) + "}>"
    });
    
    $def(self, '$==', function $Set_$eq_eq$4(other) {
      var self = this;

      if ($truthy(self['$equal?'](other))) {
        return true
      } else if ($truthy(other['$instance_of?'](self.$class()))) {
        return self.hash['$=='](other.$instance_variable_get("@hash"))
      } else if (($truthy(other['$is_a?']($$$('Set'))) && ($eqeq(self.$size(), other.$size())))) {
        return $send(other, 'all?', [], function $$5(o){var self = $$5.$$s == null ? this : $$5.$$s;
          if (self.hash == null) self.hash = nil;

          
          if (o == null) o = nil;
          return self.hash['$include?'](o);}, {$$s: self})
      } else {
        return false
      }
    });
    
    $def(self, '$add', function $$add(o) {
      var self = this;

      
      self.hash['$[]='](o, true);
      return self;
    });
    
    $def(self, '$classify', function $$classify() {
      var block = $$classify.$$p || nil, self = this, result = nil;

      $$classify.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("classify")
      };
      result = $send($$$('Hash'), 'new', [], function $$6(h, k){var $a, self = $$6.$$s == null ? this : $$6.$$s;

        
        if (h == null) h = nil;
        if (k == null) k = nil;
        return ($a = [k, self.$class().$new()], $send(h, '[]=', $a), $a[$a.length - 1]);}, {$$s: self});
      $send(self, 'each', [], function $$7(item){
        
        if (item == null) item = nil;
        return result['$[]'](Opal.yield1(block, item)).$add(item);});
      return result;
    });
    
    $def(self, '$collect!', function $Set_collect$excl$8() {
      var block = $Set_collect$excl$8.$$p || nil, self = this, result = nil;

      $Set_collect$excl$8.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("collect!")
      };
      result = self.$class().$new();
      $send(self, 'each', [], function $$9(item){
        
        if (item == null) item = nil;
        return result['$<<'](Opal.yield1(block, item));});
      return self.$replace(result);
    });
    
    $def(self, '$compare_by_identity', function $$compare_by_identity() {
      var self = this;

      if ($truthy(self.hash['$respond_to?']("compare_by_identity"))) {
        
        self.hash.$compare_by_identity();
        return self;
      } else {
        return self.$raise($$('NotImplementedError'), "" + (self.$class().$name()) + "#" + ("compare_by_identity") + " is not implemented")
      }
    });
    
    $def(self, '$compare_by_identity?', function $Set_compare_by_identity$ques$10() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.hash['$respond_to?']("compare_by_identity?")))) {
        return self.hash['$compare_by_identity?']()
      } else {
        return $ret_or_1
      }
    });
    
    $def(self, '$delete', function $Set_delete$11(o) {
      var self = this;

      
      self.hash.$delete(o);
      return self;
    });
    
    $def(self, '$delete?', function $Set_delete$ques$12(o) {
      var self = this;

      if ($truthy(self['$include?'](o))) {
        
        self.$delete(o);
        return self;
      } else {
        return nil
      }
    });
    
    $def(self, '$delete_if', function $$delete_if() {
      var $yield = $$delete_if.$$p || nil, self = this;

      $$delete_if.$$p = null;
      
      if (!($yield !== nil)) {
        return self.$enum_for("delete_if")
      };
      $send($send(self, 'select', [], function $$13(o){
        
        if (o == null) o = nil;
        return Opal.yield1($yield, o);;}), 'each', [], function $$14(o){var self = $$14.$$s == null ? this : $$14.$$s;
        if (self.hash == null) self.hash = nil;

        
        if (o == null) o = nil;
        return self.hash.$delete(o);}, {$$s: self});
      return self;
    });
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if ($truthy(self['$frozen?']())) {
        return self
      };
      self.hash.$freeze();
      return $freeze(self);;
    });
    
    $def(self, '$keep_if', function $$keep_if() {
      var $yield = $$keep_if.$$p || nil, self = this;

      $$keep_if.$$p = null;
      
      if (!($yield !== nil)) {
        return self.$enum_for("keep_if")
      };
      $send($send(self, 'reject', [], function $$15(o){
        
        if (o == null) o = nil;
        return Opal.yield1($yield, o);;}), 'each', [], function $$16(o){var self = $$16.$$s == null ? this : $$16.$$s;
        if (self.hash == null) self.hash = nil;

        
        if (o == null) o = nil;
        return self.hash.$delete(o);}, {$$s: self});
      return self;
    });
    
    $def(self, '$reject!', function $Set_reject$excl$17() {
      var block = $Set_reject$excl$17.$$p || nil, self = this, before = nil;

      $Set_reject$excl$17.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("reject!")
      };
      before = self.$size();
      $send(self, 'delete_if', [], block.$to_proc());
      if ($eqeq(self.$size(), before)) {
        return nil
      } else {
        return self
      };
    });
    
    $def(self, '$select!', function $Set_select$excl$18() {
      var block = $Set_select$excl$18.$$p || nil, self = this, before = nil;

      $Set_select$excl$18.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("select!")
      };
      before = self.$size();
      $send(self, 'keep_if', [], block.$to_proc());
      if ($eqeq(self.$size(), before)) {
        return nil
      } else {
        return self
      };
    });
    
    $def(self, '$add?', function $Set_add$ques$19(o) {
      var self = this;

      if ($truthy(self['$include?'](o))) {
        return nil
      } else {
        return self.$add(o)
      }
    });
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, self = this;

      $$each.$$p = null;
      
      ;
      if (!(block !== nil)) {
        return self.$enum_for("each")
      };
      $send(self.hash, 'each_key', [], block.$to_proc());
      return self;
    });
    
    $def(self, '$empty?', function $Set_empty$ques$20() {
      var self = this;

      return self.hash['$empty?']()
    });
    
    $def(self, '$eql?', function $Set_eql$ques$21(other) {
      var self = this;

      return self.hash['$eql?']($send(other, 'instance_eval', [], function $$22(){var self = $$22.$$s == null ? this : $$22.$$s;
        if (self.hash == null) self.hash = nil;

        return self.hash}, {$$s: self}))
    });
    
    $def(self, '$clear', function $$clear() {
      var self = this;

      
      self.hash.$clear();
      return self;
    });
    
    $def(self, '$include?', function $Set_include$ques$23(o) {
      var self = this;

      return self.hash['$include?'](o)
    });
    
    $def(self, '$merge', function $$merge(enum$) {
      var self = this;

      
      $send(enum$, 'each', [], function $$24(item){var self = $$24.$$s == null ? this : $$24.$$s;

        
        if (item == null) item = nil;
        return self.$add(item);}, {$$s: self});
      return self;
    });
    
    $def(self, '$replace', function $$replace(enum$) {
      var self = this;

      
      self.$clear();
      self.$merge(enum$);
      return self;
    });
    
    $def(self, '$size', function $$size() {
      var self = this;

      return self.hash.$size()
    });
    
    $def(self, '$subtract', function $$subtract(enum$) {
      var self = this;

      
      $send(enum$, 'each', [], function $$25(item){var self = $$25.$$s == null ? this : $$25.$$s;

        
        if (item == null) item = nil;
        return self.$delete(item);}, {$$s: self});
      return self;
    });
    
    $def(self, '$|', function $Set_$$26(enum$) {
      var self = this;

      
      if (!$truthy(enum$['$respond_to?']("each"))) {
        $Kernel.$raise($$$('ArgumentError'), "value must be enumerable")
      };
      return self.$dup().$merge(enum$);
    });
    
    function is_set(set) {
      ($truthy(($ret_or_1 = (set)['$is_a?']($$$('Set')))) ? ($ret_or_1) : ($Kernel.$raise($$$('ArgumentError'), "value must be a set")))
    }
  ;
    
    $def(self, '$superset?', function $Set_superset$ques$27(set) {
      var self = this;

      
      is_set(set);
      if ($truthy($rb_lt(self.$size(), set.$size()))) {
        return false
      };
      return $send(set, 'all?', [], function $$28(o){var self = $$28.$$s == null ? this : $$28.$$s;

        
        if (o == null) o = nil;
        return self['$include?'](o);}, {$$s: self});
    });
    
    $def(self, '$proper_superset?', function $Set_proper_superset$ques$29(set) {
      var self = this;

      
      is_set(set);
      if ($truthy($rb_le(self.$size(), set.$size()))) {
        return false
      };
      return $send(set, 'all?', [], function $$30(o){var self = $$30.$$s == null ? this : $$30.$$s;

        
        if (o == null) o = nil;
        return self['$include?'](o);}, {$$s: self});
    });
    
    $def(self, '$subset?', function $Set_subset$ques$31(set) {
      var self = this;

      
      is_set(set);
      if ($truthy($rb_lt(set.$size(), self.$size()))) {
        return false
      };
      return $send(self, 'all?', [], function $$32(o){
        
        if (o == null) o = nil;
        return set['$include?'](o);});
    });
    
    $def(self, '$proper_subset?', function $Set_proper_subset$ques$33(set) {
      var self = this;

      
      is_set(set);
      if ($truthy($rb_le(set.$size(), self.$size()))) {
        return false
      };
      return $send(self, 'all?', [], function $$34(o){
        
        if (o == null) o = nil;
        return set['$include?'](o);});
    });
    
    $def(self, '$intersect?', function $Set_intersect$ques$35(set) {
      var self = this;

      
      is_set(set);
      if ($truthy($rb_lt(self.$size(), set.$size()))) {
        return $send(self, 'any?', [], function $$36(o){
          
          if (o == null) o = nil;
          return set['$include?'](o);})
      } else {
        return $send(set, 'any?', [], function $$37(o){var self = $$37.$$s == null ? this : $$37.$$s;

          
          if (o == null) o = nil;
          return self['$include?'](o);}, {$$s: self})
      };
    });
    
    $def(self, '$disjoint?', function $Set_disjoint$ques$38(set) {
      var self = this;

      return self['$intersect?'](set)['$!']()
    });
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      return self.hash.$keys()
    });
    $alias(self, "+", "|");
    $alias(self, "<", "proper_subset?");
    $alias(self, "<<", "add");
    $alias(self, "<=", "subset?");
    $alias(self, ">", "proper_superset?");
    $alias(self, ">=", "superset?");
    $alias(self, "difference", "-");
    $alias(self, "filter!", "select!");
    $alias(self, "length", "size");
    $alias(self, "map!", "collect!");
    $alias(self, "member?", "include?");
    return $alias(self, "union", "|");
  })('::', null, $nesting)
};

Opal.modules["corelib/dir"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('[],pwd');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Dir');

    var $nesting = [self].concat($parent_nesting);

    return (function(self, $parent_nesting) {
      
      
      
      $def(self, '$chdir', function $$chdir(dir) {
        var $yield = $$chdir.$$p || nil, prev_cwd = nil;

        $$chdir.$$p = null;
        return (function() { try {
        
        prev_cwd = Opal.current_dir;
        Opal.current_dir = dir;
        return Opal.yieldX($yield, []);;
        } finally {
          Opal.current_dir = prev_cwd
        }; })()
      });
      
      $def(self, '$pwd', function $$pwd() {
        
        return Opal.current_dir || '.';
      });
      
      $def(self, '$home', function $$home() {
        var $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = $$$('ENV')['$[]']("HOME")))) {
          return $ret_or_1
        } else {
          return "."
        }
      });
      return $alias(self, "getwd", "pwd");
    })(Opal.get_singleton_class(self), $nesting)
  })('::', null, $nesting)
};

Opal.modules["corelib/file"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $truthy = Opal.truthy, $klass = Opal.klass, $const_set = Opal.const_set, $Opal = Opal.Opal, $regexp = Opal.regexp, $rb_plus = Opal.rb_plus, $def = Opal.def, $Kernel = Opal.Kernel, $eqeq = Opal.eqeq, $rb_lt = Opal.rb_lt, $rb_minus = Opal.rb_minus, $range = Opal.range, $send = Opal.send, $slice = Opal.slice, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('respond_to?,to_path,coerce_to!,pwd,split,sub,+,unshift,join,home,raise,start_with?,absolute_path,==,<,dirname,-,basename,empty?,rindex,[],length,nil?,gsub,find,=~,map,each_with_index,flatten,reject,to_proc,end_with?,expand_path,exist?');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'File');

    var $nesting = [self].concat($parent_nesting), windows_root_rx = nil;

    
    $const_set($nesting[0], 'Separator', $const_set($nesting[0], 'SEPARATOR', "/"));
    $const_set($nesting[0], 'ALT_SEPARATOR', nil);
    $const_set($nesting[0], 'PATH_SEPARATOR', ":");
    $const_set($nesting[0], 'FNM_SYSCASE', 0);
    windows_root_rx = /^[a-zA-Z]:(?:\\|\/)/;
    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$absolute_path', function $$absolute_path(path, basedir) {
        var sep = nil, sep_chars = nil, new_parts = nil, $ret_or_1 = nil, path_abs = nil, basedir_abs = nil, parts = nil, leading_sep = nil, abs = nil, new_path = nil;

        
        if (basedir == null) basedir = nil;
        sep = $$('SEPARATOR');
        sep_chars = $sep_chars();
        new_parts = [];
        path = ($truthy(path['$respond_to?']("to_path")) ? (path.$to_path()) : (path));
        path = $Opal['$coerce_to!'](path, $$$('String'), "to_str");
        basedir = ($truthy(($ret_or_1 = basedir)) ? ($ret_or_1) : ($$$('Dir').$pwd()));
        path_abs = path.substr(0, sep.length) === sep || windows_root_rx.test(path);
        basedir_abs = basedir.substr(0, sep.length) === sep || windows_root_rx.test(basedir);
        if ($truthy(path_abs)) {
          
          parts = path.$split($regexp(["[", sep_chars, "]"]));
          leading_sep = windows_root_rx.test(path) ? '' : path.$sub($regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          abs = true;
        } else {
          
          parts = $rb_plus(basedir.$split($regexp(["[", sep_chars, "]"])), path.$split($regexp(["[", sep_chars, "]"])));
          leading_sep = windows_root_rx.test(basedir) ? '' : basedir.$sub($regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          abs = basedir_abs;
        };
        
        var part;
        for (var i = 0, ii = parts.length; i < ii; i++) {
          part = parts[i];

          if (
            (part === nil) ||
            (part === ''  && ((new_parts.length === 0) || abs)) ||
            (part === '.' && ((new_parts.length === 0) || abs))
          ) {
            continue;
          }
          if (part === '..') {
            new_parts.pop();
          } else {
            new_parts.push(part);
          }
        }

        if (!abs && parts[0] !== '.') {
          new_parts.$unshift(".")
        }
      ;
        new_path = new_parts.$join(sep);
        if ($truthy(abs)) {
          new_path = $rb_plus(leading_sep, new_path)
        };
        return new_path;
      }, -2);
      
      $def(self, '$expand_path', function $$expand_path(path, basedir) {
        var self = this, sep = nil, sep_chars = nil, home = nil, leading_sep = nil, home_path_regexp = nil;

        
        if (basedir == null) basedir = nil;
        sep = $$('SEPARATOR');
        sep_chars = $sep_chars();
        if ($truthy(path[0] === '~' || (basedir && basedir[0] === '~'))) {
          
          home = $$('Dir').$home();
          if (!$truthy(home)) {
            $Kernel.$raise($$$('ArgumentError'), "couldn't find HOME environment -- expanding `~'")
          };
          leading_sep = windows_root_rx.test(home) ? '' : home.$sub($regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          if (!$truthy(home['$start_with?'](leading_sep))) {
            $Kernel.$raise($$$('ArgumentError'), "non-absolute home")
          };
          home = $rb_plus(home, sep);
          home_path_regexp = $regexp(["^\\~(?:", sep, "|$)"]);
          path = path.$sub(home_path_regexp, home);
          if ($truthy(basedir)) {
            basedir = basedir.$sub(home_path_regexp, home)
          };
        };
        return self.$absolute_path(path, basedir);
      }, -2);
      
      // Coerce a given path to a path string using #to_path and #to_str
      function $coerce_to_path(path) {
        if ($truthy((path)['$respond_to?']("to_path"))) {
          path = path.$to_path();
        }

        path = $Opal['$coerce_to!'](path, $$$('String'), "to_str");

        return path;
      }

      // Return a RegExp compatible char class
      function $sep_chars() {
        if ($$('ALT_SEPARATOR') === nil) {
          return Opal.escape_regexp($$('SEPARATOR'));
        } else {
          return Opal.escape_regexp($rb_plus($$('SEPARATOR'), $$('ALT_SEPARATOR')));
        }
      }
    ;
      
      $def(self, '$dirname', function $$dirname(path, level) {
        var self = this, sep_chars = nil;

        
        if (level == null) level = 1;
        if ($eqeq(level, 0)) {
          return path
        };
        if ($truthy($rb_lt(level, 0))) {
          $Kernel.$raise($$$('ArgumentError'), "level can't be negative")
        };
        sep_chars = $sep_chars();
        path = $coerce_to_path(path);
        
        var absolute = path.match(new RegExp("^[" + (sep_chars) + "]")), out;

        path = path.replace(new RegExp("[" + (sep_chars) + "]+$"), ''); // remove trailing separators
        path = path.replace(new RegExp("[^" + (sep_chars) + "]+$"), ''); // remove trailing basename
        path = path.replace(new RegExp("[" + (sep_chars) + "]+$"), ''); // remove final trailing separators

        if (path === '') {
          out = absolute ? '/' : '.';
        }
        else {
          out = path;
        }

        if (level == 1) {
          return out;
        }
        else {
          return self.$dirname(out, $rb_minus(level, 1))
        }
      ;
      }, -2);
      
      $def(self, '$basename', function $$basename(name, suffix) {
        var sep_chars = nil;

        
        if (suffix == null) suffix = nil;
        sep_chars = $sep_chars();
        name = $coerce_to_path(name);
        
        if (name.length == 0) {
          return name;
        }

        if (suffix !== nil) {
          suffix = $Opal['$coerce_to!'](suffix, $$$('String'), "to_str")
        } else {
          suffix = null;
        }

        name = name.replace(new RegExp("(.)[" + (sep_chars) + "]*$"), '$1');
        name = name.replace(new RegExp("^(?:.*[" + (sep_chars) + "])?([^" + (sep_chars) + "]+)$"), '$1');

        if (suffix === ".*") {
          name = name.replace(/\.[^\.]+$/, '');
        } else if(suffix !== null) {
          suffix = Opal.escape_regexp(suffix);
          name = name.replace(new RegExp("" + (suffix) + "$"), '');
        }

        return name;
      ;
      }, -2);
      
      $def(self, '$extname', function $$extname(path) {
        var self = this, filename = nil, last_dot_idx = nil;

        
        path = $coerce_to_path(path);
        filename = self.$basename(path);
        if ($truthy(filename['$empty?']())) {
          return ""
        };
        last_dot_idx = filename['$[]']($range(1, -1, false)).$rindex(".");
        if (($truthy(last_dot_idx['$nil?']()) || ($eqeq($rb_plus(last_dot_idx, 1), $rb_minus(filename.$length(), 1))))) {
          return ""
        } else {
          return filename['$[]'](Opal.Range.$new($rb_plus(last_dot_idx, 1), -1, false))
        };
      });
      
      $def(self, '$exist?', function $exist$ques$1(path) {
        
        return Opal.modules[path] != null
      });
      
      $def(self, '$directory?', function $directory$ques$2(path) {
        var files = nil;

        
        files = [];
        
        for (var key in Opal.modules) {
          files.push(key)
        }
      ;
        path = path.$gsub($regexp(["(^.", $$('SEPARATOR'), "+|", $$('SEPARATOR'), "+$)"]));
        return $send(files, 'find', [], function $$3(f){
          
          if (f == null) f = nil;
          return f['$=~']($regexp(["^", path]));});
      });
      
      $def(self, '$join', function $$join($a) {
        var $post_args, paths, result = nil;

        
        $post_args = $slice(arguments);
        paths = $post_args;
        if ($truthy(paths['$empty?']())) {
          return ""
        };
        result = "";
        paths = $send(paths.$flatten().$each_with_index(), 'map', [], function $$4(item, index){
          
          if (item == null) item = nil;
          if (index == null) index = nil;
          if (($eqeq(index, 0) && ($truthy(item['$empty?']())))) {
            return $$('SEPARATOR')
          } else if (($eqeq(paths.$length(), $rb_plus(index, 1)) && ($truthy(item['$empty?']())))) {
            return $$('SEPARATOR')
          } else {
            return item
          };});
        paths = $send(paths, 'reject', [], "empty?".$to_proc());
        $send(paths, 'each_with_index', [], function $$5(item, index){var next_item = nil;

          
          if (item == null) item = nil;
          if (index == null) index = nil;
          next_item = paths['$[]']($rb_plus(index, 1));
          if ($truthy(next_item['$nil?']())) {
            return (result = "" + (result) + (item))
          } else {
            
            if (($truthy(item['$end_with?']($$('SEPARATOR'))) && ($truthy(next_item['$start_with?']($$('SEPARATOR')))))) {
              item = item.$sub($regexp([$$('SEPARATOR'), "+$"]), "")
            };
            return (result = (($truthy(item['$end_with?']($$('SEPARATOR'))) || ($truthy(next_item['$start_with?']($$('SEPARATOR'))))) ? ("" + (result) + (item)) : ("" + (result) + (item) + ($$('SEPARATOR')))));
          };});
        return result;
      }, -1);
      
      $def(self, '$split', function $$split(path) {
        
        return path.$split($$('SEPARATOR'))
      });
      $alias(self, "realpath", "expand_path");
      return $alias(self, "exists?", "exist?");
    })(Opal.get_singleton_class(self), $nesting);
  })('::', $$$('IO'), $nesting)
};

Opal.modules["corelib/process/base"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $slice = Opal.slice, $defs = Opal.defs, $return_val = Opal.return_val, nil = Opal.nil;

  
  (function($base, $super) {
    var self = $klass($base, $super, 'Signal');

    
    return $defs(self, '$trap', function $$trap($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return nil;
    }, -1)
  })('::', null);
  return (function($base, $super) {
    var self = $klass($base, $super, 'GC');

    
    return $defs(self, '$start', $return_val(nil))
  })('::', null);
};

Opal.modules["corelib/process"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $defs = Opal.defs, $truthy = Opal.truthy, $return_val = Opal.return_val, $Kernel = Opal.Kernel, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('const_set,size,<<,__register_clock__,to_f,now,new,[],raise');
  return (function($base) {
    var self = $module($base, 'Process');

    var monotonic = nil;

    
    self.__clocks__ = [];
    $defs(self, '$__register_clock__', function $$__register_clock__(name, func) {
      var self = this;
      if (self.__clocks__ == null) self.__clocks__ = nil;

      
      self.$const_set(name, self.__clocks__.$size());
      return self.__clocks__['$<<'](func);
    });
    self.$__register_clock__("CLOCK_REALTIME", function() { return Date.now() });
    monotonic = false;
    
    if (Opal.global.performance) {
      monotonic = function() {
        return performance.now()
      };
    }
    else if (Opal.global.process && process.hrtime) {
      // let now be the base to get smaller numbers
      var hrtime_base = process.hrtime();

      monotonic = function() {
        var hrtime = process.hrtime(hrtime_base);
        var us = (hrtime[1] / 1000) | 0; // cut below microsecs;
        return ((hrtime[0] * 1000) + (us / 1000));
      };
    }
  ;
    if ($truthy(monotonic)) {
      self.$__register_clock__("CLOCK_MONOTONIC", monotonic)
    };
    $defs(self, '$pid', $return_val(0));
    $defs(self, '$times', function $$times() {
      var t = nil;

      
      t = $$$('Time').$now().$to_f();
      return $$$($$$('Benchmark'), 'Tms').$new(t, t, t, t, t);
    });
    return $defs(self, '$clock_gettime', function $$clock_gettime(clock_id, unit) {
      var self = this, $ret_or_1 = nil, clock = nil;
      if (self.__clocks__ == null) self.__clocks__ = nil;

      
      if (unit == null) unit = "float_second";
      if ($truthy(($ret_or_1 = (clock = self.__clocks__['$[]'](clock_id))))) {
        $ret_or_1
      } else {
        $Kernel.$raise($$$($$$('Errno'), 'EINVAL'), "clock_gettime(" + (clock_id) + ") " + (self.__clocks__['$[]'](clock_id)))
      };
      
      var ms = clock();
      switch (unit) {
        case 'float_second':      return  (ms / 1000);         // number of seconds as a float (default)
        case 'float_millisecond': return  (ms / 1);            // number of milliseconds as a float
        case 'float_microsecond': return  (ms * 1000);         // number of microseconds as a float
        case 'second':            return ((ms / 1000)    | 0); // number of seconds as an integer
        case 'millisecond':       return ((ms / 1)       | 0); // number of milliseconds as an integer
        case 'microsecond':       return ((ms * 1000)    | 0); // number of microseconds as an integer
        case 'nanosecond':        return ((ms * 1000000) | 0); // number of nanoseconds as an integer
        default: $Kernel.$raise($$$('ArgumentError'), "unexpected unit: " + (unit))
      }
    ;
    }, -2);
  })('::')
};

Opal.modules["corelib/random/formatter"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $module = Opal.module, $def = Opal.def, $range = Opal.range, $send = Opal.send, $rb_divide = Opal.rb_divide, $Kernel = Opal.Kernel, $Opal = Opal.Opal, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('_verify_count,bytes,encode,strict_encode64,random_bytes,urlsafe_encode64,split,hex,[]=,[],map,to_proc,join,times,<<,|,ord,/,abs,random_float,raise,coerce_to!,flatten,new,random_number,length,include,extend');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Random');

    var $nesting = [self].concat($parent_nesting);

    
    (function($base, $parent_nesting) {
      var self = $module($base, 'Formatter');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$hex', function $$hex(count) {
        var self = this;

        
        if (count == null) count = nil;
        count = $$$('Random').$_verify_count(count);
        
        var bytes = self.$bytes(count);
        var out = "";
        for (var i = 0; i < count; i++) {
          out += bytes.charCodeAt(i).toString(16).padStart(2, '0');
        }
        return (out).$encode("US-ASCII");
      ;
      }, -1);
      
      $def(self, '$random_bytes', function $$random_bytes(count) {
        var self = this;

        
        if (count == null) count = nil;
        return self.$bytes(count);
      }, -1);
      
      $def(self, '$base64', function $$base64(count) {
        var self = this;

        
        if (count == null) count = nil;
        return $$$('Base64').$strict_encode64(self.$random_bytes(count)).$encode("US-ASCII");
      }, -1);
      
      $def(self, '$urlsafe_base64', function $$urlsafe_base64(count, padding) {
        var self = this;

        
        if (count == null) count = nil;
        if (padding == null) padding = false;
        return $$$('Base64').$urlsafe_encode64(self.$random_bytes(count), padding).$encode("US-ASCII");
      }, -1);
      
      $def(self, '$uuid', function $$uuid() {
        var self = this, str = nil;

        
        str = self.$hex(16).$split("");
        str['$[]='](12, "4");
        str['$[]='](16, (parseInt(str['$[]'](16), 16) & 3 | 8).toString(16));
        str = [str['$[]']($range(0, 8, true)), str['$[]']($range(8, 12, true)), str['$[]']($range(12, 16, true)), str['$[]']($range(16, 20, true)), str['$[]']($range(20, 32, true))];
        str = $send(str, 'map', [], "join".$to_proc());
        return str.$join("-");
      });
      
      $def(self, '$random_float', function $$random_float() {
        var self = this, bs = nil, num = nil;

        
        bs = self.$bytes(4);
        num = 0;
        $send((4), 'times', [], function $$1(i){
          
          if (i == null) i = nil;
          num = num['$<<'](8);
          return (num = num['$|'](bs['$[]'](i).$ord()));});
        return $rb_divide(num.$abs(), 2147483647);
      });
      
      $def(self, '$random_number', function $$random_number(limit) {
        var self = this;

        
        ;
        
        function randomFloat() {
          return self.$random_float();
        }

        function randomInt(max) {
          return Math.floor(randomFloat() * max);
        }

        function randomRange() {
          var min = limit.begin,
              max = limit.end;

          if (min === nil || max === nil) {
            return nil;
          }

          var length = max - min;

          if (length < 0) {
            return nil;
          }

          if (length === 0) {
            return min;
          }

          if (max % 1 === 0 && min % 1 === 0 && !limit.excl) {
            length++;
          }

          return randomInt(length) + min;
        }

        if (limit == null) {
          return randomFloat();
        } else if (limit.$$is_range) {
          return randomRange();
        } else if (limit.$$is_number) {
          if (limit <= 0) {
            $Kernel.$raise($$$('ArgumentError'), "invalid argument - " + (limit))
          }

          if (limit % 1 === 0) {
            // integer
            return randomInt(limit);
          } else {
            return randomFloat() * limit;
          }
        } else {
          limit = $Opal['$coerce_to!'](limit, $$$('Integer'), "to_int");

          if (limit <= 0) {
            $Kernel.$raise($$$('ArgumentError'), "invalid argument - " + (limit))
          }

          return randomInt(limit);
        }
      ;
      }, -1);
      return $def(self, '$alphanumeric', function $$alphanumeric(count) {
        var self = this, map = nil;

        
        if (count == null) count = nil;
        count = $$('Random').$_verify_count(count);
        map = $send([$range("0", "9", false), $range("a", "z", false), $range("A", "Z", false)], 'map', [], "to_a".$to_proc()).$flatten();
        return $send($$$('Array'), 'new', [count], function $$2(i){var self = $$2.$$s == null ? this : $$2.$$s;

          
          if (i == null) i = nil;
          return map['$[]'](self.$random_number(map.$length()));}, {$$s: self}).$join();
      }, -1);
    })(self, $nesting);
    self.$include($$$($$$('Random'), 'Formatter'));
    return self.$extend($$$($$$('Random'), 'Formatter'));
  })('::', null, $nesting)
};

Opal.modules["corelib/random/mersenne_twister"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $const_set = Opal.const_set, $send = Opal.send, nil = Opal.nil, $$$ = Opal.$$$, mersenne_twister = nil;

  Opal.add_stubs('generator=');
  
  mersenne_twister = (function() {
  /* Period parameters */
  var N = 624;
  var M = 397;
  var MATRIX_A = 0x9908b0df;      /* constant vector a */
  var UMASK = 0x80000000;         /* most significant w-r bits */
  var LMASK = 0x7fffffff;         /* least significant r bits */
  var MIXBITS = function(u,v) { return ( ((u) & UMASK) | ((v) & LMASK) ); };
  var TWIST = function(u,v) { return (MIXBITS((u),(v)) >>> 1) ^ ((v & 0x1) ? MATRIX_A : 0x0); };

  function init(s) {
    var mt = {left: 0, next: N, state: new Array(N)};
    init_genrand(mt, s);
    return mt;
  }

  /* initializes mt[N] with a seed */
  function init_genrand(mt, s) {
    var j, i;
    mt.state[0] = s >>> 0;
    for (j=1; j<N; j++) {
      mt.state[j] = (1812433253 * ((mt.state[j-1] ^ (mt.state[j-1] >> 30) >>> 0)) + j);
      /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
      /* In the previous versions, MSBs of the seed affect   */
      /* only MSBs of the array state[].                     */
      /* 2002/01/09 modified by Makoto Matsumoto             */
      mt.state[j] &= 0xffffffff;  /* for >32 bit machines */
    }
    mt.left = 1;
    mt.next = N;
  }

  /* generate N words at one time */
  function next_state(mt) {
    var p = 0, _p = mt.state;
    var j;

    mt.left = N;
    mt.next = 0;

    for (j=N-M+1; --j; p++)
      _p[p] = _p[p+(M)] ^ TWIST(_p[p+(0)], _p[p+(1)]);

    for (j=M; --j; p++)
      _p[p] = _p[p+(M-N)] ^ TWIST(_p[p+(0)], _p[p+(1)]);

    _p[p] = _p[p+(M-N)] ^ TWIST(_p[p+(0)], _p[0]);
  }

  /* generates a random number on [0,0xffffffff]-interval */
  function genrand_int32(mt) {
    /* mt must be initialized */
    var y;

    if (--mt.left <= 0) next_state(mt);
    y = mt.state[mt.next++];

    /* Tempering */
    y ^= (y >>> 11);
    y ^= (y << 7) & 0x9d2c5680;
    y ^= (y << 15) & 0xefc60000;
    y ^= (y >>> 18);

    return y >>> 0;
  }

  function int_pair_to_real_exclusive(a, b) {
    a >>>= 5;
    b >>>= 6;
    return(a*67108864.0+b)*(1.0/9007199254740992.0);
  }

  // generates a random number on [0,1) with 53-bit resolution
  function genrand_real(mt) {
    /* mt must be initialized */
    var a = genrand_int32(mt), b = genrand_int32(mt);
    return int_pair_to_real_exclusive(a, b);
  }

  return { genrand_real: genrand_real, init: init };
})();
  return (function($base, $super) {
    var self = $klass($base, $super, 'Random');

    var $a;

    
    var MAX_INT = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;
    $const_set(self, 'MERSENNE_TWISTER_GENERATOR', {
    new_seed: function() { return Math.round(Math.random() * MAX_INT); },
    reseed: function(seed) { return mersenne_twister.init(seed); },
    rand: function(mt) { return mersenne_twister.genrand_real(mt); }
  });
    return ($a = [$$$(self, 'MERSENNE_TWISTER_GENERATOR')], $send(self, 'generator=', $a), $a[$a.length - 1]);
  })('::', null);
};

Opal.modules["corelib/random"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $truthy = Opal.truthy, $klass = Opal.klass, $Kernel = Opal.Kernel, $defs = Opal.defs, $Opal = Opal.Opal, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $send = Opal.send, self = Opal.top, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,attr_reader,to_int,raise,new_seed,coerce_to!,reseed,rand,seed,bytes,===,==,state,_verify_count,encode,join,new,chr,random_number,random_float,const_defined?,const_set');
  
  self.$require("corelib/random/formatter");
  (function($base, $super) {
    var self = $klass($base, $super, 'Random');

    
    
    self.$attr_reader("seed", "state");
    $defs(self, '$_verify_count', function $$_verify_count(count) {
      
      
      if (!$truthy(count)) count = 16;
      if (typeof count !== "number") count = (count).$to_int();
      if (count < 0) $Kernel.$raise($$$('ArgumentError'), "negative string size (or size too big)");
      count = Math.floor(count);
      return count;
    
    });
    
    $def(self, '$initialize', function $$initialize(seed) {
      var self = this;

      
      if (seed == null) seed = $$$('Random').$new_seed();
      seed = $Opal['$coerce_to!'](seed, $$$('Integer'), "to_int");
      self.state = seed;
      return self.$reseed(seed);
    }, -1);
    
    $def(self, '$reseed', function $$reseed(seed) {
      var self = this;

      
      self.seed = seed;
      return self.$rng = Opal.$$rand.reseed(seed);;
    });
    $defs(self, '$new_seed', function $$new_seed() {
      
      return Opal.$$rand.new_seed();
    });
    $defs(self, '$rand', function $$rand(limit) {
      var self = this;

      
      ;
      return $$$(self, 'DEFAULT').$rand(limit);
    }, -1);
    $defs(self, '$srand', function $$srand(n) {
      var self = this, previous_seed = nil;

      
      if (n == null) n = $$$('Random').$new_seed();
      n = $Opal['$coerce_to!'](n, $$$('Integer'), "to_int");
      previous_seed = $$$(self, 'DEFAULT').$seed();
      $$$(self, 'DEFAULT').$reseed(n);
      return previous_seed;
    }, -1);
    $defs(self, '$urandom', function $$urandom(size) {
      
      return $$$('SecureRandom').$bytes(size)
    });
    
    $def(self, '$==', function $Random_$eq_eq$1(other) {
      var self = this, $ret_or_1 = nil;

      
      if (!$eqeqeq($$$('Random'), other)) {
        return false
      };
      if ($truthy(($ret_or_1 = self.$seed()['$=='](other.$seed())))) {
        return self.$state()['$=='](other.$state())
      } else {
        return $ret_or_1
      };
    });
    
    $def(self, '$bytes', function $$bytes(length) {
      var self = this;

      
      length = $$$('Random').$_verify_count(length);
      return $send($$$('Array'), 'new', [length], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;

        return self.$rand(255).$chr()}, {$$s: self}).$join().$encode("ASCII-8BIT");
    });
    $defs(self, '$bytes', function $$bytes(length) {
      var self = this;

      return $$$(self, 'DEFAULT').$bytes(length)
    });
    
    $def(self, '$rand', function $$rand(limit) {
      var self = this;

      
      ;
      return self.$random_number(limit);
    }, -1);
    
    $def(self, '$random_float', function $$random_float() {
      var self = this;

      
      self.state++;
      return Opal.$$rand.rand(self.$rng);
    
    });
    $defs(self, '$random_float', function $$random_float() {
      var self = this;

      return $$$(self, 'DEFAULT').$random_float()
    });
    return $defs(self, '$generator=', function $Random_generator$eq$3(generator) {
      var self = this;

      
      Opal.$$rand = generator;
      if ($truthy(self['$const_defined?']("DEFAULT"))) {
        return $$$(self, 'DEFAULT').$reseed()
      } else {
        return self.$const_set("DEFAULT", self.$new(self.$new_seed()))
      };
    });
  })('::', null);
  return self.$require("corelib/random/mersenne_twister");
};

Opal.modules["corelib/unsupported"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $Kernel = Opal.Kernel, $klass = Opal.klass, $send = Opal.send, $slice = Opal.slice, $module = Opal.module, $def = Opal.def, $return_val = Opal.return_val, $alias = Opal.alias, $defs = Opal.defs, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('raise,warn,each,define_method,%,public,private_method_defined?,private_class_method,instance_method,instance_methods,method_defined?,private_methods');
  
  
  var warnings = {};

  function handle_unsupported_feature(message) {
    switch (Opal.config.unsupported_features_severity) {
    case 'error':
      $Kernel.$raise($$$('NotImplementedError'), message)
      break;
    case 'warning':
      warn(message)
      break;
    default: // ignore
      // noop
    }
  }

  function warn(string) {
    if (warnings[string]) {
      return;
    }

    warnings[string] = true;
    self.$warn(string);
  }
;
  (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    
    var ERROR = "String#%s not supported. Mutable String methods are not supported in Opal.";
    return $send(["<<", "capitalize!", "chomp!", "chop!", "downcase!", "gsub!", "lstrip!", "next!", "reverse!", "slice!", "squeeze!", "strip!", "sub!", "succ!", "swapcase!", "tr!", "tr_s!", "upcase!", "prepend", "[]=", "clear", "encode!", "unicode_normalize!"], 'each', [], function $String$1(method_name){var self = $String$1.$$s == null ? this : $String$1.$$s;

      
      if (method_name == null) method_name = nil;
      return $send(self, 'define_method', [method_name], function $$2($a){var $post_args, $fwd_rest;

        
        $post_args = $slice(arguments);
        $fwd_rest = $post_args;
        return $Kernel.$raise($$$('NotImplementedError'), (ERROR)['$%'](method_name));}, -1);}, {$$s: self});
  })('::', null);
  (function($base) {
    var self = $module($base, 'Kernel');

    
    
    var ERROR = "Object tainting is not supported by Opal";
    
    $def(self, '$taint', function $$taint() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    });
    
    $def(self, '$untaint', function $$untaint() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    });
    return $def(self, '$tainted?', function $Kernel_tainted$ques$3() {
      
      
      handle_unsupported_feature(ERROR);
      return false;
    });
  })('::');
  (function($base, $super) {
    var self = $klass($base, $super, 'Module');

    
    
    
    $def(self, '$public', function $Module_public$4($a) {
      var $post_args, methods, self = this;

      
      $post_args = $slice(arguments);
      methods = $post_args;
      
      if (methods.length === 0) {
        self.$$module_function = false;
        return nil;
      }
      return (methods.length === 1) ? methods[0] : methods;
    ;
    }, -1);
    
    $def(self, '$private_class_method', function $$private_class_method($a) {
      var $post_args, methods;

      
      $post_args = $slice(arguments);
      methods = $post_args;
      return (methods.length === 1) ? methods[0] : methods;;
    }, -1);
    
    $def(self, '$private_method_defined?', $return_val(false));
    
    $def(self, '$private_constant', function $$private_constant($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return nil;
    }, -1);
    $alias(self, "nesting", "public");
    $alias(self, "private", "public");
    $alias(self, "protected", "public");
    $alias(self, "protected_method_defined?", "private_method_defined?");
    $alias(self, "public_class_method", "private_class_method");
    $alias(self, "public_instance_method", "instance_method");
    $alias(self, "public_instance_methods", "instance_methods");
    return $alias(self, "public_method_defined?", "method_defined?");
  })('::', null);
  (function($base) {
    var self = $module($base, 'Kernel');

    
    
    
    $def(self, '$private_methods', function $$private_methods($a) {
      var $post_args, methods;

      
      $post_args = $slice(arguments);
      methods = $post_args;
      return [];
    }, -1);
    $alias(self, "protected_methods", "private_methods");
    $alias(self, "private_instance_methods", "private_methods");
    return $alias(self, "protected_instance_methods", "private_methods");
  })('::');
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$eval', function $Kernel_eval$5($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return $Kernel.$raise($$$('NotImplementedError'), "To use Kernel#eval, you must first require 'opal-parser'. " + ("See https://github.com/opal/opal/blob/" + ($$('RUBY_ENGINE_VERSION')) + "/docs/opal_parser.md for details."));
    }, -1)
  })('::', $nesting);
  $defs(self, '$public', function $public$6($a) {
    var $post_args, methods;

    
    $post_args = $slice(arguments);
    methods = $post_args;
    return (methods.length === 1) ? methods[0] : methods;;
  }, -1);
  return $defs(self, '$private', function $private$7($a) {
    var $post_args, methods;

    
    $post_args = $slice(arguments);
    methods = $post_args;
    return (methods.length === 1) ? methods[0] : methods;;
  }, -1);
};

Opal.modules["corelib/binding"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def, $slice = Opal.slice, $send = Opal.send, $to_a = Opal.to_a, $Kernel = Opal.Kernel, $return_ivar = Opal.return_ivar, $eqeq = Opal.eqeq, $thrower = Opal.thrower, $module = Opal.module, $const_set = Opal.const_set, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('js_eval,call,raise,inspect,include?,==,receiver,eval,attr_reader,new');
  
  (function($base, $super) {
    var self = $klass($base, $super, 'Binding');

    var $proto = self.$$prototype;

    $proto.jseval = $proto.scope_variables = nil;
    
    
    $def(self, '$initialize', function $$initialize(jseval, scope_variables, receiver, source_location) {
      var $a, self = this;

      
      if (scope_variables == null) scope_variables = [];
      ;
      if (source_location == null) source_location = nil;
      $a = [jseval, scope_variables, receiver, source_location], (self.jseval = $a[0]), (self.scope_variables = $a[1]), (self.receiver = $a[2]), (self.source_location = $a[3]), $a;
      if ($truthy(typeof receiver !== undefined)) {
        return nil
      } else {
        return (receiver = self.$js_eval("self"))
      };
    }, -2);
    
    $def(self, '$js_eval', function $$js_eval($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      if ($truthy(self.jseval)) {
        return $send(self.jseval, 'call', $to_a(args))
      } else {
        return $Kernel.$raise("Evaluation on a Proc#binding is not supported")
      };
    }, -1);
    
    $def(self, '$local_variable_get', function $$local_variable_get(symbol) {
      var self = this;

      try {
        return self.$js_eval(symbol)
      } catch ($err) {
        if (Opal.rescue($err, [$$$('Exception')])) {
          try {
            return $Kernel.$raise($$$('NameError'), "local variable `" + (symbol) + "' is not defined for " + (self.$inspect()))
          } finally { Opal.pop_exception($err); }
        } else { throw $err; }
      }
    });
    
    $def(self, '$local_variable_set', function $$local_variable_set(symbol, value) {
      var self = this;

      
      Opal.Binding.tmp_value = value;
      self.$js_eval("" + (symbol) + " = Opal.Binding.tmp_value");
      delete Opal.Binding.tmp_value;
      return value;
    });
    
    $def(self, '$local_variables', $return_ivar("scope_variables"));
    
    $def(self, '$local_variable_defined?', function $Binding_local_variable_defined$ques$1(value) {
      var self = this;

      return self.scope_variables['$include?'](value)
    });
    
    $def(self, '$eval', function $Binding_eval$2(str, file, line) {try { 
      var self = this;

      
      if (file == null) file = nil;
      if (line == null) line = nil;
      if ($eqeq(str, "self")) {
        return self.$receiver()
      };
      return $Kernel.$eval(str, self, file, line);} catch($e) {
        if ($e === Opal.t_eval_return) return $e.$v;
        throw $e;
      }
    }, -2);
    return self.$attr_reader("receiver", "source_location");
  })('::', null);
  (function($base) {
    var self = $module($base, 'Kernel');

    
    return $def(self, '$binding', function $$binding() {
      
      return $Kernel.$raise("Opal doesn't support dynamic calls to binding")
    })
  })('::');
  return $const_set($nesting[0], 'TOPLEVEL_BINDING', $$$('Binding').$new(
    function(js) {
      return (new Function("self", "return " + js))(self);
    }
  , [], self, ["<main>", 0]));
};

Opal.modules["corelib/irb"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $defs = Opal.defs, $gvars = Opal.gvars, $lambda = Opal.lambda, $hash_rehash = Opal.hash_rehash, $send = Opal.send, $rb_plus = Opal.rb_plus, $const_set = Opal.const_set, $klass = Opal.klass, $def = Opal.def, $Opal = Opal.Opal, $range = Opal.range, $eqeq = Opal.eqeq, $thrower = Opal.thrower, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include?,raise,attr_accessor,singleton_class,output=,browser?,each,dup,write_proc=,proc,+,output,join,last,split,end_with?,call,write_proc,tty=,read_proc,read_proc=,freeze,new,string,ensure_loaded,prepare_console,loop,print,gets,puts,start_with?,[],==,silence,message,empty?,warnings,warn,full_message,eval_and_print,irb');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'IRB');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $defs(self, '$ensure_loaded', function $$ensure_loaded(library) {
        var version = nil, url = nil;

        
        if ($truthy((Opal.loaded_features)['$include?'](library))) {
          return nil
        };
        version = ($truthy($$('RUBY_ENGINE_VERSION')['$include?']("dev")) ? ("master") : ($$('RUBY_ENGINE_VERSION')));
        url = "https://cdn.opalrb.com/opal/" + (version) + "/" + (library) + ".js";
        
        var libcode;

        if (typeof XMLHttpRequest !== 'undefined') { // Browser
          var r = new XMLHttpRequest();
          r.open("GET", url, false);
          r.send('');
          libcode = r.responseText;
        }
        else {
          $Kernel.$raise("You need to provision " + (library) + " yourself in this environment")
        }

        (new Function('Opal', libcode))(Opal);

        Opal.require(library);
      ;
        if ($truthy((Opal.loaded_features)['$include?'](library))) {
          return nil
        } else {
          return $Kernel.$raise("Could not load " + (library) + " for some reason")
        };
      });
      self.$singleton_class().$attr_accessor("output");
      $defs(self, '$prepare_console', function $$prepare_console() {
        var block = $$prepare_console.$$p || nil, $a, self = this, original = nil, original_read_proc = nil;
        if ($gvars.stdout == null) $gvars.stdout = nil;
        if ($gvars.stderr == null) $gvars.stderr = nil;
        if ($gvars.stdin == null) $gvars.stdin = nil;

        $$prepare_console.$$p = null;
        
        ;
        return (function() { try {
        
        self['$output=']("");
        original = $hash_rehash(new Map([[$gvars.stdout, $lambda(function $$1(i){
          
          if (i == null) i = nil;
          return ($gvars.stdout = i);})], [$gvars.stderr, $lambda(function $$2(i){
          
          if (i == null) i = nil;
          return ($gvars.stderr = i);})]]));
        if ($truthy(self['$browser?']())) {
          
          $send(original, 'each', [], function $$3(pipe, pipe_setter){var self = $$3.$$s == null ? this : $$3.$$s, new_pipe = nil;

            
            if (pipe == null) pipe = nil;
            if (pipe_setter == null) pipe_setter = nil;
            new_pipe = pipe.$dup();
            new_pipe['$write_proc=']($send(self, 'proc', [], function $$4(str){var self = $$4.$$s == null ? this : $$4.$$s;

              
              if (str == null) str = nil;
              self['$output=']($rb_plus(self.$output(), str));
              self['$output='](self.$output().$split("\n").$last(30).$join("\n"));
              if ($truthy(str['$end_with?']("\n"))) {
                self['$output=']($rb_plus(self.$output(), "\n"))
              };
              return pipe.$write_proc().$call(str);}, {$$s: self}));
            new_pipe['$tty='](false);
            return pipe_setter.$call(new_pipe);}, {$$s: self});
          original_read_proc = $gvars.stdin.$read_proc();
          $gvars.stdin['$read_proc='](function(s) { var p = prompt(self.$output()); if (p !== null) return p + "\n"; return nil; });
        };
        return Opal.yieldX(block, []);;
        } finally {
          ($send(original, 'each', [], function $$5(pipe, pipe_setter){
            
            if (pipe == null) pipe = nil;
            if (pipe_setter == null) pipe_setter = nil;
            return pipe_setter.$call(pipe);}), ($a = [original_read_proc], $send($gvars.stdin, 'read_proc=', $a), $a[$a.length - 1]), ($a = [""], $send(self, 'output=', $a), $a[$a.length - 1]))
        }; })();
      });
      $defs(self, '$browser?', function $IRB_browser$ques$6() {
        
        return typeof(document) !== 'undefined' && typeof(prompt) !== 'undefined';
      });
      $const_set($nesting[0], 'LINEBREAKS', ["unexpected token $end", "unterminated string meets end of file"].$freeze());
      return (function($base, $super) {
        var self = $klass($base, $super, 'Silencer');

        var $proto = self.$$prototype;

        $proto.collector = $proto.stderr = nil;
        
        
        $def(self, '$initialize', function $$initialize() {
          var self = this;
          if ($gvars.stderr == null) $gvars.stderr = nil;

          return (self.stderr = $gvars.stderr)
        });
        
        $def(self, '$silence', function $$silence() {
          var $yield = $$silence.$$p || nil, self = this;

          $$silence.$$p = null;
          return (function() { try {
          
          self.collector = $$$('StringIO').$new();
          $gvars.stderr = self.collector;
          return Opal.yieldX($yield, []);;
          } finally {
            ($gvars.stderr = self.stderr)
          }; })()
        });
        return $def(self, '$warnings', function $$warnings() {
          var self = this;

          return self.collector.$string()
        });
      })($nesting[0], null);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Binding');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$irb', function $$irb() {try { var $t_return = $thrower('return'); 
      var self = this, silencer = nil;

      
      $$$($Opal, 'IRB').$ensure_loaded("opal-replutils");
      silencer = $$$($$$($Opal, 'IRB'), 'Silencer').$new();
      return $send($$$($Opal, 'IRB'), 'prepare_console', [], function $$7(){var self = $$7.$$s == null ? this : $$7.$$s;

        return (function(){try { var $t_break = $thrower('break'); return $send(self, 'loop', [], function $$8(){var self = $$8.$$s == null ? this : $$8.$$s, line = nil, code = nil, mode = nil, js_code = nil, e = nil;

          
          self.$print(">> ");
          line = self.$gets();
          if (!$truthy(line)) {
            $t_break.$throw(nil, $$8.$$is_lambda)
          };
          code = "";
          if ($truthy($$$($Opal, 'IRB')['$browser?']())) {
            self.$puts(line)
          };
          if ($truthy(line['$start_with?']("ls "))) {
            
            code = line['$[]']($range(3, -1, false));
            mode = "ls";
          } else if ($eqeq(line, "ls\n")) {
            
            code = "self";
            mode = "ls";
          } else if ($truthy(line['$start_with?']("show "))) {
            
            code = line['$[]']($range(5, -1, false));
            mode = "show";
          } else {
            
            code = line;
            mode = "inspect";
          };
          js_code = nil;
          
          do { try {
            $send(silencer, 'silence', [], function $$9(){
              return (js_code = Opal.compile(code, {irb: true}))})
          } catch ($err) {
            if (Opal.rescue($err, [$$('SyntaxError')])) {(e = $err)
              try {
                if ($truthy($$$($$$($Opal, 'IRB'), 'LINEBREAKS')['$include?'](e.$message()))) {
                  
                  self.$print(".. ");
                  line = self.$gets();
                  if (!$truthy(line)) {
                    $t_return.$throw(nil, $$8.$$is_lambda)
                  };
                  if ($truthy($$$($Opal, 'IRB')['$browser?']())) {
                    self.$puts(line)
                  };
                  code = $rb_plus(code, line);
                  continue;
                } else if ($truthy(silencer.$warnings()['$empty?']())) {
                  self.$warn(e.$full_message())
                } else {
                  self.$warn(silencer.$warnings())
                }
              } finally { Opal.pop_exception($err); }
            } else { throw $err; }
          } break; } while(1);;
          if ($eqeq(mode, "show")) {
            
            self.$puts(js_code);
            $t_return.$throw(nil, $$8.$$is_lambda);
          };
          return self.$puts($$$('REPLUtils').$eval_and_print(js_code, mode, false, self));}, {$$s: self, $$ret: $t_return})} catch($e) {
          if ($e === $t_break) return $e.$v;
          throw $e;
        } finally {$t_break.is_orphan = true;}})()}, {$$s: self});} catch($e) {
        if ($e === $t_return) return $e.$v;
        throw $e;
      } finally {$t_return.is_orphan = true;}
    })
  })('::', null, $nesting);
  
  // Run in WebTools console with: Opal.irb(c => eval(c))
  Opal.irb = function(fun) {
    $$$('Binding').$new(fun).$irb()
  }

  Opal.load_parser = function() {
    Opal.Opal.IRB.$ensure_loaded('opal-parser');
  }

  if (typeof Opal.eval === 'undefined') {
    Opal.eval = function(str) {
      Opal.load_parser();
      return Opal.eval(str);
    }
  }

  if (typeof Opal.compile === 'undefined') {
    Opal.compile = function(str, options) {
      Opal.load_parser();
      return Opal.compile(str, options);
    }
  }
;
};

Opal.modules["opal"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $Object = Opal.Object, nil = Opal.nil;

  Opal.add_stubs('require,autoload');
  
  $Object.$require("opal/base");
  $Object.$require("opal/mini");
  $Object.$require("corelib/kernel/format");
  $Object.$require("corelib/string/encoding");
  $Object.$autoload("Math", "corelib/math");
  $Object.$require("corelib/complex/base");
  $Object.$autoload("Complex", "corelib/complex");
  $Object.$require("corelib/rational/base");
  $Object.$autoload("Rational", "corelib/rational");
  $Object.$require("corelib/time");
  $Object.$autoload("Struct", "corelib/struct");
  $Object.$autoload("Set", "corelib/set");
  $Object.$autoload("Dir", "corelib/dir");
  $Object.$autoload("File", "corelib/file");
  $Object.$require("corelib/process/base");
  $Object.$autoload("Process", "corelib/process");
  $Object.$autoload("Random", "corelib/random");
  $Object.$require("corelib/unsupported");
  $Object.$require("corelib/binding");
  return $Object.$require("corelib/irb");
};

Opal.load_normalized("opal");

Opal.modules["opal"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $Object = Opal.Object, nil = Opal.nil;

  Opal.add_stubs('require,autoload');
  
  $Object.$require("opal/base");
  $Object.$require("opal/mini");
  $Object.$require("corelib/kernel/format");
  $Object.$require("corelib/string/encoding");
  $Object.$autoload("Math", "corelib/math");
  $Object.$require("corelib/complex/base");
  $Object.$autoload("Complex", "corelib/complex");
  $Object.$require("corelib/rational/base");
  $Object.$autoload("Rational", "corelib/rational");
  $Object.$require("corelib/time");
  $Object.$autoload("Struct", "corelib/struct");
  $Object.$autoload("Set", "corelib/set");
  $Object.$autoload("Dir", "corelib/dir");
  $Object.$autoload("File", "corelib/file");
  $Object.$require("corelib/process/base");
  $Object.$autoload("Process", "corelib/process");
  $Object.$autoload("Random", "corelib/random");
  $Object.$require("corelib/unsupported");
  $Object.$require("corelib/binding");
  return $Object.$require("corelib/irb");
};

Opal.modules["native"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $hash_put = Opal.hash_put, $module = Opal.module, $defs = Opal.defs, $slice = Opal.slice, $truthy = Opal.truthy, $send = Opal.send, $Kernel = Opal.Kernel, $extract_kwargs = Opal.extract_kwargs, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $range = Opal.range, $to_a = Opal.to_a, $def = Opal.def, $return_ivar = Opal.return_ivar, $alias = Opal.alias, $klass = Opal.klass, $rb_minus = Opal.rb_minus, $return_val = Opal.return_val, $send2 = Opal.send2, $find_super = Opal.find_super, $eqeqeq = Opal.eqeqeq, $rb_ge = Opal.rb_ge, $return_self = Opal.return_self, $gvars = Opal.gvars, self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('try_convert,native?,respond_to?,to_n,raise,inspect,Native,proc,map!,end_with?,define_method,[],convert,call,to_proc,new,each,native_reader,native_writer,extend,warn,include,is_a?,map,Array,to_a,_Array,method_missing,bind,instance_method,[]=,slice,-,length,has_key?,enum_for,===,>=,<<,each_pair,method_defined?,initialize,_initialize,name,native_module');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Native');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $defs(self, '$is_a?', function $Native_is_a$ques$1(object, klass) {
      var self = this;

      
      try {
        return object instanceof self.$try_convert(klass);
      }
      catch (e) {
        return false;
      }
    
    });
    $defs(self, '$try_convert', function $$try_convert(value, default$) {
      var self = this;

      
      if (default$ == null) default$ = nil;
      
      if (self['$native?'](value)) {
        return value;
      }
      else if (value['$respond_to?']("to_n")) {
        return value.$to_n();
      }
      else {
        return default$;
      }
    ;
    }, -2);
    $defs(self, '$convert', function $$convert(value) {
      var self = this;

      
      if (self['$native?'](value)) {
        return value;
      }
      else if (value['$respond_to?']("to_n")) {
        return value.$to_n();
      }
      else {
        self.$raise($$('ArgumentError'), "" + (value.$inspect()) + " isn't native");
      }
    
    });
    $defs(self, '$call', function $$call(obj, key, $a) {
      var block = $$call.$$p || nil, $post_args, args, self = this;

      $$call.$$p = null;
      
      ;
      $post_args = $slice(arguments, 2);
      args = $post_args;
      
      var prop = obj[key];

      if (prop instanceof Function) {
        var converted = new Array(args.length);

        for (var i = 0, l = args.length; i < l; i++) {
          var item = args[i],
              conv = self.$try_convert(item);

          converted[i] = conv === nil ? item : conv;
        }

        if (block !== nil) {
          converted.push(block);
        }

        return self.$Native(prop.apply(obj, converted));
      }
      else {
        return self.$Native(prop);
      }
    ;
    }, -3);
    $defs(self, '$proc', function $$proc() {
      var block = $$proc.$$p || nil, self = this;

      $$proc.$$p = null;
      
      ;
      if (!$truthy(block)) {
        self.$raise($$('LocalJumpError'), "no block given")
      };
      return $send($Kernel, 'proc', [], function $$2($a){var $post_args, args, self = $$2.$$s == null ? this : $$2.$$s, instance = nil;

        
        $post_args = $slice(arguments);
        args = $post_args;
        $send(args, 'map!', [], function $$3(arg){var self = $$3.$$s == null ? this : $$3.$$s;

          
          if (arg == null) arg = nil;
          return self.$Native(arg);}, {$$s: self});
        instance = self.$Native(this);
        
        // if global is current scope, run the block in the scope it was defined
        if (this === Opal.global) {
          return block.apply(self, args);
        }

        var self_ = block.$$s;
        block.$$s = null;

        try {
          return block.apply(instance, args);
        }
        finally {
          block.$$s = self_;
        }
      ;}, {$$arity: -1, $$s: self});
    });
    (function($base, $parent_nesting) {
      var self = $module($base, 'Helpers');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$alias_native', function $$alias_native(new$, $a, $b) {
        var $post_args, $kwargs, old, as, $yield = $$alias_native.$$p || nil, self = this;

        $$alias_native.$$p = null;
        
        $post_args = $slice(arguments, 1);
        $kwargs = $extract_kwargs($post_args);
        $kwargs = $ensure_kwargs($kwargs);
        
        if ($post_args.length > 0) old = $post_args.shift();if (old == null) old = new$;
        
        as = $hash_get($kwargs, "as");if (as == null) as = nil;
        if ($truthy(old['$end_with?']("="))) {
          return $send(self, 'define_method', [new$], function $$4(value){var self = $$4.$$s == null ? this : $$4.$$s;
            if (self["native"] == null) self["native"] = nil;

            
            if (value == null) value = nil;
            self["native"][old['$[]']($range(0, -2, false))] = $$('Native').$convert(value);
            return value;}, {$$s: self})
        } else if ($truthy(as)) {
          return $send(self, 'define_method', [new$], function $$5($c){var block = $$5.$$p || nil, $post_args, args, self = $$5.$$s == null ? this : $$5.$$s, value = nil;
            if (self["native"] == null) self["native"] = nil;

            $$5.$$p = null;
            
            ;
            $post_args = $slice(arguments);
            args = $post_args;
            value = $send($$('Native'), 'call', [self["native"], old].concat($to_a(args)), block.$to_proc());
            if ($truthy(value)) {
              return as.$new(value.$to_n())
            } else {
              return nil
            };}, {$$arity: -1, $$s: self})
        } else {
          return $send(self, 'define_method', [new$], function $$6($c){var block = $$6.$$p || nil, $post_args, args, self = $$6.$$s == null ? this : $$6.$$s;
            if (self["native"] == null) self["native"] = nil;

            $$6.$$p = null;
            
            ;
            $post_args = $slice(arguments);
            args = $post_args;
            return $send($$('Native'), 'call', [self["native"], old].concat($to_a(args)), block.$to_proc());}, {$$arity: -1, $$s: self})
        };
      }, -2);
      
      $def(self, '$native_reader', function $$native_reader($a) {
        var $post_args, names, self = this;

        
        $post_args = $slice(arguments);
        names = $post_args;
        return $send(names, 'each', [], function $$7(name){var self = $$7.$$s == null ? this : $$7.$$s;

          
          if (name == null) name = nil;
          return $send(self, 'define_method', [name], function $$8(){var self = $$8.$$s == null ? this : $$8.$$s;
            if (self["native"] == null) self["native"] = nil;

            return self.$Native(self["native"][name])}, {$$s: self});}, {$$s: self});
      }, -1);
      
      $def(self, '$native_writer', function $$native_writer($a) {
        var $post_args, names, self = this;

        
        $post_args = $slice(arguments);
        names = $post_args;
        return $send(names, 'each', [], function $$9(name){var self = $$9.$$s == null ? this : $$9.$$s;

          
          if (name == null) name = nil;
          return $send(self, 'define_method', ["" + (name) + "="], function $$10(value){var self = $$10.$$s == null ? this : $$10.$$s;
            if (self["native"] == null) self["native"] = nil;

            
            if (value == null) value = nil;
            return self.$Native(self["native"][name] = value);}, {$$s: self});}, {$$s: self});
      }, -1);
      return $def(self, '$native_accessor', function $$native_accessor($a) {
        var $post_args, names, self = this;

        
        $post_args = $slice(arguments);
        names = $post_args;
        $send(self, 'native_reader', $to_a(names));
        return $send(self, 'native_writer', $to_a(names));
      }, -1);
    })($nesting[0], $nesting);
    (function($base, $parent_nesting) {
      var self = $module($base, 'Wrapper');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$initialize', function $$initialize(native$) {
        var self = this;

        
        if (!$truthy($Kernel['$native?'](native$))) {
          $Kernel.$raise($$('ArgumentError'), "" + (native$.$inspect()) + " isn't native")
        };
        return (self["native"] = native$);
      });
      
      $def(self, '$to_n', $return_ivar("native"));
      return $defs(self, '$included', function $$included(klass) {
        
        return klass.$extend($$('Helpers'))
      });
    })($nesting[0], $nesting);
    return $defs(self, '$included', function $$included(base) {
      var self = this;

      
      self.$warn("Including ::Native is deprecated. Please include Native::Wrapper instead.");
      return base.$include($$('Wrapper'));
    });
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$native?', function $Kernel_native$ques$11(value) {
      
      return value == null || !value.$$class;
    });
    
    $def(self, '$Native', function $$Native(obj) {
      var $yield = $$Native.$$p || nil, self = this;

      $$Native.$$p = null;
      if ($truthy(obj == null)) {
        return nil
      } else if ($truthy(self['$native?'](obj))) {
        return $$$($$('Native'), 'Object').$new(obj)
      } else if ($truthy(obj['$is_a?']($$('Array')))) {
        return $send(obj, 'map', [], function $$12(o){var self = $$12.$$s == null ? this : $$12.$$s;

          
          if (o == null) o = nil;
          return self.$Native(o);}, {$$s: self})
      } else if ($truthy(obj['$is_a?']($$('Proc')))) {
        return $send(self, 'proc', [], function $$13($a){var block = $$13.$$p || nil, $post_args, args, self = $$13.$$s == null ? this : $$13.$$s;

          $$13.$$p = null;
          
          ;
          $post_args = $slice(arguments);
          args = $post_args;
          return self.$Native($send(obj, 'call', $to_a(args), block.$to_proc()));}, {$$arity: -1, $$s: self})
      } else {
        return obj
      }
    });
    $alias(self, "_Array", "Array");
    return $def(self, '$Array', function $$Array(object, $a) {
      var block = $$Array.$$p || nil, $post_args, args, self = this;

      $$Array.$$p = null;
      
      ;
      $post_args = $slice(arguments, 1);
      args = $post_args;
      if ($truthy(self['$native?'](object))) {
        return $send($$$($$('Native'), 'Array'), 'new', [object].concat($to_a(args)), block.$to_proc()).$to_a()
      };
      return self.$_Array(object);
    }, -2);
  })($nesting[0], $nesting);
  (function($base, $super) {
    var self = $klass($base, $super, 'Object');

    var $proto = self.$$prototype;

    $proto["native"] = nil;
    
    self.$include($$$($$$('Native'), 'Wrapper'));
    
    $def(self, '$==', function $Object_$eq_eq$14(other) {
      var self = this;

      return self["native"] === $$$('Native').$try_convert(other)
    });
    
    $def(self, '$has_key?', function $Object_has_key$ques$15(name) {
      var self = this;

      return Opal.hasOwnProperty.call(self["native"], name)
    });
    
    $def(self, '$each', function $$each($a) {
      var $post_args, args, $yield = $$each.$$p || nil, self = this;

      $$each.$$p = null;
      
      $post_args = $slice(arguments);
      args = $post_args;
      if (($yield !== nil)) {
        
        
        for (var key in self["native"]) {
          Opal.yieldX($yield, [key, self["native"][key]])
        }
      ;
        return self;
      } else {
        return $send(self, 'method_missing', ["each"].concat($to_a(args)))
      };
    }, -1);
    
    $def(self, '$[]', function $Object_$$$16(key) {
      var self = this;

      
      var prop = self["native"][key];

      if (prop instanceof Function) {
        return prop;
      }
      else {
        return $$$('Native').$call(self["native"], key)
      }
    
    });
    
    $def(self, '$[]=', function $Object_$$$eq$17(key, value) {
      var self = this, native$ = nil;

      
      native$ = $$$('Native').$try_convert(value);
      if ($truthy(native$ === nil)) {
        return self["native"][key] = value
      } else {
        return self["native"][key] = native$
      };
    });
    
    $def(self, '$merge!', function $Object_merge$excl$18(other) {
      var self = this;

      
      
      other = $$$('Native').$convert(other);

      for (var prop in other) {
        self["native"][prop] = other[prop];
      }
    ;
      return self;
    });
    
    $def(self, '$respond_to?', function $Object_respond_to$ques$19(name, include_all) {
      var self = this;

      
      if (include_all == null) include_all = false;
      return $Kernel.$instance_method("respond_to?").$bind(self).$call(name, include_all);
    }, -2);
    
    $def(self, '$respond_to_missing?', function $Object_respond_to_missing$ques$20(name, include_all) {
      var self = this;

      
      if (include_all == null) include_all = false;
      return Opal.hasOwnProperty.call(self["native"], name);
    }, -2);
    
    $def(self, '$method_missing', function $$method_missing(mid, $a) {
      var block = $$method_missing.$$p || nil, $post_args, args, $b, self = this;

      $$method_missing.$$p = null;
      
      ;
      $post_args = $slice(arguments, 1);
      args = $post_args;
      
      if (mid.charAt(mid.length - 1) === '=') {
        return ($b = [mid.$slice(0, $rb_minus(mid.$length(), 1)), args['$[]'](0)], $send(self, '[]=', $b), $b[$b.length - 1]);
      }
      else {
        return $send($$$('Native'), 'call', [self["native"], mid].concat($to_a(args)), block.$to_proc());
      }
    ;
    }, -2);
    
    $def(self, '$nil?', $return_val(false));
    
    $def(self, '$is_a?', function $Object_is_a$ques$21(klass) {
      var self = this;

      return Opal.is_a(self, klass);
    });
    
    $def(self, '$instance_of?', function $Object_instance_of$ques$22(klass) {
      var self = this;

      return self.$$class === klass;
    });
    
    $def(self, '$class', function $Object_class$23() {
      var self = this;

      return self.$$class;
    });
    
    $def(self, '$to_a', function $$to_a(options) {
      var block = $$to_a.$$p || nil, self = this;

      $$to_a.$$p = null;
      
      ;
      if (options == null) options = (new Map());
      return $send($$$($$$('Native'), 'Array'), 'new', [self["native"], options], block.$to_proc()).$to_a();
    }, -1);
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return "#<Native:" + (String(self["native"])) + ">"
    });
    $alias(self, "include?", "has_key?");
    $alias(self, "key?", "has_key?");
    $alias(self, "kind_of?", "is_a?");
    return $alias(self, "member?", "has_key?");
  })($$('Native'), $$('BasicObject'));
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.named = $proto["native"] = $proto.get = $proto.block = $proto.set = $proto.length = nil;
    
    self.$include($$$($$('Native'), 'Wrapper'));
    self.$include($$('Enumerable'));
    
    $def(self, '$initialize', function $$initialize(native$, options) {
      var block = $$initialize.$$p || nil, self = this, $ret_or_1 = nil;

      $$initialize.$$p = null;
      
      ;
      if (options == null) options = (new Map());
      $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [native$], null);
      self.get = ($truthy(($ret_or_1 = options['$[]']("get"))) ? ($ret_or_1) : (options['$[]']("access")));
      self.named = options['$[]']("named");
      self.set = ($truthy(($ret_or_1 = options['$[]']("set"))) ? ($ret_or_1) : (options['$[]']("access")));
      self.length = ($truthy(($ret_or_1 = options['$[]']("length"))) ? ($ret_or_1) : ("length"));
      self.block = block;
      if ($truthy(self.$length() == null)) {
        return self.$raise($$('ArgumentError'), "no length found on the array-like object")
      } else {
        return nil
      };
    }, -2);
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, self = this;

      $$each.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return self.$enum_for("each")
      };
      
      for (var i = 0, length = self.$length(); i < length; i++) {
        Opal.yield1(block, self['$[]'](i));
      }
    ;
      return self;
    });
    
    $def(self, '$[]', function $Array_$$$24(index) {
      var self = this, result = nil, $ret_or_1 = nil;

      
      result = (($eqeqeq($$('String'), ($ret_or_1 = index)) || ($eqeqeq($$('Symbol'), $ret_or_1))) ? (($truthy(self.named) ? (self["native"][self.named](index)) : (self["native"][index]))) : ($eqeqeq($$('Integer'), $ret_or_1) ? (($truthy(self.get) ? (self["native"][self.get](index)) : (self["native"][index]))) : (nil)));
      if ($truthy(result)) {
        if ($truthy(self.block)) {
          return self.block.$call(result)
        } else {
          return self.$Native(result)
        }
      } else {
        return nil
      };
    });
    
    $def(self, '$[]=', function $Array_$$$eq$25(index, value) {
      var self = this;

      if ($truthy(self.set)) {
        return self["native"][self.set](index, $$('Native').$convert(value))
      } else {
        return self["native"][index] = $$('Native').$convert(value)
      }
    });
    
    $def(self, '$last', function $$last(count) {
      var self = this, index = nil, result = nil;

      
      if (count == null) count = nil;
      if ($truthy(count)) {
        
        index = $rb_minus(self.$length(), 1);
        result = [];
        while ($truthy($rb_ge(index, 0))) {
        
          result['$<<'](self['$[]'](index));
          index = $rb_minus(index, 1);
        };
        return result;
      } else {
        return self['$[]']($rb_minus(self.$length(), 1))
      };
    }, -1);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self["native"][self.length]
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      return self.$to_a().$inspect()
    });
    return $alias(self, "to_ary", "to_a");
  })($$('Native'), null, $nesting);
  (function($base, $super) {
    var self = $klass($base, $super, 'Numeric');

    
    return $def(self, '$to_n', function $$to_n() {
      var self = this;

      return self.valueOf();
    })
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Proc');

    
    return $def(self, '$to_n', $return_self)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    return $def(self, '$to_n', function $$to_n() {
      var self = this;

      return self.valueOf();
    })
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Regexp');

    
    return $def(self, '$to_n', function $$to_n() {
      var self = this;

      return self.valueOf();
    })
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'MatchData');

    
    return $def(self, '$to_n', $return_ivar("matches"))
  })($nesting[0], null);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Struct');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$to_n', function $$to_n() {
      var self = this, result = nil;

      
      result = {};
      $send(self, 'each_pair', [], function $$26(name, value){
        
        if (name == null) name = nil;
        if (value == null) value = nil;
        return result[name] = $$('Native').$try_convert(value, value);});
      return result;
    })
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$to_n', function $$to_n() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        var obj = self[i];

        result.push($$('Native').$try_convert(obj, obj));
      }

      return result;
    
    })
  })($nesting[0], null, $nesting);
  (function($base, $super) {
    var self = $klass($base, $super, 'Boolean');

    
    return $def(self, '$to_n', function $$to_n() {
      var self = this;

      return self.valueOf();
    })
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Time');

    
    return $def(self, '$to_n', $return_self)
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'NilClass');

    
    return $def(self, '$to_n', function $$to_n() {
      
      return null;
    })
  })($nesting[0], null);
  if (!$truthy($$('Hash')['$method_defined?']("_initialize"))) {
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Hash');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $alias(self, "_initialize", "initialize");
      
      function $hash_convert_and_put_value(hash, key, value) {
        if (value &&
          (value.constructor === undefined ||
            value.constructor === Object ||
            value instanceof Map)) {
         $hash_put(hash, key, $$('Hash').$new(value));
       } else if (value && value.$$is_array) {
         value = value.map(function(item) {
           if (item &&
              (item.constructor === undefined ||
               item.constructor === Object ||
               value instanceof Map)) {
             return $$('Hash').$new(item);
           }
           return self.$Native(item);
         });
         $hash_put(hash, key, value)
       } else {
         $hash_put(hash, key, self.$Native(value));
       }
      }
    ;
      
      $def(self, '$initialize', function $$initialize(defaults) {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        ;
        
        if (defaults != null) {
          if (defaults.constructor === undefined ||
              defaults.constructor === Object) {
            var key, value;

            for (key in defaults) {
              value = defaults[key];
              $hash_convert_and_put_value(self, key, value);
            }

            return self;
          } else if (defaults instanceof Map) {
            Opal.hash_each(defaults, false, function(key, value) {
              $hash_convert_and_put_value(self, key, value);
              return [false, false];
            });
          }
        }

        return $send(self, '_initialize', [defaults], block.$to_proc());
      ;
      }, -1);
      return $def(self, '$to_n', function $$to_n() {
        var self = this;

        
        var result = {};

        Opal.hash_each(self, false, function(key, value) {
          result[$$('Native').$try_convert(key, key)] = $$('Native').$try_convert(value, value);
          return [false, false];
        });

        return result;
      
      });
    })($nesting[0], null, $nesting)
  };
  (function($base, $super) {
    var self = $klass($base, $super, 'Module');

    
    return $def(self, '$native_module', function $$native_module() {
      var self = this;

      return Opal.global[self.$name()] = self
    })
  })($nesting[0], null);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Class');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$native_alias', function $$native_alias(new_jsid, existing_mid) {
      var self = this;

      
      var aliased = self.prototype[Opal.jsid(existing_mid)];
      if (!aliased) {
        self.$raise($$('NameError').$new("undefined method `" + (existing_mid) + "' for class `" + (self.$inspect()) + "'", existing_mid));
      }
      self.prototype[new_jsid] = aliased;
    
    });
    return $def(self, '$native_class', function $$native_class() {
      var self = this;

      
      self.$native_module();
      return self["new"] = self.$new;;
    });
  })($nesting[0], null, $nesting);
  return ($gvars.$ = ($gvars.global = self.$Native(Opal.global)));
};

Opal.modules["console"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $def = Opal.def, $slice = Opal.slice, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $send = Opal.send, $gvars = Opal.gvars, self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,raise,==,arity,instance_exec,to_proc,new');
  
  self.$require("native");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Console');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto["native"] = nil;
    
    self.$include($$$($$('Native'), 'Wrapper'));
    
    $def(self, '$clear', function $$clear() {
      var self = this;

      return self["native"].clear()
    });
    
    $def(self, '$trace', function $$trace() {
      var self = this;

      return self["native"].trace()
    });
    
    $def(self, '$log', function $$log($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return self["native"].log.apply(self["native"], args);
    }, -1);
    
    $def(self, '$info', function $$info($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return self["native"].info.apply(self["native"], args);
    }, -1);
    
    $def(self, '$warn', function $$warn($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return self["native"].warn.apply(self["native"], args);
    }, -1);
    
    $def(self, '$error', function $$error($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      return self["native"].error.apply(self["native"], args);
    }, -1);
    
    $def(self, '$time', function $$time(label) {
      var block = $$time.$$p || nil, self = this;

      $$time.$$p = null;
      
      ;
      if (!$truthy(block)) {
        self.$raise($$('ArgumentError'), "no block given")
      };
      self["native"].time(label);
      
      return (function() { try {
      if ($eqeq(block.$arity(), 0)) {
        return $send(self, 'instance_exec', [], block.$to_proc())
      } else {
        return Opal.yield1(block, self);
      }
      } finally {
        self["native"].timeEnd()
      }; })();;
    });
    
    $def(self, '$group', function $$group($a) {
      var block = $$group.$$p || nil, $post_args, args, self = this;

      $$group.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      if (!$truthy(block)) {
        self.$raise($$('ArgumentError'), "no block given")
      };
      self["native"].group.apply(self["native"], args);
      
      return (function() { try {
      if ($eqeq(block.$arity(), 0)) {
        return $send(self, 'instance_exec', [], block.$to_proc())
      } else {
        return Opal.yield1(block, self);
      }
      } finally {
        self["native"].groupEnd()
      }; })();;
    }, -1);
    return $def(self, '$group!', function $Console_group$excl$1($a) {
      var block = $Console_group$excl$1.$$p || nil, $post_args, args, self = this;

      $Console_group$excl$1.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      if (!(block !== nil)) {
        return nil
      };
      self["native"].groupCollapsed.apply(self["native"], args);
      
      return (function() { try {
      if ($eqeq(block.$arity(), 0)) {
        return $send(self, 'instance_exec', [], block.$to_proc())
      } else {
        return Opal.yield1(block, self);
      }
      } finally {
        self["native"].groupEnd()
      }; })();;
    }, -1);
  })($nesting[0], null, $nesting);
  if ($truthy((typeof(Opal.global.console) !== "undefined"))) {
    return ($gvars.console = $$('Console').$new(Opal.global.console))
  } else {
    return nil
  };
};

Opal.modules["promise"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $defs = Opal.defs, $slice = Opal.slice, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $truthy = Opal.truthy, $return_ivar = Opal.return_ivar, $not = Opal.not, $send = Opal.send, $to_a = Opal.to_a, $rb_plus = Opal.rb_plus, $alias = Opal.alias, $send2 = Opal.send2, $find_super = Opal.find_super, $rb_le = Opal.rb_le, $rb_minus = Opal.rb_minus, $const_set = Opal.const_set, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil;

  Opal.add_stubs('resolve,new,reject,attr_reader,===,value,key?,keys,!=,==,<<,>>,exception?,[],resolved?,rejected?,!,error,include?,action,realized?,raise,^,call,resolve!,exception!,any?,each,reject!,there_can_be_only_one!,then,to_proc,fail,always,trace,class,object_id,+,inspect,rescue,to_v2,fail!,then!,always!,itself,nil?,prev,act?,push,concat,it,proc,reverse,pop,<=,length,shift,-,wait,map,reduce,try,tap,all?,find,collect,inject');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Promise');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.value = $proto.action = $proto.realized = $proto.next = $proto.delayed = $proto.error = $proto.prev = nil;
    
    $defs(self, '$value', function $$value(value) {
      var self = this;

      return self.$new().$resolve(value)
    });
    $defs(self, '$error', function $$error(value) {
      var self = this;

      return self.$new().$reject(value)
    });
    $defs(self, '$when', function $$when($a) {
      var $post_args, promises;

      
      $post_args = $slice(arguments);
      promises = $post_args;
      return $$('When').$new(promises);
    }, -1);
    self.$attr_reader("error", "prev", "next");
    
    $def(self, '$initialize', function $$initialize(action) {
      var self = this;

      
      if (action == null) action = (new Map());
      self.action = action;
      self.realized = false;
      self.exception = false;
      self.value = nil;
      self.error = nil;
      self.delayed = false;
      self.prev = nil;
      return (self.next = []);
    }, -1);
    
    $def(self, '$value', function $$value() {
      var self = this;

      if ($eqeqeq($$('Promise'), self.value)) {
        return self.value.$value()
      } else {
        return self.value
      }
    });
    
    $def(self, '$act?', function $Promise_act$ques$1() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.action['$key?']("success")))) {
        return $ret_or_1
      } else {
        return self.action['$key?']("always")
      }
    });
    
    $def(self, '$action', function $$action() {
      var self = this;

      return self.action.$keys()
    });
    
    $def(self, '$exception?', $return_ivar("exception"));
    
    $def(self, '$realized?', function $Promise_realized$ques$2() {
      var self = this;

      return self.realized['$!='](false)
    });
    
    $def(self, '$resolved?', function $Promise_resolved$ques$3() {
      var self = this;

      return self.realized['$==']("resolve")
    });
    
    $def(self, '$rejected?', function $Promise_rejected$ques$4() {
      var self = this;

      return self.realized['$==']("reject")
    });
    
    $def(self, '$^', function $Promise_$$5(promise) {
      var self = this;

      
      promise['$<<'](self);
      self['$>>'](promise);
      return promise;
    });
    
    $def(self, '$<<', function $Promise_$lt$lt$6(promise) {
      var self = this;

      
      self.prev = promise;
      return self;
    });
    
    $def(self, '$>>', function $Promise_$gt$gt$7(promise) {
      var self = this;

      
      self.next['$<<'](promise);
      if ($truthy(self['$exception?']())) {
        promise.$reject(self.delayed['$[]'](0))
      } else if ($truthy(self['$resolved?']())) {
        promise.$resolve(($truthy(self.delayed) ? (self.delayed['$[]'](0)) : (self.$value())))
      } else if ($truthy(self['$rejected?']())) {
        if (($not(self.action['$key?']("failure")) || ($eqeqeq($$('Promise'), ($truthy(self.delayed) ? (self.delayed['$[]'](0)) : (self.error)))))) {
          promise.$reject(($truthy(self.delayed) ? (self.delayed['$[]'](0)) : (self.$error())))
        } else if ($truthy(promise.$action()['$include?']("always"))) {
          promise.$reject(($truthy(self.delayed) ? (self.delayed['$[]'](0)) : (self.$error())))
        }
      };
      return self;
    });
    
    $def(self, '$resolve', function $$resolve(value) {
      var self = this, block = nil, $ret_or_1 = nil, e = nil;

      
      if (value == null) value = nil;
      if ($truthy(self['$realized?']())) {
        self.$raise($$('ArgumentError'), "the promise has already been realized")
      };
      if ($eqeqeq($$('Promise'), value)) {
        return value['$<<'](self.prev)['$^'](self)
      };
      
      try {
        
        block = ($truthy(($ret_or_1 = self.action['$[]']("success"))) ? ($ret_or_1) : (self.action['$[]']("always")));
        if ($truthy(block)) {
          value = block.$call(value)
        };
        self['$resolve!'](value);
      } catch ($err) {
        if (Opal.rescue($err, [$$('Exception')])) {(e = $err)
          try {
            self['$exception!'](e)
          } finally { Opal.pop_exception($err); }
        } else { throw $err; }
      };;
      return self;
    }, -1);
    
    $def(self, '$resolve!', function $Promise_resolve$excl$8(value) {
      var self = this;

      
      self.realized = "resolve";
      self.value = value;
      if ($truthy(self.next['$any?']())) {
        return $send(self.next, 'each', [], function $$9(p){
          
          if (p == null) p = nil;
          return p.$resolve(value);})
      } else {
        return (self.delayed = [value])
      };
    });
    
    $def(self, '$reject', function $$reject(value) {
      var self = this, block = nil, $ret_or_1 = nil, e = nil;

      
      if (value == null) value = nil;
      if ($truthy(self['$realized?']())) {
        self.$raise($$('ArgumentError'), "the promise has already been realized")
      };
      if ($eqeqeq($$('Promise'), value)) {
        return value['$<<'](self.prev)['$^'](self)
      };
      
      try {
        
        block = ($truthy(($ret_or_1 = self.action['$[]']("failure"))) ? ($ret_or_1) : (self.action['$[]']("always")));
        if ($truthy(block)) {
          value = block.$call(value)
        };
        if ($truthy(self.action['$key?']("always"))) {
          self['$resolve!'](value)
        } else {
          self['$reject!'](value)
        };
      } catch ($err) {
        if (Opal.rescue($err, [$$('Exception')])) {(e = $err)
          try {
            self['$exception!'](e)
          } finally { Opal.pop_exception($err); }
        } else { throw $err; }
      };;
      return self;
    }, -1);
    
    $def(self, '$reject!', function $Promise_reject$excl$10(value) {
      var self = this;

      
      self.realized = "reject";
      self.error = value;
      if ($truthy(self.next['$any?']())) {
        return $send(self.next, 'each', [], function $$11(p){
          
          if (p == null) p = nil;
          return p.$reject(value);})
      } else {
        return (self.delayed = [value])
      };
    });
    
    $def(self, '$exception!', function $Promise_exception$excl$12(error) {
      var self = this;

      
      self.exception = true;
      return self['$reject!'](error);
    });
    
    $def(self, '$then', function $$then() {
      var block = $$then.$$p || nil, self = this;

      $$then.$$p = null;
      
      ;
      return self['$^']($$('Promise').$new((new Map([["success", block]]))));
    });
    
    $def(self, '$then!', function $Promise_then$excl$13() {
      var block = $Promise_then$excl$13.$$p || nil, self = this;

      $Promise_then$excl$13.$$p = null;
      
      ;
      self['$there_can_be_only_one!']();
      return $send(self, 'then', [], block.$to_proc());
    });
    
    $def(self, '$fail', function $$fail() {
      var block = $$fail.$$p || nil, self = this;

      $$fail.$$p = null;
      
      ;
      return self['$^']($$('Promise').$new((new Map([["failure", block]]))));
    });
    
    $def(self, '$fail!', function $Promise_fail$excl$14() {
      var block = $Promise_fail$excl$14.$$p || nil, self = this;

      $Promise_fail$excl$14.$$p = null;
      
      ;
      self['$there_can_be_only_one!']();
      return $send(self, 'fail', [], block.$to_proc());
    });
    
    $def(self, '$always', function $$always() {
      var block = $$always.$$p || nil, self = this;

      $$always.$$p = null;
      
      ;
      return self['$^']($$('Promise').$new((new Map([["always", block]]))));
    });
    
    $def(self, '$always!', function $Promise_always$excl$15() {
      var block = $Promise_always$excl$15.$$p || nil, self = this;

      $Promise_always$excl$15.$$p = null;
      
      ;
      self['$there_can_be_only_one!']();
      return $send(self, 'always', [], block.$to_proc());
    });
    
    $def(self, '$trace', function $$trace(depth) {
      var block = $$trace.$$p || nil, self = this;

      $$trace.$$p = null;
      
      ;
      if (depth == null) depth = nil;
      return self['$^']($$('Trace').$new(depth, block));
    }, -1);
    
    $def(self, '$trace!', function $Promise_trace$excl$16($a) {
      var block = $Promise_trace$excl$16.$$p || nil, $post_args, args, self = this;

      $Promise_trace$excl$16.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      self['$there_can_be_only_one!']();
      return $send(self, 'trace', $to_a(args), block.$to_proc());
    }, -1);
    
    $def(self, '$there_can_be_only_one!', function $Promise_there_can_be_only_one$excl$17() {
      var self = this;

      if ($truthy(self.next['$any?']())) {
        return self.$raise($$('ArgumentError'), "a promise has already been chained")
      } else {
        return nil
      }
    });
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, result = nil, $ret_or_1 = nil;

      
      result = "#<" + (self.$class()) + "(" + (self.$object_id()) + ")";
      if ($truthy(self.next['$any?']())) {
        result = $rb_plus(result, " >> " + (self.next.$inspect()))
      };
      result = $rb_plus(result, ($truthy(self['$realized?']()) ? (": " + (($truthy(($ret_or_1 = self.value)) ? ($ret_or_1) : (self.error)).$inspect()) + ">") : (">")));
      return result;
    });
    
    $def(self, '$to_v2', function $$to_v2() {
      var self = this, v2 = nil;

      
      v2 = $$('PromiseV2').$new();
      $send($send(self, 'then', [], function $$18(i){
        
        if (i == null) i = nil;
        return v2.$resolve(i);}), 'rescue', [], function $$19(i){
        
        if (i == null) i = nil;
        return v2.$reject(i);});
      return v2;
    });
    $alias(self, "await", "to_v2");
    $alias(self, "catch", "fail");
    $alias(self, "catch!", "fail!");
    $alias(self, "do", "then");
    $alias(self, "do!", "then!");
    $alias(self, "ensure", "always");
    $alias(self, "ensure!", "always!");
    $alias(self, "finally", "always");
    $alias(self, "finally!", "always!");
    $alias(self, "rescue", "fail");
    $alias(self, "rescue!", "fail!");
    $alias(self, "to_n", "to_v2");
    $alias(self, "to_v1", "itself");
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Trace');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $defs(self, '$it', function $$it(promise) {
        var self = this, current = nil, prev = nil;

        
        current = [];
        if (($truthy(promise['$act?']()) || ($truthy(promise.$prev()['$nil?']())))) {
          current.$push(promise.$value())
        };
        prev = promise.$prev();
        if ($truthy(prev)) {
          return current.$concat(self.$it(prev))
        } else {
          return current
        };
      });
      return $def(self, '$initialize', function $$initialize(depth, block) {
        var $yield = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        self.depth = depth;
        return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [(new Map([["success", $send(self, 'proc', [], function $$20(){var self = $$20.$$s == null ? this : $$20.$$s, trace = nil;

          
          trace = $$('Trace').$it(self).$reverse();
          trace.$pop();
          if (($truthy(depth) && ($truthy($rb_le(depth, trace.$length()))))) {
            trace.$shift($rb_minus(trace.$length(), depth))
          };
          return $send(block, 'call', $to_a(trace));}, {$$s: self})]]))], null);
      });
    })($nesting[0], self, $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'When');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.wait = nil;
      
      
      $def(self, '$initialize', function $$initialize(promises) {
        var $yield = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        if (promises == null) promises = [];
        $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [], null);
        self.wait = [];
        return $send(promises, 'each', [], function $$21(promise){var self = $$21.$$s == null ? this : $$21.$$s;

          
          if (promise == null) promise = nil;
          return self.$wait(promise);}, {$$s: self});
      }, -1);
      
      $def(self, '$each', function $$each() {
        var block = $$each.$$p || nil, self = this;

        $$each.$$p = null;
        
        ;
        if (!$truthy(block)) {
          self.$raise($$('ArgumentError'), "no block given")
        };
        return $send(self, 'then', [], function $$22(values){
          
          if (values == null) values = nil;
          return $send(values, 'each', [], block.$to_proc());});
      });
      
      $def(self, '$collect', function $$collect() {
        var block = $$collect.$$p || nil, self = this;

        $$collect.$$p = null;
        
        ;
        if (!$truthy(block)) {
          self.$raise($$('ArgumentError'), "no block given")
        };
        return $send(self, 'then', [], function $$23(values){
          
          if (values == null) values = nil;
          return $$('When').$new($send(values, 'map', [], block.$to_proc()));});
      });
      
      $def(self, '$inject', function $$inject($a) {
        var block = $$inject.$$p || nil, $post_args, args, self = this;

        $$inject.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        args = $post_args;
        return $send(self, 'then', [], function $$24(values){
          
          if (values == null) values = nil;
          return $send(values, 'reduce', $to_a(args), block.$to_proc());});
      }, -1);
      
      $def(self, '$wait', function $$wait(promise) {
        var self = this;

        
        if (!$eqeqeq($$('Promise'), promise)) {
          promise = $$('Promise').$value(promise)
        };
        if ($truthy(promise['$act?']())) {
          promise = promise.$then()
        };
        self.wait['$<<'](promise);
        $send(promise, 'always', [], function $$25(){var self = $$25.$$s == null ? this : $$25.$$s;
          if (self.next == null) self.next = nil;

          if ($truthy(self.next['$any?']())) {
            return self.$try()
          } else {
            return nil
          }}, {$$s: self});
        return self;
      });
      
      $def(self, '$>>', function $When_$gt$gt$26($a) {
        var $post_args, $fwd_rest, $yield = $When_$gt$gt$26.$$p || nil, self = this;

        $When_$gt$gt$26.$$p = null;
        
        $post_args = $slice(arguments);
        $fwd_rest = $post_args;
        return $send($send2(self, $find_super(self, '>>', $When_$gt$gt$26, false, true), '>>', $to_a($fwd_rest), $yield), 'tap', [], function $$27(){var self = $$27.$$s == null ? this : $$27.$$s;

          return self.$try()}, {$$s: self});
      }, -1);
      
      $def(self, '$try', function $When_try$28() {
        var self = this, promise = nil;

        if ($truthy($send(self.wait, 'all?', [], "realized?".$to_proc()))) {
          
          promise = $send(self.wait, 'find', [], "rejected?".$to_proc());
          if ($truthy(promise)) {
            return self.$reject(promise.$error())
          } else {
            return self.$resolve($send(self.wait, 'map', [], "value".$to_proc()))
          };
        } else {
          return nil
        }
      });
      $alias(self, "map", "collect");
      $alias(self, "reduce", "inject");
      return $alias(self, "and", "wait");
    })($nesting[0], self, $nesting);
  })($nesting[0], null, $nesting);
  return $const_set($nesting[0], 'PromiseV1', $$('Promise'));
};

Opal.modules["paggio/utils"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $module = Opal.module, $regexp = Opal.regexp, $defs = Opal.defs, $send = Opal.send, $eqeqeq = Opal.eqeqeq, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('size,min,scan,gsub,proc,===,merge,to_proc,merge!');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Utils');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $defs(self, '$heredoc', function $$heredoc(string) {
        var indent = nil;

        
        indent = (function() { try {
          return string.$scan(/^[ \t]*(?=\S)/).$min().$size()
        } catch ($err) {
          if (Opal.rescue($err, [$$('StandardError')])) {
            try {
              return 0
            } finally { Opal.pop_exception($err); }
          } else { throw $err; }
        }})();
        return string.$gsub($regexp(["^[ \\t]{", indent, "}"]), "");
      });
      $defs(self, '$deep_merge', function $$deep_merge(a, b) {
        var self = this, merger = nil;

        
        merger = $send(self, 'proc', [], function $$1(key, v1, v2){
          
          if (key == null) key = nil;
          if (v1 == null) v1 = nil;
          if (v2 == null) v2 = nil;
          if (($eqeqeq($$('Hash'), v1) && ($eqeqeq($$('Hash'), v2)))) {
            return $send(v1, 'merge', [v2], merger.$to_proc())
          } else {
            return v2
          };});
        return $send(a, 'merge', [b], merger.$to_proc());
      });
      return $defs(self, '$deep_merge!', function $Utils_deep_merge$excl$2(a, b) {
        var self = this, merger = nil;

        
        merger = $send(self, 'proc', [], function $$3(key, v1, v2){
          
          if (key == null) key = nil;
          if (v1 == null) v1 = nil;
          if (v2 == null) v2 = nil;
          if (($eqeqeq($$('Hash'), v1) && ($eqeqeq($$('Hash'), v2)))) {
            
            $send(v1, 'merge!', [v2], merger.$to_proc());
            return v1;
          } else {
            return v2
          };});
        return $send(a, 'merge!', [b], merger.$to_proc());
      });
    })($nesting[0], $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/html/helpers"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $send = Opal.send, $slice = Opal.slice, $to_a = Opal.to_a, $truthy = Opal.truthy, $defs = Opal.defs, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('define_method,instance_exec,to_proc,do,defhelper,[]=');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'Element');

        
        
        $defs(self, '$defhelper', function $$defhelper(name) {
          var block = $$defhelper.$$p || nil, self = this;

          $$defhelper.$$p = null;
          
          ;
          return $send(self, 'define_method', [name], function $$1($a){var body = $$1.$$p || nil, $post_args, args, self = $$1.$$s == null ? this : $$1.$$s;

            $$1.$$p = null;
            
            ;
            $post_args = $slice(arguments);
            args = $post_args;
            $send(self, 'instance_exec', $to_a(args), block.$to_proc());
            if ($truthy(body)) {
              $send(self, 'do', [], body.$to_proc())
            };
            return self;}, {$$arity: -1, $$s: self});
        });
        return $defs(self, '$defhelper!', function $Element_defhelper$excl$2(name, attribute) {
          var self = this;

          
          if (attribute == null) attribute = name;
          return $send(self, 'defhelper', ["" + (name) + "!"], function $$3(){var $a, self = $$3.$$s == null ? this : $$3.$$s;
            if (self.attributes == null) self.attributes = nil;

            return ($a = [attribute, true], $send(self.attributes, '[]=', $a), $a[$a.length - 1])}, {$$s: self});
        }, -2);
      })($nesting[0], $$('BasicObject'))
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/html/element/a"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $send = Opal.send, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('each,defhelper,[]=,to_s,defhelper!,<<');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'A');

          
          
          $send((new Map([["href", "href"], ["url", "href"], ["rel", "rel"], ["relative", "rel"], ["target", "target"], ["type", "type"], ["lang", "hreflang"], ["language", "hreflang"], ["media", "media"]])), 'each', [], function $A$1(name, attribute){var self = $A$1.$$s == null ? this : $A$1.$$s;

            
            if (name == null) name = nil;
            if (attribute == null) attribute = nil;
            return $send(self, 'defhelper', [name], function $$2(value){var $a, self = $$2.$$s == null ? this : $$2.$$s;
              if (self.attributes == null) self.attributes = nil;

              
              if (value == null) value = nil;
              return ($a = [name, value.$to_s()], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$s: self});}, {$$s: self});
          self['$defhelper!']("download");
          self['$defhelper!']("ping");
          return $send(self, 'defhelper', ["text"], function $A$3(string){var self = $A$3.$$s == null ? this : $A$3.$$s;

            
            if (string == null) string = nil;
            return self['$<<'](string);}, {$$s: self});
        })($nesting[0], self)
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/html/element/base"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $send = Opal.send, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('each,defhelper,[]=,to_s');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Base');

          
          return $send((new Map([["href", "href"], ["url", "href"], ["target", "target"]])), 'each', [], function $Base$1(name, attribute){var self = $Base$1.$$s == null ? this : $Base$1.$$s;

            
            if (name == null) name = nil;
            if (attribute == null) attribute = nil;
            return $send(self, 'defhelper', [name], function $$2(value){var $a, self = $$2.$$s == null ? this : $$2.$$s;
              if (self.attributes == null) self.attributes = nil;

              
              if (value == null) value = nil;
              return ($a = [name, value.$to_s()], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$s: self});}, {$$s: self})
        })($nesting[0], self)
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/html/element/blockquote"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $send = Opal.send, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('defhelper,[]=,to_s');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Blockquote');

          
          return $send(self, 'defhelper', ["cite"], function $Blockquote$1(value){var $a, self = $Blockquote$1.$$s == null ? this : $Blockquote$1.$$s;
            if (self.attributes == null) self.attributes = nil;

            
            if (value == null) value = nil;
            return ($a = ["cite", value.$to_s()], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$s: self})
        })($nesting[0], self)
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/html/element/button"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $send = Opal.send, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('each,defhelper,[]=,to_s,defhelper!');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Button');

          
          
          $send((new Map([["form", "form"], ["name", "name"], ["type", "type"], ["value", "value"], ["action", "formaction"], ["encoding", "formenctype"], ["method", "formmethod"], ["target", "formtarget"]])), 'each', [], function $Button$1(name, attributes){var self = $Button$1.$$s == null ? this : $Button$1.$$s;

            
            if (name == null) name = nil;
            if (attributes == null) attributes = nil;
            return $send(self, 'defhelper', [name], function $$2(value){var $a, self = $$2.$$s == null ? this : $$2.$$s;
              if (self.attributes == null) self.attributes = nil;

              
              if (value == null) value = nil;
              return ($a = [name, value.$to_s()], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$s: self});}, {$$s: self});
          self['$defhelper!']("autofocus");
          return self['$defhelper!']("disabled");
        })($nesting[0], self)
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/html/element/canvas"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $send = Opal.send, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('each,defhelper,[]=,to_s');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Canvas');

          
          return $send((new Map([["width", "width"], ["height", "height"]])), 'each', [], function $Canvas$1(name, attribute){var self = $Canvas$1.$$s == null ? this : $Canvas$1.$$s;

            
            if (name == null) name = nil;
            if (attribute == null) attribute = nil;
            return $send(self, 'defhelper', [name], function $$2(value){var $a, self = $$2.$$s == null ? this : $$2.$$s;
              if (self.attributes == null) self.attributes = nil;

              
              if (value == null) value = nil;
              return ($a = [name, value.$to_s()], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$s: self});}, {$$s: self})
        })($nesting[0], self)
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/html/element/embed"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $send = Opal.send, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('each,defhelper,[]=');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Embed');

          
          return $send((new Map([["type", "type"], ["height", "height"], ["width", "width"]])), 'each', [], function $Embed$1(name, attribute){var self = $Embed$1.$$s == null ? this : $Embed$1.$$s;

            
            if (name == null) name = nil;
            if (attribute == null) attribute = nil;
            return $send(self, 'defhelper', [name], function $$2(value){var $a, self = $$2.$$s == null ? this : $$2.$$s;
              if (self.attributes == null) self.attributes = nil;

              
              if (value == null) value = nil;
              return ($a = [name, value], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$s: self});}, {$$s: self})
        })($nesting[0], self)
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/html/element/img"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $send = Opal.send, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('each,defhelper,[]=,to_s');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Img');

          
          
          $send((new Map([["src", "src"], ["url", "src"], ["alt", "alt"], ["description", "alt"], ["height", "height"], ["width", "width"], ["map", "usemap"]])), 'each', [], function $Img$1(name, attribute){var self = $Img$1.$$s == null ? this : $Img$1.$$s;

            
            if (name == null) name = nil;
            if (attribute == null) attribute = nil;
            return $send(self, 'defhelper', [name], function $$2(value){var $a, self = $$2.$$s == null ? this : $$2.$$s;
              if (self.attributes == null) self.attributes = nil;

              
              if (value == null) value = nil;
              return ($a = [name, value.$to_s()], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$s: self});}, {$$s: self});
          return $send(self, 'defhelper', ["map!"], function $Img$3(){var $a, self = $Img$3.$$s == null ? this : $Img$3.$$s;
            if (self.attributes == null) self.attributes = nil;

            return ($a = ["ismap", true], $send(self.attributes, '[]=', $a), $a[$a.length - 1])}, {$$s: self});
        })($nesting[0], self)
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/html/element/input"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $send = Opal.send, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('each,defhelper,[]=');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Input');

          
          return $send((new Map([["type", "type"], ["name", "name"], ["value", "value"], ["size", "size"], ["place_holder", "placeholder"], ["read_only", "readonly"], ["required", "required"], ["limit", "maxlength"]])), 'each', [], function $Input$1(name, attribute){var self = $Input$1.$$s == null ? this : $Input$1.$$s;

            
            if (name == null) name = nil;
            if (attribute == null) attribute = nil;
            return $send(self, 'defhelper', [name], function $$2(value){var $a, self = $$2.$$s == null ? this : $$2.$$s;
              if (self.attributes == null) self.attributes = nil;

              
              if (value == null) value = nil;
              return ($a = [name, value], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$s: self});}, {$$s: self})
        })($nesting[0], self)
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/html/element/link"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $send = Opal.send, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('each,defhelper,[]=,to_s');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Link');

          
          return $send((new Map([["cross_origin", "crossorigin"], ["href", "href"], ["href_lang", "hreflang"], ["media", "media"], ["rel", "rel"], ["sizes", "sizes"], ["type", "type"]])), 'each', [], function $Link$1(name, attribute){var self = $Link$1.$$s == null ? this : $Link$1.$$s;

            
            if (name == null) name = nil;
            if (attribute == null) attribute = nil;
            return $send(self, 'defhelper', [name], function $$2(value){var $a, self = $$2.$$s == null ? this : $$2.$$s;
              if (self.attributes == null) self.attributes = nil;

              
              if (value == null) value = nil;
              return ($a = [name, value.$to_s()], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$s: self});}, {$$s: self})
        })($nesting[0], self)
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/html/element/object"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $send = Opal.send, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('each,defhelper,[]=');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Object');

          
          return $send((new Map([["type", "type"], ["data", "data"], ["name", "name"], ["height", "height"], ["width", "width"]])), 'each', [], function $Object$1(name, attribute){var self = $Object$1.$$s == null ? this : $Object$1.$$s;

            
            if (name == null) name = nil;
            if (attribute == null) attribute = nil;
            return $send(self, 'defhelper', [name], function $$2(value){var $a, self = $$2.$$s == null ? this : $$2.$$s;
              if (self.attributes == null) self.attributes = nil;

              
              if (value == null) value = nil;
              return ($a = [name, value], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$s: self});}, {$$s: self})
        })($nesting[0], self)
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/html/element/option"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $send = Opal.send, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('each,defhelper,[]=,defhelper!');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Option');

          
          
          $send(["label", "value"], 'each', [], function $Option$1(name){var self = $Option$1.$$s == null ? this : $Option$1.$$s;

            
            if (name == null) name = nil;
            return $send(self, 'defhelper', [name], function $$2(value){var $a, self = $$2.$$s == null ? this : $$2.$$s;
              if (self.attributes == null) self.attributes = nil;

              
              if (value == null) value = nil;
              return ($a = [name, value], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$s: self});}, {$$s: self});
          self['$defhelper!']("disabled");
          return self['$defhelper!']("selected");
        })($nesting[0], self)
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/html/element/optgroup"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $send = Opal.send, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('each,defhelper,[]=,defhelper!');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Optgroup');

          
          
          $send(["label", "value"], 'each', [], function $Optgroup$1(name){var self = $Optgroup$1.$$s == null ? this : $Optgroup$1.$$s;

            
            if (name == null) name = nil;
            return $send(self, 'defhelper', [name], function $$2(value){var $a, self = $$2.$$s == null ? this : $$2.$$s;
              if (self.attributes == null) self.attributes = nil;

              
              if (value == null) value = nil;
              return ($a = [name, value], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$s: self});}, {$$s: self});
          self['$defhelper!']("disabled");
          return self['$defhelper!']("selected");
        })($nesting[0], self)
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/html/element/select"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $send = Opal.send, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('each,defhelper,[]=,defhelper!');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Select');

          
          
          $send(["form", "name", "size"], 'each', [], function $Select$1(name){var self = $Select$1.$$s == null ? this : $Select$1.$$s;

            
            if (name == null) name = nil;
            return $send(self, 'defhelper', [name], function $$2(value){var $a, self = $$2.$$s == null ? this : $$2.$$s;
              if (self.attributes == null) self.attributes = nil;

              
              if (value == null) value = nil;
              return ($a = [name, value], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$s: self});}, {$$s: self});
          self['$defhelper!']("auto_focus", "autofocus");
          self['$defhelper!']("disabled");
          return self['$defhelper!']("required");
        })($nesting[0], self)
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/html/element/td"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $send = Opal.send, $slice = Opal.slice, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('defhelper,[]=,to_s,join');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Td');

          
          
          $send(self, 'defhelper', ["columns"], function $Td$1(value){var $a, self = $Td$1.$$s == null ? this : $Td$1.$$s;
            if (self.attributes == null) self.attributes = nil;

            
            if (value == null) value = nil;
            return ($a = ["colspan", value.$to_s()], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$s: self});
          $send(self, 'defhelper', ["rows"], function $Td$2(value){var $a, self = $Td$2.$$s == null ? this : $Td$2.$$s;
            if (self.attributes == null) self.attributes = nil;

            
            if (value == null) value = nil;
            return ($a = ["rowspan", value.$to_s()], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$s: self});
          return $send(self, 'defhelper', ["headers"], function $Td$3($a){var $post_args, args, $b, self = $Td$3.$$s == null ? this : $Td$3.$$s;
            if (self.attributes == null) self.attributes = nil;

            
            $post_args = $slice(arguments);
            args = $post_args;
            return ($b = ["headers", args.$join(" ")], $send(self.attributes, '[]=', $b), $b[$b.length - 1]);}, {$$arity: -1, $$s: self});
        })($nesting[0], self)
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/html/element"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $eqeq = Opal.eqeq, $send2 = Opal.send2, $find_super = Opal.find_super, $truthy = Opal.truthy, $not = Opal.not, $defs = Opal.defs, $def = Opal.def, $send = Opal.send, $range = Opal.range, $eqeqeq = Opal.eqeqeq, $to_a = Opal.to_a, $slice = Opal.slice, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,==,capitalize,const_defined?,!,include?,to_s,new,const_get,each,to_proc,<<,end_with?,[]=,[],===,has_key?,unshift,|,split,delete,to_a,deep_merge!,>>,extend!,pop,join,heredoc,defhelper,map,empty?,upcase,inspect');
  
  self.$require("paggio/html/element/a");
  self.$require("paggio/html/element/base");
  self.$require("paggio/html/element/blockquote");
  self.$require("paggio/html/element/button");
  self.$require("paggio/html/element/canvas");
  self.$require("paggio/html/element/embed");
  self.$require("paggio/html/element/img");
  self.$require("paggio/html/element/input");
  self.$require("paggio/html/element/link");
  self.$require("paggio/html/element/object");
  self.$require("paggio/html/element/option");
  self.$require("paggio/html/element/optgroup");
  self.$require("paggio/html/element/select");
  self.$require("paggio/html/element/td");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.children = $proto.attributes = $proto.class_names = $proto.owner = $proto.name = nil;
        
        $defs(self, '$new', function $Element_new$1(owner, name, attributes) {
          var $yield = $Element_new$1.$$p || nil, self = this, const$ = nil;

          $Element_new$1.$$p = null;
          
          if (attributes == null) attributes = (new Map());
          if (!$eqeq(self, $$('Element'))) {
            return $send2(self, $find_super(self, 'new', $Element_new$1, false, true), 'new', [owner, name, attributes], $yield)
          };
          const$ = name.$capitalize();
          if (($not(const$.$to_s()['$include?']("-")) && ($truthy(self['$const_defined?'](const$))))) {
            return self.$const_get(const$).$new(owner, name, attributes)
          } else {
            return $send2(self, $find_super(self, 'new', $Element_new$1, false, true), 'new', [owner, name, attributes], $yield)
          };
        }, -3);
        
        $def(self, '$initialize', function $$initialize(owner, name, attributes) {
          var self = this;

          
          if (attributes == null) attributes = (new Map());
          self.owner = owner;
          self.name = name;
          self.attributes = attributes;
          self.children = [];
          return (self.class_names = []);
        }, -3);
        
        $def(self, '$each', function $$each() {
          var block = $$each.$$p || nil, self = this;

          $$each.$$p = null;
          
          ;
          return $send(self.children, 'each', [], block.$to_proc());
        });
        
        $def(self, '$<<', function $Element_$lt$lt$2(what) {
          var self = this;

          
          self.children['$<<'](what);
          return self;
        });
        
        $def(self, '$method_missing', function $$method_missing(name, content) {
          var block = $$method_missing.$$p || nil, self = this;

          $$method_missing.$$p = null;
          
          ;
          if (content == null) content = nil;
          if ($truthy(name.$to_s()['$end_with?']("!"))) {
            self.attributes['$[]=']("id", name['$[]']($range(0, -2, false)))
          } else {
            self.class_names['$<<'](name)
          };
          if ($eqeqeq($$$('Hash'), content)) {
            
            if (($truthy(content['$has_key?']("class")) || ($truthy(content['$has_key?']("classes"))))) {
              $send(self.class_names, 'unshift', $to_a(content.$delete("class").$to_s().$split()['$|'](content.$delete("classes").$to_a())))
            };
            $$$($$$('Paggio'), 'Utils')['$deep_merge!'](self.attributes, content);
          } else if ($truthy(content)) {
            self['$>>'](content)
          };
          if ($truthy(block)) {
            $send(self.owner, 'extend!', [self], block.$to_proc())
          };
          return self;
        }, -2);
        
        $def(self, '$[]', function $Element_$$$3($a) {
          var $post_args, names, self = this, last = nil;

          
          $post_args = $slice(arguments);
          names = $post_args;
          if ($truthy((last = self.class_names.$pop()))) {
            self.class_names['$<<']([last].concat($to_a(names)).$join("-"))
          };
          return self;
        }, -1);
        
        $def(self, '$do', function $Element_do$4() {
          var block = $Element_do$4.$$p || nil, self = this;

          $Element_do$4.$$p = null;
          
          ;
          $send(self.owner, 'extend!', [self], block.$to_proc());
          return self;
        });
        
        $def(self, '$>>', function $Element_$gt$gt$5(content) {
          var self = this;

          
          self['$<<']($$$($$$('Paggio'), 'Utils').$heredoc(content.$to_s()));
          return self;
        });
        $send(self, 'defhelper', ["style"], function $Element$6(hash){var $a, self = $Element$6.$$s == null ? this : $Element$6.$$s;
          if (self.attributes == null) self.attributes = nil;

          
          if (hash == null) hash = nil;
          return ($a = ["style", $send(hash, 'map', [], function $$7(name, value){
            
            if (name == null) name = nil;
            if (value == null) value = nil;
            return "" + (name) + ": " + (value);}).$join(";")], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$s: self});
        $send(self, 'defhelper', ["data"], function $Element$8(hash){var self = $Element$8.$$s == null ? this : $Element$8.$$s;

          
          if (hash == null) hash = nil;
          return $send(hash, 'each', [], function $$9(name, value){var $a, self = $$9.$$s == null ? this : $$9.$$s;
            if (self.attributes == null) self.attributes = nil;

            
            if (name == null) name = nil;
            if (value == null) value = nil;
            return ($a = ["data-" + (name), value.$to_s()], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);}, {$$s: self});}, {$$s: self});
        return $def(self, '$inspect', function $$inspect() {
          var self = this;

          if ($truthy(self.children['$empty?']())) {
            return "#<HTML::Element(" + (self.name.$upcase()) + ")>"
          } else {
            return "#<HTML::Element(" + (self.name.$upcase()) + "): " + (self.children.$inspect()['$[]']($range(1, -2, false))) + ">"
          }
        });
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting);
};

Opal.modules["paggio/html"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $slice = Opal.slice, $extract_kwargs = Opal.extract_kwargs, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $def = Opal.def, $eqeq = Opal.eqeq, $not = Opal.not, $send = Opal.send, $return_ivar = Opal.return_ivar, $eqeqeq = Opal.eqeqeq, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $alias = Opal.alias, $range = Opal.range, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,attr_reader,raise,build!,<<,==,arity,!,instance_exec,to_proc,call,first,===,instance_eval,each,end_with?,to_s,empty?,heredoc,shift,new,method_missing,[],inspect');
  
  self.$require("paggio/html/helpers");
  self.$require("paggio/html/element");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.current = $proto.roots = $proto.block = $proto.version = nil;
      
      self.$attr_reader("version");
      
      $def(self, '$initialize', function $$initialize($a, $b) {
        var block = $$initialize.$$p || nil, $post_args, $kwargs, version, defer, self = this;

        $$initialize.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        $kwargs = $extract_kwargs($post_args);
        $kwargs = $ensure_kwargs($kwargs);
        
        if ($post_args.length > 0) version = $post_args.shift();if (version == null) version = 5;
        
        defer = $hash_get($kwargs, "defer");if (defer == null) defer = false;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "no block given")
        };
        self.version = version;
        self.roots = [];
        self.current = nil;
        self.block = block;
        if ($truthy(defer)) {
          return nil
        } else {
          return self['$build!']()
        };
      }, -1);
      
      $def(self, '$<<', function $HTML_$lt$lt$1(what) {
        var self = this, $ret_or_1 = nil;

        return ($truthy(($ret_or_1 = self.current)) ? ($ret_or_1) : (self.roots))['$<<'](what)
      });
      
      $def(self, '$build!', function $HTML_build$excl$2($kwargs) {
        var force_call, self = this;

        
        $kwargs = $ensure_kwargs($kwargs);
        
        force_call = $hash_get($kwargs, "force_call");if (force_call == null) force_call = false;
        if (($not(force_call) && ($eqeq(self.block.$arity(), 0)))) {
          $send(self, 'instance_exec', [], self.block.$to_proc())
        } else {
          self.block.$call(self)
        };
        return (self.block = nil);
      }, -1);
      
      $def(self, '$root!', function $HTML_root$excl$3() {
        var self = this;

        return self.roots.$first()
      });
      
      $def(self, '$roots!', $return_ivar("roots"));
      
      $def(self, '$element!', $return_ivar("current"));
      
      $def(self, '$extend!', function $HTML_extend$excl$4(element) {
        var block = $HTML_extend$excl$4.$$p || nil, $a, self = this, old = nil, result = nil;

        $HTML_extend$excl$4.$$p = null;
        
        ;
        if (element == null) element = nil;
        $a = [self.current, element], (old = $a[0]), (self.current = $a[1]), $a;
        result = block.$call(self);
        if ($eqeqeq($$$('String'), result)) {
          $send(self.current, 'instance_eval', [], function $$5(){var self = $$5.$$s == null ? this : $$5.$$s;

            return (self.inner_html = result)}, {$$s: self})
        };
        self.current = old;
        return self;
      }, -1);
      
      $def(self, '$each', function $$each() {
        var block = $$each.$$p || nil, self = this;

        $$each.$$p = null;
        
        ;
        return $send(self.roots, 'each', [], block.$to_proc());
      });
      
      $def(self, '$text', function $$text($a) {
        var block = $$text.$$p || nil, $post_args, fragments, self = this;

        $$text.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        fragments = $post_args;
        if ($truthy(block)) {
          fragments['$<<'](Opal.yieldX(block, []))
        };
        return $send(fragments, 'each', [], function $$6(fragment){var self = $$6.$$s == null ? this : $$6.$$s;

          
          if (fragment == null) fragment = nil;
          return self['$<<'](fragment);}, {$$s: self});
      }, -1);
      
      $def(self, '$method_missing', function $$method_missing(name, $a) {
        var block = $$method_missing.$$p || nil, $post_args, args, self = this, content = nil, element = nil, parent = nil, result = nil;

        $$method_missing.$$p = null;
        
        ;
        $post_args = $slice(arguments, 1);
        args = $post_args;
        if ($truthy(name.$to_s()['$end_with?']("!"))) {
          return $send2(self, $find_super(self, 'method_missing', $$method_missing, false, true), 'method_missing', [name].concat($to_a(args)), block)
        };
        if (!($truthy(args['$empty?']()) || ($eqeqeq($$$('Hash'), args.$first())))) {
          content = $$$($$$('Paggio'), 'Utils').$heredoc(args.$shift().$to_s())
        };
        element = $send($$('Element'), 'new', [self, name].concat($to_a(args)));
        if ($truthy(content)) {
          element['$<<'](content)
        };
        if ($truthy(block)) {
          
          parent = self.current;
          self.current = element;
          result = block.$call(self);
          self.current = parent;
          if ($eqeqeq($$$('String'), result)) {
            $send(element, 'instance_eval', [], function $$7(){var self = $$7.$$s == null ? this : $$7.$$s;

              return (self.inner_html = result)}, {$$s: self})
          };
        };
        self['$<<'](element);
        return element;
      }, -2);
      $alias(self, "e", "method_missing");
      return $def(self, '$inspect', function $$inspect() {
        var self = this;

        if ($truthy(self.roots['$empty?']())) {
          return "#<HTML(" + (self.version) + ")>"
        } else {
          return "#<HTML(" + (self.version) + "): " + (self.roots.$inspect()['$[]']($range(1, -2, false))) + ">"
        }
      });
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting);
};

Opal.modules["paggio/css/unit"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $const_set = Opal.const_set, $send = Opal.send, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $truthy = Opal.truthy, $alias = Opal.alias, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $rb_minus = Opal.rb_minus, $rb_times = Opal.rb_times, $rb_divide = Opal.rb_divide, $return_self = Opal.return_self, $return_val = Opal.return_val, self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('map,to_proc,attr_reader,===,respond_to?,raise,class,to_u,new,==,convert,type,number,hash,each,define_method,+,compatible?,-,*,/,to_i,to_f,to_s,private,include?,class_eval,%,old_percent,match,[],__send__,downcase');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'CSS');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Unit');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.type = $proto.number = nil;
        
        $const_set($nesting[0], 'TYPES', $send(["em", "ex", "ch", "rem", "vh", "vw", "vmin", "vmax", "px", "mm", "cm", "in", "pt", "pc", "s", "deg"], 'map', [], "to_sym".$to_proc()));
        $const_set($nesting[0], 'COMPATIBLE', $send(["in", "pt", "mm", "cm", "px", "pc"], 'map', [], "to_sym".$to_proc()));
        self.$attr_reader("type", "number");
        
        $def(self, '$initialize', function $$initialize(number, type) {
          var self = this;

          
          self.number = number;
          return (self.type = type);
        });
        
        $def(self, '$coerce', function $$coerce(other) {
          var self = this;

          return [self, other]
        });
        
        $def(self, '$==', function $Unit_$eq_eq$1(other) {
          var self = this;

          
          if (!$eqeqeq($$('Unit'), other)) {
            
            if (!$truthy(other['$respond_to?']("to_u"))) {
              self.$raise($$('TypeError'), "no implicit conversion of " + (other.$class()) + " into Unit")
            };
            other = other.$to_u();
          };
          if (!$eqeqeq($$('Unit'), other)) {
            other = $$('Unit').$new(other, self.type)
          };
          return self.number['$=='](self.$convert(other, self.type));
        });
        
        $def(self, '$===', function $Unit_$eq_eq_eq$2(other) {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self.type['$=='](other.$type())))) {
            return self.number['$=='](other.$number())
          } else {
            return $ret_or_1
          }
        });
        $alias(self, "eql?", "==");
        
        $def(self, '$hash', function $$hash() {
          var self = this;

          return [self.number, self.type].$hash()
        });
        $send($$('TYPES'), 'each', [], function $Unit$3(name){var self = $Unit$3.$$s == null ? this : $Unit$3.$$s;

          
          if (name == null) name = nil;
          return $send(self, 'define_method', [name], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

            return $$('Unit').$new(self.$convert(self, name), name)}, {$$s: self});}, {$$s: self});
        
        $def(self, '$+', function $Unit_$plus$5(other) {
          var self = this;

          
          if (!$eqeqeq($$('Unit'), other)) {
            return $$('Unit').$new($rb_plus(self.number, other), self.type)
          };
          if ($eqeq(self.type, other.$type())) {
            return $$('Unit').$new($rb_plus(self.number, other.$number()), self.type)
          } else if (($truthy(self['$compatible?'](self)) && ($truthy(self['$compatible?'](other))))) {
            return $$('Unit').$new($rb_plus(self.number, self.$convert(other, self.type)), self.type)
          } else {
            return self.$raise($$('ArgumentError'), "" + (other.$type()) + " isn't compatible with " + (self.type))
          };
        });
        
        $def(self, '$-', function $Unit_$minus$6(other) {
          var self = this;

          
          if (!$eqeqeq($$('Unit'), other)) {
            return $$('Unit').$new($rb_minus(self.number, other), self.type)
          };
          if ($eqeq(self.type, other.$type())) {
            return $$('Unit').$new($rb_minus(self.number, other.$number()), self.type)
          } else if (($truthy(self['$compatible?'](self)) && ($truthy(self['$compatible?'](other))))) {
            return $$('Unit').$new($rb_minus(self.number, self.$convert(other, self.type)), self.type)
          } else {
            return self.$raise($$('ArgumentError'), "" + (other.$type()) + " isn't compatible with " + (self.type))
          };
        });
        
        $def(self, '$*', function $Unit_$$7(other) {
          var self = this;

          
          if (!$eqeqeq($$('Unit'), other)) {
            return $$('Unit').$new($rb_times(self.number, other), self.type)
          };
          if ($eqeq(self.type, other.$type())) {
            return $$('Unit').$new($rb_times(self.number, other.$number()), self.type)
          } else if (($truthy(self['$compatible?'](self)) && ($truthy(self['$compatible?'](other))))) {
            return $$('Unit').$new($rb_times(self.number, self.$convert(other, self.type)), self.type)
          } else {
            return self.$raise($$('ArgumentError'), "" + (other.$type()) + " isn't compatible with " + (self.type))
          };
        });
        
        $def(self, '$/', function $Unit_$slash$8(other) {
          var self = this;

          
          if (!$eqeqeq($$('Unit'), other)) {
            return $$('Unit').$new($rb_divide(self.number, other), self.type)
          };
          if ($eqeq(self.type, other.$type())) {
            return $$('Unit').$new($rb_divide(self.number, other.$number()), self.type)
          } else if (($truthy(self['$compatible?'](self)) && ($truthy(self['$compatible?'](other))))) {
            return $$('Unit').$new($rb_divide(self.number, self.$convert(other, self.type)), self.type)
          } else {
            return self.$raise($$('ArgumentError'), "" + (other.$type()) + " isn't compatible with " + (self.type))
          };
        });
        
        $def(self, '$-@', function $Unit_$minus$$9() {
          var self = this;

          return $$('Unit').$new($rb_times(self.number, -1), self.type)
        });
        
        $def(self, '$+@', function $Unit_$plus$$10() {
          var self = this;

          return $$('Unit').$new(self.number, self.type)
        });
        
        $def(self, '$to_i', function $$to_i() {
          var self = this;

          return self.number.$to_i()
        });
        
        $def(self, '$to_f', function $$to_f() {
          var self = this;

          return self.number.$to_f()
        });
        
        $def(self, '$to_u', $return_self);
        
        $def(self, '$to_s', function $$to_s() {
          var self = this;

          return "" + (self.number) + (self.type)
        });
        $alias(self, "to_str", "to_s");
        $alias(self, "inspect", "to_s");
        self.$private();
        
        $def(self, '$compatible?', function $Unit_compatible$ques$11(unit) {
          
          return $$('COMPATIBLE')['$include?'](unit.$type())
        });
        return $def(self, '$convert', function $$convert(unit, type) {
          var value = nil, px = nil, $ret_or_1 = nil;

          
          value = unit.$number();
          if ($eqeq(unit.$type(), type)) {
            return value
          };
          px = ($eqeqeq("in", ($ret_or_1 = unit.$type())) ? ($rb_times(value, 96)) : ($eqeqeq("pt", $ret_or_1) ? ($rb_divide($rb_times(value, 4.0), 3.0)) : ($eqeqeq("pc", $ret_or_1) ? ($rb_divide($rb_times($rb_divide(value, 12), 4.0), 3.0)) : ($eqeqeq("mm", $ret_or_1) ? ($rb_times(value, 3.77953)) : ($eqeqeq("cm", $ret_or_1) ? ($rb_times($rb_times(value, 10), 3.77953)) : ($eqeqeq("px", $ret_or_1) ? (value) : (nil)))))));
          
          switch (type.valueOf()) {
            case "in":
              return $rb_divide(px, 96.0)
            case "pt":
              return $rb_divide($rb_divide(px, 4.0), 3.0)
            case "pc":
              return $rb_divide($rb_divide($rb_times(px, 12), 4.0), 3.0)
            case "mm":
              return $rb_divide(px, 3.77953)
            case "cm":
              return $rb_divide($rb_divide(px, 10), 3.77953)
            case "px":
              return px
            default:
              return nil
          };
        });
      })($nesting[0], null, $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Numeric');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $send($$$($$$($$$($$('Paggio'), 'CSS'), 'Unit'), 'TYPES'), 'each', [], function $Numeric$12(name){var self = $Numeric$12.$$s == null ? this : $Numeric$12.$$s;

      
      if (name == null) name = nil;
      return $send(self, 'define_method', [name], function $$13(){var self = $$13.$$s == null ? this : $$13.$$s;

        return $$$($$$($$('Paggio'), 'CSS'), 'Unit').$new(self, name)}, {$$s: self});}, {$$s: self});
    return $def(self, '$to_u', $return_self);
  })($nesting[0], null, $nesting);
  $send([$$('Fixnum'), $$('Float')], 'each', [], function $$14(klass){var self = $$14.$$s == null ? this : $$14.$$s;

    
    if (klass == null) klass = nil;
    return $send(klass, 'class_eval', [], function $$15(){var self = $$15.$$s == null ? this : $$15.$$s;

      
      $alias(self, "old_percent", "%");
      return $def(self, '$%', function $percent$16(other) {
        var self = this;

        
        if (other == null) other = nil;
        if ($truthy(other)) {
          return self.$old_percent(other)
        } else {
          return $$$($$$($$('Paggio'), 'CSS'), 'Unit').$new(self, "%")
        };
      }, -1);}, {$$s: self});}, {$$s: self});
  (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    return $def(self, '$to_u', function $$to_u() {
      var self = this, matches = nil, value = nil, unit = nil;

      if ($truthy((matches = self.$match(/^([\d+.]+)(.+)?$/)))) {
        
        value = matches['$[]'](1).$to_f();
        if ($truthy((unit = matches['$[]'](2)))) {
          return value.$__send__(unit.$downcase())
        } else {
          return value
        };
      } else {
        return 0
      }
    })
  })($nesting[0], null);
  return (function($base, $super) {
    var self = $klass($base, $super, 'NilClass');

    
    return $def(self, '$to_u', $return_val(0))
  })($nesting[0], null);
};

Opal.modules["paggio/css/color"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $def = Opal.def, $send = Opal.send, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('each,map,to_proc,define_method,new');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'CSS');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'Color');

        
        return $def(self, '$initialize', function $$initialize(value, type) {
          var self = this;

          
          self.internal = value;
          return (self.type = type);
        })
      })($nesting[0], null)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $send($send(["rgb", "rgba", "hsl", "hsla"], 'map', [], "to_sym".$to_proc()), 'each', [], function $String$1(name){var self = $String$1.$$s == null ? this : $String$1.$$s;

      
      if (name == null) name = nil;
      return $send(self, 'define_method', [name], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;

        return $$$($$$($$('Paggio'), 'CSS'), 'Color').$new(self, name)}, {$$s: self});}, {$$s: self})
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $send($send(["rgb", "rgba", "hsl", "hsla"], 'map', [], "to_sym".$to_proc()), 'each', [], function $Array$3(name){var self = $Array$3.$$s == null ? this : $Array$3.$$s;

      
      if (name == null) name = nil;
      return $send(self, 'define_method', [name], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

        return $$$($$$($$('Paggio'), 'CSS'), 'Color').$new(self, name)}, {$$s: self});}, {$$s: self})
  })($nesting[0], null, $nesting);
};

Opal.modules["paggio/css/definition"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $const_set = Opal.const_set, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $send = Opal.send, $def = Opal.def, $slice = Opal.slice, $to_a = Opal.to_a, $eqeqeq = Opal.eqeqeq, $rb_gt = Opal.rb_gt, $rb_times = Opal.rb_times, $range = Opal.range, $not = Opal.not, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('new,==,arity,instance_exec,to_proc,call,empty?,each,inspect,to_s,define_method,a,===,first,>,length,raise,style,name,value,[],join,map,to_i,*,end_with?,__send__,<<,last,pop,!,other,shift,horizontal?,private');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'CSS');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Definition');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.style = $proto.important = nil;
        
        $const_set($nesting[0], 'Style', $$$('Struct').$new("name", "value", "important"));
        
        $def(self, '$initialize', function $$initialize() {
          var block = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          
          ;
          self.style = [];
          if ($truthy(block)) {
            if ($eqeq(block.$arity(), 0)) {
              return $send(self, 'instance_exec', [], block.$to_proc())
            } else {
              return block.$call(self)
            }
          } else {
            return nil
          };
        });
        
        $def(self, '$empty?', function $Definition_empty$ques$1() {
          var self = this;

          return self.style['$empty?']()
        });
        
        $def(self, '$each', function $$each() {
          var block = $$each.$$p || nil, self = this;

          $$each.$$p = null;
          
          ;
          return $send(self.style, 'each', [], block.$to_proc());
        });
        
        $def(self, '$gradient', function $$gradient($a) {
          var $post_args, args;

          
          $post_args = $slice(arguments);
          args = $post_args;
          return $send($$('Gradient'), 'new', $to_a(args));
        }, -1);
        
        $def(self, '$url', function $$url(value) {
          
          return "url(" + (value.$to_s().$inspect()) + ")"
        });
        $send(["blur", "brightness", "rotate", "contrast", "grayscale", "invert", "opacity", "saturate", "sepia"], 'each', [], function $Definition$2(name){var self = $Definition$2.$$s == null ? this : $Definition$2.$$s;

          
          if (name == null) name = nil;
          return $send(self, 'define_method', [name], function $$3(value){
            
            if (value == null) value = nil;
            return "" + (name) + "(" + (value) + ")";});}, {$$s: self});
        
        $def(self, '$rgb', function $$rgb(r, g, b) {
          var self = this;

          return "rgb(" + (r) + ", " + (g) + ", " + (b) + ", " + (self.$a()) + ")"
        });
        
        $def(self, '$rgba', function $$rgba(r, g, b, a) {
          
          return "rgba(" + (r) + ", " + (g) + ", " + (b) + ", " + (a) + ")"
        });
        $send(["scale", "skew", "translate"], 'each', [], function $Definition$4(name){var self = $Definition$4.$$s == null ? this : $Definition$4.$$s;

          
          if (name == null) name = nil;
          return $send(self, 'define_method', [name], function $$5(a, b){
            
            if (a == null) a = nil;
            if (b == null) b = nil;
            if ($truthy(b)) {
              return "" + (name) + "(" + (a) + ", " + (b) + ")"
            } else {
              return "" + (name) + "(" + (a) + ")"
            };}, -2);}, {$$s: self});
        $send(["translateX", "translateY", "translateZ", "rotateX", "rotateY", "rotateZ", "skewX", "skewY", "scaleX", "scaleY"], 'each', [], function $Definition$6(name){var self = $Definition$6.$$s == null ? this : $Definition$6.$$s;

          
          if (name == null) name = nil;
          return $send(self, 'define_method', [name], function $$7(value){
            
            if (value == null) value = nil;
            return "" + (name) + "(" + (value) + ")";});}, {$$s: self});
        
        $def(self, '$background', function $$background($a) {
          var $post_args, args, self = this;

          
          $post_args = $slice(arguments);
          args = $post_args;
          if ($eqeqeq($$('Gradient'), args.$first())) {
            
            if ($truthy($rb_gt(args.$length(), 1))) {
              self.$raise($$('NotImplementedError'), "multiple gradients not implemented yet")
            };
            return $send(args.$first(), 'each', [], function $$8(s){var self = $$8.$$s == null ? this : $$8.$$s, $ret_or_1 = nil;

              
              if (s == null) s = nil;
              return self.$style(($truthy(($ret_or_1 = s.$name())) ? ($ret_or_1) : ("background-image")), s.$value());}, {$$s: self});
          } else if ($eqeqeq($$$('Hash'), args.$first())) {
            return $send(args.$first(), 'each', [], function $$9(sub, value){var self = $$9.$$s == null ? this : $$9.$$s;

              
              if (sub == null) sub = nil;
              if (value == null) value = nil;
              return self.$style("background-" + (sub), value);}, {$$s: self})
          } else {
            return self.$style("background", args)
          };
        }, -1);
        
        $def(self, '$border', function $$border($a) {
          var $post_args, args, self = this, options = nil;

          
          $post_args = $slice(arguments);
          args = $post_args;
          if ($eqeqeq($$$('Hash'), args.$first())) {
            
            if ($eqeq(args.$length(), 1)) {
              options = args.$first()
            };
            return $send(options, 'each', [], function $$10(name, value){var self = $$10.$$s == null ? this : $$10.$$s;

              
              if (name == null) name = nil;
              if (value == null) value = nil;
              
              switch (name.valueOf()) {
                case "top":
                case "bottom":
                case "left":
                case "right":
                  if ($eqeqeq($$$('Hash'), value)) {
                    return $send(value, 'each', [], function $$11(n, v){var self = $$11.$$s == null ? this : $$11.$$s;

                      
                      if (n == null) n = nil;
                      if (v == null) v = nil;
                      return self.$style("border-" + (name) + "-" + (n), v);}, {$$s: self})
                  } else {
                    return self.$style("border-" + (name), value)
                  }
                  break;
                case "radius":
                  if ($eqeqeq($$$('Hash'), value)) {
                    return $send(value, 'each', [], function $$12(horizontal, value){var self = $$12.$$s == null ? this : $$12.$$s;

                      
                      if (horizontal == null) horizontal = nil;
                      if (value == null) value = nil;
                      return $send(value, 'each', [], function $$13(vertical, value){var self = $$13.$$s == null ? this : $$13.$$s;

                        
                        if (vertical == null) vertical = nil;
                        if (value == null) value = nil;
                        self.$style("-moz-border-radius-" + (horizontal) + (vertical), value);
                        self.$style("-webkit-border-" + (horizontal) + "-" + (vertical) + "-radius", value);
                        return self.$style("border-" + (horizontal) + "-" + (vertical) + "-radius", value);}, {$$s: self});}, {$$s: self})
                  } else {
                    
                    self.$style("-moz-border-radius", value);
                    self.$style("-webkit-border-radius", value);
                    return self.$style("border-radius", value);
                  }
                  break;
                case "color":
                  if ($eqeqeq($$$('Hash'), value)) {
                    return $send(value, 'each', [], function $$14(name, value){var self = $$14.$$s == null ? this : $$14.$$s;

                      
                      if (name == null) name = nil;
                      if (value == null) value = nil;
                      return self.$style("border-" + (name) + "-color", value);}, {$$s: self})
                  } else {
                    return self.$style("border-color", value)
                  }
                  break;
                default:
                  return self.$style("border-" + (name), value)
              };}, {$$s: self});
          } else {
            return self.$style("border", args)
          };
        }, -1);
        
        $def(self, '$box', function $$box(options) {
          var self = this;

          if ($eqeqeq($$$('Hash'), options)) {
            return $send(options, 'each', [], function $$15(name, value){var self = $$15.$$s == null ? this : $$15.$$s;

              
              if (name == null) name = nil;
              if (value == null) value = nil;
              
              switch (name.valueOf()) {
                case "shadow":
                  
                  if ($eqeqeq($$$('Array'), value)) {
                    if ($eqeqeq($$$('Array'), value['$[]'](0))) {
                      value = $send(value, 'map', [], function $$16(v){
                        
                        if (v == null) v = nil;
                        return v.$join(" ");}).$join(", ")
                    } else {
                      value = value.$join(" ")
                    }
                  };
                  self.$style("-moz-box-shadow", value);
                  self.$style("-webkit-box-shadow", value);
                  return self.$style("box-shadow", value);
                default:
                  return self.$style("box-" + (name), value)
              };}, {$$s: self})
          } else {
            return self.$style("box", options)
          }
        });
        
        $def(self, '$opacity', function $$opacity(value) {
          var self = this;

          
          self.$style("opacity", value);
          self.$style("-moz-opacity", value);
          self.$style("-ms-filter", "\"progid:DXImageTransform.Microsoft.Alpha(Opacity=" + ($rb_times(value, 100).$to_i()) + ")\"");
          return self.$style("filter", "alpha(opacity=" + ($rb_times(value, 100).$to_i()) + ")");
        });
        
        $def(self, '$animation', function $$animation($a) {
          var $post_args, args, self = this, options = nil;

          
          $post_args = $slice(arguments);
          args = $post_args;
          if ($eqeqeq($$('Hash'), args.$first())) {
            
            if ($eqeq(args.$length(), 1)) {
              options = args.$first()
            };
            return $send(options, 'each', [], function $$17(name, value){var self = $$17.$$s == null ? this : $$17.$$s;

              
              if (name == null) name = nil;
              if (value == null) value = nil;
              self.$style("-webkit-animation-" + (name), value);
              return self.$style("animation-" + (name), value);}, {$$s: self});
          } else {
            
            self.$style("animation", args);
            return self.$style("-webkit-animation", args);
          };
        }, -1);
        
        $def(self, '$transition', function $$transition($a) {
          var $post_args, args, self = this;

          
          $post_args = $slice(arguments);
          args = $post_args;
          self.$style("transition", args);
          self.$style("-webkit-transition", args);
          return self.$style("-moz-transition", args);
        }, -1);
        
        $def(self, '$user_select', function $$user_select($a) {
          var $post_args, args, self = this;

          
          $post_args = $slice(arguments);
          args = $post_args;
          self.$style("user-select", args);
          self.$style("-webkit-user-select", args);
          self.$style("-moz-user-select", args);
          return self.$style("-ms-user-select", args);
        }, -1);
        
        $def(self, '$transform', function $$transform($a) {
          var $post_args, args, self = this;

          
          $post_args = $slice(arguments);
          args = $post_args;
          self.$style("transform", args);
          self.$style("-webkit-transform", args);
          self.$style("-moz-transform", args);
          self.$style("-ms-transform", args);
          return self.$style("-o-transform", args);
        }, -1);
        
        $def(self, '$filter', function $$filter($a) {
          var $post_args, args, self = this;

          
          $post_args = $slice(arguments);
          args = $post_args;
          self.$style("filter", args);
          self.$style("-webkit-filter", args);
          self.$style("-moz-filter", args);
          self.$style("-ms-filter", args);
          return self.$style("-o-filter", args);
        }, -1);
        
        $def(self, '$method_missing', function $$method_missing(name, $a) {
          var block = $$method_missing.$$p || nil, $post_args, args, self = this, argument = nil;

          $$method_missing.$$p = null;
          
          ;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          name = name.$to_s();
          if ($truthy(name['$end_with?']("!"))) {
            
            name = name['$[]']($range(0, -2, false));
            self.important = true;
            $send(self, '__send__', [name].concat($to_a(args)), block.$to_proc());
            self.important = false;
            return nil;
          };
          if ($eqeq(args.$length(), 1)) {
            
            argument = args.$first();
            if ($eqeqeq($$$('Hash'), argument)) {
              $send(argument, 'each', [], function $$18(sub, value){var self = $$18.$$s == null ? this : $$18.$$s;

                
                if (sub == null) sub = nil;
                if (value == null) value = nil;
                return self.$style("" + (name) + "-" + (sub), value);}, {$$s: self})
            } else {
              self.$style(name, argument)
            };
          } else {
            self.$style(name, args.$join(" "))
          };
          self.important = false;
          return self;
        }, -2);
        
        $def(self, '$style', function $$style(name, value, important) {
          var self = this;

          
          if (value == null) value = nil;
          if (important == null) important = self.important;
          if ($eqeqeq($$$('Array'), value)) {
            value = value.$join(" ")
          };
          if ($eqeqeq($$('Style'), name)) {
            return self.style['$<<'](name)
          } else {
            return self.style['$<<']($$('Style').$new(name, value, important))
          };
        }, -2);
        
        $def(self, '$style!', function $Definition_style$excl$19(name, value) {
          var self = this;

          
          if (value == null) value = nil;
          return self.$style(name, value, true);
        }, -2);
        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Gradient');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto.from = $proto.to = $proto.start = $proto.end = nil;
          
          
          $def(self, '$initialize', function $$initialize($a) {
            var $post_args, args, self = this, options = nil;

            
            $post_args = $slice(arguments);
            args = $post_args;
            options = ($eqeqeq($$$('Hash'), args.$last()) ? (args.$pop()) : ((new Map())));
            self.to = options['$[]']("to");
            self.from = options['$[]']("from");
            if (($truthy(self.to) && ($not(self.from)))) {
              self.from = self.$other(self.to)
            } else if (($truthy(self.from) && ($not(self.to)))) {
              self.to = self.$other(self.from)
            };
            self.start = args.$shift();
            return (self.end = args.$shift());
          }, -1);
          
          $def(self, '$each', function $$each() {
            var block = $$each.$$p || nil, self = this;

            $$each.$$p = null;
            
            ;
            block.$call(self.$style("-moz-linear-gradient(" + (self.to) + ", " + (self.start) + " 0%, " + (self.end) + " 100%)"));
            if ($truthy(self['$horizontal?']())) {
              block.$call(self.$style("-webkit-gradient(linear, " + (self.from) + " top, " + (self.to) + " top, color-stop(0%, " + (self.start) + "), color-stop(100%, " + (self.end) + "))"))
            } else {
              block.$call(self.$style("-webkit-gradient(linear, left " + (self.from) + ", left " + (self.to) + ", color-stop(0%, " + (self.start) + "), color-stop(100%, " + (self.end) + "))"))
            };
            block.$call(self.$style("-webkit-linear-gradient(" + (self.to) + ", " + (self.start) + " 0%, " + (self.end) + " 100%)"));
            block.$call(self.$style("-o-linear-gradient(" + (self.to) + ", " + (self.start) + " 0%, " + (self.end) + " 100%)"));
            block.$call(self.$style("-ms-linear-gradient(" + (self.to) + ", " + (self.start) + " 0%, " + (self.end) + " 100%)"));
            return block.$call(self.$style("linear-gradient(to " + (self.to) + ", " + (self.start) + " 0%, " + (self.end) + " 100%)"));
          });
          
          $def(self, '$horizontal?', function $Gradient_horizontal$ques$20() {
            var self = this, $ret_or_1 = nil;

            if ($truthy(($ret_or_1 = self.to['$==']("left")))) {
              return $ret_or_1
            } else {
              return self.to['$==']("right")
            }
          });
          
          $def(self, '$vertical?', function $Gradient_vertical$ques$21() {
            var self = this, $ret_or_1 = nil;

            if ($truthy(($ret_or_1 = self.to['$==']("top")))) {
              return $ret_or_1
            } else {
              return self.to['$==']("bottom")
            }
          });
          self.$private();
          
          $def(self, '$other', function $$other(side) {
            
            
            switch (side.valueOf()) {
              case "left":
                return "right"
              case "right":
                return "left"
              case "top":
                return "bottom"
              case "bottom":
                return "top"
              default:
                return nil
            }
          });
          return $def(self, '$style', function $$style($a) {
            var $post_args, args;

            
            $post_args = $slice(arguments);
            args = $post_args;
            if ($eqeq(args.$length(), 1)) {
              return $$('Style').$new(nil, args.$first())
            } else {
              return $send($$('Style'), 'new', $to_a(args))
            };
          }, -1);
        })($nesting[0], null, $nesting);
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/css/rule"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $def = Opal.def, $slice = Opal.slice, $send = Opal.send, $to_a = Opal.to_a, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('attr_reader,new,__send__,to_proc');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'CSS');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Rule');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.definition = nil;
        
        self.$attr_reader("selector", "media");
        
        $def(self, '$initialize', function $$initialize(selector, media) {
          var self = this;

          
          self.selector = selector;
          self.media = media;
          return (self.definition = $$('Definition').$new());
        });
        return $def(self, '$method_missing', function $$method_missing($a) {
          var block = $$method_missing.$$p || nil, $post_args, args, self = this;

          $$method_missing.$$p = null;
          
          ;
          $post_args = $slice(arguments);
          args = $post_args;
          return $send(self.definition, '__send__', $to_a(args), block.$to_proc());
        }, -1);
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/css/font"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $def = Opal.def, $slice = Opal.slice, $send = Opal.send, $to_a = Opal.to_a, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('attr_reader,new,font,__send__,to_proc');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'CSS');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Font');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.definition = nil;
        
        self.$attr_reader("name");
        
        $def(self, '$initialize', function $$initialize(name) {
          var self = this;

          
          self.name = name;
          self.definition = $$('Definition').$new();
          return self.$font((new Map([["family", name]])));
        });
        return $def(self, '$method_missing', function $$method_missing($a) {
          var block = $$method_missing.$$p || nil, $post_args, args, self = this;

          $$method_missing.$$p = null;
          
          ;
          $post_args = $slice(arguments);
          args = $post_args;
          return $send(self.definition, '__send__', $to_a(args), block.$to_proc());
        }, -1);
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/css/animation"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $def = Opal.def, $slice = Opal.slice, $send = Opal.send, $to_a = Opal.to_a, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('attr_reader,new,__send__,to_proc,<<,call,%,last');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'CSS');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Animation');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.steps = nil;
        
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Step');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto.definition = nil;
          
          self.$attr_reader("value");
          
          $def(self, '$initialize', function $$initialize(value) {
            var self = this;

            
            self.value = value;
            return (self.definition = $$('Definition').$new());
          });
          return $def(self, '$method_missing', function $$method_missing($a) {
            var block = $$method_missing.$$p || nil, $post_args, args, self = this;

            $$method_missing.$$p = null;
            
            ;
            $post_args = $slice(arguments);
            args = $post_args;
            return $send(self.definition, '__send__', $to_a(args), block.$to_proc());
          }, -1);
        })($nesting[0], $$('BasicObject'), $nesting);
        self.$attr_reader("name", "steps");
        
        $def(self, '$initialize', function $$initialize(name) {
          var self = this;

          
          self.name = name;
          return (self.steps = []);
        });
        
        $def(self, '$step', function $$step(value) {
          var block = $$step.$$p || nil, self = this;

          $$step.$$p = null;
          
          ;
          self.steps['$<<']($$('Step').$new(value));
          return block.$call();
        });
        
        $def(self, '$from', function $$from(value) {
          var block = $$from.$$p || nil, self = this;

          $$from.$$p = null;
          
          ;
          self.steps['$<<']($$('Step').$new((0)['$%']()));
          return block.$call();
        });
        
        $def(self, '$to', function $$to(value) {
          var block = $$to.$$p || nil, self = this;

          $$to.$$p = null;
          
          ;
          self.steps['$<<']($$('Step').$new((100)['$%']()));
          return block.$call();
        });
        return $def(self, '$method_missing', function $$method_missing($a) {
          var block = $$method_missing.$$p || nil, $post_args, args, self = this;

          $$method_missing.$$p = null;
          
          ;
          $post_args = $slice(arguments);
          args = $post_args;
          return $send(self.steps.$last(), '__send__', $to_a(args), block.$to_proc());
        }, -1);
      })($nesting[0], $$('BasicObject'), $nesting)
    })($nesting[0], $$('BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["paggio/css"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $range = Opal.range, $eqeq = Opal.eqeq, $defs = Opal.defs, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $Kernel = Opal.Kernel, $def = Opal.def, $not = Opal.not, $slice = Opal.slice, $to_a = Opal.to_a, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,each,start_with?,+,[],==,attr_reader,raise,build!,arity,!,instance_exec,to_proc,call,any?,include?,<<,new,selector,pop,method_missing,__send__,last');
  
  self.$require("paggio/css/unit");
  self.$require("paggio/css/color");
  self.$require("paggio/css/definition");
  self.$require("paggio/css/rule");
  self.$require("paggio/css/font");
  self.$require("paggio/css/animation");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'CSS');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.block = $proto.media = $proto.current = $proto.fonts = $proto.animations = nil;
      
      $defs(self, '$selector', function $$selector(list) {
        var result = nil;

        
        result = "";
        $send(list, 'each', [], function $$1(part){
          
          if (part == null) part = nil;
          if ($truthy(part['$start_with?']("&"))) {
            return (result = $rb_plus(result, part['$[]']($range(1, -1, false))))
          } else {
            return (result = $rb_plus(result, $rb_plus(" ", part)))
          };});
        if ($eqeq(result['$[]'](0), " ")) {
          return result['$[]']($range(1, -1, false))
        } else {
          return result
        };
      });
      self.$attr_reader("rules", "media", "fonts", "animations");
      
      $def(self, '$initialize', function $$initialize($kwargs) {
        var block = $$initialize.$$p || nil, defer, self = this;

        $$initialize.$$p = null;
        
        ;
        $kwargs = $ensure_kwargs($kwargs);
        
        defer = $hash_get($kwargs, "defer");if (defer == null) defer = false;
        if (!$truthy(block)) {
          $Kernel.$raise($$$('ArgumentError'), "no block given")
        };
        self.selector = [];
        self.current = [];
        self.rules = [];
        self.fonts = [];
        self.animations = [];
        self.block = block;
        if ($truthy(defer)) {
          return nil
        } else {
          return self['$build!']()
        };
      }, -1);
      
      $def(self, '$build!', function $CSS_build$excl$2($kwargs) {
        var force_call, self = this;

        
        $kwargs = $ensure_kwargs($kwargs);
        
        force_call = $hash_get($kwargs, "force_call");if (force_call == null) force_call = false;
        if (($not(force_call) && ($eqeq(self.block.$arity(), 0)))) {
          $send(self, 'instance_exec', [], self.block.$to_proc())
        } else {
          self.block.$call(self)
        };
        return (self.block = nil);
      }, -1);
      
      $def(self, '$rule', function $$rule($a) {
        var block = $$rule.$$p || nil, $post_args, names, self = this;

        $$rule.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        names = $post_args;
        if (!$truthy(block)) {
          return nil
        };
        if ($truthy($send(names, 'any?', [], function $$3(n){
          
          if (n == null) n = nil;
          return n['$include?'](",");}))) {
          $Kernel.$raise($$$('ArgumentError'), "selectors cannot contain commas")
        };
        return $send(names, 'each', [], function $$4(name){var self = $$4.$$s == null ? this : $$4.$$s;
          if (self.selector == null) self.selector = nil;
          if (self.current == null) self.current = nil;
          if (self.media == null) self.media = nil;
          if (self.rules == null) self.rules = nil;

          
          if (name == null) name = nil;
          self.selector['$<<'](name);
          self.current['$<<']($$('Rule').$new($$('CSS').$selector(self.selector), self.media));
          block.$call();
          self.selector.$pop();
          return self.rules['$<<'](self.current.$pop());}, {$$s: self});
      }, -1);
      
      $def(self, '$media', function $$media(query, $a) {
        var block = $$media.$$p || nil, $post_args, args, $b, self = this, old = nil;

        $$media.$$p = null;
        
        ;
        $post_args = $slice(arguments, 1);
        args = $post_args;
        if ($truthy(block)) {
          
          $b = [self.media, query], (old = $b[0]), (self.media = $b[1]), $b;
          block.$call();
          return (self.media = old);
        } else {
          return $send(self, 'method_missing', ["media", query].concat($to_a(args)))
        };
      }, -2);
      
      $def(self, '$font', function $$font(name, $a) {
        var block = $$font.$$p || nil, $post_args, args, self = this;

        $$font.$$p = null;
        
        ;
        $post_args = $slice(arguments, 1);
        args = $post_args;
        if ($truthy(block)) {
          
          self.current['$<<']($$('Font').$new(name));
          block.$call();
          return self.fonts['$<<'](self.current.$pop());
        } else {
          return $send(self, 'method_missing', ["font", name].concat($to_a(args)))
        };
      }, -2);
      
      $def(self, '$animation', function $$animation(name, $a) {
        var block = $$animation.$$p || nil, $post_args, args, self = this;

        $$animation.$$p = null;
        
        ;
        $post_args = $slice(arguments, 1);
        args = $post_args;
        if ($truthy(block)) {
          
          self.current['$<<']($$('Animation').$new(name));
          block.$call();
          return self.animations['$<<'](self.current.$pop());
        } else {
          return $send(self, 'method_missing', ["animation", name].concat($to_a(args)))
        };
      }, -2);
      return $def(self, '$method_missing', function $$method_missing($a) {
        var block = $$method_missing.$$p || nil, $post_args, args, self = this;

        $$method_missing.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        args = $post_args;
        return $send(self.current.$last(), '__send__', $to_a(args), block.$to_proc());
      }, -1);
    })($nesting[0], $$('BasicObject'), $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.current = $proto.roots = nil;
      return $def(self, '$style', function $$style() {
        var block = $$style.$$p || nil, self = this, $ret_or_1 = nil;

        $$style.$$p = null;
        
        ;
        return ($truthy(($ret_or_1 = self.current)) ? ($ret_or_1) : (self.roots))['$<<']($send($$('CSS'), 'new', [], block.$to_proc()));
      })
    })($nesting[0], $$('BasicObject'), $nesting);
  })($nesting[0], null, $nesting);
};

Opal.modules["stringio"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $const_set = Opal.const_set, $defs = Opal.defs, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $truthy = Opal.truthy, $rb_ge = Opal.rb_ge, $rb_gt = Opal.rb_gt, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $return_ivar = Opal.return_ivar, $eqeq = Opal.eqeq, $alias = Opal.alias, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('new,call,close,attr_accessor,check_readable,==,length,===,>=,raise,>,+,-,seek,check_writable,String,[],eof?,write,read,tell');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StringIO');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.position = $proto.string = nil;
    
    $const_set($nesting[0], 'VERSION', "0");
    $defs(self, '$open', function $$open(string, mode) {
      var block = $$open.$$p || nil, self = this, io = nil, res = nil;

      $$open.$$p = null;
      
      ;
      if (string == null) string = "";
      if (mode == null) mode = nil;
      io = self.$new(string, mode);
      res = block.$call(io);
      io.$close();
      return res;
    }, -1);
    self.$attr_accessor("string");
    
    $def(self, '$initialize', function $$initialize(string, mode) {
      var $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      if (string == null) string = "";
      if (mode == null) mode = "rw";
      self.string = string;
      self.position = 0;
      return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [nil, mode], null);
    }, -1);
    
    $def(self, '$eof?', function $StringIO_eof$ques$1() {
      var self = this;

      
      self.$check_readable();
      return self.position['$=='](self.string.$length());
    });
    
    $def(self, '$seek', function $$seek(pos, whence) {
      var self = this, $ret_or_1 = nil;

      
      if (whence == null) whence = $$$($$('IO'), 'SEEK_SET');
      self.read_buffer = "";
      if ($eqeqeq($$$($$('IO'), 'SEEK_SET'), ($ret_or_1 = whence))) {
        
        if (!$truthy($rb_ge(pos, 0))) {
          self.$raise($$$($$('Errno'), 'EINVAL'))
        };
        self.position = pos;
      } else if ($eqeqeq($$$($$('IO'), 'SEEK_CUR'), $ret_or_1)) {
        if ($truthy($rb_gt($rb_plus(self.position, pos), self.string.$length()))) {
          self.position = self.string.$length()
        } else {
          self.position = $rb_plus(self.position, pos)
        }
      } else if ($eqeqeq($$$($$('IO'), 'SEEK_END'), $ret_or_1)) {
        if ($truthy($rb_gt(pos, self.string.$length()))) {
          self.position = 0
        } else {
          self.position = $rb_minus(self.position, pos)
        }
      } else {
        nil
      };
      return 0;
    }, -2);
    
    $def(self, '$tell', $return_ivar("position"));
    
    $def(self, '$rewind', function $$rewind() {
      var self = this;

      return self.$seek(0)
    });
    
    $def(self, '$write', function $$write(string) {
      var self = this, before = nil, after = nil;

      
      self.$check_writable();
      self.read_buffer = "";
      string = self.$String(string);
      if ($eqeq(self.string.$length(), self.position)) {
        
        self.string = $rb_plus(self.string, string);
        return (self.position = $rb_plus(self.position, string.$length()));
      } else {
        
        before = self.string['$[]'](Opal.Range.$new(0, $rb_minus(self.position, 1), false));
        after = self.string['$[]'](Opal.Range.$new($rb_plus(self.position, string.$length()), -1, false));
        self.string = $rb_plus($rb_plus(before, string), after);
        return (self.position = $rb_plus(self.position, string.$length()));
      };
    });
    
    $def(self, '$read', function $$read(length, outbuf) {
      var self = this, string = nil, str = nil;

      
      if (length == null) length = nil;
      if (outbuf == null) outbuf = nil;
      self.$check_readable();
      if ($truthy(self['$eof?']())) {
        return nil
      };
      string = ($truthy(length) ? (((str = self.string['$[]'](self.position, length)), (self.position = $rb_plus(self.position, length)), ($truthy($rb_gt(self.position, self.string.$length())) ? ((self.position = self.string.$length())) : nil), str)) : (((str = self.string['$[]'](Opal.Range.$new(self.position, -1, false))), (self.position = self.string.$length()), str)));
      if ($truthy(outbuf)) {
        return outbuf.$write(string)
      } else {
        return string
      };
    }, -1);
    
    $def(self, '$sysread', function $$sysread(length) {
      var self = this;

      
      self.$check_readable();
      return self.$read(length);
    });
    $alias(self, "eof", "eof?");
    $alias(self, "pos", "tell");
    $alias(self, "pos=", "seek");
    return $alias(self, "readpartial", "read");
  })($nesting[0], $$('IO'), $nesting)
};

Opal.modules["paggio/formatter"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $defs = Opal.defs, $send = Opal.send, $const_set = Opal.const_set, $eqeqeq = Opal.eqeqeq, $def = Opal.def, $thrower = Opal.thrower, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $rb_times = Opal.rb_times, $to_ary = Opal.to_ary, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,[]=,to_h,[],dup,deep_merge!,call,replace,===,new,merge,each,string,indent?,+,-,lines,puts,*,chomp,print,gsub,to_s,for,version,indent,format,instance_eval,empty?,map,escape,<<,join,include?,downcase,name,value,important,fonts,animations,steps,reverse,rules,media,selector,deindent');
  
  self.$require("stringio");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Formatter');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.options = $proto.io = nil;
      
      $defs(self, '$to_h', function $$to_h() {
        var self = this, $ret_or_1 = nil;
        if (self.formatters == null) self.formatters = nil;

        return (self.formatters = ($truthy(($ret_or_1 = self.formatters)) ? ($ret_or_1) : ((new Map()))))
      });
      $defs(self, '$for', function $Formatter_for$1(klass) {
        var block = $Formatter_for$1.$$p || nil, $a, self = this;

        $Formatter_for$1.$$p = null;
        
        ;
        if ($truthy(block)) {
          return ($a = [klass, block], $send(self.$to_h(), '[]=', $a), $a[$a.length - 1])
        } else {
          return self.$to_h()['$[]'](klass)
        };
      });
      $defs(self, '$options', function $$options(options) {
        var block = $$options.$$p || nil, old = nil, result = nil;

        $$options.$$p = null;
        
        ;
        old = $$('OPTIONS').$dup();
        $$('Utils')['$deep_merge!']($$('OPTIONS'), options);
        result = block.$call();
        $$('OPTIONS').$replace(old);
        return result;
      });
      $const_set($nesting[0], 'OPTIONS', (new Map([["indent", (new Map([["level", 0], ["with", "\t"]]))]])));
      
      $def(self, '$initialize', function $$initialize(io, options) {
        var self = this, $ret_or_1 = nil;

        
        if (io == null) io = nil;
        if (options == null) options = (new Map());
        if ($eqeqeq($$('Hash'), io)) {
          
          self.io = $$('StringIO').$new();
          self.options = io;
        } else {
          
          self.io = ($truthy(($ret_or_1 = io)) ? ($ret_or_1) : ($$('StringIO').$new()));
          self.options = options;
        };
        return (self.options = $$('OPTIONS').$merge(self.options));
      }, -1);
      
      $def(self, '$format', function $$format(item) {
        var self = this;

        
        (function(){try { var $t_break = $thrower('break'); return $send($$('Formatter').$to_h(), 'each', [], function $$2(klass, block){var self = $$2.$$s == null ? this : $$2.$$s;

          
          if (klass == null) klass = nil;
          if (block == null) block = nil;
          if ($eqeqeq(klass, item)) {
            
            block.$call(self, item);
            $t_break.$throw(nil, $$2.$$is_lambda);
          } else {
            return nil
          };}, {$$s: self})} catch($e) {
          if ($e === $t_break) return $e.$v;
          throw $e;
        } finally {$t_break.is_orphan = true;}})();
        return self;
      });
      
      $def(self, '$to_s', function $$to_s() {
        var self = this;

        return self.io.$string()
      });
      
      $def(self, '$indent?', function $Formatter_indent$ques$3() {
        var block = $Formatter_indent$ques$3.$$p || nil, self = this;

        $Formatter_indent$ques$3.$$p = null;
        
        ;
        try {
          return self.options['$[]']("indent")['$[]']("level")
        } catch ($err) {
          if (Opal.rescue($err, [$$('StandardError')])) {
            try {
              return false
            } finally { Opal.pop_exception($err); }
          } else { throw $err; }
        };
      });
      
      $def(self, '$indent', function $$indent() {
        var block = $$indent.$$p || nil, $a, self = this, $binary_op_recvr_tmp_1 = nil, $binary_op_recvr_tmp_2 = nil, $binary_op_recvr_tmp_3 = nil;

        $$indent.$$p = null;
        
        ;
        if ($truthy(self['$indent?']())) {
          if ($truthy(block)) {
            
            
            $binary_op_recvr_tmp_1 = self.options['$[]']("indent");
            $binary_op_recvr_tmp_1['$[]=']("level", $rb_plus($binary_op_recvr_tmp_1['$[]']("level"), 1));;
            block.$call();
            
            $binary_op_recvr_tmp_2 = self.options['$[]']("indent");
            return ($a = ["level", $rb_minus($binary_op_recvr_tmp_2['$[]']("level"), 1)], $send($binary_op_recvr_tmp_2, '[]=', $a), $a[$a.length - 1]);;
          } else {
            
            $binary_op_recvr_tmp_3 = self.options['$[]']("indent");
            return ($a = ["level", $rb_plus($binary_op_recvr_tmp_3['$[]']("level"), 1)], $send($binary_op_recvr_tmp_3, '[]=', $a), $a[$a.length - 1]);
          }
        } else if ($truthy(block)) {
          return block.$call()
        } else {
          return nil
        };
      });
      
      $def(self, '$deindent', function $$deindent() {
        var $a, self = this, $binary_op_recvr_tmp_4 = nil;

        if ($truthy(self['$indent?']())) {
          
          $binary_op_recvr_tmp_4 = self.options['$[]']("indent");
          return ($a = ["level", $rb_minus($binary_op_recvr_tmp_4['$[]']("level"), 1)], $send($binary_op_recvr_tmp_4, '[]=', $a), $a[$a.length - 1]);
        } else {
          return nil
        }
      });
      
      $def(self, '$print', function $$print(text) {
        var self = this, level = nil;

        if ($truthy((level = self['$indent?']()))) {
          return $send(text.$lines(), 'each', [], function $$4(line){var self = $$4.$$s == null ? this : $$4.$$s;
            if (self.io == null) self.io = nil;
            if (self.options == null) self.options = nil;

            
            if (line == null) line = nil;
            return self.io.$puts("" + ($rb_times(self.options['$[]']("indent")['$[]']("with"), level)) + (line.$chomp()));}, {$$s: self})
        } else {
          return self.io.$print(text)
        }
      });
      return $def(self, '$escape', function $$escape(string) {
        
        return string.$to_s().$gsub(/["><']|&(?!([a-zA-Z]+|(#\d+));)/, (new Map([["&", "&amp;"], [">", "&gt;"], ["<", "&lt;"], ["\"", "&quot;"], ["'", "&#39;"]])))
      });
    })($nesting[0], null, $nesting);
    $send($$('Formatter'), 'for', [$$('HTML')], function $Paggio$5(f, item){
      
      if (f == null) f = nil;
      if (item == null) item = nil;
      
      switch (item.$version().valueOf()) {
        case 5:
          f.$print("<!DOCTYPE html>")
          break;
        default:
          nil
      };
      f.$print("<html>");
      $send(f, 'indent', [], function $$6(){
        return $send(item, 'each', [], function $$7(root){
          
          if (root == null) root = nil;
          return f.$format(root);})});
      return f.$print("</html>");});
    $send($$('Formatter'), 'for', [$$$($$('HTML'), 'Element')], function $Paggio$8(f, item){var $a, $b, self = $Paggio$8.$$s == null ? this : $Paggio$8.$$s, name = nil, attributes = nil, class_names = nil, attrs = nil;

      
      if (f == null) f = nil;
      if (item == null) item = nil;
      $b = $send(item, 'instance_eval', [], function $$9(){var self = $$9.$$s == null ? this : $$9.$$s;
        if (self.name == null) self.name = nil;
        if (self.attributes == null) self.attributes = nil;
        if (self.class_names == null) self.class_names = nil;

        return [self.name, self.attributes, self.class_names]}, {$$s: self}), $a = $to_ary($b), (name = ($a[0] == null ? nil : $a[0])), (attributes = ($a[1] == null ? nil : $a[1])), (class_names = ($a[2] == null ? nil : $a[2])), $b;
      if (($truthy(attributes['$empty?']()) && ($truthy(class_names['$empty?']())))) {
        f.$print("<" + (name) + ">")
      } else {
        
        attrs = $send(attributes, 'map', [], function $$10(key, value){
          
          if (key == null) key = nil;
          if (value == null) value = nil;
          return "" + (f.$escape(key)) + "=\"" + (f.$escape(value)) + "\"";});
        if (!$truthy(class_names['$empty?']())) {
          attrs['$<<']("class=\"" + (f.$escape(class_names.$join(" "))) + "\"")
        };
        f.$print("<" + (name) + " " + (attrs.$join(" ")) + ">");
      };
      if ($truthy(["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "menuitem", "meta", "param", "source", "track", "wbr"]['$include?'](name.$to_s().$downcase()))) {
        return nil
      };
      $send(f, 'indent', [], function $$11(){var self = $$11.$$s == null ? this : $$11.$$s, inner = nil;

        if ($truthy((inner = $send(item, 'instance_eval', [], function $$12(){var self = $$12.$$s == null ? this : $$12.$$s;
          if (self.inner_html == null) self.inner_html = nil;

          return self.inner_html}, {$$s: self})))) {
          return f.$print(inner)
        } else {
          return $send(item, 'each', [], function $$13(child){var $ret_or_1 = nil;

            
            if (child == null) child = nil;
            if ($eqeqeq($$('String'), ($ret_or_1 = child))) {
              return f.$print(f.$escape(child))
            } else if ($eqeqeq($$('CSS'), $ret_or_1)) {
              
              f.$print("<style>");
              $send(f, 'indent', [], function $$14(){
                return f.$format(child)});
              return f.$print("</style>");
            } else {
              return f.$format(child)
            };})
        }}, {$$s: self});
      return f.$print("</" + (name) + ">");}, {$$s: self});
    $send($$('Formatter'), 'for', [$$$($$$($$('CSS'), 'Definition'), 'Style')], function $Paggio$15(f, style){
      
      if (f == null) f = nil;
      if (style == null) style = nil;
      return f.$print("" + (style.$name()) + ": " + (style.$value()) + (($truthy(style.$important()) ? (" !important") : nil)) + ";");});
    return $send($$('Formatter'), 'for', [$$('CSS')], function $Paggio$16(f, item){
      
      if (f == null) f = nil;
      if (item == null) item = nil;
      $send(item.$fonts(), 'each', [], function $$17(font){
        
        if (font == null) font = nil;
        f.$print("@font-face {");
        $send(f, 'indent', [], function $$18(){
          return $send(font, 'each', [], function $$19(style){
            
            if (style == null) style = nil;
            return f.$format(style);})});
        return f.$print("}");});
      $send(item.$animations(), 'each', [], function $$20(animation){
        
        if (animation == null) animation = nil;
        return $send(["", "-webkit-", "-moz-", "-o-"], 'each', [], function $$21(platform){
          
          if (platform == null) platform = nil;
          f.$print("@" + (platform) + "keyframes " + (animation.$name()) + " {");
          $send(animation.$steps(), 'each', [], function $$22(step){
            
            if (step == null) step = nil;
            f.$print("" + (step.$value()) + " {");
            $send(step, 'each', [], function $$23(style){
              
              if (style == null) style = nil;
              return f.$format(style);});
            return f.$print("}");});
          return f.$print("}");});});
      return $send(item.$rules().$reverse(), 'each', [], function $$24(rule){var m = nil;

        
        if (rule == null) rule = nil;
        if ($truthy(rule['$empty?']())) {
          return nil
        };
        if ($truthy((m = rule.$media()))) {
          
          f.$print("@media " + (m) + " {");
          f.$indent();
        };
        f.$print("" + (rule.$selector()) + " {");
        $send(f, 'indent', [], function $$25(){
          return $send(rule, 'each', [], function $$26(style){
            
            if (style == null) style = nil;
            return f.$format(style);})});
        f.$print("}");
        if ($truthy(rule.$media())) {
          
          f.$print("}");
          return f.$deindent();
        } else {
          return nil
        };});});
  })($nesting[0], null, $nesting);
};

Opal.modules["paggio"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $send = Opal.send, $defs = Opal.defs, $slice = Opal.slice, $to_a = Opal.to_a, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,options,to_proc,to_s,format,new,tap,each');
  
  self.$require("paggio/utils");
  self.$require("paggio/html");
  self.$require("paggio/css");
  self.$require("paggio/formatter");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $defs(self, '$options', function $$options(options) {
      var block = $$options.$$p || nil;

      $$options.$$p = null;
      
      ;
      return $send($$('Formatter'), 'options', [options], block.$to_proc());
    });
    $defs(self, '$indent', function $$indent(options) {
      var block = $$indent.$$p || nil, self = this;

      $$indent.$$p = null;
      
      ;
      return $send(self, 'options', [(new Map([["indent", options]]))], block.$to_proc());
    });
    $defs(self, '$css', function $$css($a) {
      var block = $$css.$$p || nil, $post_args, args;

      $$css.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      return $$('Formatter').$new().$format($send($$('CSS'), 'new', $to_a(args), block.$to_proc())).$to_s();
    }, -1);
    $defs(self, '$html', function $$html($a) {
      var block = $$html.$$p || nil, $post_args, args;

      $$html.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      return $$('Formatter').$new().$format($send($$('HTML'), 'new', $to_a(args), block.$to_proc())).$to_s();
    }, -1);
    return $defs(self, '$html!', function $Paggio_html$excl$1() {
      var block = $Paggio_html$excl$1.$$p || nil;

      $Paggio_html$excl$1.$$p = null;
      
      ;
      return $send($$('Formatter').$new(), 'tap', [], function $$2(f){
        
        if (f == null) f = nil;
        return $send($send($$('HTML'), 'new', [], block.$to_proc()), 'each', [], function $$3(root){
          
          if (root == null) root = nil;
          return f.$format(root);});}).$to_s();
    });
  })($nesting[0], null, $nesting);
};

Opal.modules["browser/version"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $const_set = Opal.const_set, $nesting = [], nil = Opal.nil;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return $const_set($nesting[0], 'VERSION', "0.3.3")
  })($nesting[0], $nesting)
};

Opal.modules["browser/utils"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $const_set = Opal.const_set, $truthy = Opal.truthy, $defs = Opal.defs, $def = Opal.def, $not = Opal.not, $send2 = Opal.send2, $find_super = Opal.find_super, $klass = Opal.klass, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('new,include,extend,!,private,restricted?,allocate,instance_variable_set,native?,raise,warn,encode_uri,to_s,encode,decode,decode_uri,parse_query,build_query');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $a, $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $const_set($nesting[0], 'Promise', ($truthy((($a = $$('PromiseV2', 'skip_raise')) ? 'constant' : nil)) ? ($$('PromiseV2')) : ($$$('Promise'))));
    $const_set($nesting[0], 'Size', $$('Struct').$new("width", "height"));
    $const_set($nesting[0], 'Position', $$('Struct').$new("x", "y"));
    (function($base, $parent_nesting) {
      var self = $module($base, 'NativeCachedWrapper');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $defs(self, '$included', function $$included(klass) {
        
        
        klass.$include($$$($$('Native'), 'Wrapper'));
        return klass.$extend($$('NativeCachedWrapperClassMethods'));
      });
      
      $def(self, '$restricted?', function $NativeCachedWrapper_restricted$ques$1() {
        var self = this;
        if (self.restricted == null) self.restricted = nil;

        return self.restricted['$!']()['$!']()
      });
      return $def(self, '$set_native_reference', function $$set_native_reference(native$) {
        var self = this;

        
        native$.$$opal_native_cached = self;
        return (self["native"] = native$);
      });
    })($nesting[0], $nesting);
    return (function($base, $parent_nesting) {
      var self = $module($base, 'NativeCachedWrapperClassMethods');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      self.$private($def(self, '$restricted?', function $NativeCachedWrapperClassMethods_restricted$ques$2(native$) {
        
        
        try {
          typeof(native$.$$try_restricted_access);
        } catch (e) {
          if (e.name == 'SecurityError') return true;
        }
        return false;
      
      }));
      return $def(self, '$new', function $NativeCachedWrapperClassMethods_new$3(native$) {
        var $yield = $NativeCachedWrapperClassMethods_new$3.$$p || nil, self = this, obj = nil;

        $NativeCachedWrapperClassMethods_new$3.$$p = null;
        
        if ($truthy(self['$restricted?'](native$))) {
          
          obj = self.$allocate();
          obj.$instance_variable_set("@native", native$);
          obj.$instance_variable_set("@restricted", true);
          return obj;
        };
        if ($not(self['$native?'](native$))) {
          self.$raise($$('ArgumentError'))
        };
        if ($truthy((typeof(native$.$$opal_native_cached) !== "undefined"))) {
          return native$.$$opal_native_cached
        } else {
          return native$.$$opal_native_cached = $send2(self, $find_super(self, 'new', $NativeCachedWrapperClassMethods_new$3, false, true), 'new', [native$], null)
        };
      });
    })($nesting[0], $nesting);
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Object');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$encode_uri', function $$encode_uri() {
      var self = this;

      
      self.$warn("opal-browser: Object#encode_uri is deprecated. Please use FormData.encode_uri");
      return $$('FormData').$encode_uri(self.$to_s());
    });
    return $def(self, '$encode_uri_component', function $$encode_uri_component() {
      var self = this;

      
      self.$warn("opal-browser: Object#encode_uri_component is deprecated. Please use FormData.encode");
      return $$('FormData').$encode(self.$to_s());
    });
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$encode_uri_component', function $$encode_uri_component() {
      var self = this;

      
      self.$warn("opal-browser: String#encode_uri_component is deprecated. Please use FormData.encode");
      return $$('FormData').$encode(self);
    });
    
    $def(self, '$encode_uri', function $$encode_uri() {
      var self = this;

      
      self.$warn("opal-browser: String#encode_uri is deprecated. Please use FormData.encode_uri");
      return $$('FormData').$encode_uri(self);
    });
    
    $def(self, '$decode_uri_component', function $$decode_uri_component() {
      var self = this;

      
      self.$warn("opal-browser: String#decode_uri_component is deprecated. Please use FormData.decode");
      return $$('FormData').$decode(self);
    });
    return $def(self, '$decode_uri', function $$decode_uri() {
      var self = this;

      
      self.$warn("opal-browser: String#decode_uri is deprecated. Please use FormData.decode_uri");
      return $$('FormData').$decode_uri(self);
    });
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Hash');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $defs(self, '$decode_uri', function $$decode_uri(string) {
      var self = this;

      
      self.$warn("opal-browser: Hash.decode_uri is deprecated. Please use FormData.parse_query");
      return $$('FormData').$parse_query(string);
    });
    return $def(self, '$encode_uri', function $$encode_uri() {
      var self = this;

      
      self.$warn("opal-browser: Hash#encode_uri is deprecated. Please use FormData.build_query");
      return $$('FormData').$build_query(self);
    });
  })($nesting[0], null, $nesting);
};

Opal.modules["browser/form_data"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $send = Opal.send, $neqeq = Opal.neqeq, $rb_plus = Opal.rb_plus, $truthy = Opal.truthy, $not = Opal.not, $defs = Opal.defs, $to_ary = Opal.to_ary, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,===,each,!=,+,flatten,first,split,scan,proc,call,<<,last,[],[]=,!,any?,include?,class,join,map,encode,to_s,create,unflatten,to_proc,method,new,extend,build_form_data,to_n,convert,from_native,set,to_a,to_h');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'FormData');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = nil;
      
      self.$include($$('NativeCachedWrapper'));
      (function($base, $parent_nesting) {
        var self = $module($base, 'Converter');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        
        $def(self, '$encode', function $$encode(string) {
          
          return encodeURIComponent(string)
        });
        
        $def(self, '$decode', function $$decode(string) {
          
          return decodeURIComponent(string)
        });
        
        $def(self, '$encode_uri', function $$encode_uri(string) {
          
          return encodeURI(string)
        });
        
        $def(self, '$decode_uri', function $$decode_uri(string) {
          
          return decodeURI(string)
        });
        
        $def(self, '$flatten', function $$flatten(value, key) {
          var self = this, $ret_or_1 = nil, out = nil;

          
          if (key == null) key = "";
          if ($eqeqeq($$('Hash'), ($ret_or_1 = value))) {
            
            out = [];
            $send(value, 'each', [], function $$1(k, v){var self = $$1.$$s == null ? this : $$1.$$s;

              
              if (k == null) k = nil;
              if (v == null) v = nil;
              if ($neqeq(key, "")) {
                k = "" + (key) + "[" + (k) + "]"
              };
              return (out = $rb_plus(out, self.$flatten(v, k)));}, {$$s: self});
            return out;
          } else if ($eqeqeq($$('Array'), $ret_or_1)) {
            
            out = [];
            $send(value, 'each', [], function $$2(v){var self = $$2.$$s == null ? this : $$2.$$s, k = nil;

              
              if (v == null) v = nil;
              k = "" + (key) + "[]";
              return (out = $rb_plus(out, self.$flatten(v, k)));}, {$$s: self});
            return out;
          } else {
            return [[key, value]]
          };
        }, -2);
        
        $def(self, '$unflatten', function $$unflatten(array) {
          var self = this, out = nil;

          
          out = (new Map());
          $send(array, 'each', [], function $$3(k, v){var self = $$3.$$s == null ? this : $$3.$$s, path = nil, c = nil, set = nil;

            
            if (k == null) k = nil;
            if (v == null) v = nil;
            path = $rb_plus([k.$split("[").$first()], k.$scan(/\[(.*?)\]/).$flatten());
            c = out;
            set = $send(self, 'proc', [], function $$4(v, weak){
              
              if (v == null) v = nil;
              if (weak == null) weak = nil;
              return nil;});
            $send(path, 'each', [], function $$5(i){var self = $$5.$$s == null ? this : $$5.$$s;

              
              if (i == null) i = nil;
              
              switch (i.valueOf()) {
                case "":
                  
                  set.$call([], true);
                  return (set = $send(self, 'proc', [], function $$6(v, weak){
                    
                    if (v == null) v = nil;
                    if (weak == null) weak = nil;
                    c['$<<'](v);
                    return (c = c.$last());}));
                default:
                  
                  set.$call((new Map()), true);
                  return (set = $send(self, 'proc', [], function $$7(v, weak){var $ret_or_2 = nil;

                    
                    if (v == null) v = nil;
                    if (weak == null) weak = nil;
                    if ($truthy(($ret_or_2 = c['$[]'](i)))) {
                      $ret_or_2
                    } else {
                      c['$[]='](i, v)
                    };
                    if ($not(weak)) {
                      c['$[]='](i, v)
                    };
                    return (c = c['$[]'](i));}));
              };}, {$$s: self});
            return set.$call(v, false);}, {$$s: self});
          return out;
        });
        
        $def(self, '$contain_files?', function $Converter_contain_files$ques$8(hash) {
          var self = this;

          return $send(self.$flatten(hash), 'any?', [], function $$9(k, v){
            
            if (k == null) k = nil;
            if (v == null) v = nil;
            return [$$('File'), $$('Blob')]['$include?'](v.$class());})
        });
        
        $def(self, '$build_query', function $$build_query(hash, sep) {
          var self = this;

          
          if (sep == null) sep = "&";
          return $send(self.$flatten(hash), 'map', [], function $$10(k, v){var self = $$10.$$s == null ? this : $$10.$$s;

            
            if (k == null) k = nil;
            if (v == null) v = nil;
            return $rb_plus($rb_plus(self.$encode(k), "="), self.$encode(v.$to_s()));}, {$$s: self}).$join(sep);
        }, -2);
        
        $def(self, '$build_form_data', function $$build_form_data(hash) {
          var self = this, fd = nil;

          
          fd = $$('FormData').$create();
          $send(self.$flatten(hash), 'each', [], function $$11(k, v){
            
            if (k == null) k = nil;
            if (v == null) v = nil;
            return fd['$<<']([k, v]);});
          return fd;
        });
        
        $def(self, '$parse_query', function $$parse_query(string, sep) {
          var self = this;

          
          if (sep == null) sep = "&";
          return self.$unflatten($send(string.$split(sep), 'map', [], function $$12(s){var self = $$12.$$s == null ? this : $$12.$$s;

            
            if (s == null) s = nil;
            return $send(s.$split("="), 'map', [], self.$method("decode").$to_proc());}, {$$s: self}));
        }, -2);
        return $def(self, '$from_native', function $$from_native(n) {
          
          
          
        var c = n.constructor;
        if (c === File) {
          (n = $$('File').$new(n))
        }
        else if (c === Blob) {
          (n = $$('Blob').$new(n))
        }
      ;
          return n;
        });
      })($nesting[0], $nesting);
      self.$extend($$('Converter'));
      self.$include($$('Enumerable'));
      $defs(self, '$create', function $$create(hash) {
        var self = this;

        
        if (hash == null) hash = nil;
        if ($eqeqeq($$('Hash'), hash)) {
          return $$('FormData').$build_form_data(hash)
        } else if ($eqeqeq($$$($$$($$('DOM'), 'Element'), 'Form'), hash)) {
          return self.$new(new FormData(hash.$to_n()))
        } else {
          return self.$new(new FormData())
        };
      }, -1);
      
      $def(self, '$<<', function $FormData_$lt$lt$13(tuple) {
        var $a, $b, self = this, key = nil, value = nil, filename = nil;

        
        $b = tuple, $a = $to_ary($b), (key = ($a[0] == null ? nil : $a[0])), (value = ($a[1] == null ? nil : $a[1])), (filename = ($a[2] == null ? nil : $a[2])), $b;
        if ($truthy(filename)) {
          return self["native"].append(key, $$('Native').$convert(value), filename)
        } else {
          return self["native"].append(key, $$('Native').$convert(value))
        };
      });
      
      $def(self, '$[]', function $FormData_$$$14(key) {
        var self = this;

        return $$('FormData').$from_native(self["native"].get(key))
      });
      
      $def(self, '$set', function $$set(key, value, filename) {
        var self = this;

        
        if (filename == null) filename = nil;
        if ($truthy(filename)) {
          return self["native"].set(key, $$('Native').$convert(value), filename)
        } else {
          return self["native"].set(key, $$('Native').$convert(value))
        };
      }, -3);
      $alias(self, "[]=", "set");
      
      $def(self, '$to_h', function $$to_h() {
        var $a, self = this, hash = nil;

        
        hash = (new Map());
        
      var pair, v, e = self["native"].entries();
      while (true) {
        v = e.next();
        if (v.done) break;
        pair = v.value;
        ($a = [pair[0], $$('FormData').$from_native(pair[1])], $send(hash, '[]=', $a), $a[$a.length - 1])
      }
    ;
        return hash;
      });
      
      $def(self, '$to_a', function $$to_a() {
        var self = this;

        return self.$to_h().$to_a()
      });
      
      $def(self, '$each', function $$each() {
        var block = $$each.$$p || nil, self = this;

        $$each.$$p = null;
        
        ;
        return $send(self.$to_h(), 'each', [], block.$to_proc());
      });
      
      $def(self, '$include?', function $FormData_include$ques$15(key) {
        var self = this;

        return self["native"].has(key)
      });
      return $def(self, '$delete', function $FormData_delete$16(key) {
        var self = this;

        return self["native"].delete(key)
      });
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/support"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $const_set = Opal.const_set, $module = Opal.module, $truthy = Opal.truthy, $eqeqeq = Opal.eqeqeq, $not = Opal.not, $gvars = Opal.gvars, $defs = Opal.defs, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('downcase,===,!,supports?');
  
  $const_set($nesting[0], 'BROWSER_ENGINE', (function() { try {
    return (/MSIE|WebKit|Presto|Gecko/.exec(navigator.userAgent)[0]).$downcase()
  } catch ($err) {
    if (Opal.rescue($err, [$$('StandardError')])) {
      try {
        return "unknown"
      } finally { Opal.pop_exception($err); }
    } else { throw $err; }
  }})());
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.support = {};
    $defs(self, '$supports?', function $Browser_supports$ques$1(feature) {
      var $a, self = this, support = nil, $ret_or_1 = nil;
      if (self.support == null) self.support = nil;

      
      if ($truthy((typeof(self.support[feature]) !== "undefined"))) {
        return self.support[feature]
      };
      support = (function() {if ($eqeqeq("MutationObserver", ($ret_or_1 = feature))) {
        return (typeof(window.MutationObserver) !== "undefined")
      } else if ($eqeqeq("WebSocket", $ret_or_1)) {
        return (typeof(window.WebSocket) !== "undefined")
      } else if ($eqeqeq("EventSource", $ret_or_1)) {
        return (typeof(window.EventSource) !== "undefined")
      } else if ($eqeqeq("XHR", $ret_or_1)) {
        return (typeof(window.XMLHttpRequest) !== "undefined")
      } else if ($eqeqeq("ActiveX", $ret_or_1)) {
        return (typeof(window.ActiveXObject) !== "undefined")
      } else if ($eqeqeq("WebSQL", $ret_or_1)) {
        return (typeof(window.openDatabase) !== "undefined")
      } else if ($eqeqeq("Query.css", $ret_or_1)) {
        return (typeof(document.querySelectorAll) !== "undefined")
      } else if ($eqeqeq("Query.xpath", $ret_or_1)) {
        return (typeof(document.evaluate) !== "undefined")
      } else if ($eqeqeq("Storage.local", $ret_or_1)) {
        return (typeof(window.localStorage) !== "undefined")
      } else if ($eqeqeq("Storage.global", $ret_or_1)) {
        return (typeof(window.globalStorage) !== "undefined")
      } else if ($eqeqeq("Storage.session", $ret_or_1)) {
        return (typeof(window.sessionStorage) !== "undefined")
      } else if ($eqeqeq("Immediate", $ret_or_1)) {
        return (typeof(window.setImmediate) !== "undefined")
      } else if ($eqeqeq("Immediate (Internet Explorer)", $ret_or_1)) {
        return (typeof(window.msSetImmediate) !== "undefined")
      } else if ($eqeqeq("Immediate (Firefox)", $ret_or_1)) {
        return (typeof(window.mozSetImmediate) !== "undefined")
      } else if ($eqeqeq("Immediate (Opera)", $ret_or_1)) {
        return (typeof(window.oSetImmediate) !== "undefined")
      } else if (($eqeqeq("Immediate (Chrome)", $ret_or_1) || ($eqeqeq("setImmediate (Safari)", $ret_or_1)))) {
        return (typeof(window.webkitSetImmediate) !== "undefined")
      } else if ($eqeqeq("CSS.computed", $ret_or_1)) {
        return (typeof(window.getComputedStyle) !== "undefined")
      } else if ($eqeqeq("CSS.current", $ret_or_1)) {
        return (typeof(document.documentElement.currentStyle) !== "undefined")
      } else if ($eqeqeq("Window.send", $ret_or_1)) {
        return (typeof(window.postMessage) !== "undefined")
      } else if ($eqeqeq("Window.send (Asynchronous)", $ret_or_1)) {
        if (($truthy((typeof(window.postMessage) !== "undefined")) && ($not((typeof(window.importScripts) !== "undefined"))))) {
          
            var ok  = true,
                old = window.onmessage;

            window.onmessage = function() { ok = false; };
            window.postMessage("", "*")
            window.onmessage = old;

            return ok;
          
        } else {
          return nil
        }
      } else if ($eqeqeq("Window.send (Synchronous)", $ret_or_1)) {
        return self['$supports?']("Window.send (Asynchronous)")['$!']()
      } else if ($eqeqeq("Window.innerSize", $ret_or_1)) {
        return (typeof(window.innerHeight) !== "undefined")
      } else if ($eqeqeq("Window.outerSize", $ret_or_1)) {
        return (typeof(window.outerHeight) !== "undefined")
      } else if ($eqeqeq("Window.scroll", $ret_or_1)) {
        return (typeof(document.documentElement.scrollLeft) !== "undefined")
      } else if ($eqeqeq("Window.scrollBy", $ret_or_1)) {
        return (typeof(document.documentElement.scrollBy) !== "undefined")
      } else if ($eqeqeq("Window.pageOffset", $ret_or_1)) {
        return (typeof(window.pageXOffset) !== "undefined")
      } else if ($eqeqeq("Attr.isId", $ret_or_1)) {
        
          var div = document.createElement('div');
              div.setAttribute('id', 'xxxxxxxxxxxxx');

          return typeof(div.attributes['id'].isId) !== "undefined";
        
      } else if ($eqeqeq("Element.addBehavior", $ret_or_1)) {
        return (typeof(document.documentElement.addBehavior) !== "undefined")
      } else if ($eqeqeq("Element.className", $ret_or_1)) {
        
          var div = document.createElement("div");
              div.setAttribute('className', 'x');

          return div.className === 'x';
        
      } else if ($eqeqeq("Element.class", $ret_or_1)) {
        
          var div = document.createElement("div");
              div.setAttribute('class', 'x');

          return div.className === 'x';
        
      } else if ($eqeqeq("Element.for", $ret_or_1)) {
        
          var label = document.createElement("label");
              label.setAttribute('for', 'x');

          return label.htmlFor === 'x';
        
      } else if ($eqeqeq("Element.htmlFor", $ret_or_1)) {
        
          var label = document.createElement("label");
              label.setAttribute('htmlFor', 'x');

          return label.htmlFor === 'x';
        
      } else if ($eqeqeq("Element.clientSize", $ret_or_1)) {
        return (typeof(document.documentElement.clientHeight) !== "undefined")
      } else if ($eqeqeq("Element.scroll", $ret_or_1)) {
        return (typeof(document.documentElement.scrollLeft) !== "undefined")
      } else if ($eqeqeq("Element.textContent", $ret_or_1)) {
        return (typeof(document.documentElement.textContent) !== "undefined")
      } else if ($eqeqeq("Element.innerText", $ret_or_1)) {
        return (typeof(document.documentElement.innerText) !== "undefined")
      } else if ($eqeqeq("Element.matches", $ret_or_1)) {
        return (typeof(document.documentElement.matches) !== "undefined")
      } else if ($eqeqeq("Element.matches (Internet Explorer)", $ret_or_1)) {
        return (typeof(document.documentElement.msMatchesSelector) !== "undefined")
      } else if ($eqeqeq("Element.matches (Firefox)", $ret_or_1)) {
        return (typeof(document.documentElement.mozMatchesSelector) !== "undefined")
      } else if ($eqeqeq("Element.matches (Opera)", $ret_or_1)) {
        return (typeof(document.documentElement.oMatchesSelector) !== "undefined")
      } else if (($eqeqeq("Element.matches (Chrome)", $ret_or_1) || ($eqeqeq("Element.matches (Safari)", $ret_or_1)))) {
        return (typeof(document.documentElement.webkitMatchesSelector) !== "undefined")
      } else if ($eqeqeq("Element.getBoundingClientRect", $ret_or_1)) {
        return (typeof(document.documentElement.getBoundingClientRect) !== "undefined")
      } else if ($eqeqeq("Event.readystatechange", $ret_or_1)) {
        return "onreadystatechange" in window.document.createElement("script");
      } else if ($eqeqeq("Event.constructor", $ret_or_1)) {
        
        try {
          
          new MouseEvent("click");
          return true;
        } catch ($err) {
          if (Opal.rescue($err, [$$('StandardError'), $$$($$('JS'), 'Error')])) {
            try {
              return false
            } finally { Opal.pop_exception($err); }
          } else { throw $err; }
        };
      } else if ($eqeqeq("Event.create", $ret_or_1)) {
        return (typeof(document.createEvent) !== "undefined")
      } else if ($eqeqeq("Event.createObject", $ret_or_1)) {
        return (typeof(document.createEventObject) !== "undefined")
      } else if ($eqeqeq("Event.addListener", $ret_or_1)) {
        return (typeof(document.addEventListener) !== "undefined")
      } else if ($eqeqeq("Event.attach", $ret_or_1)) {
        return (typeof(document.attachEvent) !== "undefined")
      } else if ($eqeqeq("Event.removeListener", $ret_or_1)) {
        return (typeof(document.removeEventListener) !== "undefined")
      } else if ($eqeqeq("Event.detach", $ret_or_1)) {
        return (typeof(document.detachEvent) !== "undefined")
      } else if ($eqeqeq("Event.dispatch", $ret_or_1)) {
        return (typeof(document.dispatchEvent) !== "undefined")
      } else if ($eqeqeq("Event.fire", $ret_or_1)) {
        return (typeof(document.fireEvent) !== "undefined")
      } else if ($eqeqeq(/^Event\.([A-Z].*?)$/, $ret_or_1)) {
        return ((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)) + "Event") in window
      } else if ($eqeqeq("Document.view", $ret_or_1)) {
        return (typeof(document.defaultView) !== "undefined")
      } else if ($eqeqeq("Document.window", $ret_or_1)) {
        return (typeof(document.parentWindow) !== "undefined")
      } else if ($eqeqeq("History", $ret_or_1)) {
        return (typeof(window.history.pushState) !== "undefined")
      } else if ($eqeqeq("History.state", $ret_or_1)) {
        return (typeof(window.history.state) !== "undefined")
      } else if ($eqeqeq("Animation.request", $ret_or_1)) {
        return (typeof(window.requestAnimationFrame) !== "undefined")
      } else if ($eqeqeq("Animation.request (Internet Explorer)", $ret_or_1)) {
        return (typeof(window.msRequestAnimationFrame) !== "undefined")
      } else if ($eqeqeq("Animation.request (Firefox)", $ret_or_1)) {
        return (typeof(window.mozRequestAnimationFrame) !== "undefined")
      } else if ($eqeqeq("Animation.request (Opera)", $ret_or_1)) {
        return (typeof(window.oRequestAnimationFrame) !== "undefined")
      } else if (($eqeqeq("Animation.request (Chrome)", $ret_or_1) || ($eqeqeq("Animation.request (Safari)", $ret_or_1)))) {
        return (typeof(window.webkitRequestAnimationFrame) !== "undefined")
      } else if ($eqeqeq("Animation.cancel", $ret_or_1)) {
        return (typeof(window.cancelAnimationFrame) !== "undefined")
      } else if ($eqeqeq("Animation.cancel (Internet Explorer)", $ret_or_1)) {
        return (typeof(window.msCancelAnimationFrame) !== "undefined")
      } else if ($eqeqeq("Animation.cancel (Firefox)", $ret_or_1)) {
        return (typeof(window.mozCancelAnimationFrame) !== "undefined")
      } else if ($eqeqeq("Animation.cancel (Opera)", $ret_or_1)) {
        return (typeof(window.oCancelAnimationFrame) !== "undefined")
      } else if (($eqeqeq("Animation.cancel (Chrome)", $ret_or_1) || ($eqeqeq("Animation.cancel (Safari)", $ret_or_1)))) {
        return (typeof(window.webkitCancelAnimationFrame) !== "undefined")
      } else if ($eqeqeq("Animation.cancelRequest", $ret_or_1)) {
        return (typeof(window.cancelRequestAnimationFrame) !== "undefined")
      } else if ($eqeqeq("Animation.cancelRequest (Internet Explorer)", $ret_or_1)) {
        return (typeof(window.msCancelRequestAnimationFrame) !== "undefined")
      } else if ($eqeqeq("Animation.cancelRequest (Firefox)", $ret_or_1)) {
        return (typeof(window.mozCancelRequestAnimationFrame) !== "undefined")
      } else if ($eqeqeq("Animation.cancelRequest (Opera)", $ret_or_1)) {
        return (typeof(window.oCancelRequestAnimationFrame) !== "undefined")
      } else if (($eqeqeq("Animation.cancelRequest (Chrome)", $ret_or_1) || ($eqeqeq("Animation.cancelRequest (Safari)", $ret_or_1)))) {
        return (typeof(window.webkitCancelRequestAnimationFrame) !== "undefined")
      } else if ($eqeqeq("Audio", $ret_or_1)) {
        return (typeof(window.AudioContext) !== "undefined")
      } else if (($eqeqeq("Audio (Safari)", $ret_or_1) || ($eqeqeq("Audio (Chrome)", $ret_or_1)))) {
        return (typeof(window.webkitAudioContext) !== "undefined")
      } else if ($eqeqeq("Custom Elements", $ret_or_1)) {
        return (typeof(window.customElements) !== "undefined")
      } else {
        return nil
      }})();
      return self.support[feature] = support;
    });
    return $defs(self, '$loaded?', function $Browser_loaded$ques$2(name) {
      
      
      switch (name.valueOf()) {
        case "Sizzle":
          return (typeof(window.Sizzle) !== "undefined")
        case "wicked-good-xpath":
          return (typeof(window.wgxpath) !== "undefined")
        default:
          return nil
      }
    });
  })($nesting[0], $nesting);
};

Opal.modules["browser/setup/base"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var self = Opal.top, nil = Opal.nil;

  Opal.add_stubs('require');
  
  self.$require("browser/version");
  self.$require("browser/utils");
  self.$require("browser/form_data");
  return self.$require("browser/support");
};

Opal.modules["browser/event/base"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $truthy = Opal.truthy, $defs = Opal.defs, $def = Opal.def, $send = Opal.send, $thrower = Opal.thrower, $lambda = Opal.lambda, $to_a = Opal.to_a, $const_set = Opal.const_set, $eqeq = Opal.eqeq, $slice = Opal.slice, $eqeqeq = Opal.eqeqeq, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,call,to_n,<<,converters,native?,each,instance_eval,register,to_proc,attr_reader,new,stopped?,arguments,!,prevented?,class_for,off,target,[],delegated,delete,last,empty?,first,raise,name_for,handlers,[]=,include?,callback=,on!,delegate,on,handlers=,push,callbacks,attach,attach!,supports?,name,==,event,warn,===,detach,gsub,delete_if,=~,clear,none?,is_a?,create,dispatch,trigger,bubbles=,private,nil?,dup,on=,parent');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      self.$include($$$($$('Native'), 'Wrapper'));
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Definition');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$include($$$($$('Native'), 'Wrapper'));
        $defs(self, '$new', function $Definition_new$1() {
          var block = $Definition_new$1.$$p || nil, self = this, data = nil;

          $Definition_new$1.$$p = null;
          
          ;
          data = $send2(self, $find_super(self, 'new', $Definition_new$1, false, true), 'new', [{ bubbles: true, cancelable: true }], null);
          if ($truthy(block)) {
            block.$call(data)
          };
          return data.$to_n();
        });
        
        $def(self, '$bubbles=', function $Definition_bubbles$eq$2(value) {
          var self = this;

          return self["native"].bubbles = value
        });
        return $def(self, '$cancelable=', function $Definition_cancelable$eq$3(value) {
          var self = this;

          return self["native"].cancelable = value
        });
      })($nesting[0], null, $nesting);
      return (function($base, $parent_nesting) {
        var self = $module($base, 'Target');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        $defs(self, '$converters', function $$converters() {
          var self = this, $ret_or_1 = nil;
          if (self.converters == null) self.converters = nil;

          return (self.converters = ($truthy(($ret_or_1 = self.converters)) ? ($ret_or_1) : ([])))
        });
        $defs(self, '$register', function $$register() {
          var block = $$register.$$p || nil, self = this;

          $$register.$$p = null;
          
          ;
          return self.$converters()['$<<'](block);
        });
        $defs(self, '$convert', function $$convert(value) {try { var $t_return = $thrower('return'); 
          var self = this;

          
          if (!$truthy(self['$native?'](value))) {
            return value
          };
          $send(self.$converters(), 'each', [], function $$4(block){var result = nil;

            
            if (block == null) block = nil;
            if ($truthy((result = block.$call(value)))) {
              $t_return.$throw(result, $$4.$$is_lambda)
            } else {
              return nil
            };}, {$$ret: $t_return});
          return nil;} catch($e) {
            if ($e === $t_return) return $e.$v;
            throw $e;
          } finally {$t_return.is_orphan = true;}
        });
        $defs(self, '$included', function $$included(klass) {
          var self = this;

          return $send(klass, 'instance_eval', [], function $$5(){var self = $$5.$$s == null ? this : $$5.$$s;

            return $defs(self, '$target', function $$target() {
              var block = $$target.$$p || nil;

              $$target.$$p = null;
              
              ;
              return $send($$$($$('Event'), 'Target'), 'register', [], block.$to_proc());
            })}, {$$s: self})
        });
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Callback');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto.proc = $proto.name = nil;
          
          self.$attr_reader("target", "name", "selector");
          
          $def(self, '$initialize', function $$initialize(target, name, selector) {
            var block = $$initialize.$$p || nil, self = this;

            $$initialize.$$p = null;
            
            ;
            if (selector == null) selector = nil;
            self.target = target;
            self.name = name;
            self.selector = selector;
            return (self.block = block);
          }, -3);
          
          $def(self, '$call', function $$call(event) {
            var self = this;

            return self.$to_proc().$call(event)
          });
          
          $def(self, '$to_proc', function $$to_proc() {
            var self = this, $ret_or_1 = nil;

            return (self.proc = (function() {if ($truthy(($ret_or_1 = self.proc))) {
              return $ret_or_1
            } else {
              return $lambda(function $$6(event){var self = $$6.$$s == null ? this : $$6.$$s;
                if (self.block == null) self.block = nil;

                
                if (event == null) event = nil;
                
            if (!event.currentTarget) {
              event.currentTarget = self.target.native;
            }
          ;
                event = $$('Event').$new(event, self);
                if (!$truthy(event['$stopped?']())) {
                  $send(self.block, 'call', [event].concat($to_a(event.$arguments())))
                };
                return event['$prevented?']()['$!']();}, {$$s: self})
            }})())
          });
          
          $def(self, '$event', function $$event() {
            var self = this;

            return $$('Event').$class_for(self.name)
          });
          return $def(self, '$off', function $$off() {
            var self = this;

            return self.$target().$off(self)
          });
        })($nesting[0], null, $nesting);
        (function($base, $super) {
          var self = $klass($base, $super, 'Delegate');

          var $proto = self.$$prototype;

          $proto.target = $proto.name = $proto.pair = nil;
          
          
          $def(self, '$initialize', function $$initialize(target, name, pair) {
            var self = this;

            
            self.target = target;
            self.name = name;
            return (self.pair = pair);
          });
          return $def(self, '$off', function $$off() {
            var self = this, delegate = nil;

            
            delegate = self.target.$delegated()['$[]'](self.name);
            delegate.$last().$delete(self.pair);
            if ($truthy(delegate.$last()['$empty?']())) {
              
              delegate.$first().$off();
              return delegate.$delete(self.name);
            } else {
              return nil
            };
          });
        })($nesting[0], null);
        $const_set($nesting[0], 'Delegates', $$('Struct').$new("callback", "handlers"));
        
        $def(self, '$on', function $$on(name, selector) {
          var block = $$on.$$p || nil, $a, self = this, delegate = nil, pair = nil, callback = nil;

          $$on.$$p = null;
          
          ;
          if (selector == null) selector = nil;
          if (!$truthy(block)) {
            self.$raise($$('ArgumentError'), "no block has been given")
          };
          name = $$('Event').$name_for(name);
          if ($truthy(selector)) {
            if ($truthy((delegate = self.$delegated()['$[]'](name)))) {
              
              pair = [selector, block];
              delegate.$handlers()['$<<'](pair);
              return $$('Delegate').$new(self, name, pair);
            } else {
              
              delegate = ($a = [name, $$('Delegates').$new()], $send(self.$delegated(), '[]=', $a), $a[$a.length - 1]);
              if ($truthy(["blur", "focus"]['$include?'](name))) {
                delegate['$callback=']($send(self, 'on!', [name], function $$7(e){var self = $$7.$$s == null ? this : $$7.$$s;

                  
                  if (e == null) e = nil;
                  return self.$delegate(delegate, e);}, {$$s: self}))
              } else {
                delegate['$callback=']($send(self, 'on', [name], function $$8(e){var self = $$8.$$s == null ? this : $$8.$$s;

                  
                  if (e == null) e = nil;
                  return self.$delegate(delegate, e);}, {$$s: self}))
              };
              pair = [selector, block];
              delegate['$handlers=']([pair]);
              return $$('Delegate').$new(self, name, pair);
            }
          } else {
            
            callback = $send($$('Callback'), 'new', [self, name, selector], block.$to_proc());
            self.$callbacks().$push(callback);
            return self.$attach(callback);
          };
        }, -2);
        
        $def(self, '$on!', function $Target_on$excl$9(name) {
          var block = $Target_on$excl$9.$$p || nil, self = this, callback = nil;

          $Target_on$excl$9.$$p = null;
          
          ;
          if (!$truthy(block)) {
            self.$raise($$('ArgumentError'), "no block has been given")
          };
          name = $$('Event').$name_for(name);
          callback = $send($$('Callback'), 'new', [self, name], block.$to_proc());
          self.$callbacks().$push(callback);
          return self['$attach!'](callback);
        });
        if ($truthy($$('Browser')['$supports?']("Event.addListener"))) {
          
          
          $def(self, '$attach', function $$attach(callback) {
            var self = this;
            if (self["native"] == null) self["native"] = nil;

            
            self["native"].addEventListener(callback.$name(), callback.$to_proc());
            return callback;
          });
          
          $def(self, '$attach!', function $Target_attach$excl$10(callback) {
            var self = this;
            if (self["native"] == null) self["native"] = nil;

            
            self["native"].addEventListener(callback.$name(), callback.$to_proc(), true);
            return callback;
          });
        } else if ($truthy($$('Browser')['$supports?']("Event.attach"))) {
          
          
          $def(self, '$attach', function $$attach(callback) {
            var self = this;
            if (self["native"] == null) self["native"] = nil;

            
            if ($eqeq(callback.$event(), $$('Custom'))) {
              
            if (!self["native"].$custom) {
              self["native"].$custom = function(event) {
                for (var i = 0, length = self["native"].$callbacks.length; i < length; i++) {
                  var callback = self["native"].$callbacks[i];

                  if ((callback).$event()['$==']($$('Custom'))) {
                    event.type = callback.name;

                    (callback).$call(event);
                  }
                }
              };

              self["native"].attachEvent("ondataavailable", self["native"].$custom);
            }
          
            } else {
              self["native"].attachEvent("on" + callback.$name(), callback.$to_proc())
            };
            return callback;
          });
          
          $def(self, '$attach!', function $Target_attach$excl$11(callback) {
            var self = this;
            if (self["native"] == null) self["native"] = nil;

            
            
            switch (callback.$name().valueOf()) {
              case "blur":
                self["native"].attachEvent("onfocusout", callback.$to_proc())
                break;
              case "focus":
                self["native"].attachEvent("onfocusin", callback.$to_proc())
                break;
              default:
                
                self.$warn("attach: capture doesn't work on this browser");
                self.$attach(callback);
            };
            return callback;
          });
        } else {
          
          
          $def(self, '$attach', function $$attach($a) {
            var $post_args, $fwd_rest, self = this;

            
            $post_args = $slice(arguments);
            $fwd_rest = $post_args;
            return self.$raise($$('NotImplementedError'));
          }, -1);
          
          $def(self, '$attach!', function $Target_attach$excl$12($a) {
            var $post_args, $fwd_rest, self = this;

            
            $post_args = $slice(arguments);
            $fwd_rest = $post_args;
            return self.$raise($$('NotImplementedError'));
          }, -1);
        };
        
        $def(self, '$one', function $$one(name, selector) {
          var block = $$one.$$p || nil, self = this, cb = nil;

          $$one.$$p = null;
          
          ;
          if (selector == null) selector = nil;
          if (!$truthy(block)) {
            self.$raise($$('ArgumentError'), "no block has been given")
          };
          return (cb = $send(self, 'on', [name, selector], function $$13($a){var $post_args, args, out = nil;

            
            $post_args = $slice(arguments);
            args = $post_args;
            out = $send(block, 'call', $to_a(args));
            cb.$off();
            return out;}, -1));
        }, -2);
        
        $def(self, '$off', function $$off(what) {
          var self = this, $ret_or_1 = nil;

          
          if (what == null) what = nil;
          if ($eqeqeq($$('Callback'), ($ret_or_1 = what))) {
            
            self.$callbacks().$delete(what);
            return self.$detach(what);
          } else if ($eqeqeq($$('String'), $ret_or_1)) {
            if (($truthy(what['$include?']("*")) || ($truthy(what['$include?']("?"))))) {
              return self.$off($$('Regexp').$new(what.$gsub(/\*/, ".*?").$gsub(/\?/, ".")))
            } else {
              
              what = $$('Event').$name_for(what);
              return $send(self.$callbacks(), 'delete_if', [], function $$14(callback){var self = $$14.$$s == null ? this : $$14.$$s;

                
                if (callback == null) callback = nil;
                if ($eqeq(callback.$name(), what)) {
                  
                  self.$detach(callback);
                  return true;
                } else {
                  return nil
                };}, {$$s: self});
            }
          } else if ($eqeqeq($$('Regexp'), $ret_or_1)) {
            return $send(self.$callbacks(), 'delete_if', [], function $$15(callback){var self = $$15.$$s == null ? this : $$15.$$s;

              
              if (callback == null) callback = nil;
              if ($truthy(callback.$name()['$=~'](what))) {
                
                self.$detach(callback);
                return true;
              } else {
                return nil
              };}, {$$s: self})
          } else {
            
            $send(self.$callbacks(), 'each', [], function $$16(callback){var self = $$16.$$s == null ? this : $$16.$$s;

              
              if (callback == null) callback = nil;
              return self.$detach(callback);}, {$$s: self});
            return self.$callbacks().$clear();
          };
        }, -1);
        if ($truthy($$('Browser')['$supports?']("Event.removeListener"))) {
          
          $def(self, '$detach', function $$detach(callback) {
            var self = this;
            if (self["native"] == null) self["native"] = nil;

            return self["native"].removeEventListener(callback.$name(), callback.$to_proc(), false)
          })
        } else if ($truthy($$('Browser')['$supports?']("Event.detach"))) {
          
          $def(self, '$detach', function $$detach(callback) {
            var self = this;
            if (self["native"] == null) self["native"] = nil;

            if ($eqeq(callback.$event(), $$('Custom'))) {
              if ($truthy($send(self.$callbacks(), 'none?', [], function $$17(c){
                
                if (c == null) c = nil;
                return c.$event()['$==']($$('Custom'));}))) {
                
              self["native"].detachEvent("ondataavailable", self["native"].$custom);

              delete self["native"].$custom;
            
              } else {
                return nil
              }
            } else {
              return self["native"].detachEvent("on" + callback.$name(), callback.$to_proc())
            }
          })
        } else {
          
          $def(self, '$detach', function $$detach(callback) {
            var self = this;

            return self.$raise($$('NotImplementedError'))
          })
        };
        
        $def(self, '$trigger', function $$trigger(event, $a) {
          var block = $$trigger.$$p || nil, $post_args, args, self = this;

          $$trigger.$$p = null;
          
          ;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          if ($truthy(event['$is_a?']($$('String')))) {
            event = $send($$('Event'), 'create', [event].concat($to_a(args)), block.$to_proc())
          };
          return self.$dispatch(event);
        }, -2);
        
        $def(self, '$trigger!', function $Target_trigger$excl$18(event, $a) {
          var block = $Target_trigger$excl$18.$$p || nil, $post_args, args, self = this;

          $Target_trigger$excl$18.$$p = null;
          
          ;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          return $send(self, 'trigger', [event].concat($to_a(args)), function $$19(e){var $b;

            
            if (e == null) e = nil;
            if ($truthy(block)) {
              block.$call(e)
            };
            return ($b = [false], $send(e, 'bubbles=', $b), $b[$b.length - 1]);});
        }, -2);
        if ($truthy($$('Browser')['$supports?']("Event.dispatch"))) {
          
          $def(self, '$dispatch', function $$dispatch(event) {
            var self = this;
            if (self["native"] == null) self["native"] = nil;

            return self["native"].dispatchEvent(event.$to_n())
          })
        } else if ($truthy($$('Browser')['$supports?']("Event.fire"))) {
          
          $def(self, '$dispatch', function $$dispatch(event) {
            var self = this;
            if (self["native"] == null) self["native"] = nil;

            if ($eqeqeq($$('Custom'), event)) {
              return self["native"].fireEvent("ondataavailable", event.$to_n())
            } else {
              return self["native"].fireEvent("on" + event.$name(), event.$to_n())
            }
          })
        } else {
          
          $def(self, '$dispatch', function $$dispatch($a) {
            var $post_args, $fwd_rest, self = this;

            
            $post_args = $slice(arguments);
            $fwd_rest = $post_args;
            return self.$raise($$('NotImplementedError'));
          }, -1)
        };
        self.$private();
        
        $def(self, '$callbacks', function $$callbacks() {
          var self = this;
          if (self["native"] == null) self["native"] = nil;

          
        if (!self["native"].$callbacks) {
          self["native"].$callbacks = [];
        }

        return self["native"].$callbacks;
      
        });
        
        $def(self, '$delegated', function $$delegated() {
          var self = this;
          if (self["native"] == null) self["native"] = nil;

          
        if (!self["native"].$delegated) {
          self["native"].$delegated = (new Map());
        }

        return self["native"].$delegated;
      
        });
        return $def(self, '$delegate', function $$delegate(delegates, event, element) {
          var self = this;

          
          if (element == null) element = event.$target();
          if (($truthy(element['$nil?']()) || ($eqeq(element, event.$on())))) {
            return nil
          };
          $send(delegates.$handlers(), 'each', [], function $$20(selector, block){var new$ = nil;

            
            if (selector == null) selector = nil;
            if (block == null) block = nil;
            if ($truthy(element['$=~'](selector))) {
              
              new$ = event.$dup();
              new$['$on='](element);
              return $send(block, 'call', [new$].concat($to_a(new$.$arguments())));
            } else {
              return nil
            };});
          return self.$delegate(delegates, event, element.$parent());
        }, -3);
      })($nesting[0], $nesting);
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/ui"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('supports?,supported?,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'UI');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        $defs(self, '$supported?', function $UI_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.UI")
        });
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$detail=', function $Definition_detail$eq$2(value) {
            var self = this;

            return self["native"].detail = value
          });
          return $def(self, '$view=', function $Definition_view$eq$3(value) {
            var self = this;

            return self["native"].view = value
          });
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new UIEvent(name, desc)
            })
          } else if ($truthy($$('Browser')['$supports?']("Event.create"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              
        var event = document.createEvent("UIEvent");
            event.initUIEvent(name, desc.bubbles, desc.cancelable,
              desc.view || window, desc.detail || 0);

        return event;
      
            })
          }
        };
        self.$alias_native("detail");
        return self.$alias_native("view");
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/mouse"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $gvars = Opal.gvars, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('handles,!,nil?,[],include,new,try_convert,supported?,supports?,alias_native,x,screen,y,DOM,==,downcase,name');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Mouse');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$handles("click", "contextmenu", "dblclick", "mousedown", "mouseenter", "mouseleave", "mousemove", "mouseout", "mouseover", "mouseup", "show");
        $defs(self, '$supported?', function $Mouse_supported$ques$1() {
                    if ($gvars.$ == null) $gvars.$ = nil;

          return $gvars.$['$[]']("MouseEvent")['$nil?']()['$!']()
        });
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto["native"] = nil;
          
          (function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'Client');

            var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

            $proto["native"] = nil;
            
            self.$include($$$($$('Native'), 'Wrapper'));
            
            $def(self, '$x=', function $Client_x$eq$2(value) {
              var self = this;

              return self["native"].clientX = value
            });
            return $def(self, '$y=', function $Client_y$eq$3(value) {
              var self = this;

              return self["native"].clientY = value
            });
          })($nesting[0], null, $nesting);
          (function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'Layer');

            var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

            $proto["native"] = nil;
            
            self.$include($$$($$('Native'), 'Wrapper'));
            
            $def(self, '$x=', function $Layer_x$eq$4(value) {
              var self = this;

              return self["native"].layerX = value
            });
            return $def(self, '$y=', function $Layer_y$eq$5(value) {
              var self = this;

              return self["native"].layerY = value
            });
          })($nesting[0], null, $nesting);
          (function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'Offset');

            var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

            $proto["native"] = nil;
            
            self.$include($$$($$('Native'), 'Wrapper'));
            
            $def(self, '$x=', function $Offset_x$eq$6(value) {
              var self = this;

              return self["native"].offsetX = value
            });
            return $def(self, '$y=', function $Offset_y$eq$7(value) {
              var self = this;

              return self["native"].offsetY= value
            });
          })($nesting[0], null, $nesting);
          (function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'Page');

            var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

            $proto["native"] = nil;
            
            self.$include($$$($$('Native'), 'Wrapper'));
            
            $def(self, '$x=', function $Page_x$eq$8(value) {
              var self = this;

              return self["native"].pageX = value
            });
            return $def(self, '$y=', function $Page_y$eq$9(value) {
              var self = this;

              return self["native"].pageY = value
            });
          })($nesting[0], null, $nesting);
          (function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'Screen');

            var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

            $proto["native"] = nil;
            
            self.$include($$$($$('Native'), 'Wrapper'));
            
            $def(self, '$x=', function $Screen_x$eq$10(value) {
              var self = this;

              return self["native"].screenX = value
            });
            return $def(self, '$y=', function $Screen_y$eq$11(value) {
              var self = this;

              return self["native"].screenY = value
            });
          })($nesting[0], null, $nesting);
          (function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'Ancestor');

            var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

            $proto["native"] = nil;
            
            self.$include($$$($$('Native'), 'Wrapper'));
            
            $def(self, '$x=', function $Ancestor_x$eq$12(value) {
              var self = this;

              return self["native"].x = value
            });
            return $def(self, '$y=', function $Ancestor_y$eq$13(value) {
              var self = this;

              return self["native"].y = value
            });
          })($nesting[0], null, $nesting);
          
          $def(self, '$x=', function $Definition_x$eq$14(value) {
            var self = this;

            return self["native"].screenX = value
          });
          
          $def(self, '$y=', function $Definition_y$eq$15(value) {
            var self = this;

            return self["native"].screenY = value
          });
          
          $def(self, '$alt!', function $Definition_alt$excl$16() {
            var self = this;

            return self["native"].altKey = true
          });
          
          $def(self, '$ctrl!', function $Definition_ctrl$excl$17() {
            var self = this;

            return self["native"].ctrlKey = true
          });
          
          $def(self, '$meta!', function $Definition_meta$excl$18() {
            var self = this;

            return self["native"].metaKey = true
          });
          
          $def(self, '$button=', function $Definition_button$eq$19(value) {
            var self = this;

            return self["native"].button = value
          });
          
          $def(self, '$client', function $$client() {
            var self = this;

            return $$('Client').$new(self["native"])
          });
          
          $def(self, '$layer', function $$layer() {
            var self = this;

            return $$('Layer').$new(self["native"])
          });
          
          $def(self, '$offset', function $$offset() {
            var self = this;

            return $$('Offset').$new(self["native"])
          });
          
          $def(self, '$page', function $$page() {
            var self = this;

            return $$('Page').$new(self["native"])
          });
          
          $def(self, '$screen', function $$screen() {
            var self = this;

            return $$('Screen').$new(self["native"])
          });
          
          $def(self, '$ancestor', function $$ancestor() {
            var self = this;

            return $$('Ancestor').$new(self["native"])
          });
          
          $def(self, '$related=', function $Definition_related$eq$20(elem) {
            var self = this;

            return self["native"].relatedTarget = $$('Native').$try_convert(elem)
          });
          
          $def(self, '$from=', function $Definition_from$eq$21(elem) {
            var self = this;

            return self["native"].fromElement = $$('Native').$try_convert(elem)
          });
          return $def(self, '$to=', function $Definition_to$eq$22(elem) {
            var self = this;

            return self["native"].toElement = $$('Native').$try_convert(elem)
          });
        })($nesting[0], $$$($$('UI'), 'Definition'), $nesting);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new MouseEvent(name, desc)
            })
          } else if ($truthy($$('Browser')['$supports?']("Event.create"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              
        var event = document.createEvent("MouseEvent");
            event.initMouseEvent(name, desc.bubbles, desc.cancelable,
              desc.view || window, desc.detail || 0,
              desc.screenX || 0, desc.screenY || 0,
              desc.clientX || 0, desc.clientY || 0,
              desc.ctrlKey || false, desc.altKey || false,
              desc.shiftKey || false, desc.metaKey || false,
              desc.button || 0, desc.relatedTarget || null);

        return event;
      
            })
          }
        };
        self.$alias_native("alt?", "altKey");
        self.$alias_native("ctrl?", "ctrlKey");
        self.$alias_native("meta?", "metaKey");
        self.$alias_native("shift?", "shiftKey");
        self.$alias_native("button");
        
        $def(self, '$client', function $$client() {
          var self = this;

          return $$('Position').$new(self["native"].clientX, self["native"].clientY)
        });
        
        $def(self, '$layer', function $$layer() {
          var self = this;

          if ($truthy(self["native"].layerX == null)) {
            return nil
          } else {
            return $$('Position').$new(self["native"].layerX, self["native"].layerY)
          }
        });
        
        $def(self, '$offset', function $$offset() {
          var self = this;

          if ($truthy(self["native"].offsetX == null)) {
            return nil
          } else {
            return $$('Position').$new(self["native"].offsetX, self["native"].offsetY)
          }
        });
        
        $def(self, '$page', function $$page() {
          var self = this;

          if ($truthy(self["native"].pageX == null)) {
            return nil
          } else {
            return $$('Position').$new(self["native"].pageX, self["native"].pageY)
          }
        });
        
        $def(self, '$screen', function $$screen() {
          var self = this;

          if ($truthy(self["native"].screenX == null)) {
            return nil
          } else {
            return $$('Position').$new(self["native"].screenX, self["native"].screenY)
          }
        });
        
        $def(self, '$ancestor', function $$ancestor() {
          var self = this;

          if ($truthy(self["native"].x == null)) {
            return nil
          } else {
            return $$('Position').$new(self["native"].x, self["native"].y)
          }
        });
        
        $def(self, '$x', function $$x() {
          var self = this;

          return self.$screen().$x()
        });
        
        $def(self, '$y', function $$y() {
          var self = this;

          return self.$screen().$y()
        });
        
        $def(self, '$related', function $$related() {
          var self = this;

          if ($truthy(self["native"].relatedTarget == null)) {
            return nil
          } else {
            return self.$DOM(self["native"].relatedTarget)
          }
        });
        
        $def(self, '$from', function $$from() {
          var self = this;

          if ($truthy(self["native"].fromElement == null)) {
            return nil
          } else {
            return self.$DOM(self["native"].fromElement)
          }
        });
        
        $def(self, '$to', function $$to() {
          var self = this;

          if ($truthy(self["native"].toElement == null)) {
            return nil
          } else {
            return self.$DOM(self["native"].toElement)
          }
        });
        
        $def(self, '$click?', function $Mouse_click$ques$23() {
          var self = this;

          return self.$name().$downcase()['$==']("click")
        });
        
        $def(self, '$double_click?', function $Mouse_double_click$ques$24() {
          var self = this;

          return self.$name().$downcase()['$==']("dblclick")
        });
        
        $def(self, '$down?', function $Mouse_down$ques$25() {
          var self = this;

          return self.$name().$downcase()['$==']("mousedown")
        });
        
        $def(self, '$enter?', function $Mouse_enter$ques$26() {
          var self = this;

          return self.$name().$downcase()['$==']("mouseenter")
        });
        
        $def(self, '$leave?', function $Mouse_leave$ques$27() {
          var self = this;

          return self.$name().$downcase()['$==']("mouseleave")
        });
        
        $def(self, '$move?', function $Mouse_move$ques$28() {
          var self = this;

          return self.$name().$downcase()['$==']("mousemove")
        });
        
        $def(self, '$out?', function $Mouse_out$ques$29() {
          var self = this;

          return self.$name().$downcase()['$==']("mouseout")
        });
        
        $def(self, '$over?', function $Mouse_over$ques$30() {
          var self = this;

          return self.$name().$downcase()['$==']("mouseover")
        });
        
        $def(self, '$up?', function $Mouse_up$ques$31() {
          var self = this;

          return self.$name().$downcase()['$==']("mouseup")
        });
        return $def(self, '$show?', function $Mouse_show$ques$32() {
          var self = this;

          return self.$name().$downcase()['$==']("show")
        });
      })($nesting[0], $$('UI'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/keyboard"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $const_set = Opal.const_set, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('handles,supports?,supported?,alias_native,[],code,chr,key,==,downcase,name');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Keyboard');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$handles("keydown", "keypress", "keyup");
        $defs(self, '$supported?', function $Keyboard_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.Keyboard")
        });
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$alt!', function $Definition_alt$excl$2() {
            var self = this;

            return self["native"].altKey = true
          });
          
          $def(self, '$ctrl!', function $Definition_ctrl$excl$3() {
            var self = this;

            return self["native"].ctrlKey = true
          });
          
          $def(self, '$meta!', function $Definition_meta$excl$4() {
            var self = this;

            return self["native"].metaKey = true
          });
          
          $def(self, '$shift!', function $Definition_shift$excl$5() {
            var self = this;

            return self["native"].shiftKey = true
          });
          
          $def(self, '$code=', function $Definition_code$eq$6(code) {
            var self = this;

            return self["native"].keyCode = self["native"].which = code
          });
          
          $def(self, '$key=', function $Definition_key$eq$7(key) {
            var self = this;

            return self["native"].key = key
          });
          
          $def(self, '$char=', function $Definition_char$eq$8(char$) {
            var self = this;

            return self["native"].char = self["native"].charCode = char$
          });
          
          $def(self, '$repeat!', function $Definition_repeat$excl$9() {
            var self = this;

            return self["native"].repeat = true
          });
          return $def(self, '$locale=', function $Definition_locale$eq$10(value) {
            var self = this;

            return self["native"].locale = value
          });
        })($nesting[0], $$$($$('UI'), 'Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new KeyboardEvent(name, desc)
            })
          } else if ($truthy($$('Browser')['$supports?']("Event.create"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              
        var modifiers = "";

        if (desc.altKey) {
          modifiers += "Alt ";
        }

        if (desc.ctrlKey) {
          modifiers += "Ctrl ";
        }

        if (desc.shiftKey) {
          modifiers += "Shift" ;
        }

        if (desc.metaKey) {
          modifiers += "Meta ";
        }

        var event = document.createEvent("KeyboardEvent");
            event.initKeyboardEvent(name, desc.bubbles, desc.cancelable,
              desc.view || window, desc.which, 0,
              modifiers, desc.repeat, desc.locale);

        return event;
      
            })
          }
        };
        self.$alias_native("alt?", "altKey");
        self.$alias_native("ctrl?", "ctrlKey");
        self.$alias_native("meta?", "metaKey");
        self.$alias_native("shift?", "shiftKey");
        self.$alias_native("locale");
        self.$alias_native("repeat?", "repeat");
        $const_set($nesting[0], 'IE_MAP', (new Map([["Down", "ArrowDown"], ["Up", "ArrowUp"], ["Left", "ArrowLeft"], ["Right", "ArrowRight"], ["Esc", "Escape"], ["Del", "Delete"]])));
        
        $def(self, '$key', function $$key() {
          var self = this, key = nil, $ret_or_1 = nil;

          
          key = self["native"].key || self["native"].keyIdentifier || nil;
          if ($truthy(($ret_or_1 = $$('IE_MAP')['$[]'](key)))) {
            return $ret_or_1
          } else {
            return key
          };
        });
        
        $def(self, '$code', function $$code() {
          var self = this;

          return self["native"].keyCode || self["native"].which || nil
        });
        
        $def(self, '$char', function $Keyboard_char$11() {
          var self = this;

          return self["native"].char || self["native"].charCode || ($truthy(self.$code()) ? (self.$code().$chr()) : (nil))
        });
        $alias(self, "to_i", "key");
        
        $def(self, '$down?', function $Keyboard_down$ques$12() {
          var self = this;

          return self.$name().$downcase()['$==']("keydown")
        });
        
        $def(self, '$press?', function $Keyboard_press$ques$13() {
          var self = this;

          return self.$name().$downcase()['$==']("keypress")
        });
        return $def(self, '$up?', function $Keyboard_up$ques$14() {
          var self = this;

          return self.$name().$downcase()['$==']("keyup")
        });
      })($nesting[0], $$('UI'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["ostruct"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $def = Opal.def, $slice = Opal.slice, $rb_gt = Opal.rb_gt, $neqeq = Opal.neqeq, $range = Opal.range, $send2 = Opal.send2, $find_super = Opal.find_super, $rb_plus = Opal.rb_plus, $alias = Opal.alias, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('each_pair,[]=,new_ostruct_member,[],to_sym,>,length,raise,new,end_with?,!=,chomp,to_s,key?,enum_for,is_a?,==,instance_variable_get,===,eql?,to_h,to_proc,dup,to_n,hash,attr_reader,__send__,singleton_class,delete,respond_to?,define_singleton_method,__id__,class,any?,+,join,map,inspect');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'OpenStruct');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.table = nil;
    
    
    $def(self, '$initialize', function $$initialize(hash) {
      var self = this;

      
      if (hash == null) hash = nil;
      self.table = (new Map());
      if ($truthy(hash)) {
        return $send(hash, 'each_pair', [], function $$1(key, value){var $a, self = $$1.$$s == null ? this : $$1.$$s;
          if (self.table == null) self.table = nil;

          
          if (key == null) key = nil;
          if (value == null) value = nil;
          return ($a = [self.$new_ostruct_member(key), value], $send(self.table, '[]=', $a), $a[$a.length - 1]);}, {$$s: self})
      } else {
        return nil
      };
    }, -1);
    
    $def(self, '$[]', function $OpenStruct_$$$2(name) {
      var self = this;

      return self.table['$[]'](name.$to_sym())
    });
    
    $def(self, '$[]=', function $OpenStruct_$$$eq$3(name, value) {
      var $a, self = this;

      return ($a = [self.$new_ostruct_member(name), value], $send(self.table, '[]=', $a), $a[$a.length - 1])
    });
    
    $def(self, '$method_missing', function $$method_missing(name, $a) {
      var $post_args, args, $b, self = this;

      
      $post_args = $slice(arguments, 1);
      args = $post_args;
      if ($truthy($rb_gt(args.$length(), 2))) {
        self.$raise($$('NoMethodError').$new("undefined method `" + (name) + "' for #<OpenStruct>", name))
      };
      if ($truthy(name['$end_with?']("="))) {
        
        if ($neqeq(args.$length(), 1)) {
          self.$raise($$('ArgumentError'), "wrong number of arguments (0 for 1)")
        };
        return ($b = [self.$new_ostruct_member(name['$[]']($range(0, -2, false))), args['$[]'](0)], $send(self.table, '[]=', $b), $b[$b.length - 1]);
      } else {
        return self.table['$[]'](name.$to_sym())
      };
    }, -2);
    
    $def(self, '$respond_to_missing?', function $OpenStruct_respond_to_missing$ques$4(mid, include_private) {
      var $a, $yield = $OpenStruct_respond_to_missing$ques$4.$$p || nil, self = this, mname = nil, $ret_or_1 = nil;

      $OpenStruct_respond_to_missing$ques$4.$$p = null;
      
      if (include_private == null) include_private = false;
      mname = mid.$to_s().$chomp("=").$to_sym();
      if ($truthy(($ret_or_1 = ($a = self.table, ($a === nil || $a == null) ? nil : $a['$key?'](mname))))) {
        return $ret_or_1
      } else {
        return $send2(self, $find_super(self, 'respond_to_missing?', $OpenStruct_respond_to_missing$ques$4, false, true), 'respond_to_missing?', [mid, include_private], $yield)
      };
    }, -2);
    
    $def(self, '$each_pair', function $$each_pair() {
      var $yield = $$each_pair.$$p || nil, self = this;

      $$each_pair.$$p = null;
      
      if (!($yield !== nil)) {
        return self.$enum_for("each_pair")
      };
      return $send(self.table, 'each_pair', [], function $$5(pair){
        
        if (pair == null) pair = nil;
        return Opal.yield1($yield, pair);;});
    });
    
    $def(self, '$==', function $OpenStruct_$eq_eq$6(other) {
      var self = this;

      
      if (!$truthy(other['$is_a?']($$('OpenStruct')))) {
        return false
      };
      return self.table['$=='](other.$instance_variable_get("@table"));
    });
    
    $def(self, '$===', function $OpenStruct_$eq_eq_eq$7(other) {
      var self = this;

      
      if (!$truthy(other['$is_a?']($$('OpenStruct')))) {
        return false
      };
      return self.table['$==='](other.$instance_variable_get("@table"));
    });
    
    $def(self, '$eql?', function $OpenStruct_eql$ques$8(other) {
      var self = this;

      
      if (!$truthy(other['$is_a?']($$('OpenStruct')))) {
        return false
      };
      return self.table['$eql?'](other.$instance_variable_get("@table"));
    });
    
    $def(self, '$to_h', function $$to_h() {
      var block = $$to_h.$$p || nil, self = this;

      $$to_h.$$p = null;
      
      ;
      if ((block !== nil)) {
        return $send(self.table, 'to_h', [], block.$to_proc())
      } else {
        return self.table.$dup()
      };
    });
    
    $def(self, '$to_n', function $$to_n() {
      var self = this;

      return self.table.$to_n()
    });
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      return self.table.$hash()
    });
    self.$attr_reader("table");
    
    $def(self, '$delete_field', function $$delete_field(name) {
      var self = this, sym = nil;

      
      sym = name.$to_sym();
      
      try {
        self.$singleton_class().$__send__("remove_method", sym, "" + (sym) + "=")
      } catch ($err) {
        if (Opal.rescue($err, [$$('NameError')])) {
          try {
            nil
          } finally { Opal.pop_exception($err); }
        } else { throw $err; }
      };;
      return self.table.$delete(sym);
    });
    
    $def(self, '$new_ostruct_member', function $$new_ostruct_member(name) {
      var self = this;

      
      name = name.$to_sym();
      if (!$truthy(self['$respond_to?'](name))) {
        
        $send(self, 'define_singleton_method', [name], function $$9(){var self = $$9.$$s == null ? this : $$9.$$s;
          if (self.table == null) self.table = nil;

          return self.table['$[]'](name)}, {$$s: self});
        $send(self, 'define_singleton_method', ["" + (name) + "="], function $$10(x){var $a, self = $$10.$$s == null ? this : $$10.$$s;
          if (self.table == null) self.table = nil;

          
          if (x == null) x = nil;
          return ($a = [name, x], $send(self.table, '[]=', $a), $a[$a.length - 1]);}, {$$s: self});
      };
      return name;
    });
    var ostruct_ids;;
    
    $def(self, '$inspect', function $$inspect() {
      var self = this, result = nil;

      
      
      var top = (ostruct_ids === undefined),
          ostruct_id = self.$__id__();
    ;
      
      return (function() { try {
      
      result = "#<" + (self.$class());
      
        if (top) {
          ostruct_ids = {};
        }
        if (ostruct_ids.hasOwnProperty(ostruct_id)) {
          return result + ' ...>';
        }
        ostruct_ids[ostruct_id] = true;
      ;
      if ($truthy(self.table['$any?']())) {
        result = $rb_plus(result, " ")
      };
      result = $rb_plus(result, $send(self.$each_pair(), 'map', [], function $$11(name, value){
        
        if (name == null) name = nil;
        if (value == null) value = nil;
        return "" + (name) + "=" + (value.$inspect());}).$join(", "));
      result = $rb_plus(result, ">");
      return result;
      } finally {
        
        if (top) {
          ostruct_ids = undefined;
        }
      
      }; })();;
    });
    return $alias(self, "to_s", "inspect");
  })($nesting[0], null, $nesting)
};

Opal.modules["browser/event/custom"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $truthy = Opal.truthy, $range = Opal.range, $def = Opal.def, $send2 = Opal.send2, $find_super = Opal.find_super, $slice = Opal.slice, $to_a = Opal.to_a, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,supports?,end_with?,[],to_n,merge!,Native,new,has_key?');
  
  self.$require("ostruct");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Custom');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.detail = nil;
        
        $defs(self, '$supported?', function $Custom_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.Custom")
        });
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          return $def(self, '$method_missing', function $$method_missing(name, value) {
            var self = this;

            if ($truthy(name['$end_with?']("="))) {
              return self["native"][name['$[]']($range(0, -2, false))] = value
            } else {
              return nil
            }
          })
        })($nesting[0], $$('Definition'));
        if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
          $defs(self, '$construct', function $$construct(name, desc) {
            
            return new CustomEvent(name, {
        bubbles:    desc.bubbles,
        cancelable: desc.cancelable,
        detail:     desc })
          })
        } else if ($truthy($$('Browser')['$supports?']("Event.create"))) {
          $defs(self, '$construct', function $$construct(name, desc) {
            
            
        var event = document.createEvent("CustomEvent");
            event.initCustomEvent(name, desc.bubbles, desc.cancelable, desc);

        return event;
      
          })
        } else if ($truthy($$('Browser')['$supports?']("Event.createObject"))) {
          $defs(self, '$construct', function $$construct(name, desc) {
            var self = this;

            return self.$Native(document.createEventObject())['$merge!']({
        type:       name,
        bubbles:    desc.bubbles,
        cancelable: desc.cancelable,
        detail:     desc }).$to_n()
          })
        } else {
          $defs(self, '$construct', function $$construct(name, desc) {
            var self = this;

            return self.$Native(desc)['$merge!']({
        type:       name,
        bubbles:    desc.bubbles,
        cancelable: desc.cancelable,
        detail:     desc }).$to_n()
          })
        };
        
        $def(self, '$initialize', function $$initialize(event, callback) {
          var $yield = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          
          if (callback == null) callback = nil;
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [event, callback], null);
          return (self.detail = $$('Hash').$new(event.detail));
        }, -2);
        return $def(self, '$method_missing', function $$method_missing(id, $a) {
          var $post_args, $fwd_rest, $yield = $$method_missing.$$p || nil, self = this;

          $$method_missing.$$p = null;
          
          $post_args = $slice(arguments, 1);
          $fwd_rest = $post_args;
          if ($truthy(self.detail['$has_key?'](id))) {
            return self.detail['$[]'](id)
          };
          return $send2(self, $find_super(self, 'method_missing', $$method_missing, false, true), 'method_missing', [id].concat($to_a($fwd_rest)), $yield);
        }, -2);
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["browser/event"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $defs = Opal.defs, $slice = Opal.slice, $send = Opal.send, $return_val = Opal.return_val, $eqeq = Opal.eqeq, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,gsub,[],aliases,each,[]=,handlers,handles,name_for,class_for,new,construct,const_get,to_proc,arguments=,supports?,merge!,Native,to_n,==,name,attr_reader,attr_writer,convert,alias_native,off,prevent,stop');
  
  self.$require("browser/event/base");
  (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = $proto.on = $proto.callback = nil;
      
      $defs(self, '$aliases', function $$aliases() {
        var self = this, $ret_or_1 = nil;
        if (self.aliases == null) self.aliases = nil;

        return (self.aliases = ($truthy(($ret_or_1 = self.aliases)) ? ($ret_or_1) : ((new Map([["dom:load", "DOMContentLoaded"], ["hover", "mouse:over"]])))))
      });
      $defs(self, '$name_for', function $$name_for(name) {
        var self = this, $ret_or_1 = nil;

        return ($truthy(($ret_or_1 = self.$aliases()['$[]'](name))) ? ($ret_or_1) : (name)).$gsub(":", "")
      });
      $defs(self, '$handlers', function $$handlers() {
        var self = this, $ret_or_1 = nil;
        if (self.handlers == null) self.handlers = nil;

        return (self.handlers = ($truthy(($ret_or_1 = self.handlers)) ? ($ret_or_1) : ((new Map()))))
      });
      $defs(self, '$handles', function $$handles($a) {
        var $post_args, events, self = this;

        
        $post_args = $slice(arguments);
        events = $post_args;
        return $send(events, 'each', [], function $$1(event){var $b, self = $$1.$$s == null ? this : $$1.$$s;

          
          if (event == null) event = nil;
          return ($b = [event, self], $send($$('Event').$handlers(), '[]=', $b), $b[$b.length - 1]);}, {$$s: self});
      }, -1);
      self.$handles("abort", "afterprint", "beforeprint", "cached", "canplay", "canplaythrough", "change", "chargingchange", "chargingtimechange", "checking", "close", "dischargingtimechange", "DOMContentLoaded", "downloading", "durationchange", "emptied", "ended", "error", "fullscreenchange", "fullscreenerror", "input", "invalid", "levelchange", "loadeddata", "loadedmetadata", "noupdate", "obsolete", "offline", "online", "open", "orientationchange", "pause", "pointerlockchange", "pointerlockerror", "play", "playing", "ratechange", "readystatechange", "reset", "seeked", "seeking", "stalled", "submit", "success", "suspend", "timeupdate", "updateready", "visibilitychange", "volumechange", "waiting");
      $defs(self, '$class_for', function $$class_for(name) {
        var self = this, $ret_or_1 = nil;
        if (self.handlers == null) self.handlers = nil;

        if ($truthy(($ret_or_1 = self.handlers['$[]'](self.$name_for(name))))) {
          return $ret_or_1
        } else {
          return $$('Custom')
        }
      });
      $defs(self, '$supported?', $return_val(true));
      $defs(self, '$create', function $$create(name, $a) {
        var block = $$create.$$p || nil, $post_args, args, self = this, klass = nil, event = nil;

        $$create.$$p = null;
        
        ;
        $post_args = $slice(arguments, 1);
        args = $post_args;
        name = self.$name_for(name);
        klass = self.$class_for(name);
        event = klass.$new(klass.$construct(name, $send(klass.$const_get("Definition"), 'new', [], block.$to_proc())));
        event['$arguments='](args);
        return event;
      }, -2);
      if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
        $defs(self, '$construct', function $$construct(name, desc) {
          
          return new Event(name, desc)
        })
      } else if ($truthy($$('Browser')['$supports?']("Event.create"))) {
        $defs(self, '$construct', function $$construct(name, desc) {
          var self = this;

          
        var event = document.createEvent("HTMLEvents");
            event.initEvent(name, desc.bubbles, desc.cancelable);

        return self.$Native(event)['$merge!'](desc);
      
        })
      } else if ($truthy($$('Browser')['$supports?']("Event.createObject"))) {
        $defs(self, '$construct', function $$construct(name, desc) {
          var self = this;

          return self.$Native(document.createEventObject())['$merge!'](desc)['$merge!']({ type: name }).$to_n()
        })
      } else {
        $defs(self, '$construct', function $$construct(name, desc) {
          var self = this;

          return self.$Native(desc)['$merge!']({ type: name }).$to_n()
        })
      };
      $defs(self, '$new', function $Event_new$2(value, callback) {
        var $yield = $Event_new$2.$$p || nil, self = this, klass = nil;

        $Event_new$2.$$p = null;
        
        if (callback == null) callback = nil;
        if (!$eqeq(self, $$('Event'))) {
          return $send2(self, $find_super(self, 'new', $Event_new$2, false, true), 'new', [value, callback], $yield)
        };
        klass = self.$class_for(($truthy(callback) ? (callback.$name()) : (value.type)));
        if ($eqeq(klass, $$('Event'))) {
          return $send2(self, $find_super(self, 'new', $Event_new$2, false, true), 'new', [value, callback], $yield)
        } else {
          return klass.$new(value, callback)
        };
      }, -2);
      self.$attr_reader("callback");
      self.$attr_writer("on");
      
      $def(self, '$initialize', function $$initialize(event, callback) {
        var $yield = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        if (callback == null) callback = nil;
        $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [event], null);
        return (self.callback = callback);
      }, -2);
      
      $def(self, '$name', function $$name() {
        var self = this;

        return self["native"].type
      });
      
      $def(self, '$on', function $$on() {
        var self = this, $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = self.on))) {
          return $ret_or_1
        } else {
          return $$('Target').$convert(self["native"].currentTarget)
        }
      });
      
      $def(self, '$target', function $$target() {
        var self = this;

        return $$('Target').$convert(self["native"].srcElement || self["native"].target)
      });
      
      $def(self, '$arguments', function $Event_arguments$3() {
        var self = this;

        return self["native"].arguments || []
      });
      
      $def(self, '$arguments=', function $Event_arguments$eq$4(args) {
        var self = this;

        return self["native"].arguments = args
      });
      self.$alias_native("bubbles?", "bubbles");
      self.$alias_native("cancelable?", "cancelable");
      self.$alias_native("data");
      self.$alias_native("phase", "eventPhase");
      self.$alias_native("at", "timeStamp");
      
      $def(self, '$off', function $$off() {
        var self = this;

        if ($truthy(self.callback)) {
          return self.callback.$off()
        } else {
          return nil
        }
      });
      
      $def(self, '$stopped?', function $Event_stopped$ques$5() {
        var self = this;

        return !!self["native"].stopped
      });
      
      $def(self, '$stop', function $$stop() {
        var self = this;

        
        if ($truthy((typeof(self["native"].stopPropagation) !== "undefined"))) {
          self["native"].stopPropagation()
        };
        return self["native"].stopped = true;
      });
      
      $def(self, '$prevent', function $$prevent() {
        var self = this;

        
        if ($truthy((typeof(self["native"].preventDefault) !== "undefined"))) {
          self["native"].preventDefault()
        };
        return self["native"].prevented = true;
      });
      
      $def(self, '$prevented?', function $Event_prevented$ques$6() {
        var self = this;

        return !!self["native"].prevented
      });
      return $def(self, '$stop!', function $Event_stop$excl$7() {
        var self = this;

        
        self.$prevent();
        return self.$stop();
      });
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
  self.$require("browser/event/ui");
  self.$require("browser/event/mouse");
  self.$require("browser/event/keyboard");
  return self.$require("browser/event/custom");
};

Opal.modules["browser/window/view"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('to_n,supports?,raise');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Window');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'View');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        
        $def(self, '$initialize', function $$initialize(window) {
          var self = this;

          
          self.window = window;
          return (self["native"] = window.$to_n());
        });
        if ($truthy($$('Browser')['$supports?']("Window.innerSize"))) {
          
          
          $def(self, '$width', function $$width() {
            var self = this;

            return self["native"].innerWidth
          });
          
          $def(self, '$height', function $$height() {
            var self = this;

            return self["native"].innerHeight
          });
        } else if ($truthy($$('Browser')['$supports?']("Element.clientSize"))) {
          
          
          $def(self, '$height', function $$height() {
            var self = this;

            return self["native"].document.documentElement.clientHeight
          });
          
          $def(self, '$width', function $$width() {
            var self = this;

            return self["native"].document.documentElement.clientWidth
          });
        } else {
          
          
          $def(self, '$width', function $$width() {
            var self = this;

            return self.$raise($$('NotImplementedError'), "window size unsupported")
          });
          
          $def(self, '$height', function $$height() {
            var self = this;

            return self.$raise($$('NotImplementedError'), "window size unsupported")
          });
        };
        
        $def(self, '$zoom', function $$zoom() {
          var self = this;

          return self["native"].devicePixelRatio
        });
        return $def(self, '$on_zoom', function $$on_zoom() {
          var block = $$on_zoom.$$p || nil, self = this;

          $$on_zoom.$$p = null;
          
          ;
          
      var mqString = "(resolution: " + self["native"].devicePixelRatio + "dppx)";
      self["native"].matchMedia(mqString).addListener(block.$to_n());
    ;
        });
      })($nesting[0], null, $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/window/size"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $slice = Opal.slice, $eqeqeq = Opal.eqeqeq, $to_ary = Opal.to_ary, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('to_n,===,first,values_at,width,height,supports?,raise,set');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Window');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Size');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        
        $def(self, '$initialize', function $$initialize(window) {
          var self = this;

          
          self.window = window;
          return (self["native"] = window.$to_n());
        });
        
        $def(self, '$set', function $$set($a) {
          var $post_args, args, $b, $c, self = this, width = nil, height = nil, $ret_or_1 = nil;

          
          $post_args = $slice(arguments);
          args = $post_args;
          if ($eqeqeq($$('Hash'), args.$first())) {
            $c = args.$first().$values_at("width", "height"), $b = $to_ary($c), (width = ($b[0] == null ? nil : $b[0])), (height = ($b[1] == null ? nil : $b[1])), $c
          } else {
            $c = args, $b = $to_ary($c), (width = ($b[0] == null ? nil : $b[0])), (height = ($b[1] == null ? nil : $b[1])), $c
          };
          width = ($truthy(($ret_or_1 = width)) ? ($ret_or_1) : (self.$width()));
          height = ($truthy(($ret_or_1 = height)) ? ($ret_or_1) : (self.$height()));
          self["native"].resizeTo(width, height);
          return self;
        }, -1);
        if ($truthy($$('Browser')['$supports?']("Window.outerSize"))) {
          
          
          $def(self, '$width', function $$width() {
            var self = this;

            return self["native"].outerWidth
          });
          
          $def(self, '$height', function $$height() {
            var self = this;

            return self["native"].outerHeight
          });
        } else {
          
          
          $def(self, '$width', function $$width() {
            var self = this;

            return self.$raise($$('NotImplementedError'), "window outer size not supported")
          });
          
          $def(self, '$height', function $$height() {
            var self = this;

            return self.$raise($$('NotImplementedError'), "window outer size not supported")
          });
        };
        
        $def(self, '$width=', function $Size_width$eq$1(value) {
          var self = this;

          return self.$set((new Map([["width", value]])))
        });
        
        $def(self, '$height=', function $Size_height$eq$2(value) {
          var self = this;

          return self.$set((new Map([["height", value]])))
        });
        
        $def(self, '$inner_width', function $$inner_width() {
          var self = this;

          return self["native"].innerWidth
        });
        return $def(self, '$inner_height', function $$inner_height() {
          var self = this;

          return self["native"].innerHeight
        });
      })($nesting[0], null, $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/window"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $eqeqeq = Opal.eqeqeq, $defs = Opal.defs, $truthy = Opal.truthy, $gvars = Opal.gvars, $def = Opal.def, self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,delete,join,map,===,new,include,target,supports?,[],raise,alert,prompt,confirm');
  
  self.$require("browser/window/view");
  self.$require("browser/window/size");
  (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Window');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = $proto.parent = $proto.top = $proto.opener = $proto.view = $proto.size = $proto.scroll = nil;
      
      $defs(self, '$open', function $$open(url, options) {
        var self = this, name = nil, features = nil;

        
        name = options.$delete("name");
        features = $send(options, 'map', [], function $$1(key, value){var $ret_or_1 = nil;

          
          if (key == null) key = nil;
          if (value == null) value = nil;
          value = ($eqeqeq(true, ($ret_or_1 = value)) ? ("yes") : ($eqeqeq(false, $ret_or_1) ? ("no") : (value)));
          return "" + (key) + "=" + (value);}).$join(",");
        
      var win = window.open(url, name, features);

      if (win == null) {
        return nil;
      }

      return self.$new(win);
    ;
      });
      self.$include($$$($$('Browser'), 'NativeCachedWrapper'));
      self.$include($$$($$('Event'), 'Target'));
      $send(self, 'target', [], function $Window$2(value){        if ($gvars.window == null) $gvars.window = nil;

        
        if (value == null) value = nil;
        if ($truthy(value == window)) {
          return $gvars.window
        } else {
          return nil
        };});
      
      $def(self, '$alert', function $$alert(value) {
        var self = this;

        
        self["native"].alert(value);
        return value;
      });
      
      $def(self, '$prompt', function $$prompt(value, default$) {
        var self = this, $ret_or_1 = nil;

        
        if (default$ == null) default$ = nil;
        return self["native"].prompt(value, ($truthy(($ret_or_1 = default$)) ? ($ret_or_1) : (""))) || nil;
      }, -2);
      
      $def(self, '$confirm', function $$confirm(value) {
        var self = this;

        return self["native"].confirm(value) || false
      });
      
      $def(self, '$parent', function $$parent() {
        var self = this, $ret_or_1 = nil;

        return (self.parent = ($truthy(($ret_or_1 = self.parent)) ? ($ret_or_1) : ($$$($$('Browser'), 'Window').$new(self["native"].parent))))
      });
      
      $def(self, '$top', function $$top() {
        var self = this, $ret_or_1 = nil;

        return (self.top = ($truthy(($ret_or_1 = self.top)) ? ($ret_or_1) : ($$$($$('Browser'), 'Window').$new(self["native"].top))))
      });
      
      $def(self, '$opener', function $$opener() {
        var self = this, $ret_or_1 = nil;

        return (self.opener = ($truthy(($ret_or_1 = self.opener)) ? ($ret_or_1) : ($$$($$('Browser'), 'Window').$new(self["native"].opener))))
      });
      
      $def(self, '$view', function $$view() {
        var self = this, $ret_or_1 = nil;

        return (self.view = ($truthy(($ret_or_1 = self.view)) ? ($ret_or_1) : ($$('View').$new(self))))
      });
      
      $def(self, '$size', function $$size() {
        var self = this, $ret_or_1 = nil;

        return (self.size = ($truthy(($ret_or_1 = self.size)) ? ($ret_or_1) : ($$('Size').$new(self))))
      });
      
      $def(self, '$scroll', function $$scroll() {
        var self = this, $ret_or_1 = nil;

        return (self.scroll = ($truthy(($ret_or_1 = self.scroll)) ? ($ret_or_1) : ($$$($$$($$('DOM'), 'Element'), 'Scroll').$new(self))))
      });
      if ($truthy($$('Browser')['$supports?']("Window.send"))) {
        
        $def(self, '$send', function $$send(message, options) {
          var self = this, $ret_or_1 = nil;

          
          if (options == null) options = (new Map());
          return self["native"].postMessage(message, ($truthy(($ret_or_1 = options['$[]']("to"))) ? ($ret_or_1) : ("*")));
        }, -2)
      } else {
        
        $def(self, '$send', function $$send(message, options) {
          var self = this;

          
          if (options == null) options = (new Map());
          return self.$raise($$('NotImplementedError'), "message sending unsupported");
        }, -2)
      };
      return $def(self, '$close', function $$close() {
        var self = this;

        return self["native"].close()
      });
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
  $gvars.window = $$$($$('Browser'), 'Window').$new(window);
  return (function($base) {
    var self = $module($base, 'Kernel');

    
    
    
    $def(self, '$alert', function $$alert(value) {
            if ($gvars.window == null) $gvars.window = nil;

      return $gvars.window.$alert(value)
    });
    
    $def(self, '$prompt', function $$prompt(value, default$) {
            if ($gvars.window == null) $gvars.window = nil;

      
      if (default$ == null) default$ = nil;
      return $gvars.window.$prompt(value, default$);
    }, -2);
    return $def(self, '$confirm', function $$confirm(value) {
            if ($gvars.window == null) $gvars.window = nil;

      return $gvars.window.$confirm(value)
    });
  })($nesting[0]);
};

Opal.modules["browser/dom/node_set"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $slice = Opal.slice, $send = Opal.send, $defs = Opal.defs, $assign_ivar = Opal.assign_ivar, $def = Opal.def, $truthy = Opal.truthy, $to_a = Opal.to_a, $eqeqeq = Opal.eqeqeq, $thrower = Opal.thrower, $return_ivar = Opal.return_ivar, $alias = Opal.alias, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('new,uniq,map,flatten,DOM,convert,respond_to?,each,__send__,to_proc,===,at_css,at_xpath,[],css,select,=~,search,join,xpath,to_ary');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'NodeSet');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.literal = nil;
        
        $defs(self, '$[]', function $NodeSet_$$$1($a) {
          var $post_args, nodes, self = this;

          
          $post_args = $slice(arguments);
          nodes = $post_args;
          return self.$new($send(nodes.$flatten(), 'map', [], function $$2(x){var self = $$2.$$s == null ? this : $$2.$$s;

            
            if (x == null) x = nil;
            return self.$DOM($$('Native').$convert(x));}, {$$s: self}).$uniq());
        }, -1);
        
        $def(self, '$initialize', $assign_ivar("literal"));
        
        $def(self, '$method_missing', function $$method_missing(name, $a) {
          var block = $$method_missing.$$p || nil, $post_args, args, self = this, result = nil;

          $$method_missing.$$p = null;
          
          ;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          if (!$truthy(self.literal['$respond_to?'](name))) {
            
            $send(self, 'each', [], function $$3(el){
              
              if (el == null) el = nil;
              return $send(el, '__send__', [name].concat($to_a(args)), block.$to_proc());});
            return self;
          };
          result = $send(self.literal, '__send__', [name].concat($to_a(args)), block.$to_proc());
          if ($truthy(result === self.literal)) {
            return self
          } else if ($eqeqeq($$('Array'), result)) {
            return $$('NodeSet').$new(result)
          } else {
            return result
          };
        }, -2);
        
        $def(self, '$respond_to_missing?', function $NodeSet_respond_to_missing$ques$4(name, $a) {
          var $post_args, $fwd_rest, self = this;

          
          $post_args = $slice(arguments, 1);
          $fwd_rest = $post_args;
          return self.literal['$respond_to?'](name);
        }, -2);
        
        $def(self, '$at_css', function $$at_css($a) {try { var $t_return = $thrower('return'); 
          var $post_args, rules, self = this;

          
          $post_args = $slice(arguments);
          rules = $post_args;
          $send(self, 'each', [], function $$5(node){
            
            if (node == null) node = nil;
            if ($truthy((node = $send(node, 'at_css', $to_a(rules))))) {
              $t_return.$throw(node, $$5.$$is_lambda)
            } else {
              return nil
            };}, {$$ret: $t_return});
          return nil;} catch($e) {
            if ($e === $t_return) return $e.$v;
            throw $e;
          } finally {$t_return.is_orphan = true;}
        }, -1);
        
        $def(self, '$at_xpath', function $$at_xpath($a) {try { var $t_return = $thrower('return'); 
          var $post_args, paths, self = this;

          
          $post_args = $slice(arguments);
          paths = $post_args;
          $send(self, 'each', [], function $$6(node){
            
            if (node == null) node = nil;
            if ($truthy((node = $send(node, 'at_xpath', $to_a(paths))))) {
              $t_return.$throw(node, $$6.$$is_lambda)
            } else {
              return nil
            };}, {$$ret: $t_return});
          return nil;} catch($e) {
            if ($e === $t_return) return $e.$v;
            throw $e;
          } finally {$t_return.is_orphan = true;}
        }, -1);
        
        $def(self, '$css', function $$css(path) {
          var self = this;

          return $$('NodeSet')['$[]']($send(self.literal, 'map', [], function $$7(node){
            
            if (node == null) node = nil;
            return node.$css(path);}))
        });
        
        $def(self, '$filter', function $$filter(expression) {
          var self = this;

          return $$('NodeSet')['$[]']($send(self.literal, 'select', [], function $$8(node){
            
            if (node == null) node = nil;
            return node['$=~'](expression);}))
        });
        
        $def(self, '$search', function $$search($a) {
          var $post_args, what, self = this;

          
          $post_args = $slice(arguments);
          what = $post_args;
          return $$('NodeSet')['$[]']($send(self.literal, 'map', [], function $$9(node){
            
            if (node == null) node = nil;
            return $send(node, 'search', $to_a(what));}));
        }, -1);
        
        $def(self, '$outer_html', function $$outer_html() {
          var self = this;

          return $send(self.literal, 'map', [], "outer_html".$to_proc()).$join()
        });
        
        $def(self, '$xpath', function $$xpath(path) {
          var self = this;

          return $$('NodeSet')['$[]']($send(self.literal, 'map', [], function $$10(node){
            
            if (node == null) node = nil;
            return node.$xpath(path);}))
        });
        
        $def(self, '$to_ary', $return_ivar("literal"));
        return $alias(self, "to_a", "to_ary");
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/node"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $eqeq = Opal.eqeq, $truthy = Opal.truthy, $send2 = Opal.send2, $find_super = Opal.find_super, $defs = Opal.defs, $def = Opal.def, $send = Opal.send, $eqeqeq = Opal.eqeqeq, $alias = Opal.alias, $return_val = Opal.return_val, $gvars = Opal.gvars, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,==,[],new,raise,class,convert,set_native_reference,to_n,respond_to?,each,<<,to_dom,document,native?,===,>>,DOM,to_proc,add_next_sibling,parent,last,pop,select!,=~,add_previous_sibling,remove_child,remove,children,supports?,node_type,first,try_convert,elem?,select,element_children,content,content=,to_s,next,!,element?,name,name=,create_element,dup,inner_html,previous,replace');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Node');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$include($$$($$('Browser'), 'NativeCachedWrapper'));
        $const_set($nesting[0], 'ELEMENT_NODE', 1);
        $const_set($nesting[0], 'ATTRIBUTE_NODE', 2);
        $const_set($nesting[0], 'TEXT_NODE', 3);
        $const_set($nesting[0], 'CDATA_SECTION_NODE', 4);
        $const_set($nesting[0], 'ENTITY_REFERENCE_NOCE', 5);
        $const_set($nesting[0], 'ENTITY_NODE', 6);
        $const_set($nesting[0], 'PROCESSING_INSTRUCTION_NODE', 7);
        $const_set($nesting[0], 'COMMENT_NODE', 8);
        $const_set($nesting[0], 'DOCUMENT_NODE', 9);
        $const_set($nesting[0], 'DOCUMENT_TYPE_NODE', 10);
        $const_set($nesting[0], 'DOCUMENT_FRAGMENT_NODE', 11);
        $const_set($nesting[0], 'NOTATION_NODE', 12);
        $defs(self, '$new', function $Node_new$1(value) {
          var $yield = $Node_new$1.$$p || nil, self = this, $ret_or_1 = nil, klass = nil;
          if (self.classes == null) self.classes = nil;

          $Node_new$1.$$p = null;
          if ($eqeq(self, $$('Node'))) {
            
            self.classes = ($truthy(($ret_or_1 = self.classes)) ? ($ret_or_1) : ([nil, $$('Element'), $$('Attribute'), $$('Text'), $$('CDATA'), nil, nil, nil, $$('Comment'), $$('Document'), nil, $$('DocumentFragment')]));
            if ($truthy((klass = self.classes['$[]'](value.nodeType)))) {
              return klass.$new(value)
            } else {
              return self.$raise($$('ArgumentError'), "cannot instantiate a non derived Node object")
            };
          } else {
            return $send2(self, $find_super(self, 'new', $Node_new$1, false, true), 'new', [value], $yield)
          }
        });
        
        $def(self, '$initialize', function $$initialize(node) {
          var $yield = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          
          if (!$truthy(node)) {
            self.$raise($$('ArgumentError'), "Please ensure that #initialize of " + (self.$class()) + " accepts one argument")
          };
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [node], $yield);
        });
        
        $def(self, '$==', function $Node_$eq_eq$2(other) {
          var self = this;

          return self["native"] === $$('Native').$convert(other)
        });
        
        $def(self, '$initialize_copy', function $$initialize_copy(old) {
          var self = this;

          return self.$set_native_reference(old.$to_n().cloneNode(true))
        });
        
        $def(self, '$<<', function $Node_$lt$lt$3(node) {
          var self = this;

          
          if ($truthy($$('Opal')['$respond_to?'](node, "each"))) {
            
            $send(node, 'each', [], function $$4(n){var self = $$4.$$s == null ? this : $$4.$$s;

              
              if (n == null) n = nil;
              return self['$<<'](n);}, {$$s: self});
            return self;
          } else if ($truthy($$('Opal')['$respond_to?'](node, "to_dom"))) {
            node = node.$to_dom(self.$document())
          };
          if (!$truthy(self['$native?'](node))) {
            if ($eqeqeq($$('String'), node)) {
              node = self["native"].ownerDocument.createTextNode(node)
            } else {
              node = $$('Native').$convert(node)
            }
          };
          self["native"].appendChild(node);
          return self;
        });
        
        $def(self, '$>>', function $Node_$gt$gt$5(node) {
          var self = this;

          
          if ($truthy($$('Opal')['$respond_to?'](node, "each"))) {
            
            $send(node, 'each', [], function $$6(n){var self = $$6.$$s == null ? this : $$6.$$s;

              
              if (n == null) n = nil;
              return self['$>>'](n);}, {$$s: self});
            return self;
          } else if ($truthy($$('Opal')['$respond_to?'](node, "to_dom"))) {
            node = node.$to_dom(self.$document())
          };
          if (!$truthy(self['$native?'](node))) {
            if ($eqeqeq($$('String'), node)) {
              node = self["native"].ownerDocument.createTextNode(node)
            } else {
              node = $$('Native').$convert(node)
            }
          };
          if ($truthy(self["native"].firstChild == null)) {
            self["native"].appendChild(node)
          } else {
            self["native"].insertBefore(node, self["native"].firstChild)
          };
          return self;
        });
        
        $def(self, '$add_child', function $$add_child(node) {
          var block = $$add_child.$$p || nil, self = this;

          $$add_child.$$p = null;
          
          ;
          if (node == null) node = nil;
          if (!$truthy(node)) {
            node = $send(self, 'DOM', [], block.$to_proc())
          };
          return self['$<<'](node);
        }, -1);
        
        $def(self, '$add_next_sibling', function $$add_next_sibling(node) {
          var block = $$add_next_sibling.$$p || nil, self = this;

          $$add_next_sibling.$$p = null;
          
          ;
          if (node == null) node = nil;
          if (!$truthy(node)) {
            node = $send(self, 'DOM', [], block.$to_proc())
          };
          if ($truthy($$('Opal')['$respond_to?'](node, "to_dom"))) {
            node = node.$to_dom(self.$document())
          };
          if (!$truthy(self['$native?'](node))) {
            if ($eqeqeq($$('String'), node)) {
              node = self["native"].ownerDocument.createTextNode(node)
            } else {
              node = $$('Native').$convert(node)
            }
          };
          return self["native"].parentNode.insertBefore(node, self["native"].nextSibling);
        }, -1);
        
        $def(self, '$add_previous_sibling', function $$add_previous_sibling(node) {
          var block = $$add_previous_sibling.$$p || nil, self = this;

          $$add_previous_sibling.$$p = null;
          
          ;
          if (node == null) node = nil;
          if (!$truthy(node)) {
            node = $send(self, 'DOM', [], block.$to_proc())
          };
          if ($truthy($$('Opal')['$respond_to?'](node, "to_dom"))) {
            node = node.$to_dom(self.$document())
          };
          if (!$truthy(self['$native?'](node))) {
            if ($eqeqeq($$('String'), node)) {
              node = self["native"].ownerDocument.createTextNode(node)
            } else {
              node = $$('Native').$convert(node)
            }
          };
          return self["native"].parentNode.insertBefore(node, self["native"]);
        }, -1);
        $alias(self, "after", "add_next_sibling");
        
        $def(self, '$append_to', function $$append_to(node) {
          var self = this;

          
          node['$<<'](self);
          return self;
        });
        
        $def(self, '$ancestors', function $$ancestors(expression) {
          var self = this, parents = nil, parent = nil;

          
          if (expression == null) expression = nil;
          if (!$truthy(self.$parent())) {
            return $$('NodeSet')['$[]']()
          };
          parents = [self.$parent()];
          while ($truthy((parent = parents.$last().$parent()))) {
          parents['$<<'](parent)
          };
          if ($eqeqeq($$('Document'), parents.$last())) {
            parents.$pop()
          };
          if ($truthy(expression)) {
            $send(parents, 'select!', [], function $$7(p){
              
              if (p == null) p = nil;
              return p['$=~'](expression);})
          };
          return $$('NodeSet').$new(parents);
        }, -1);
        
        $def(self, '$attached?', function $Node_attached$ques$8() {
          var self = this;

          return self["native"].isConnected
        });
        $alias(self, "before", "add_previous_sibling");
        
        $def(self, '$remove', function $$remove() {
          var self = this;

          
          if ($truthy(self.$parent())) {
            self.$parent().$remove_child(self)
          };
          return self;
        });
        
        $def(self, '$clear', function $$clear() {
          var self = this;

          return self.$children().$remove()
        });
        if ($truthy($$('Browser')['$supports?']("Element.textContent"))) {
          
          
          $def(self, '$content', function $$content() {
            var self = this;

            return self["native"].textContent
          });
          
          $def(self, '$content=', function $Node_content$eq$9(value) {
            var self = this;

            return self["native"].textContent = value
          });
        } else if ($truthy($$('Browser')['$supports?']("Element.innerText"))) {
          
          
          $def(self, '$content', function $$content() {
            var self = this;

            return self["native"].innerText
          });
          
          $def(self, '$content=', function $Node_content$eq$10(value) {
            var self = this;

            return self["native"].innerText = value
          });
        } else {
          
          
          $def(self, '$content', function $$content() {
            var self = this;

            return self.$raise($$('NotImplementedError'), "node text content unsupported")
          });
          
          $def(self, '$content=', function $Node_content$eq$11(value) {
            var self = this;

            return self.$raise($$('NotImplementedError'), "node text content unsupported")
          });
        };
        
        $def(self, '$blank?', function $Node_blank$ques$12() {
          var self = this;

          return self.$raise($$('NotImplementedError'))
        });
        
        $def(self, '$cdata?', function $Node_cdata$ques$13() {
          var self = this;

          return self.$node_type()['$==']($$('CDATA_SECTION_NODE'))
        });
        
        $def(self, '$child', function $$child() {
          var self = this;

          return self.$children().$first()
        });
        
        $def(self, '$children', function $$children() {
          var self = this;

          return $$('NodeSet')['$[]']($$$($$('Native'), 'Array').$new(self["native"].childNodes))
        });
        
        $def(self, '$children=', function $Node_children$eq$14(node) {
          var self = this;

          return self.$raise($$('NotImplementedError'))
        });
        
        $def(self, '$comment?', function $Node_comment$ques$15() {
          var self = this;

          return self.$node_type()['$==']($$('COMMENT_NODE'))
        });
        
        $def(self, '$custom?', $return_val(false));
        
        $def(self, '$document', function $$document() {
          var self = this;

          if ($truthy((typeof(self["native"].ownerDocument) !== "undefined"))) {
            return self.$DOM(self["native"].ownerDocument)
          } else {
            return nil
          }
        });
        
        $def(self, '$document=', function $Node_document$eq$16(new_document) {
          var self = this;

          return $$('Native').$try_convert(new_document, new_document).adoptNode(self["native"])
        });
        
        $def(self, '$document?', function $Node_document$ques$17() {
          var self = this;

          return self.$node_type()['$==']($$('DOCUMENT_NODE'))
        });
        
        $def(self, '$elem?', function $Node_elem$ques$18() {
          var self = this;

          return self.$node_type()['$==']($$('ELEMENT_NODE'))
        });
        $alias(self, "element?", "elem?");
        
        $def(self, '$element_children', function $$element_children() {
          var self = this;

          return $send(self.$children(), 'select', [], "element?".$to_proc())
        });
        $alias(self, "elements", "element_children");
        
        $def(self, '$first_element_child', function $$first_element_child() {
          var self = this;

          return self.$element_children().$first()
        });
        
        $def(self, '$fragment?', function $Node_fragment$ques$19() {
          var self = this;

          return self.$node_type()['$==']($$('DOCUMENT_FRAGMENT_NODE'))
        });
        $alias(self, "inner_text", "content");
        $alias(self, "inner_text=", "content=");
        
        $def(self, '$last_element_child', function $$last_element_child() {
          var self = this;

          return self.$element_children().$last()
        });
        
        $def(self, '$name', function $$name() {
          var self = this;

          return self["native"].nodeName || nil
        });
        
        $def(self, '$name=', function $Node_name$eq$20(value) {
          var self = this;

          return self["native"].nodeName = value.$to_s()
        });
        
        $def(self, '$namespace', function $$namespace() {
          var self = this;

          return self["native"].namespaceURI || nil
        });
        
        $def(self, '$next', function $$next() {
          var self = this;

          if ($truthy(self["native"].nextSibling != null)) {
            return self.$DOM(self["native"].nextSibling)
          } else {
            return nil
          }
        });
        $alias(self, "next=", "add_next_sibling");
        
        $def(self, '$next_element', function $$next_element() {
          var self = this, current = nil, $ret_or_1 = nil;

          
          current = self.$next();
          while ($truthy(($truthy(($ret_or_1 = current)) ? (current['$element?']()['$!']()) : ($ret_or_1)))) {
          current = current.$next()
          };
          return current;
        });
        $alias(self, "next_sibling", "next");
        $alias(self, "node_name", "name");
        $alias(self, "node_name=", "name=");
        
        $def(self, '$node_type', function $$node_type() {
          var self = this;

          return self["native"].nodeType
        });
        
        $def(self, '$outer_html', function $$outer_html() {
          var self = this, div = nil;
          if ($gvars.document == null) $gvars.document = nil;

          
          div = $gvars.document.$create_element("DIV");
          div['$<<'](self.$dup());
          return div.$inner_html();
        });
        
        $def(self, '$parent', function $$parent() {
          var self = this;

          if ($truthy(self["native"].parentNode != null)) {
            return self.$DOM(self["native"].parentNode)
          } else {
            return nil
          }
        });
        
        $def(self, '$parent=', function $Node_parent$eq$21(node) {
          var self = this;

          return self["native"].parentNode = $$('Native').$convert(node)
        });
        
        $def(self, '$parse', function $$parse(text, options) {
          var self = this;

          
          if (options == null) options = (new Map());
          return self.$raise($$('NotImplementedError'));
        }, -2);
        
        $def(self, '$path', function $$path() {
          var self = this;

          return self.$raise($$('NotImplementedError'))
        });
        
        $def(self, '$prepend_to', function $$prepend_to(node) {
          var self = this;

          
          node['$>>'](self);
          return self;
        });
        
        $def(self, '$previous', function $$previous() {
          var self = this;

          if ($truthy(self["native"].previousSibling != null)) {
            return self.$DOM(self["native"].previousSibling)
          } else {
            return nil
          }
        });
        $alias(self, "previous=", "add_previous_sibling");
        
        $def(self, '$previous_element', function $$previous_element() {
          var self = this, current = nil, $ret_or_1 = nil;

          
          current = self.$previous();
          while ($truthy(($truthy(($ret_or_1 = current)) ? (current['$element?']()['$!']()) : ($ret_or_1)))) {
          current = current.$previous()
          };
          return current;
        });
        $alias(self, "previous_sibling", "previous");
        
        $def(self, '$remove_child', function $$remove_child(node) {
          var self = this;

          
          self["native"].removeChild($$('Native').$try_convert(node));
          return self;
        });
        
        $def(self, '$replace', function $$replace(node) {
          var self = this;

          
          if ($truthy($$('Opal')['$respond_to?'](node, "to_dom"))) {
            node = node.$to_dom(self.$document())
          };
          if (!$truthy(self['$native?'](node))) {
            if ($eqeqeq($$('String'), node)) {
              node = self["native"].ownerDocument.createTextNode(node)
            } else {
              node = $$('Native').$convert(node)
            }
          };
          self["native"].parentNode.replaceChild(node, self["native"]);
          return self.$DOM(node);
        });
        $alias(self, "replace_with", "replace");
        $alias(self, "text", "content");
        $alias(self, "text=", "content=");
        
        $def(self, '$text?', function $Node_text$ques$22() {
          var self = this;

          return self.$node_type()['$==']($$('TEXT_NODE'))
        });
        
        $def(self, '$traverse', function $$traverse() {
          var block = $$traverse.$$p || nil, self = this;

          $$traverse.$$p = null;
          
          ;
          return self.$raise($$('NotImplementedError'));
        });
        $alias(self, "type", "node_type");
        
        $def(self, '$value', function $$value() {
          var self = this;

          return self["native"].nodeValue || nil
        });
        
        $def(self, '$value=', function $Node_value$eq$23(value) {
          var self = this;

          return self["native"].nodeValue = value
        });
        return $def(self, '$inspect', function $$inspect() {
          var self = this;

          return "#<DOM::Node: " + (self.$name()) + ">"
        });
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/attribute"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,alias_native,supports?,==,name');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Attribute');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$include($$$($$('Browser'), 'NativeCachedWrapper'));
        self.$alias_native("name");
        self.$alias_native("value");
        self.$alias_native("value=");
        if ($truthy($$('Browser')['$supports?']("Attr.isId"))) {
          return self.$alias_native("id?", "isId")
        } else {
          return $def(self, '$id?', function $Attribute_id$ques$1() {
            var self = this;

            return self.$name()['$==']("id")
          })
        };
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/character_data"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'CharacterData');

        var $proto = self.$$prototype;

        $proto["native"] = nil;
        
        
        $def(self, '$append', function $$append(string) {
          var self = this;

          
          self["native"].appendData(string);
          return self;
        });
        
        $def(self, '$data', function $$data() {
          var self = this;

          return self["native"].data
        });
        
        $def(self, '$delete', function $CharacterData_delete$1(count, offset) {
          var self = this;

          
          if (offset == null) offset = 0;
          self["native"].deleteData(offset, count);
          return self;
        }, -2);
        
        $def(self, '$insert', function $$insert(string, offset) {
          var self = this;

          
          if (offset == null) offset = 0;
          self["native"].insertData(offset, string);
          return self;
        }, -2);
        self.$alias_native("length");
        
        $def(self, '$replace', function $$replace(string, offset, count) {
          var self = this;

          
          if (offset == null) offset = 0;
          if (count == null) count = self["native"].length;
          self["native"].replaceData(offset, count, string);
          return self;
        }, -2);
        return $def(self, '$substring', function $$substring(count, offset) {
          var self = this;

          
          if (offset == null) offset = 0;
          return self["native"].substringData(offset, count);
        }, -2);
      })($nesting[0], $$('Node'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/text"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $gvars = Opal.gvars, $defs = Opal.defs, $def = Opal.def, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('create_text,DOM,data');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'Text');

        var $proto = self.$$prototype;

        $proto["native"] = nil;
        
        $defs(self, '$create', function $$create(content) {
                    if ($gvars.document == null) $gvars.document = nil;

          return $gvars.document.$create_text(content)
        });
        
        $def(self, '$whole', function $$whole() {
          var self = this;

          return self["native"].wholeText
        });
        
        $def(self, '$split', function $$split(offset) {
          var self = this;

          return self.$DOM(self["native"].splitText(offset))
        });
        return $def(self, '$inspect', function $$inspect() {
          var self = this;

          return "#<DOM::Text: " + (self.$data()) + ">"
        });
      })($nesting[0], $$('CharacterData'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/cdata"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('value');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'CDATA');

        
        return $def(self, '$inspect', function $$inspect() {
          var self = this;

          return "#<DOM::CDATA: " + (self.$value()) + ">"
        })
      })($nesting[0], $$('Text'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/comment"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('value');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'Comment');

        
        return $def(self, '$inspect', function $$inspect() {
          var self = this;

          return "#<DOM::Comment: " + (self.$value()) + ">"
        })
      })($nesting[0], $$('CharacterData'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/element/attributes"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $send = Opal.send, $alias = Opal.alias, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('attr_reader,to_n,[],supports?,==,to_s,[]=,include,enum_for,each,attribute_nodes,name,value,!');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Attributes');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto.namespace = $proto["native"] = $proto.element = nil;
          
          self.$attr_reader("namespace");
          
          $def(self, '$initialize', function $$initialize(element, options) {
            var self = this;

            
            self.element = element;
            self["native"] = element.$to_n();
            return (self.namespace = options['$[]']("namespace"));
          });
          if (($truthy($$('Browser')['$supports?']("Element.className")) || ($truthy($$('Browser')['$supports?']("Element.htmlFor"))))) {
            
            
            $def(self, '$[]', function $Attributes_$$$1(name, options) {
              var self = this, namespace = nil, $ret_or_1 = nil;

              
              if (options == null) options = (new Map());
              if (($eqeq(name, "class") && ($truthy($$('Browser')['$supports?']("Element.className"))))) {
                name = "className"
              } else if (($eqeq(name, "for") && ($truthy($$('Browser')['$supports?']("Element.htmlFor"))))) {
                name = "htmlFor"
              };
              if ($truthy((namespace = ($truthy(($ret_or_1 = options['$[]']("namespace"))) ? ($ret_or_1) : (self.namespace))))) {
                return self["native"].getAttributeNS(namespace.$to_s(), name.$to_s()) || nil
              } else {
                return self["native"].getAttribute(name.$to_s()) || nil
              };
            }, -2);
            
            $def(self, '$[]=', function $Attributes_$$$eq$2(name, value, options) {
              var self = this, namespace = nil, $ret_or_1 = nil;

              
              if (options == null) options = (new Map());
              if (($eqeq(name, "class") && ($truthy($$('Browser')['$supports?']("Element.className"))))) {
                name = "className"
              } else if (($eqeq(name, "for") && ($truthy($$('Browser')['$supports?']("Element.htmlFor"))))) {
                name = "htmlFor"
              };
              if ($truthy((namespace = ($truthy(($ret_or_1 = options['$[]']("namespace"))) ? ($ret_or_1) : (self.namespace))))) {
                if ($truthy(value)) {
                  return self["native"].setAttributeNS(namespace.$to_s(), name.$to_s(), value)
                } else {
                  return self["native"].removeAttributeNS(namespace.$to_s(), name.$to_s())
                }
              } else if ($truthy(value)) {
                return self["native"].setAttribute(name.$to_s(), value.$to_s())
              } else {
                return self["native"].removeAttribute(name.$to_s())
              };
            }, -3);
          } else {
            
            
            $def(self, '$[]', function $Attributes_$$$3(name, options) {
              var self = this, namespace = nil, $ret_or_1 = nil;

              
              if (options == null) options = (new Map());
              if ($truthy((namespace = ($truthy(($ret_or_1 = options['$[]']("namespace"))) ? ($ret_or_1) : (self.namespace))))) {
                return self["native"].getAttributeNS(namespace.$to_s(), name.$to_s()) || nil
              } else {
                return self["native"].getAttribute(name.$to_s()) || nil
              };
            }, -2);
            
            $def(self, '$[]=', function $Attributes_$$$eq$4(name, value, options) {
              var self = this, namespace = nil, $ret_or_1 = nil;

              
              if (options == null) options = (new Map());
              if ($truthy((namespace = ($truthy(($ret_or_1 = options['$[]']("namespace"))) ? ($ret_or_1) : (self.namespace))))) {
                if ($truthy(value)) {
                  return self["native"].setAttributeNS(namespace.$to_s(), name.$to_s(), value)
                } else {
                  return self["native"].removeAttributeNS(namespace.$to_s(), name.$to_s())
                }
              } else if ($truthy(value)) {
                return self["native"].setAttribute(name.$to_s(), value.$to_s())
              } else {
                return self["native"].removeAttribute(name.$to_s())
              };
            }, -3);
          };
          
          $def(self, '$delete', function $Attributes_delete$5(name) {
            var self = this, attr = nil;

            
            attr = self['$[]'](name);
            self['$[]='](name, nil);
            return attr;
          });
          self.$include($$('Enumerable'));
          
          $def(self, '$each', function $$each() {
            var block = $$each.$$p || nil, self = this;

            $$each.$$p = null;
            
            ;
            if (!(block !== nil)) {
              return self.$enum_for("each")
            };
            $send(self.element.$attribute_nodes(), 'each', [], function $$6(attr){
              
              if (attr == null) attr = nil;
              return Opal.yieldX(block, [attr.$name(), attr.$value()]);;});
            return self;
          });
          $alias(self, "get", "[]");
          
          $def(self, '$has_key?', function $Attributes_has_key$ques$7(name) {
            var self = this;

            return self['$[]'](name)['$!']()['$!']()
          });
          
          $def(self, '$merge!', function $Attributes_merge$excl$8(hash) {
            var self = this;

            
            $send(hash, 'each', [], function $$9(name, value){var $a, self = $$9.$$s == null ? this : $$9.$$s;

              
              if (name == null) name = nil;
              if (value == null) value = nil;
              return ($a = [name, value], $send(self, '[]=', $a), $a[$a.length - 1]);}, {$$s: self});
            return self;
          });
          return $alias(self, "set", "[]=");
        })($nesting[0], null, $nesting)
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/element/data"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def, $send = Opal.send, $gvars = Opal.gvars, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('attr_reader,to_n,include,enum_for,call,each,attributes,=~,[]=,[],include?,respond_to?,to_str,to_s,to_int');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Data');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto["native"] = $proto.element = nil;
          
          self.$attr_reader("element");
          
          $def(self, '$initialize', function $$initialize(element) {
            var self = this;

            
            self.element = element;
            self["native"] = element.$to_n();
            if ($truthy((typeof(self["native"].$data) !== "undefined"))) {
              return nil
            } else {
              return self["native"].$data = {}
            };
          });
          self.$include($$('Enumerable'));
          
          $def(self, '$each', function $$each() {
            var block = $$each.$$p || nil, self = this;

            $$each.$$p = null;
            
            ;
            if (!$truthy(block)) {
              return self.$enum_for("each")
            };
            
      var data = self["native"].$data;

      for (var key in data) {
        block.$call(key, data[key]);
      }
    ;
            $send(self.element.$attributes(), 'each', [], function $$1(name, value){var $a;

              
              if (name == null) name = nil;
              if (value == null) value = nil;
              if ($truthy(name['$=~'](/^data-(.*)$/))) {
                return block.$call((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)), value)
              } else {
                return nil
              };});
            return self;
          });
          
          $def(self, '$assign', function $$assign(data) {
            var self = this;

            
            $send(data, 'each', [], function $$2(name, value){var $a, self = $$2.$$s == null ? this : $$2.$$s;

              
              if (name == null) name = nil;
              if (value == null) value = nil;
              return ($a = [name, value], $send(self, '[]=', $a), $a[$a.length - 1]);}, {$$s: self});
            return self;
          });
          
          $def(self, '$[]', function $Data_$$$3(name) {
            var self = this, data = nil;

            
            if ($truthy((data = self.element['$[]']("data-" + (name))))) {
              return data
            };
            
      var value = self["native"].$data[name];

      if (value === undefined) {
        return nil;
      }
      else {
        return value;
      }
    ;
          });
          
          $def(self, '$[]=', function $Data_$$$eq$4(name, value) {
            var $a, self = this;

            
            delete self["native"].$data[name];
            if ($truthy([true, false, nil]['$include?'](value))) {
              return ($a = ["data-" + (name), value], $send(self.element, '[]=', $a), $a[$a.length - 1])
            } else if ($truthy(value['$respond_to?']("to_str"))) {
              return ($a = ["data-" + (name), value.$to_str()], $send(self.element, '[]=', $a), $a[$a.length - 1])
            } else if ($truthy(value['$respond_to?']("to_int"))) {
              return ($a = ["data-" + (name), value.$to_int().$to_s()], $send(self.element, '[]=', $a), $a[$a.length - 1])
            } else {
              return self["native"].$data[name] = value
            };
          });
          return $def(self, '$delete', function $Data_delete$5(name) {
            var self = this, data = nil;

            
            data = self['$[]'](name);
            self['$[]='](name, nil);
            return data;
          });
        })($nesting[0], null, $nesting)
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/element/position"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $eqeq = Opal.eqeq, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('attr_reader,to_n,offset,get,parent,new,==,[],style,=~,x=,+,x,to_i,y=,y,-');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Position');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto.element = nil;
          
          self.$attr_reader("element");
          
          $def(self, '$initialize', function $$initialize(element) {
            var self = this;

            
            self.element = element;
            return (self["native"] = element.$to_n());
          });
          
          $def(self, '$get', function $$get() {
            var self = this, offset = nil, position = nil, parent = nil, parent_offset = nil;

            
            offset = self.element.$offset();
            position = offset.$get();
            parent = offset.$parent();
            parent_offset = $$$($$('Browser'), 'Position').$new(0, 0);
            if ($eqeq(self.element.$style()['$[]']("position"), "fixed")) {
              
              if (!$truthy(parent['$=~']("html"))) {
                parent_offset = parent.$offset()
              };
              parent_offset['$x=']($rb_plus(parent_offset.$x(), parent.$style()['$[]']("border-top-width").$to_i()));
              parent_offset['$y=']($rb_plus(parent_offset.$y(), parent.$style()['$[]']("border-left-width").$to_i()));
            };
            return $$$($$('Browser'), 'Position').$new($rb_minus($rb_minus(position.$x(), parent_offset.$x()), self.element.$style()['$[]']("margin-left").$to_i()), $rb_minus($rb_minus(position.$y(), parent_offset.$y()), self.element.$style()['$[]']("margin-top").$to_i()));
          });
          
          $def(self, '$x', function $$x() {
            var self = this;

            return self.$get().$x()
          });
          return $def(self, '$y', function $$y() {
            var self = this;

            return self.$get().$y()
          });
        })($nesting[0], null, $nesting)
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/element/offset"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $slice = Opal.slice, $eqeq = Opal.eqeq, $eqeqeq = Opal.eqeqeq, $to_ary = Opal.to_ary, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $send = Opal.send, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('attr_reader,to_n,DOM,root,document,x,get,set,y,supports?,window,new,[],style!,==,[]=,style,to_u,===,first,+,-,px');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Offset');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto["native"] = $proto.element = nil;
          
          self.$attr_reader("element");
          
          $def(self, '$initialize', function $$initialize(element) {
            var self = this;

            
            self.element = element;
            return (self["native"] = element.$to_n());
          });
          
          $def(self, '$parent', function $$parent() {
            var self = this;

            return self.$DOM(self["native"].offsetParent || self.element.$document().$root().$to_n())
          });
          
          $def(self, '$x', function $$x() {
            var self = this;

            return self.$get().$x()
          });
          
          $def(self, '$x=', function $Offset_x$eq$1(value) {
            var self = this;

            return self.$set(value, nil)
          });
          
          $def(self, '$y', function $$y() {
            var self = this;

            return self.$get().$y()
          });
          
          $def(self, '$y=', function $Offset_y$eq$2(value) {
            var self = this;

            return self.$set(nil, value)
          });
          if ($truthy($$('Browser')['$supports?']("Element.getBoundingClientRect"))) {
            
            $def(self, '$get', function $$get() {
              var self = this, doc = nil, root = nil, win = nil;

              
              doc = self.element.$document();
              root = doc.$root().$to_n();
              win = doc.$window().$to_n();
              
        var box = self["native"].getBoundingClientRect(),
            y   = box.top + (win.pageYOffset || root.scrollTop) - (root.clientTop || 0),
            x   = box.left + (win.pageXOffset || root.scrollLeft) - (root.clientLeft || 0);
      ;
              return $$$($$('Browser'), 'Position').$new(x, y);
            })
          } else {
            
            $def(self, '$get', function $$get() {
              var self = this, doc = nil, root = nil, win = nil;

              
              doc = self.$document();
              root = doc.$root().$to_n();
              win = doc.$window().$to_n();
              
        var y = (win.pageYOffset || root.scrollTop) - (root.clientTop || 0),
            x = (win.pageXOffset || root.scrollLeft) - (root.clientLeft || 0);
      ;
              return $$$($$('Browser'), 'Position').$new(x, y);
            })
          };
          return $def(self, '$set', function $$set($a) {
            var $post_args, value, $b, $c, self = this, position = nil, offset = nil, top = nil, left = nil, x = nil, y = nil;

            
            $post_args = $slice(arguments);
            value = $post_args;
            position = self.element['$style!']()['$[]']("position");
            if ($eqeq(position, "static")) {
              self.element.$style()['$[]=']("position", "relative")
            };
            offset = self.$get();
            top = self.element['$style!']()['$[]']("top").$to_u();
            left = self.element['$style!']()['$[]']("left").$to_u();
            if ($eqeqeq($$$($$('Browser'), 'Position'), value.$first())) {
              $b = [value.$first().$x(), value.$first().$y()], (x = $b[0]), (y = $b[1]), $b
            } else if ($eqeqeq($$('Hash'), value.$first())) {
              $b = [value.$first()['$[]']("x"), value.$first()['$[]']("y")], (x = $b[0]), (y = $b[1]), $b
            } else {
              $c = value, $b = $to_ary($c), (x = ($b[0] == null ? nil : $b[0])), (y = ($b[1] == null ? nil : $b[1])), $c
            };
            if ($truthy(x)) {
              self.element.$style()['$[]=']("left", $rb_plus($rb_minus(x.$px(), offset.$x()), left))
            };
            if ($truthy(y)) {
              return ($b = ["top", $rb_plus($rb_minus(y.$px(), offset.$y()), top)], $send(self.element.$style(), '[]=', $b), $b[$b.length - 1])
            } else {
              return nil
            };
          }, -1);
        })($nesting[0], null, $nesting)
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/element/scroll"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def, $slice = Opal.slice, $eqeqeq = Opal.eqeqeq, $to_ary = Opal.to_ary, $rb_plus = Opal.rb_plus, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('attr_reader,to_n,include?,class,===,first,[],set,set_by,supports?,private,+,x,y,new,raise,position');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Scroll');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto["native"] = $proto.element = $proto.scrolling_native = nil;
          
          self.$attr_reader("element");
          
          $def(self, '$initialize', function $$initialize(element) {
            var self = this;

            
            self.element = element;
            self["native"] = element.$to_n();
            self.scrolling_native = self["native"];
            if ($truthy([$$('Document'), $$('Window')]['$include?'](self.element.$class()))) {
              
              if ($truthy((typeof(self.scrolling_native.document) !== "undefined"))) {
                self.scrolling_native = self.scrolling_native.document
              };
              if ($truthy((typeof(self.scrolling_native.documentElement.scrollTop) !== "undefined"))) {
                return (self.scrolling_native = self.scrolling_native.documentElement)
              } else if ($truthy((typeof(self.scrolling_native.body.scrollTop) !== "undefined"))) {
                return (self.scrolling_native = self.scrolling_native.body)
              } else {
                return nil
              };
            } else {
              return nil
            };
          });
          
          $def(self, '$to', function $$to($a) {
            var $post_args, args, $b, $c, self = this, x = nil, y = nil, $ret_or_1 = nil;

            
            $post_args = $slice(arguments);
            args = $post_args;
            $b = [nil, nil], (x = $b[0]), (y = $b[1]), $b;
            if ($eqeqeq($$('Hash'), ($ret_or_1 = args.$first()))) {
              
              x = args.$first()['$[]']("x");
              y = args.$first()['$[]']("y");
            } else if ($eqeqeq("top", $ret_or_1)) {
              y = 0
            } else if ($eqeqeq("bottom", $ret_or_1)) {
              y = 99999999
            } else {
              $c = args, $b = $to_ary($c), (x = ($b[0] == null ? nil : $b[0])), (y = ($b[1] == null ? nil : $b[1])), $c
            };
            if (($truthy(x) || ($truthy(y)))) {
              self.$set(x, y)
            };
            return self;
          }, -1);
          
          $def(self, '$by', function $$by($a) {
            var $post_args, args, $b, $c, self = this, $ret_or_1 = nil, x = nil, $ret_or_2 = nil, y = nil;

            
            $post_args = $slice(arguments);
            args = $post_args;
            if ($eqeqeq($$('Hash'), ($ret_or_1 = args.$first()))) {
              
              x = ($truthy(($ret_or_2 = args.$first()['$[]']("x"))) ? ($ret_or_2) : (0));
              y = ($truthy(($ret_or_2 = args.$first()['$[]']("y"))) ? ($ret_or_2) : (0));
            } else {
              $c = args, $b = $to_ary($c), (x = ($b[0] == null ? nil : $b[0])), (y = ($b[1] == null ? nil : $b[1])), $c
            };
            self.$set_by(x, y);
            return self;
          }, -1);
          if ($truthy($$('Browser')['$supports?']("Element.scrollBy"))) {
            self.$private($def(self, '$set_by', function $$set_by(x, y) {
              var self = this;

              return self.scrolling_native.scrollBy(x, y)
            }))
          } else {
            self.$private($def(self, '$set_by', function $$set_by(x, y) {
              var self = this;

              return self.$set($rb_plus(self.$x(), x), $rb_plus(self.$y(), y))
            }))
          };
          if ($truthy($$('Browser')['$supports?']("Element.scroll"))) {
            
            self.$private($def(self, '$set', function $$set(x, y) {
              var self = this;

              
              if (x == null) x = nil;
              if (y == null) y = nil;
              if ($truthy(y)) {
                self.scrolling_native.scrollTop  = y
              };
              if ($truthy(x)) {
                return self.scrolling_native.scrollLeft = x
              } else {
                return nil
              };
            }, -1));
            
            $def(self, '$position', function $$position() {
              var self = this;

              return $$$($$('Browser'), 'Position').$new(self.scrolling_native.scrollLeft, self.scrolling_native.scrollTop)
            });
          } else {
            
            self.$private($def(self, '$set', function $$set(x, y) {
              var self = this;

              
              if (x == null) x = nil;
              if (y == null) y = nil;
              return self.$raise($$('NotImplementedError'), "scroll on element unsupported");
            }, -1));
            
            $def(self, '$position', function $$position() {
              var self = this;

              return self.$raise($$('NotImplementedError'), "scroll on element unsupported")
            });
          };
          
          $def(self, '$x', function $$x() {
            var self = this;

            return self.$position().$x()
          });
          
          $def(self, '$y', function $$y() {
            var self = this;

            return self.$position().$y()
          });
          
          $def(self, '$height', function $$height() {
            var self = this;

            return self.scrolling_native.scrollHeight
          });
          
          $def(self, '$width', function $$width() {
            var self = this;

            return self.scrolling_native.scrollWidth
          });
          if ($truthy($$('Browser')['$supports?']("Element.scrollIntoViewIfNeeded"))) {
            
            $def(self, '$into_view', function $$into_view(align) {
              var self = this;

              
              if (align == null) align = true;
              return self.scrolling_native.scrollIntoViewIfNeeded(align);
            }, -1)
          } else {
            
            $def(self, '$into_view', function $$into_view(align) {
              var self = this;

              
              if (align == null) align = true;
              return self.$raise($$('NotImplementedError'));
            }, -1)
          };
          return $def(self, '$into_view!', function $Scroll_into_view$excl$1(align) {
            var self = this;

            
            if (align == null) align = true;
            return self.scrolling_native.scrollIntoView(align);
          }, -1);
        })($nesting[0], null, $nesting)
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/element/size"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $slice = Opal.slice, $def = Opal.def, $send = Opal.send, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('attr_reader,to_n,[]=,style');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Size');

          var $proto = self.$$prototype;

          $proto["native"] = $proto.element = nil;
          
          self.$attr_reader("element");
          
          $def(self, '$initialize', function $$initialize(element, $a) {
            var $post_args, inc, self = this;

            
            $post_args = $slice(arguments, 1);
            inc = $post_args;
            self.element = element;
            self["native"] = element.$to_n();
            return (self.include = inc);
          }, -2);
          
          $def(self, '$width', function $$width() {
            var self = this;

            return self["native"].offsetWidth
          });
          
          $def(self, '$width=', function $Size_width$eq$1(value) {
            var $a, self = this;

            return ($a = ["width", value], $send(self.element.$style(), '[]=', $a), $a[$a.length - 1])
          });
          
          $def(self, '$height', function $$height() {
            var self = this;

            return self["native"].offsetHeight
          });
          
          $def(self, '$height=', function $Size_height$eq$2(value) {
            var $a, self = this;

            return ($a = ["height", value], $send(self.element.$style(), '[]=', $a), $a[$a.length - 1])
          });
          
          $def(self, '$client_width', function $$client_width() {
            var self = this;

            return self["native"].clientWidth
          });
          return $def(self, '$client_height', function $$client_height() {
            var self = this;

            return self["native"].clientHeight
          });
        })($nesting[0], null)
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/element/button"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('def_selector');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Button');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$def_selector("button");
          
          $def(self, '$disabled?', function $Button_disabled$ques$1() {
            var self = this;

            return self["native"].disabled
          });
          
          $def(self, '$disabled=', function $Button_disabled$eq$2(value) {
            var self = this;

            return self["native"].disabled = value
          });
          
          $def(self, '$autofocus?', function $Button_autofocus$ques$3() {
            var self = this;

            return self["native"].autofocus
          });
          
          $def(self, '$autofocus=', function $Button_autofocus$eq$4(value) {
            var self = this;

            return self["native"].autofocus = value
          });
          
          $def(self, '$name_', function $$name_() {
            var self = this;

            return self["native"].name
          });
          return $def(self, '$name_=', function $Button_name_$eq$5(value) {
            var self = this;

            return self["native"].name = value
          });
        })($nesting[0], $$('Element'))
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/element/image"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $const_set = Opal.const_set, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('def_selector');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        (function($base, $super) {
          var self = $klass($base, $super, 'Image');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$def_selector("img");
          
          $def(self, '$complete?', function $Image_complete$ques$1() {
            var self = this;

            return self["native"].complete
          });
          
          $def(self, '$cross?', function $Image_cross$ques$2() {
            var self = this;

            return self["native"].crossOrigin
          });
          
          $def(self, '$height', function $$height() {
            var self = this;

            return self["native"].naturalHeight
          });
          return $def(self, '$width', function $$width() {
            var self = this;

            return self["native"].naturalWidth
          });
        })($nesting[0], $$('Element'));
        return $const_set($nesting[0], 'Img', $$('Image'));
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/element/form"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $send = Opal.send, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('def_selector,create,to_n,form_data,==,encoding,to_h,send,method,target,to_proc,alias_native,[],new');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Form');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$def_selector("form");
          
          $def(self, '$form_data', function $$form_data() {
            var self = this;

            return $$('FormData').$create(self)
          });
          
          $def(self, '$valid?', function $Form_valid$ques$1() {
            var self = this;

            return self["native"].reportValidity()
          });
          
          $def(self, '$submit', function $$submit() {
            var self = this;

            return self["native"].submit()
          });
          
          $def(self, '$request_submit', function $$request_submit(submitter) {
            var self = this;

            
            if (submitter == null) submitter = nil;
            if ($truthy(submitter)) {
              return self["native"].requestSubmit(submitter.$to_n())
            } else {
              return self["native"].requestSubmit()
            };
          }, -1);
          
          $def(self, '$ajax_submit', function $$ajax_submit() {
            var block = $$ajax_submit.$$p || nil, self = this, data = nil;

            $$ajax_submit.$$p = null;
            
            ;
            data = self.$form_data();
            if (!$eqeq(self.$encoding(), "multipart/form-data")) {
              data = data.$to_h()
            };
            return $send($$('HTTP'), 'send', [self.$method(), self.$target(), self.$form_data()], block.$to_proc());
          });
          
          $def(self, '$reset', function $$reset() {
            var self = this;

            return self["native"].reset()
          });
          self.$alias_native("action");
          self.$alias_native("action=");
          self.$alias_native("method");
          self.$alias_native("method=");
          self.$alias_native("target");
          self.$alias_native("target=");
          self.$alias_native("encoding");
          self.$alias_native("encoding=");
          return $def(self, '$controls', function $$controls() {
            var self = this;

            return $$('NodeSet')['$[]']($$$($$('Native'), 'Array').$new(self["native"].elements))
          });
        })($nesting[0], $$('Element'), $nesting)
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/element/input"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $send = Opal.send, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('def_selector,map,new,to_n');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Input');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$def_selector("input");
          
          $def(self, '$value', function $$value() {
            var self = this;

            
      if (self["native"].value == "") {
        return nil;
      }
      else {
        return self["native"].value;
      }
    
          });
          
          $def(self, '$value=', function $Input_value$eq$1(value) {
            var self = this;

            return self["native"].value = value
          });
          
          $def(self, '$name_', function $$name_() {
            var self = this;

            return self["native"].name
          });
          
          $def(self, '$type', function $$type() {
            var self = this;

            return self["native"].type
          });
          
          $def(self, '$checked?', function $Input_checked$ques$2() {
            var self = this;

            return self["native"].checked
          });
          
          $def(self, '$check!', function $Input_check$excl$3() {
            var self = this;

            return self["native"].checked = 'checked'
          });
          
          $def(self, '$uncheck!', function $Input_uncheck$excl$4() {
            var self = this;

            return self["native"].checked = ''
          });
          
          $def(self, '$enabled?', function $Input_enabled$ques$5() {
            var self = this;

            return self["native"].enabled
          });
          
          $def(self, '$disable!', function $Input_disable$excl$6() {
            var self = this;

            return self["native"].disabled = 'disabled'
          });
          
          $def(self, '$enable!', function $Input_enable$excl$7() {
            var self = this;

            return self["native"].disabled = ''
          });
          
          $def(self, '$clear', function $$clear() {
            var self = this;

            return self["native"].value = ''
          });
          return $def(self, '$files', function $$files() {
            var self = this;

            return $send($$$($$('Native'), 'Array').$new(self["native"].files), 'map', [], function $$8(f){
              
              if (f == null) f = nil;
              return $$('File').$new(f.$to_n());})
          });
        })($nesting[0], $$('Element'), $nesting)
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/element/select"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('def_selector,to_n,[],new,DOM,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Select');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$def_selector("select");
          
          $def(self, '$value', function $$value() {
            var self = this;

            
      if (self["native"].value == "") {
        return nil;
      }
      else {
        return self["native"].value;
      }
    
          });
          
          $def(self, '$value=', function $Select_value$eq$1(value) {
            var self = this;

            return self["native"].value = value.$to_n()
          });
          
          $def(self, '$labels', function $$labels() {
            var self = this;

            return $$('NodeSet')['$[]']($$$($$('Native'), 'Array').$new(self["native"].labels))
          });
          
          $def(self, '$options', function $$options() {
            var self = this;

            return $$('NodeSet')['$[]']($$$($$('Native'), 'Array').$new(self["native"].options))
          });
          
          $def(self, '$option', function $$option() {
            var self = this;

            return self.$DOM(self["native"].options[self["native"].selectedIndex])
          });
          
          $def(self, '$index', function $$index() {
            var self = this;

            return self["native"].selectedIndex
          });
          self.$alias_native("multiple?", "multiple");
          self.$alias_native("required?", "required");
          return self.$alias_native("length");
        })($nesting[0], $$('Element'), $nesting)
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/element/template"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('def_selector,DOM');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Template');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$def_selector("template");
          return $def(self, '$content', function $$content() {
            var self = this;

            return self.$DOM(self["native"].content)
          });
        })($nesting[0], $$('Element'))
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/element/textarea"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('def_selector');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super) {
          var self = $klass($base, $super, 'Textarea');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$def_selector("textarea");
          
          $def(self, '$value', function $$value() {
            var self = this;

            
      if (self["native"].value == "") {
        return nil;
      }
      else {
        return self["native"].value;
      }
    
          });
          
          $def(self, '$value=', function $Textarea_value$eq$1(value) {
            var self = this;

            return self["native"].value = value
          });
          return $def(self, '$clear', function $$clear() {
            var self = this;

            return self["native"].value = ''
          });
        })($nesting[0], $$('Element'))
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/element/iframe"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('def_selector,alias_native,new,DOM,send,content_window');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Iframe');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$def_selector("iframe");
          self.$alias_native("src");
          self.$alias_native("src=");
          
          $def(self, '$content_window', function $$content_window() {
            var self = this;

            return $$$($$('Browser'), 'Window').$new(self["native"].contentWindow)
          });
          
          $def(self, '$content_document', function $$content_document() {
            var self = this;

            return self.$DOM(self["native"].contentDocument || self["native"].contentWindow.document)
          });
          return $def(self, '$send', function $$send(message, options) {
            var self = this;

            
            if (options == null) options = (new Map());
            return self.$content_window().$send(message, options);
          }, -2);
        })($nesting[0], $$('Element'), $nesting);
        return (function($base, $super) {
          var self = $klass($base, $super, 'Object');

          
          return self.$def_selector("object")
        })($nesting[0], $$('Iframe'));
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/element/media"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('def_selector');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        (function($base, $super) {
          var self = $klass($base, $super, 'Media');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          return $def(self, '$play', function $$play() {
            var self = this;

            return self["native"].play()
          })
        })($nesting[0], $$('Element'));
        (function($base, $super) {
          var self = $klass($base, $super, 'Video');

          
          return self.$def_selector("video")
        })($nesting[0], $$('Media'));
        return (function($base, $super) {
          var self = $klass($base, $super, 'Audio');

          
          return self.$def_selector("audio")
        })($nesting[0], $$('Media'));
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/element"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $slice = Opal.slice, $eqeqeq = Opal.eqeqeq, $gvars = Opal.gvars, $eqeq = Opal.eqeq, $send = Opal.send, $to_a = Opal.to_a, $truthy = Opal.truthy, $defs = Opal.defs, $return_ivar = Opal.return_ivar, $not = Opal.not, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $alias = Opal.alias, $rb_plus = Opal.rb_plus, $thrower = Opal.thrower, $rb_minus = Opal.rb_minus, $to_ary = Opal.to_ary, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('===,first,shift,==,create_element,to_proc,last,pop,upcase,scan,flatten,delete,|,to_h,map,merge,raise,<<,subclasses,=~,native?,[],!,length,create,select,native_is?,new,include,target,DOM,tag_name,native_matches?,selector,supports?,loaded?,xpath,get,attributes,set,+,class_names,empty?,join,uniq,css,each,alias_native,reject,split,assign,height,size,height=,to_s,inner_dom=,to_a,document,clear,downcase,name,id,gsub,class,offset,concat,[]=,replace,apply,to_n,window,-,partition,include?,add_class,remove_class,width,width=,require');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = $proto.position = $proto.scroll = nil;
        
        $defs(self, '$create', function $$create($a) {
          var block = $$create.$$p || nil, $post_args, args, $b, self = this, document = nil, kwargs = nil, custom_attrs = nil, custom_id = nil, custom_classes = nil, tag_name = nil, $ret_or_1 = nil, classes = nil, id = nil, attrs = nil;
          if (self.tag_name == null) self.tag_name = nil;
          if (self.selector == null) self.selector = nil;
          if ($gvars.document == null) $gvars.document = nil;

          $$create.$$p = null;
          
          ;
          $post_args = $slice(arguments);
          args = $post_args;
          if ($eqeqeq($$('Document'), args.$first())) {
            document = args.$shift()
          } else {
            document = $gvars.document
          };
          if ($eqeq(self, $$('Element'))) {
            return $send(document, 'create_element', $to_a(args), block.$to_proc())
          } else if ($truthy(self.tag_name)) {
            return $send(document, 'create_element', [self.tag_name].concat($to_a(args)), block.$to_proc())
          } else if ($truthy(self.selector)) {
            
            kwargs = (new Map());
            if ($eqeqeq($$('Hash'), args.$last())) {
              kwargs = args.$pop()
            };
            $b = [nil, nil, nil], (custom_attrs = $b[0]), (custom_id = $b[1]), (custom_classes = $b[2]), $b;
            tag_name = ($truthy(($ret_or_1 = self.selector.$scan(/^[\w-]+/).$first())) ? ($ret_or_1) : ("div")).$upcase();
            classes = self.selector.$scan(/\.([\w-]+)/).$flatten();
            if ($truthy((custom_classes = kwargs.$delete("classes")))) {
              classes = classes['$|'](custom_classes)
            };
            id = self.selector.$scan(/#([\w-]+)/).$flatten().$first();
            if ($truthy((custom_id = kwargs.$delete("id")))) {
              id = custom_id
            };
            attrs = $send(self.selector.$scan(/\[([\w-]+)=((["'])(.*?)\3|[\w_-]*)\]/), 'map', [], function $$1(a, b, _, d){
              
              if (a == null) a = nil;
              if (b == null) b = nil;
              if (_ == null) _ = nil;
              if (d == null) d = nil;
              return [a, ($truthy(($ret_or_1 = d)) ? ($ret_or_1) : (b))];}).$to_h();
            if ($truthy((custom_attrs = kwargs.$delete("attrs")))) {
              attrs = attrs.$merge(custom_attrs)
            };
            return $send(document, 'create_element', [tag_name].concat($to_a(args)).concat([(new Map([["classes", classes], ["id", id], ["attrs", attrs]])).$merge(Opal.to_hash(kwargs))]), block.$to_proc());
          } else {
            return self.$raise($$('NotImplementedError'))
          };
        }, -1);
        $defs(self, '$subclasses', function $$subclasses() {
          var self = this, $ret_or_1 = nil;
          if (self.subclasses == null) self.subclasses = nil;

          return (self.subclasses = ($truthy(($ret_or_1 = self.subclasses)) ? ($ret_or_1) : ([])))
        });
        $defs(self, '$def_selector', function $$def_selector(selector) {
          var self = this;

          
          $$('Element').$subclasses()['$<<'](self);
          self.selector = selector;
          if ($truthy(selector['$=~'](/[^\w-]/))) {
            return nil
          } else {
            return (self.tag_name = selector.$upcase())
          };
        });
        $defs(self, '$selector', $return_ivar("selector"));
        $defs(self, '$tag_name', $return_ivar("tag_name"));
        $defs(self, '$new', function $Element_new$2($a) {
          var block = $Element_new$2.$$p || nil, $post_args, args, self = this, node = nil, subclass = nil;

          $Element_new$2.$$p = null;
          
          ;
          $post_args = $slice(arguments);
          args = $post_args;
          if ((($eqeq(args.$length(), 1) && ($not((block !== nil)))) && ($truthy($$('Opal')['$native?'](args['$[]'](0)))))) {
            node = args['$[]'](0)
          } else {
            return $send(self, 'create', $to_a(args), block.$to_proc())
          };
          if ($eqeq(self, $$('Element'))) {
            
            subclass = $send($$('Element').$subclasses(), 'select', [], function $$3(subclass){
              
              if (subclass == null) subclass = nil;
              return $$('Element')['$native_is?'](node, subclass);}).$last();
            if ($truthy(subclass)) {
              return subclass.$new(node)
            } else {
              return $send2(self, $find_super(self, 'new', $Element_new$2, false, true), 'new', [node], null)
            };
          } else {
            return $send2(self, $find_super(self, 'new', $Element_new$2, false, true), 'new', [node], null)
          };
        }, -1);
        self.$include($$$($$('Event'), 'Target'));
        $send(self, 'target', [], function $Element$4(value){var self = $Element$4.$$s == null ? this : $Element$4.$$s;

          
          if (value == null) value = nil;
          try {
            return self.$DOM(value)
          } catch ($err) {
            if (Opal.rescue($err, [$$('StandardError'), $$$($$('JS'), 'Error')])) {
              try {
                return nil
              } finally { Opal.pop_exception($err); }
            } else { throw $err; }
          };}, {$$s: self});
        $defs(self, '$native_is?', function $Element_native_is$ques$5(native$, klass) {
          var tag_name = nil, is = nil;

          if ($truthy((tag_name = klass.$tag_name()))) {
            
            is = (native$.getAttribute("is") || "");
            return tag_name === is.toUpperCase() || tag_name === native$.nodeName;
          } else {
            return $$('Element')['$native_matches?'](native$, klass.$selector())
          }
        });
        if ($truthy($$('Browser')['$supports?']("Element.matches"))) {
          $defs(self, '$native_matches?', function $Element_native_matches$ques$6(native$, selector) {
            
            return native$.matches(selector)
          })
        } else if ($truthy($$('Browser')['$supports?']("Element.matches (Opera)"))) {
          $defs(self, '$native_matches?', function $Element_native_matches$ques$7(native$, selector) {
            
            return native$.oMatchesSelector(selector)
          })
        } else if ($truthy($$('Browser')['$supports?']("Element.matches (Internet Explorer)"))) {
          $defs(self, '$native_matches?', function $Element_native_matches$ques$8(native$, selector) {
            
            return native$.msMatchesSelector(selector)
          })
        } else if ($truthy($$('Browser')['$supports?']("Element.matches (Firefox)"))) {
          $defs(self, '$native_matches?', function $Element_native_matches$ques$9(native$, selector) {
            
            return native$.mozMatchesSelector(selector)
          })
        } else if ($truthy($$('Browser')['$supports?']("Element.matches (Chrome)"))) {
          $defs(self, '$native_matches?', function $Element_native_matches$ques$10(native$, selector) {
            
            return native$.webkitMatchesSelector(selector)
          })
        } else if ($truthy($$('Browser')['$loaded?']("Sizzle"))) {
          $defs(self, '$native_matches?', function $Element_native_matches$ques$11(native$, selector) {
            
            return Sizzle.matchesSelector(native$, selector)
          })
        } else {
          $defs(self, '$native_matches?', function $Element_native_matches$ques$12(native$, selector) {
            var self = this;

            return self.$raise($$('NotImplementedError'), "selector matching unsupported")
          })
        };
        
        $def(self, '$=~', function $Element_$eq_tilde$13(selector) {
          var self = this;

          return $$('Element')['$native_matches?'](self["native"], selector)
        });
        $alias(self, "===", "=~");
        
        $def(self, '$/', function $Element_$slash$14($a) {
          var $post_args, paths, self = this;

          
          $post_args = $slice(arguments);
          paths = $post_args;
          return $$('NodeSet')['$[]']($send(paths, 'map', [], function $$15(path){var self = $$15.$$s == null ? this : $$15.$$s;

            
            if (path == null) path = nil;
            return self.$xpath(path);}, {$$s: self}));
        }, -1);
        
        $def(self, '$[]', function $Element_$$$16(name, options) {
          var self = this;

          
          if (options == null) options = (new Map());
          return self.$attributes().$get(name, options);
        }, -2);
        
        $def(self, '$[]=', function $Element_$$$eq$17(name, value, options) {
          var self = this;

          
          if (options == null) options = (new Map());
          return self.$attributes().$set(name, value, options);
        }, -3);
        
        $def(self, '$add_class', function $$add_class($a) {
          var $post_args, names, self = this, classes = nil;

          
          $post_args = $slice(arguments);
          names = $post_args;
          classes = $rb_plus(self.$class_names(), names);
          if (!$truthy(classes['$empty?']())) {
            self["native"].className = classes.$uniq().$join(" ")
          };
          return self;
        }, -1);
        
        $def(self, '$at', function $$at(path_or_selector) {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self.$xpath(path_or_selector).$first()))) {
            return $ret_or_1
          } else {
            return self.$css(path_or_selector).$first()
          }
        });
        
        $def(self, '$at_css', function $$at_css($a) {
          var $post_args, rules, self = this, result = nil;

          
          $post_args = $slice(arguments);
          rules = $post_args;
          result = nil;
          (function(){try { var $t_break = $thrower('break'); return $send(rules, 'each', [], function $$18(rule){var self = $$18.$$s == null ? this : $$18.$$s;

            
            if (rule == null) rule = nil;
            if ($truthy((result = self.$css(rule).$first()))) {
              $t_break.$throw(nil, $$18.$$is_lambda)
            } else {
              return nil
            };}, {$$s: self})} catch($e) {
            if ($e === $t_break) return $e.$v;
            throw $e;
          } finally {$t_break.is_orphan = true;}})();
          return result;
        }, -1);
        
        $def(self, '$at_xpath', function $$at_xpath($a) {
          var $post_args, paths, self = this, result = nil;

          
          $post_args = $slice(arguments);
          paths = $post_args;
          result = nil;
          (function(){try { var $t_break = $thrower('break'); return $send(paths, 'each', [], function $$19(path){var self = $$19.$$s == null ? this : $$19.$$s;

            
            if (path == null) path = nil;
            if ($truthy((result = self.$xpath(path).$first()))) {
              $t_break.$throw(nil, $$19.$$is_lambda)
            } else {
              return nil
            };}, {$$s: self})} catch($e) {
            if ($e === $t_break) return $e.$v;
            throw $e;
          } finally {$t_break.is_orphan = true;}})();
          return result;
        }, -1);
        $alias(self, "attr", "[]");
        $alias(self, "attribute", "[]");
        
        $def(self, '$attributes', function $$attributes(options) {
          var self = this;

          
          if (options == null) options = (new Map());
          return $$('Attributes').$new(self, options);
        }, -1);
        
        $def(self, '$attribute_nodes', function $$attribute_nodes() {
          var self = this;

          return $$('NodeSet')['$[]']($$$($$('Native'), 'Array').$new(self["native"].attributes, (new Map([["get", "item"]]))))
        });
        self.$alias_native("class_name", "className");
        
        $def(self, '$class_names', function $$class_names() {
          var self = this;

          return $send((self["native"].className).$split(/\s+/), 'reject', [], "empty?".$to_proc())
        });
        if ($truthy($$('Browser')['$supports?']("Query.css"))) {
          
          $def(self, '$css', function $$css(path) {
            var self = this;

            try {
              return $$('NodeSet')['$[]']($$$($$('Native'), 'Array').$new(self["native"].querySelectorAll(path)))
            } catch ($err) {
              if (Opal.rescue($err, [$$('StandardError'), $$$($$('JS'), 'Error')])) {
                try {
                  return $$('NodeSet')['$[]']()
                } finally { Opal.pop_exception($err); }
              } else { throw $err; }
            }
          })
        } else if ($truthy($$('Browser')['$loaded?']("Sizzle"))) {
          
          $def(self, '$css', function $$css(path) {
            var self = this;

            try {
              return $$('NodeSet')['$[]'](Sizzle(path, self["native"]))
            } catch ($err) {
              if (Opal.rescue($err, [$$('StandardError'), $$$($$('JS'), 'Error')])) {
                try {
                  return $$('NodeSet')['$[]']()
                } finally { Opal.pop_exception($err); }
              } else { throw $err; }
            }
          })
        } else {
          
          $def(self, '$css', function $$css(selector) {
            var self = this;

            return self.$raise($$('NotImplementedError'), "query by CSS selector unsupported")
          })
        };
        
        $def(self, '$click', function $$click() {
          var self = this;

          
          self["native"].click();
          return self;
        });
        
        $def(self, '$data', function $$data(value) {
          var self = this, data = nil;

          
          if (value == null) value = nil;
          data = $$('Data').$new(self);
          if (!$truthy(value)) {
            return data
          };
          if ($eqeqeq($$('Hash'), value)) {
            data.$assign(value)
          } else {
            self.$raise($$('ArgumentError'), "unknown data type")
          };
          return self;
        }, -1);
        $alias(self, "get_attribute", "[]");
        $alias(self, "get", "[]");
        
        $def(self, '$height', function $$height() {
          var self = this;

          return self.$size().$height()
        });
        
        $def(self, '$height=', function $Element_height$eq$20(value) {
          var $a, self = this;

          return ($a = [value], $send(self.$size(), 'height=', $a), $a[$a.length - 1])
        });
        
        $def(self, '$id', function $$id() {
          var self = this;

          
      var id = self["native"].id;

      if (id === "") {
        return nil;
      }
      else {
        return id;
      }
    
        });
        
        $def(self, '$id=', function $Element_id$eq$21(value) {
          var self = this;

          return self["native"].id = value.$to_s()
        });
        
        $def(self, '$inner_dom', function $$inner_dom(builder) {
          var block = $$inner_dom.$$p || nil, self = this;

          $$inner_dom.$$p = null;
          
          ;
          if (builder == null) builder = nil;
          self['$inner_dom=']($send($$('Builder'), 'new', [self.$document(), builder], block.$to_proc()).$to_a());
          return self;
        }, -1);
        
        $def(self, '$inner_dom=', function $Element_inner_dom$eq$22(node) {
          var self = this;

          
          self.$clear();
          return self['$<<'](node);
        });
        
        $def(self, '$inner_html', function $$inner_html() {
          var self = this;

          return self["native"].innerHTML
        });
        
        $def(self, '$inner_html=', function $Element_inner_html$eq$23(value) {
          var self = this;

          return self["native"].innerHTML = value
        });
        
        $def(self, '$inspect', function $$inspect() {
          var self = this, inspect = nil;

          
          inspect = self.$name().$downcase();
          if ($truthy(self.$id())) {
            inspect = $rb_plus(inspect, $rb_plus($rb_plus(".", self.$id()), "!"))
          };
          if (!$truthy(self.$class_names()['$empty?']())) {
            inspect = $rb_plus(inspect, $rb_plus(".", self.$class_names().$join(".")))
          };
          return "#<" + (self.$class().$name().$gsub("Browser::", "")) + ": " + (inspect) + ">";
        });
        
        $def(self, '$offset', function $$offset($a) {
          var $post_args, values, self = this, off = nil;

          
          $post_args = $slice(arguments);
          values = $post_args;
          off = $$('Offset').$new(self);
          if (!$truthy(values['$empty?']())) {
            $send(off, 'set', $to_a(values))
          };
          return off;
        }, -1);
        
        $def(self, '$offset=', function $Element_offset$eq$24(value) {
          var self = this;

          return $send(self.$offset(), 'set', $to_a(value))
        });
        
        $def(self, '$outer_html', function $$outer_html() {
          var self = this;

          return self["native"].outerHTML
        });
        
        $def(self, '$position', function $$position() {
          var self = this, $ret_or_1 = nil;

          return (self.position = ($truthy(($ret_or_1 = self.position)) ? ($ret_or_1) : ($$('Position').$new(self))))
        });
        
        $def(self, '$scroll', function $$scroll() {
          var self = this, $ret_or_1 = nil;

          return (self.scroll = ($truthy(($ret_or_1 = self.scroll)) ? ($ret_or_1) : ($$('Scroll').$new(self))))
        });
        
        $def(self, '$search', function $$search($a) {
          var $post_args, selectors, self = this;

          
          $post_args = $slice(arguments);
          selectors = $post_args;
          return $$('NodeSet').$new($send(selectors, 'map', [], function $$25(selector){var self = $$25.$$s == null ? this : $$25.$$s;

            
            if (selector == null) selector = nil;
            return self.$xpath(selector).$to_a().$concat(self.$css(selector).$to_a());}, {$$s: self}).$flatten().$uniq());
        }, -1);
        $alias(self, "set", "[]=");
        $alias(self, "set_attribute", "[]=");
        
        $def(self, '$shadow', function $$shadow(open) {
          var self = this, root = nil;

          
          if (open == null) open = true;
          if ($truthy((root = self["native"].shadowRoot))) {
            return self.$DOM(root)
          } else {
            return self.$DOM(self["native"].attachShadow({mode: ($truthy(open) ? ("open") : ("closed"))}))
          };
        }, -1);
        
        $def(self, '$shadow?', function $Element_shadow$ques$26() {
          var self = this;

          return !!self["native"].shadowRoot
        });
        
        $def(self, '$style', function $$style(data) {
          var block = $$style.$$p || nil, self = this, style = nil;

          $$style.$$p = null;
          
          ;
          if (data == null) data = nil;
          style = $$$($$('CSS'), 'Declaration').$new(self["native"].style);
          if (!($truthy(data) || ($truthy(block)))) {
            return style
          };
          if ($eqeqeq($$('String'), data)) {
            style.$replace(data)
          } else if ($eqeqeq($$('Hash'), data)) {
            style.$assign(data)
          } else if ($truthy(block)) {
            $send(style, 'apply', [], block.$to_proc())
          } else {
            self.$raise($$('ArgumentError'), "unknown data type")
          };
          return self;
        }, -1);
        if ($truthy($$('Browser')['$supports?']("CSS.computed"))) {
          
          $def(self, '$style!', function $Element_style$excl$27() {
            var self = this;

            return $$$($$('CSS'), 'Declaration').$new(self.$window().$to_n().getComputedStyle(self["native"], null))
          })
        } else if ($truthy($$('Browser')['$supports?']("CSS.current"))) {
          
          $def(self, '$style!', function $Element_style$excl$28() {
            var self = this;

            return $$$($$('CSS'), 'Declaration').$new(self["native"].currentStyle)
          })
        } else {
          
          $def(self, '$style!', function $Element_style$excl$29() {
            var self = this;

            return self.$raise($$('NotImplementedError'), "computed style unsupported")
          })
        };
        
        $def(self, '$remove_attribute', function $$remove_attribute(name) {
          var self = this;

          return self["native"].removeAttribute(name)
        });
        
        $def(self, '$remove_class', function $$remove_class($a) {
          var $post_args, names, self = this, classes = nil;

          
          $post_args = $slice(arguments);
          names = $post_args;
          classes = $rb_minus(self.$class_names(), names);
          if ($truthy(classes['$empty?']())) {
            self["native"].removeAttribute('class')
          } else {
            self["native"].className = classes.$join(" ")
          };
          return self;
        }, -1);
        
        $def(self, '$size', function $$size($a) {
          var $post_args, inc, self = this;

          
          $post_args = $slice(arguments);
          inc = $post_args;
          return $send($$('Size'), 'new', [self].concat($to_a(inc)));
        }, -1);
        
        $def(self, '$toggle_class', function $$toggle_class($a) {
          var $post_args, names, $b, $c, self = this, to_remove = nil, to_add = nil;

          
          $post_args = $slice(arguments);
          names = $post_args;
          $c = $send(names, 'partition', [], function $$30(name){var self = $$30.$$s == null ? this : $$30.$$s;

            
            if (name == null) name = nil;
            return self.$class_names()['$include?'](name);}, {$$s: self}), $b = $to_ary($c), (to_remove = ($b[0] == null ? nil : $b[0])), (to_add = ($b[1] == null ? nil : $b[1])), $c;
          $send(self, 'add_class', $to_a(to_add));
          return $send(self, 'remove_class', $to_a(to_remove));
        }, -1);
        
        $def(self, '$width', function $$width() {
          var self = this;

          return self.$size().$width()
        });
        
        $def(self, '$width=', function $Element_width$eq$31(value) {
          var $a, self = this;

          return ($a = [value], $send(self.$size(), 'width=', $a), $a[$a.length - 1])
        });
        
        $def(self, '$window', function $$window() {
          var self = this;

          return self.$document().$window()
        });
        if (($truthy($$('Browser')['$supports?']("Query.xpath")) || ($truthy($$('Browser')['$loaded?']("wicked-good-xpath"))))) {
          
          if ($truthy($$('Browser')['$loaded?']("wicked-good-xpath"))) {
            wgxpath.install()
          };
          return $def(self, '$xpath', function $$xpath(path) {
            var self = this;

            try {
              return $$('NodeSet')['$[]']($$$($$('Native'), 'Array').$new((self["native"].ownerDocument || self["native"]).evaluate(path,
           self["native"], null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null), (new Map([["get", "snapshotItem"], ["length", "snapshotLength"]]))))
            } catch ($err) {
              if (Opal.rescue($err, [$$('StandardError'), $$$($$('JS'), 'Error')])) {
                try {
                  return $$('NodeSet')['$[]']()
                } finally { Opal.pop_exception($err); }
              } else { throw $err; }
            }
          });
        } else {
          return $def(self, '$xpath', function $$xpath(path) {
            var self = this;

            return self.$raise($$('NotImplementedError'), "query by XPath unsupported")
          })
        };
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
  self.$require("browser/dom/element/attributes");
  self.$require("browser/dom/element/data");
  self.$require("browser/dom/element/position");
  self.$require("browser/dom/element/offset");
  self.$require("browser/dom/element/scroll");
  self.$require("browser/dom/element/size");
  self.$require("browser/dom/element/button");
  self.$require("browser/dom/element/image");
  self.$require("browser/dom/element/form");
  self.$require("browser/dom/element/input");
  self.$require("browser/dom/element/select");
  self.$require("browser/dom/element/template");
  self.$require("browser/dom/element/textarea");
  self.$require("browser/dom/element/iframe");
  return self.$require("browser/dom/element/media");
};

Opal.modules["browser/dom/document_or_shadow_root"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $send = Opal.send, $def = Opal.def, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('new,style_sheets');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $parent_nesting) {
        var self = $module($base, 'DocumentOrShadowRoot');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        
        $def(self, '$style_sheets', function $$style_sheets() {
          var self = this;
          if (self["native"] == null) self["native"] = nil;

          return $send($$$($$('Native'), 'Array'), 'new', [self["native"].styleSheets], function $$1(e){
            
            if (e == null) e = nil;
            return $$$($$('CSS'), 'StyleSheet').$new(e);})
        });
        return $alias(self, "stylesheets", "style_sheets");
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/document"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def, $alias = Opal.alias, $slice = Opal.slice, $extract_kwargs = Opal.extract_kwargs, $ensure_kwargs = Opal.ensure_kwargs, $kwrestargs = Opal.kwrestargs, $send = Opal.send, $return_self = Opal.return_self, $return_val = Opal.return_val, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('include,DOM,first,css,xpath,[],raise,[]=,dig,to_n,join,Array,each,inner_dom,to_proc,<<,supports?,ready?,call,on,off,convert,new');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Document');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$include($$('DocumentOrShadowRoot'));
        
        $def(self, '$[]', function $Document_$$$1(what) {
          var self = this, $ret_or_1 = nil;

          
          
      var result = self["native"].getElementById(what);

      if (result) {
        return self.$DOM(result);
      }
    ;
          if ($truthy(($ret_or_1 = self.$css(what).$first()))) {
            return $ret_or_1
          } else {
            return self.$xpath(what).$first()
          };
        });
        $alias(self, "at", "[]");
        
        $def(self, '$body', function $$body() {
          var self = this;

          try {
            return self.$DOM(self["native"].body)
          } catch ($err) {
            if (Opal.rescue($err, [$$('ArgumentError')])) {
              try {
                return self.$raise("$document.body is not defined; try to wrap your code in $document.ready{}")
              } finally { Opal.pop_exception($err); }
            } else { throw $err; }
          }
        });
        
        $def(self, '$create_element', function $$create_element(name, $a, $b) {
          var block = $$create_element.$$p || nil, $post_args, $kwargs, builder, options, $c, self = this, opts = nil, ns = nil, elem = nil, dom = nil;

          $$create_element.$$p = null;
          
          ;
          $post_args = $slice(arguments, 1);
          $kwargs = $extract_kwargs($post_args);
          $kwargs = $ensure_kwargs($kwargs);
          
          if ($post_args.length > 0) builder = $post_args.shift();if (builder == null) builder = nil;
          options = $kwrestargs($kwargs, {});
          opts = (new Map());
          if (($truthy(options['$[]']("is")) || ($truthy(($c = ["is", options.$dig("attrs", "is")], $send(options, '[]=', $c), $c[$c.length - 1]))))) {
            opts['$[]=']("is", options['$[]']("is"))
          };
          if ($truthy((ns = options['$[]']("namespace")))) {
            elem = self["native"].createElementNS(ns, name, opts.$to_n())
          } else {
            elem = self["native"].createElement(name, opts.$to_n())
          };
          if ($truthy(options['$[]']("classes"))) {
            elem.className = self.$Array(options['$[]']("classes")).$join(" ")
          };
          if ($truthy(options['$[]']("id"))) {
            elem.id = options['$[]']("id")
          };
          if ($truthy(options['$[]']("attrs"))) {
            $send(options['$[]']("attrs"), 'each', [], function $$2(k, v){
              
              if (k == null) k = nil;
              if (v == null) v = nil;
              if (!$truthy(v)) {
                return nil
              };
              return elem.setAttribute(k, v);})
          };
          dom = self.$DOM(elem);
          if ((block !== nil)) {
            $send(dom, 'inner_dom', [builder], block.$to_proc())
          };
          if ($truthy(builder)) {
            builder['$<<'](dom)
          };
          return dom;
        }, -2);
        
        $def(self, '$create_document_fragment', function $$create_document_fragment() {
          var self = this;

          return self.$DOM(self["native"].createDocumentFragment())
        });
        
        $def(self, '$create_text', function $$create_text(content) {
          var self = this;

          return self.$DOM(self["native"].createTextNode(content))
        });
        
        $def(self, '$create_comment', function $$create_comment(content) {
          var self = this;

          return self.$DOM(self["native"].createComment(content))
        });
        
        $def(self, '$document', $return_self);
        
        $def(self, '$head', function $$head() {
          var self = this;

          return self.$DOM(self["native"].getElementsByTagName("head")[0])
        });
        
        $def(self, '$inspect', $return_val("#<DOM::Document>"));
        if ($truthy($$('Browser')['$supports?']("Event.addListener"))) {
          
          $def(self, '$ready', function $$ready() {
            var block = $$ready.$$p || nil, self = this;

            $$ready.$$p = null;
            
            ;
            if (!$truthy(block)) {
              self.$raise($$('ArgumentError'), "no block given")
            };
            if ($truthy(self['$ready?']())) {
              return block.$call()
            };
            return $send(self, 'on', ["dom:load"], function $$3(e){
              
              if (e == null) e = nil;
              e.$off();
              return block.$call();});
          })
        } else if ($truthy($$('Browser')['$supports?']("Event.attach"))) {
          
          $def(self, '$ready', function $$ready() {
            var block = $$ready.$$p || nil, self = this;

            $$ready.$$p = null;
            
            ;
            if (!$truthy(block)) {
              self.$raise($$('ArgumentError'), "no block given")
            };
            if ($truthy(self['$ready?']())) {
              return block.$call()
            };
            return $send(self, 'on', ["ready:state:change"], function $$4(e){var self = $$4.$$s == null ? this : $$4.$$s;

              
              if (e == null) e = nil;
              if ($truthy(self['$ready?']())) {
                
                e.$off();
                return block.$call();
              } else {
                return nil
              };}, {$$s: self});
          })
        } else {
          
          $def(self, '$ready', function $$ready() {
            var block = $$ready.$$p || nil, self = this;

            $$ready.$$p = null;
            
            ;
            return self.$raise($$('NotImplementedError'), "document ready unsupported");
          })
        };
        
        $def(self, '$ready?', function $Document_ready$ques$5() {
          var self = this;

          return self["native"].readyState === "complete" || self["native"].readyState === "interactive"
        });
        
        $def(self, '$referrer', function $$referrer() {
          var self = this;

          return self["native"].referrer
        });
        
        $def(self, '$root', function $$root() {
          var self = this;

          return self.$DOM(self["native"].documentElement)
        });
        
        $def(self, '$root=', function $Document_root$eq$6(element) {
          var self = this;

          return self["native"].documentElement = $$('Native').$convert(element)
        });
        
        $def(self, '$title', function $$title() {
          var self = this;

          return self["native"].title
        });
        
        $def(self, '$title=', function $Document_title$eq$7(value) {
          var self = this;

          return self["native"].title = value
        });
        
        $def(self, '$hidden?', function $Document_hidden$ques$8() {
          var self = this;

          return self["native"].hidden
        });
        
        $def(self, '$visibility', function $$visibility() {
          var self = this;

          return self["native"].visibilityState
        });
        if ($truthy($$('Browser')['$supports?']("Document.view"))) {
          return $def(self, '$window', function $$window() {
            var self = this;

            return $$('Window').$new(self["native"].defaultView)
          })
        } else if ($truthy($$('Browser')['$supports?']("Document.window"))) {
          return $def(self, '$window', function $$window() {
            var self = this;

            return $$('Window').$new(self["native"].parentWindow)
          })
        } else {
          return $def(self, '$window', function $$window() {
            var self = this;

            return self.$raise($$('NotImplementedError'), "window from document unsupported")
          })
        };
      })($nesting[0], $$('Element'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/document_fragment"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $eqeq = Opal.eqeq, $truthy = Opal.truthy, $send2 = Opal.send2, $find_super = Opal.find_super, $defs = Opal.defs, $gvars = Opal.gvars, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('==,new,create_document_fragment');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'DocumentFragment');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        $defs(self, '$new', function $DocumentFragment_new$1(node) {
          var $yield = $DocumentFragment_new$1.$$p || nil, self = this;

          $DocumentFragment_new$1.$$p = null;
          if ($eqeq(self, $$('DocumentFragment'))) {
            if ($truthy((typeof(node.mode) !== "undefined"))) {
              return $$('ShadowRoot').$new(node)
            } else {
              return $send2(self, $find_super(self, 'new', $DocumentFragment_new$1, false, true), 'new', [node], $yield)
            }
          } else {
            return $send2(self, $find_super(self, 'new', $DocumentFragment_new$1, false, true), 'new', [node], $yield)
          }
        });
        return $defs(self, '$create', function $$create() {
                    if ($gvars.document == null) $gvars.document = nil;

          return $gvars.document.$create_document_fragment()
        });
      })($nesting[0], $$('Element'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/shadow_root"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('include,raise');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'ShadowRoot');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$include($$('DocumentOrShadowRoot'));
        return $defs(self, '$create', function $$create() {
          var self = this;

          return self.$raise($$('ArgumentError'))
        });
      })($nesting[0], $$('DocumentFragment'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom/mutation_observer"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $send = Opal.send, $send2 = Opal.send2, $find_super = Opal.find_super, $eqeq = Opal.eqeq, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('supports?,include,==,type,new,[],DOM,alias_native,call,map,convert,private,Native,[]=,to_n');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'MutationObserver');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        $defs(self, '$supported?', function $MutationObserver_supported$ques$1() {
          
          return $$('Browser')['$supports?']("MutationObserver")
        });
        self.$include($$$($$('Native'), 'Wrapper'));
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Record');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$include($$$($$('Browser'), 'NativeCachedWrapper'));
          
          $def(self, '$type', function $$type() {
            var self = this;

            
            switch (self["native"].type.valueOf()) {
              case "attributes":
                return "attribute"
              case "childList":
                return "tree"
              case "characterData":
                return "cdata"
              default:
                return nil
            }
          });
          
          $def(self, '$attribute?', function $Record_attribute$ques$2() {
            var self = this;

            return self.$type()['$==']("attribute")
          });
          
          $def(self, '$tree?', function $Record_tree$ques$3() {
            var self = this;

            return self.$type()['$==']("tree")
          });
          
          $def(self, '$cdata?', function $Record_cdata$ques$4() {
            var self = this;

            return self.$type()['$==']("cdata")
          });
          
          $def(self, '$added', function $$added() {
            var self = this, array = nil;

            
            array = ($truthy(self["native"].addedNodes != null) ? ($$$($$('Native'), 'Array').$new(self["native"].addedNodes)) : ([]));
            return $$('NodeSet')['$[]'](array);
          });
          
          $def(self, '$removed', function $$removed() {
            var self = this, array = nil;

            
            array = ($truthy(self["native"].removedNodes != null) ? ($$$($$('Native'), 'Array').$new(self["native"].removedNodes)) : ([]));
            return $$('NodeSet')['$[]'](array);
          });
          
          $def(self, '$target', function $$target() {
            var self = this;

            return self.$DOM(self["native"].target)
          });
          self.$alias_native("old", "oldValue");
          self.$alias_native("name", "attributeName");
          return self.$alias_native("namespace", "attributeNamespace");
        })($nesting[0], null, $nesting);
        
        $def(self, '$initialize', function $$initialize() {
          var block = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          
          ;
          
      var func = function(records) {
        return block.$call($send((records), 'map', [], function $$5(r){
            
            if (r == null) r = nil;
            return $$$($$$($$$($$('Browser'), 'DOM'), 'MutationObserver'), 'Record').$new(r);}));
      }
    ;
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [new window.MutationObserver(func)], null);
        });
        
        $def(self, '$observe', function $$observe(target, options) {
          var self = this;

          
          if (options == null) options = nil;
          if (!$truthy(options)) {
            options = (new Map([["children", true], ["tree", true], ["attributes", "old"], ["cdata", "old"]]))
          };
          self["native"].observe($$('Native').$convert(target), self.$convert(options));
          return self;
        }, -2);
        
        $def(self, '$take', function $$take() {
          var self = this;

          return $send((self["native"].takeRecords()), 'map', [], function $$6(r){
            
            if (r == null) r = nil;
            return $$('Record').$new(r);})
        });
        
        $def(self, '$disconnect', function $$disconnect() {
          var self = this;

          return self["native"].disconnect()
        });
        self.$private();
        return $def(self, '$convert', function $$convert(hash) {
          var self = this, options = nil, attrs = nil, filter = nil, cdata = nil;

          
          options = self.$Native({});
          if ($truthy(hash['$[]']("children"))) {
            options['$[]=']("childList", true)
          };
          if ($truthy(hash['$[]']("tree"))) {
            options['$[]=']("subtree", true)
          };
          if ($truthy((attrs = hash['$[]']("attributes")))) {
            
            options['$[]=']("attributes", true);
            if ($eqeq(attrs, "old")) {
              options['$[]=']("attributeOldValue", true)
            };
          };
          if ($truthy((filter = hash['$[]']("filter")))) {
            options['$[]=']("attributeFilter", filter)
          };
          if ($truthy((cdata = hash['$[]']("cdata")))) {
            
            options['$[]=']("characterData", true);
            if ($eqeq(cdata, "old")) {
              options['$[]=']("characterDataOldValue", true)
            };
          };
          return options.$to_n();
        });
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/dom"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $def = Opal.def, $slice = Opal.slice, $truthy = Opal.truthy, $gvars = Opal.gvars, $send = Opal.send, $eqeq = Opal.eqeq, $eqeqeq = Opal.eqeqeq, $klass = Opal.klass, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;
  if ($gvars.window == null) $gvars.window = nil;

  Opal.add_stubs('require,DOM,shift,to_a,new,to_proc,==,length,first,respond_to?,to_dom,raise,native?,===,tap,create_element,<<,try_convert,document');
  
  self.$require("browser/dom/node_set");
  self.$require("browser/dom/node");
  self.$require("browser/dom/attribute");
  self.$require("browser/dom/character_data");
  self.$require("browser/dom/text");
  self.$require("browser/dom/cdata");
  self.$require("browser/dom/comment");
  self.$require("browser/dom/element");
  self.$require("browser/dom/document_or_shadow_root");
  self.$require("browser/dom/document");
  self.$require("browser/dom/document_fragment");
  self.$require("browser/dom/shadow_root");
  self.$require("browser/dom/mutation_observer");
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$XML', function $$XML(what) {
      var self = this;

      
      
      var doc;

      if (window.DOMParser) {
        doc = new DOMParser().parseFromString(what, 'text/xml');
      }
      else {
        doc       = new ActiveXObject('Microsoft.XMLDOM');
        doc.async = 'false';
        doc.loadXML(what);
      }
    ;
      return self.$DOM(doc);
    });
    return $def(self, '$DOM', function $$DOM($a) {
      var block = $$DOM.$$p || nil, $post_args, args, self = this, document = nil, $ret_or_1 = nil, roots = nil, what = nil;
      if ($gvars.document == null) $gvars.document = nil;

      $$DOM.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      if ($truthy(block)) {
        
        document = ($truthy(($ret_or_1 = args.$shift())) ? ($ret_or_1) : ($gvars.document));
        roots = $send($$$($$$($$('Browser'), 'DOM'), 'Builder'), 'new', [document], block.$to_proc()).$to_a();
        if ($eqeq(roots.$length(), 1)) {
          return roots.$first()
        } else {
          return $$$($$$($$('Browser'), 'DOM'), 'NodeSet').$new(roots)
        };
      } else {
        
        what = args.$shift();
        document = ($truthy(($ret_or_1 = args.$shift())) ? ($ret_or_1) : ($gvars.document));
        if ($truthy($$('Opal')['$respond_to?'](what, "to_dom"))) {
          what = what.$to_dom(document)
        };
        if ($truthy(typeof(what) === 'undefined' || what === null)) {
          return self.$raise($$('ArgumentError'), "argument is null")
        } else if ($truthy(self['$native?'](what))) {
          return $$$($$$($$('Browser'), 'DOM'), 'Node').$new(what)
        } else if ($eqeqeq($$$($$$($$('Browser'), 'DOM'), 'Node'), what)) {
          return what
        } else if ($truthy($$('Opal')['$respond_to?'](what, "each"))) {
          return $send(document.$create_element("DIV"), 'tap', [], function $$1(div){
            
            if (div == null) div = nil;
            return div['$<<'](what);})
        } else if ($eqeqeq($$('String'), what)) {
          
          var doc = $$('Native').$try_convert(document).createElement('div');
          doc.innerHTML = what;

          return self.$DOM(doc.childNodes.length == 1 ? doc.childNodes[0] : doc);
        
        } else {
          return self.$raise($$('ArgumentError'), "argument is not DOM convertible")
        };
      };
    }, -1);
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super) {
      var self = $klass($base, $super, 'Window');

      var $proto = self.$$prototype;

      $proto["native"] = nil;
      return $def(self, '$document', function $$document() {
        var self = this;

        return self.$DOM(self["native"].document)
      })
    })($nesting[0], null)
  })($nesting[0], $nesting);
  return ($gvars.document = $gvars.window.$document());
};

Opal.modules["browser/css/declaration"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def, $send = Opal.send, $range = Opal.range, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,new,each,[]=,to_proc,important,name,value,to_s,enum_for,[],alias_native,end_with?');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'CSS');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Declaration');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$include($$$($$('Browser'), 'NativeCachedWrapper'));
        self.$include($$('Enumerable'));
        
        $def(self, '$rule', function $$rule() {
          var self = this;

          if ($truthy((typeof(self["native"].parentRule) !== "undefined"))) {
            return $$('Rule').$new(self["native"].parentRule)
          } else {
            return nil
          }
        });
        
        $def(self, '$assign', function $$assign(data) {
          var self = this;

          
          $send(data, 'each', [], function $$1(name, value){var $a, self = $$1.$$s == null ? this : $$1.$$s;

            
            if (name == null) name = nil;
            if (value == null) value = nil;
            return ($a = [name, value], $send(self, '[]=', $a), $a[$a.length - 1]);}, {$$s: self});
          return self;
        });
        
        $def(self, '$replace', function $$replace(string) {
          var self = this;

          return self["native"].cssText = string
        });
        
        $def(self, '$apply', function $$apply() {
          var block = $$apply.$$p || nil, self = this;

          $$apply.$$p = null;
          
          ;
          return $send($send($$$($$$($$('Paggio'), 'CSS'), 'Definition'), 'new', [], block.$to_proc()), 'each', [], function $$2(style){var self = $$2.$$s == null ? this : $$2.$$s;
            if (self["native"] == null) self["native"] = nil;

            
            if (style == null) style = nil;
            if ($truthy(style.$important())) {
              return self["native"].setProperty(style.$name(), style.$value(), "important")
            } else {
              return self["native"].setProperty(style.$name(), style.$value(), "")
            };}, {$$s: self});
        });
        
        $def(self, '$delete', function $Declaration_delete$3(name) {
          var self = this;

          return self["native"].removeProperty(name)
        });
        
        $def(self, '$[]', function $Declaration_$$$4(name) {
          var self = this;

          
      var result = self["native"].getPropertyValue(name);

      if (result == null || result === "") {
        return nil;
      }

      return result;
    
        });
        
        $def(self, '$[]=', function $Declaration_$$$eq$5(name, value) {
          var self = this;

          return self["native"].setProperty(name, value.$to_s(), "")
        });
        
        $def(self, '$important?', function $Declaration_important$ques$6(name) {
          var self = this;

          return self["native"].getPropertyPriority(name) == "important"
        });
        
        $def(self, '$each', function $$each() {
          var block = $$each.$$p || nil, self = this;

          $$each.$$p = null;
          
          ;
          if (!(block !== nil)) {
            return self.$enum_for("each")
          };
          
      for (var i = 0, length = self["native"].length; i < length; i++) {
        var name  = self["native"].item(i);

        Opal.yieldX(block, [name, self['$[]'](name)])
      }
    ;
          return self;
        });
        self.$alias_native("length");
        self.$alias_native("to_s", "cssText");
        return $def(self, '$method_missing', function $$method_missing(name, value) {
          var $a, self = this;

          
          if (value == null) value = nil;
          if ($truthy(name['$end_with?']("="))) {
            return ($a = [name['$[]']($range(0, -2, false)), value], $send(self, '[]=', $a), $a[$a.length - 1])
          } else {
            return self['$[]'](name)
          };
        }, -2);
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/css/style_sheet"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $eqeqeq = Opal.eqeqeq, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $truthy = Opal.truthy, $send = Opal.send, $slice = Opal.slice, $to_a = Opal.to_a, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,===,to_n,alias_native,new,DOM,join,map,insert,length,find,rules,log,==,id,__send__,to_proc');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'CSS');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'StyleSheet');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$include($$$($$('Browser'), 'NativeCachedWrapper'));
        
        $def(self, '$initialize', function $$initialize(what) {
          var $yield = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          if ($eqeqeq($$$($$('DOM'), 'Element'), what)) {
            return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [what.$to_n().sheet], null)
          } else {
            return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [what], null)
          }
        });
        self.$alias_native("disabled?", "disabled");
        self.$alias_native("href");
        self.$alias_native("title");
        self.$alias_native("type");
        
        $def(self, '$media', function $$media() {
          var self = this;

          if ($truthy(self["native"].media != null)) {
            return $$('Media').$new(self["native"].media)
          } else {
            return nil
          }
        });
        
        $def(self, '$owner', function $$owner() {
          var self = this;

          return self.$DOM(self["native"].ownerNode)
        });
        
        $def(self, '$parent', function $$parent() {
          var self = this;

          if ($truthy(self["native"].parentStyleSheet != null)) {
            return $$('Sheet').$new(self["native"].parentStyleSheet)
          } else {
            return nil
          }
        });
        
        $def(self, '$rules', function $$rules() {
          var self = this;

          return $send($$$($$('Native'), 'Array'), 'new', [self["native"].cssRules], function $$1(e){
            
            if (e == null) e = nil;
            return $$('Rule').$new(e);})
        });
        
        $def(self, '$delete', function $StyleSheet_delete$2(index) {
          var self = this;

          return self["native"].deleteRule(index)
        });
        
        $def(self, '$insert', function $$insert(index, rule) {
          var self = this;

          return self["native"].insertRule(rule, index)
        });
        
        $def(self, '$rule', function $$rule(selector, body) {
          var self = this;

          
          if (!$eqeqeq($$('String'), selector)) {
            selector = selector.$join(", ")
          };
          if (!$eqeqeq($$('String'), body)) {
            body = $send(body, 'map', [], function $$3(name, value){
              
              if (name == null) name = nil;
              if (value == null) value = nil;
              return "" + (name) + ": " + (value) + ";";}).$join("\n")
          };
          return self.$insert(self.$length(), "" + (selector) + " { " + (body) + " }");
        });
        
        $def(self, '$[]', function $StyleSheet_$$$4(id) {
          var self = this;

          return $send(self.$rules(), 'find', [], function $$5(r){var self = $$5.$$s == null ? this : $$5.$$s;

            
            if (r == null) r = nil;
            self.$log(r);
            return r.$id()['$=='](id);}, {$$s: self})
        });
        
        $def(self, '$method_missing', function $$method_missing($a) {
          var block = $$method_missing.$$p || nil, $post_args, args, self = this;

          $$method_missing.$$p = null;
          
          ;
          $post_args = $slice(arguments);
          args = $post_args;
          return $send(self.$rules(), '__send__', $to_a(args), block.$to_proc());
        }, -1);
        return (function($base, $super) {
          var self = $klass($base, $super, 'Media');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$alias_native("text", "mediaText");
          self.$alias_native("to_s", "mediaText");
          
          $def(self, '$push', function $$push(medium) {
            var self = this;

            
            self["native"].appendMedium(medium);
            return self;
          });
          return $def(self, '$delete', function $Media_delete$6(medium) {
            var self = this;

            return self["native"].deleteMedium(medium)
          });
        })($nesting[0], $$$($$('Native'), 'Array'));
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/css/rule"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $eqeq = Opal.eqeq, $truthy = Opal.truthy, $send2 = Opal.send2, $find_super = Opal.find_super, $defs = Opal.defs, $def = Opal.def, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,==,[],new,raise,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'CSS');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Rule');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$include($$$($$('Browser'), 'NativeCachedWrapper'));
        $const_set($nesting[0], 'STYLE_RULE', 1);
        $const_set($nesting[0], 'CHARSET_RULE', 2);
        $const_set($nesting[0], 'IMPORT_RULE', 3);
        $const_set($nesting[0], 'MEDIA_RULE', 4);
        $const_set($nesting[0], 'FONT_FACE_RULE', 5);
        $const_set($nesting[0], 'PAGE_RULE', 6);
        $const_set($nesting[0], 'KEYFRAMES_RULE', 7);
        $const_set($nesting[0], 'KEYFRAME_RULE', 8);
        $const_set($nesting[0], 'NAMESPACE_RULE', 10);
        $const_set($nesting[0], 'COUNTER_STYLE_RULE', 11);
        $const_set($nesting[0], 'SUPPORTS_RULE', 12);
        $const_set($nesting[0], 'DOCUMENT_RULE', 13);
        $const_set($nesting[0], 'FONT_FEATURE_VALUES_RULE', 14);
        $const_set($nesting[0], 'VIEWPORT_RULE', 15);
        $const_set($nesting[0], 'REGION_STYLE_RULE', 16);
        $defs(self, '$new', function $Rule_new$1(rule) {
          var $yield = $Rule_new$1.$$p || nil, self = this, $ret_or_1 = nil, klass = nil;
          if (self.classes == null) self.classes = nil;

          $Rule_new$1.$$p = null;
          if ($eqeq(self, $$('Rule'))) {
            
            self.classes = ($truthy(($ret_or_1 = self.classes)) ? ($ret_or_1) : ([nil, $$('Style')]));
            if ($truthy((klass = self.classes['$[]'](rule.type)))) {
              return klass.$new(rule)
            } else {
              return self.$raise($$('ArgumentError'), "cannot instantiate a non derived Rule object")
            };
          } else {
            return $send2(self, $find_super(self, 'new', $Rule_new$1, false, true), 'new', [rule], null)
          }
        });
        self.$alias_native("text", "cssText");
        self.$alias_native("to_s", "cssText");
        
        $def(self, '$parent', function $$parent() {
          var self = this;

          if ($truthy(self["native"].parentRule != null)) {
            return $$('Rule').$new(self["native"].parentRule)
          } else {
            return nil
          }
        });
        return $def(self, '$style_sheet', function $$style_sheet() {
          var self = this;

          if ($truthy(self["native"].parentStyleSheet != null)) {
            return $$('StyleSheet').$new(self["native"].parentStyleSheet)
          } else {
            return nil
          }
        });
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/css/rule/style"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $slice = Opal.slice, $send = Opal.send, $to_a = Opal.to_a, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('alias_native,new,__send__,declaration,to_proc');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'CSS');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Rule');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Style');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$alias_native("selector", "selectorText");
          self.$alias_native("id", "selectorText");
          
          $def(self, '$declaration', function $$declaration() {
            var self = this;

            return $$('Declaration').$new(self["native"].style)
          });
          return $def(self, '$method_missing', function $$method_missing($a) {
            var block = $$method_missing.$$p || nil, $post_args, args, self = this;

            $$method_missing.$$p = null;
            
            ;
            $post_args = $slice(arguments);
            args = $post_args;
            return $send(self.$declaration(), '__send__', $to_a(args), block.$to_proc());
          }, -1);
        })($nesting[0], $$('Rule'), $nesting)
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/css"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $slice = Opal.slice, $truthy = Opal.truthy, $rb_gt = Opal.rb_gt, $gvars = Opal.gvars, $send = Opal.send, $def = Opal.def, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,>,length,pop,create_element,[]=,inner_text=,css,to_proc,join');
  
  self.$require("browser/css/declaration");
  self.$require("browser/css/style_sheet");
  self.$require("browser/css/rule");
  self.$require("browser/css/rule/style");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$CSS', function $$CSS($a) {
      var block = $$CSS.$$p || nil, $post_args, args, document = nil, $ret_or_1 = nil, style = nil;
      if ($gvars.document == null) $gvars.document = nil;

      $$CSS.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      document = ($truthy(($ret_or_1 = (($truthy($rb_gt(args.$length(), 1)) || ((block !== nil))) ? (args.$pop()) : nil))) ? ($ret_or_1) : ($gvars.document));
      style = document.$create_element("style");
      style['$[]=']("type", "text/css");
      if ($truthy(block)) {
        style['$inner_text=']($send($$('Paggio'), 'css', [], block.$to_proc()))
      } else {
        style['$inner_text='](args.$join(""))
      };
      return style;
    }, -1)
  })($nesting[0], $nesting);
};

Opal.modules["browser/setup/mini"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var self = Opal.top, nil = Opal.nil;

  Opal.add_stubs('require');
  
  self.$require("browser/setup/base");
  self.$require("browser/event");
  self.$require("browser/window");
  self.$require("browser/dom");
  return self.$require("browser/css");
};

Opal.modules["browser/animation_frame"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $gvars = Opal.gvars, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('any?,supports?,to_n,request,raise,new,to_proc');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'AnimationFrame');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = $proto.id = nil;
      
      $defs(self, '$supported?', function $AnimationFrame_supported$ques$1() {
        
        return $send(["Animation.request", "Animation.request (Chrome)", "Animation.request (Firefox)", "Animation.request (Opera)", "Animation.request (Internet Explorer)"], 'any?', [], function $$2(feature){
          
          if (feature == null) feature = nil;
          return $$('Browser')['$supports?'](feature);})
      });
      
      $def(self, '$initialize', function $$initialize(window) {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        self.window = window;
        self["native"] = window.$to_n();
        return (self.id = self.$request(block));
      });
      if ($truthy($$('Browser')['$supports?']("Animation.request"))) {
        
        $def(self, '$request', function $$request(block) {
          var self = this;

          return self["native"].requestAnimationFrame(block.$to_n())
        })
      } else if ($truthy($$('Browser')['$supports?']("Animation.request (Chrome)"))) {
        
        $def(self, '$request', function $$request(block) {
          var self = this;

          return self["native"].webkitRequestAnimationFrame(block.$to_n())
        })
      } else if ($truthy($$('Browser')['$supports?']("Animation.request (Firefox)"))) {
        
        $def(self, '$request', function $$request(block) {
          var self = this;

          return self["native"].mozRequestAnimationFrame(block.$to_n())
        })
      } else if ($truthy($$('Browser')['$supports?']("Animation.request (Opera)"))) {
        
        $def(self, '$request', function $$request(block) {
          var self = this;

          return self["native"].oRequestAnimationFrame(block.$to_n())
        })
      } else if ($truthy($$('Browser')['$supports?']("Animation.request (Internet Explorer)"))) {
        
        $def(self, '$request', function $$request(block) {
          var self = this;

          return self["native"].msRequestAnimationFrame(block.$to_n())
        })
      } else {
        
        $def(self, '$request', function $$request() {
          var self = this;

          return self.$raise($$('NotImplementedError'), "window requestAnimationFrame unsupported")
        })
      };
      if ($truthy($$('Browser')['$supports?']("Animation.cancel"))) {
        return $def(self, '$cancel', function $$cancel() {
          var self = this;

          return self["native"].cancelAnimationFrame(self.id)
        })
      } else if ($truthy($$('Browser')['$supports?']("Animation.cancel (Chrome)"))) {
        return $def(self, '$cancel', function $$cancel() {
          var self = this;

          return self["native"].webkitCancelAnimationFrame(self.id)
        })
      } else if ($truthy($$('Browser')['$supports?']("Animation.cancelRequest (Chrome)"))) {
        return $def(self, '$cancel', function $$cancel() {
          var self = this;

          return self["native"].webkitCancelRequestAnimationFrame(self.id)
        })
      } else if ($truthy($$('Browser')['$supports?']("Animation.cancel (Firefox)"))) {
        return $def(self, '$cancel', function $$cancel() {
          var self = this;

          return self["native"].mozCancelAnimationFrame(self.id)
        })
      } else if ($truthy($$('Browser')['$supports?']("Animation.cancelRequest (Firefox)"))) {
        return $def(self, '$cancel', function $$cancel() {
          var self = this;

          return self["native"].mozCancelRequestAnimationFrame(self.id)
        })
      } else if ($truthy($$('Browser')['$supports?']("Animation.cancel (Opera)"))) {
        return $def(self, '$cancel', function $$cancel() {
          var self = this;

          return self["native"].oCancelAnimationFrame(self.id)
        })
      } else if ($truthy($$('Browser')['$supports?']("Animation.cancelRequest (Opera)"))) {
        return $def(self, '$cancel', function $$cancel() {
          var self = this;

          return self["native"].oCancelRequestAnimationFrame(self.id)
        })
      } else if ($truthy($$('Browser')['$supports?']("Animation.cancel (Internet Explorer)"))) {
        return $def(self, '$cancel', function $$cancel() {
          var self = this;

          return self["native"].msCancelAnimationFrame(self.id)
        })
      } else if ($truthy($$('Browser')['$supports?']("Animation.cancelRequest (Internet Explorer)"))) {
        return $def(self, '$cancel', function $$cancel() {
          var self = this;

          return self["native"].msCancelRequestAnimationFrame(self.id)
        })
      } else {
        return $def(self, '$cancel', function $$cancel() {
          var self = this;

          return self.$raise($$('NotImplementedError'), "window cancelAnimationFrame unsupported")
        })
      };
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$animation_frame', function $$animation_frame() {
      var block = $$animation_frame.$$p || nil;
      if ($gvars.window == null) $gvars.window = nil;

      $$animation_frame.$$p = null;
      
      ;
      return $send($$$($$('Browser'), 'AnimationFrame'), 'new', [$gvars.window], block.$to_proc());
    })
  })($nesting[0], $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Proc');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$animation_frame', function $$animation_frame() {
      var self = this;
      if ($gvars.window == null) $gvars.window = nil;

      return $send($$$($$('Browser'), 'AnimationFrame'), 'new', [$gvars.window], self.$to_proc())
    })
  })($nesting[0], null, $nesting);
};

Opal.modules["browser/effects"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $not = Opal.not, $truthy = Opal.truthy, $send = Opal.send, $eqeq = Opal.eqeq, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $to_a = Opal.to_a, $slice = Opal.slice, $kwrestargs = Opal.kwrestargs, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,DOM,[]=,style,!,nil?,!=,[],style!,visible?,hide,show,new,proc,==,resolve,then,value,animation_frame,s,animation_queue,join,compact,map,keys,each,one,call,animate,fade_out,to_proc,fade_in,height,size,px,slide_up,slide_down');
  
  self.$require("browser/animation_frame");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      (function($base, $super) {
        var self = $klass($base, $super, 'Document');

        var $proto = self.$$prototype;

        $proto["native"] = nil;
        return $def(self, '$active_element', function $$active_element() {
          var self = this;

          return self.$DOM(self["native"].activeElement)
        })
      })($nesting[0], $$('Element'));
      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.virtually_visible = $proto["native"] = $proto.animation_promise = nil;
        
        
        $def(self, '$show', function $$show(what) {
          var self = this;

          
          if (what == null) what = "block";
          self.$style()['$[]=']("display", what);
          return self;
        }, -1);
        
        $def(self, '$hide', function $$hide() {
          var self = this;

          
          self.$style()['$[]=']("display", "none");
          return self;
        });
        
        $def(self, '$visible?', function $Element_visible$ques$1() {
          var self = this;

          if ($not(self.virtually_visible['$nil?']())) {
            return self.virtually_visible
          } else {
            return self['$style!']()['$[]']("display")['$!=']("none")
          }
        });
        
        $def(self, '$toggle', function $$toggle(what) {
          var self = this;

          
          if (what == null) what = "block";
          if ($truthy(self['$visible?']())) {
            self.$hide()
          } else {
            self.$show(what)
          };
          return self;
        }, -1);
        
        $def(self, '$focus', function $$focus() {
          var self = this;

          
          self["native"].focus();
          return self;
        });
        
        $def(self, '$blur', function $$blur() {
          var self = this;

          
          self["native"].blur();
          return self;
        });
        
        $def(self, '$focused?', function $Element_focused$ques$2() {
          var self = this;

          return self["native"].hasFocus
        });
        
        $def(self, '$animation_queue', function $$animation_queue() {
          var block = $$animation_queue.$$p || nil, self = this, promise = nil, promise_resolve = nil, $ret_or_1 = nil;

          $$animation_queue.$$p = null;
          
          ;
          promise = $$('Promise').$new();
          promise_resolve = $send(self, 'proc', [], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;
            if (self.animation_promise == null) self.animation_promise = nil;

            
            if ($eqeq(self.animation_promise, promise)) {
              self.animation_promise = nil
            };
            return promise.$resolve();}, {$$s: self});
          return (self.animation_promise = $send(($truthy(($ret_or_1 = self.animation_promise)) ? ($ret_or_1) : ($$('Promise').$value(true))), 'then', [], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

            
            $send(self, 'animation_frame', [], function $$5(){
              return Opal.yield1(block, promise_resolve);});
            return promise;}, {$$s: self}));
        });
        
        $def(self, '$animate', function $$animate(properties, $kwargs) {
          var block = $$animate.$$p || nil, duration, easing, resolve, self = this;

          $$animate.$$p = null;
          
          ;
          $kwargs = $ensure_kwargs($kwargs);
          
          duration = $hash_get($kwargs, "duration");if (duration == null) duration = (0.4).$s();
          
          easing = $hash_get($kwargs, "easing");if (easing == null) easing = "ease";
          
          resolve = $hash_get($kwargs, "resolve");if (resolve == null) resolve = false;
          $send(self, 'animation_queue', [resolve], function $$6(res){var self = $$6.$$s == null ? this : $$6.$$s, original_value = nil, promise = nil;

            
            if (res == null) res = nil;
            if ($eqeq(duration, "slow")) {
              duration = (0.6).$s()
            };
            if ($eqeq(duration, "fast")) {
              duration = (0.2).$s()
            };
            original_value = self.$style()['$[]']("transition");
            self.$style()['$[]=']("transition", [original_value].concat($to_a($send(properties.$keys(), 'map', [], function $$7(key){
              
              if (key == null) key = nil;
              return "" + (key) + " " + (duration) + " " + (easing);}))).$compact().$join(", "));
            $send(properties, 'each', [], function $$8(key, value){var $a, self = $$8.$$s == null ? this : $$8.$$s;

              
              if (key == null) key = nil;
              if (value == null) value = nil;
              return ($a = [key, value], $send(self.$style(), '[]=', $a), $a[$a.length - 1]);}, {$$s: self});
            promise = $$('Promise').$new();
            return $send(self, 'one', ["transitionend"], function $$9($a){var $post_args, args, self = $$9.$$s == null ? this : $$9.$$s;

              
              $post_args = $slice(arguments);
              args = $post_args;
              self.$style()['$[]=']("transition", original_value);
              if ((block !== nil)) {
                Opal.yieldX(block, $to_a(args))
              };
              return res.$call();}, {$$arity: -1, $$s: self});}, {$$s: self});
          return self;
        }, -2);
        
        $def(self, '$fade_in', function $$fade_in($kwargs) {
          var block = $$fade_in.$$p || nil, kwargs, self = this;

          $$fade_in.$$p = null;
          
          ;
          $kwargs = $ensure_kwargs($kwargs);
          kwargs = $kwrestargs($kwargs, {});
          $send(self, 'animation_queue', [], function $$10(resolve){var self = $$10.$$s == null ? this : $$10.$$s;

            
            if (resolve == null) resolve = nil;
            if ($not(self['$visible?']())) {
              
              self.virtually_visible = true;
              self.$show();
              self.$style()['$[]=']("opacity", 0.0);
              $send(self, 'animate', [(new Map([["opacity", 1.0]])).$merge(Opal.to_hash(kwargs))], function $$11($a){var $post_args, args, self = $$11.$$s == null ? this : $$11.$$s;

                
                $post_args = $slice(arguments);
                args = $post_args;
                self.virtually_visible = nil;
                self.$style()['$[]=']("opacity", nil);
                if ((block !== nil)) {
                  return Opal.yieldX(block, $to_a(args));
                } else {
                  return nil
                };}, {$$arity: -1, $$s: self});
            };
            return resolve.$call();}, {$$s: self});
          return self;
        }, -1);
        
        $def(self, '$fade_out', function $$fade_out($kwargs) {
          var block = $$fade_out.$$p || nil, kwargs, self = this;

          $$fade_out.$$p = null;
          
          ;
          $kwargs = $ensure_kwargs($kwargs);
          kwargs = $kwrestargs($kwargs, {});
          $send(self, 'animation_queue', [], function $$12(resolve){var self = $$12.$$s == null ? this : $$12.$$s;

            
            if (resolve == null) resolve = nil;
            if ($truthy(self['$visible?']())) {
              
              self.virtually_visible = false;
              self.$style()['$[]=']("opacity", 1.0);
              $send(self, 'animate', [(new Map([["opacity", 0.0]])).$merge(Opal.to_hash(kwargs))], function $$13($a){var $post_args, args, self = $$13.$$s == null ? this : $$13.$$s;

                
                $post_args = $slice(arguments);
                args = $post_args;
                self.virtually_visible = nil;
                self.$style()['$[]=']("opacity", nil);
                self.$hide();
                if ((block !== nil)) {
                  return Opal.yieldX(block, $to_a(args));
                } else {
                  return nil
                };}, {$$arity: -1, $$s: self});
            };
            return resolve.$call();}, {$$s: self});
          return self;
        }, -1);
        
        $def(self, '$fade_toggle', function $$fade_toggle($kwargs) {
          var block = $$fade_toggle.$$p || nil, kwargs, self = this;

          $$fade_toggle.$$p = null;
          
          ;
          $kwargs = $ensure_kwargs($kwargs);
          kwargs = $kwrestargs($kwargs, {});
          if ($truthy(self['$visible?']())) {
            $send(self, 'fade_out', [Opal.to_hash(kwargs)], block.$to_proc())
          } else {
            $send(self, 'fade_in', [Opal.to_hash(kwargs)], block.$to_proc())
          };
          return self;
        }, -1);
        
        $def(self, '$slide_down', function $$slide_down($kwargs) {
          var block = $$slide_down.$$p || nil, kwargs, self = this;

          $$slide_down.$$p = null;
          
          ;
          $kwargs = $ensure_kwargs($kwargs);
          kwargs = $kwrestargs($kwargs, {});
          $send(self, 'animation_queue', [], function $$14(resolve){var self = $$14.$$s == null ? this : $$14.$$s, height = nil, orig_height = nil;

            
            if (resolve == null) resolve = nil;
            if ($not(self['$visible?']())) {
              
              self.virtually_visible = true;
              self.$show();
              height = self.$size().$height();
              orig_height = self.$style()['$[]']("height");
              self.$style()['$[]=']("height", (0).$px());
              $send(self, 'animate', [(new Map([["height", height.$px()]])).$merge(Opal.to_hash(kwargs))], function $$15($a){var $post_args, args, self = $$15.$$s == null ? this : $$15.$$s;

                
                $post_args = $slice(arguments);
                args = $post_args;
                self.virtually_visible = nil;
                self.$style()['$[]=']("height", orig_height);
                if ((block !== nil)) {
                  return Opal.yieldX(block, $to_a(args));
                } else {
                  return nil
                };}, {$$arity: -1, $$s: self});
            };
            return resolve.$call();}, {$$s: self});
          return self;
        }, -1);
        
        $def(self, '$slide_up', function $$slide_up($kwargs) {
          var block = $$slide_up.$$p || nil, kwargs, self = this;

          $$slide_up.$$p = null;
          
          ;
          $kwargs = $ensure_kwargs($kwargs);
          kwargs = $kwrestargs($kwargs, {});
          $send(self, 'animation_queue', [], function $$16(resolve){var self = $$16.$$s == null ? this : $$16.$$s, orig_height = nil;

            
            if (resolve == null) resolve = nil;
            if ($truthy(self['$visible?']())) {
              
              self.virtually_visible = false;
              orig_height = self.$style()['$[]']("height");
              $send(self, 'animate', [(new Map([["height", (0).$px()]])).$merge(Opal.to_hash(kwargs))], function $$17($a){var $post_args, args, self = $$17.$$s == null ? this : $$17.$$s;

                
                $post_args = $slice(arguments);
                args = $post_args;
                self.virtually_visible = nil;
                self.$style()['$[]=']("height", orig_height);
                self.$hide();
                if ((block !== nil)) {
                  return Opal.yieldX(block, $to_a(args));
                } else {
                  return nil
                };}, {$$arity: -1, $$s: self});
            };
            return resolve.$call();}, {$$s: self});
          return self;
        }, -1);
        return $def(self, '$slide_toggle', function $$slide_toggle($kwargs) {
          var block = $$slide_toggle.$$p || nil, kwargs, self = this;

          $$slide_toggle.$$p = null;
          
          ;
          $kwargs = $ensure_kwargs($kwargs);
          kwargs = $kwrestargs($kwargs, {});
          if ($truthy(self['$visible?']())) {
            $send(self, 'slide_up', [Opal.to_hash(kwargs)], block.$to_proc())
          } else {
            $send(self, 'slide_down', [Opal.to_hash(kwargs)], block.$to_proc())
          };
          return self;
        }, -1);
      })($nesting[0], null, $nesting);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["browser/http/binary"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $eqeqeq = Opal.eqeqeq, $def = Opal.def, $truthy = Opal.truthy, $rb_lt = Opal.rb_lt, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('attr_reader,===,to_a,include,enum_for,length,<,call,[],+,==');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'HTTP');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Binary');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.type = $proto.data = nil;
        
        self.$attr_reader("type");
        
        $def(self, '$initialize', function $$initialize(value) {
          var self = this;

          if ($eqeqeq($$('String'), value)) {
            
            self.type = "string";
            return (self.data = value);
          } else {
            
            self.type = "buffer";
            return (self.data = value.$to_a());
          }
        });
        self.$include($$('Enumerable'));
        
        $def(self, '$each', function $$each() {
          var block = $$each.$$p || nil, self = this, index = nil, length = nil;

          $$each.$$p = null;
          
          ;
          if (!$truthy(block)) {
            return self.$enum_for("each")
          };
          index = 0;
          length = self.$length();
          while ($truthy($rb_lt(index, length))) {
          
            block.$call(self['$[]'](index));
            index = $rb_plus(index, 1);
          };
          return self;
        });
        
        $def(self, '$[]', function $Binary_$$$1(index) {
          var self = this;

          if ($eqeq(self.type, "string")) {
            return self.data.charCodeAt(index) & 0xff
          } else {
            return self.data['$[]'](index)
          }
        });
        return $def(self, '$length', function $$length() {
          var self = this;

          return self.data.$length()
        });
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/http/headers"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $const_set = Opal.const_set, $klass = Opal.klass, $send = Opal.send, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $alias = Opal.alias, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('new,[],map,lines,split,chomp,each,[]=,include,clear,enum_for,call,name,value,downcase,<<,length');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'HTTP');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $const_set($nesting[0], 'Header', $$('Struct').$new("name", "value"));
      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Headers');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.hash = nil;
        
        $defs(self, '$parse', function $$parse(string) {
          var self = this;

          return self['$[]']($send(string.$lines(), 'map', [], function $$1(l){
            
            if (l == null) l = nil;
            return l.$chomp().$split(/\s*:\s*/);}))
        });
        $defs(self, '$[]', function $Headers_$$$2(hash) {
          var self = this, result = nil;

          
          result = self.$new();
          $send(hash, 'each', [], function $$3(name, value){var $a;

            
            if (name == null) name = nil;
            if (value == null) value = nil;
            return ($a = [name, value], $send(result, '[]=', $a), $a[$a.length - 1]);});
          return result;
        });
        self.$include($$('Enumerable'));
        
        $def(self, '$initialize', function $$initialize() {
          var self = this;

          return (self.hash = $$('Hash').$new())
        });
        
        $def(self, '$clear', function $$clear() {
          var self = this;

          return self.hash.$clear()
        });
        
        $def(self, '$each', function $$each() {
          var block = $$each.$$p || nil, self = this;

          $$each.$$p = null;
          
          ;
          if (!$truthy(block)) {
            return self.$enum_for("each")
          };
          $send(self.hash, 'each', [], function $$4(_, header){
            
            if (_ == null) _ = nil;
            if (header == null) header = nil;
            return block.$call([header.$name(), header.$value()]);});
          return self;
        });
        
        $def(self, '$[]', function $Headers_$$$5(name) {
          var self = this;

          return self.hash['$[]'](name.$downcase())
        });
        
        $def(self, '$[]=', function $Headers_$$$eq$6(name, value) {
          var $a, self = this, header = nil;

          
          header = $$('Header').$new(name, value);
          return ($a = [name.$downcase(), header], $send(self.hash, '[]=', $a), $a[$a.length - 1]);
        });
        
        $def(self, '$<<', function $Headers_$lt$lt$7(header) {
          var self = this;

          
          self.hash['$[]='](header.$name().$downcase(), header);
          return self;
        });
        $alias(self, "push", "<<");
        
        $def(self, '$merge!', function $Headers_merge$excl$8(other) {
          var self = this;

          
          $send(other, 'each', [], function $$9(name, value){var $a, self = $$9.$$s == null ? this : $$9.$$s;

            
            if (name == null) name = nil;
            if (value == null) value = nil;
            return ($a = [name, value], $send(self, '[]=', $a), $a[$a.length - 1]);}, {$$s: self});
          return self;
        });
        return $def(self, '$length', function $$length() {
          var self = this;

          return self.hash.$length()
        });
      })($nesting[0], null, $nesting);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/http/request"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $send2 = Opal.send2, $find_super = Opal.find_super, $send = Opal.send, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $def = Opal.def, $return_ivar = Opal.return_ivar, $assign_ivar_val = Opal.assign_ivar_val, $slice = Opal.slice, $eqeqeq = Opal.eqeqeq, $to_a = Opal.to_a, $rb_plus = Opal.rb_plus, $not = Opal.not, $lambda = Opal.lambda, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,attr_reader,transport,[],new,[]=,==,arity,instance_exec,to_proc,call,supports?,raise,!,===,include?,<<,opened?,nil?,cacheable?,rand,empty?,+,build_query,upcase,to_s,to_n,callback,sent?,each,binary?,supported?,mime_type,contain_files?,build_form_data,private,response,code,status,success?');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'HTTP');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Request');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.asynchronous = $proto.user = $proto.password = $proto.mime_type = $proto.content_type = $proto.encoding = $proto.parameters = $proto.query = $proto.callbacks = $proto.url = $proto["native"] = $proto.method = $proto.headers = $proto.response = nil;
        
        self.$include($$$($$('Native'), 'Wrapper'));
        self.$include($$$($$('Event'), 'Target'));
        $const_set($nesting[0], 'HEADERS', (new Map([["X-Requested-With", "XMLHttpRequest"], ["X-Opal-Version", $$('RUBY_ENGINE_VERSION')], ["Accept", "text/javascript, text/html, application/xml, text/xml, */*"]])));
        $const_set($nesting[0], 'STATES', ["uninitialized", "loading", "loaded", "interactive", "complete"]);
        self.$attr_reader("headers");
        self.$attr_reader("response");
        self.$attr_reader("method");
        self.$attr_reader("url");
        
        $def(self, '$initialize', function $$initialize() {
          var block = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          
          ;
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [self.$transport()], null);
          self.parameters = (new Map());
          self.query = (new Map());
          self.headers = $$('Headers')['$[]']($$('HEADERS'));
          self.method = "get";
          self.asynchronous = true;
          self.binary = false;
          self.cacheable = true;
          self.opened = false;
          self.sent = false;
          self.completed = false;
          self.callbacks = $send($$('Hash'), 'new', [], function $$1(h, k){var $a;

            
            if (h == null) h = nil;
            if (k == null) k = nil;
            return ($a = [k, []], $send(h, '[]=', $a), $a[$a.length - 1]);});
          if ($truthy(block)) {
            if ($eqeq(block.$arity(), 0)) {
              return $send(self, 'instance_exec', [], block.$to_proc())
            } else {
              return block.$call(self)
            }
          } else {
            return nil
          };
        });
        if ($truthy($$('Browser')['$supports?']("XHR"))) {
          
          $def(self, '$transport', function $$transport() {
            
            return new XMLHttpRequest();
          })
        } else if ($truthy($$('Browser')['$supports?']("ActiveX"))) {
          
          $def(self, '$transport', function $$transport() {
            
            return new ActiveXObject("MSXML2.XMLHTTP.3.0");
          })
        } else {
          
          $def(self, '$transport', function $$transport() {
            var self = this;

            return self.$raise($$('NotImplementedError'))
          })
        };
        
        $def(self, '$opened?', $return_ivar("opened"));
        
        $def(self, '$sent?', $return_ivar("sent"));
        
        $def(self, '$completed?', $return_ivar("completed"));
        
        $def(self, '$asynchronous?', $return_ivar("asynchronous"));
        
        $def(self, '$synchronous?', function $Request_synchronous$ques$2() {
          var self = this;

          return self.asynchronous['$!']()
        });
        
        $def(self, '$asynchronous!', $assign_ivar_val("asynchronous", true));
        
        $def(self, '$synchronous!', $assign_ivar_val("asynchronous", false));
        
        $def(self, '$binary?', $return_ivar("binary"));
        
        $def(self, '$binary!', $assign_ivar_val("binary", true));
        
        $def(self, '$cacheable?', $return_ivar("cacheable"));
        
        $def(self, '$no_cache!', $assign_ivar_val("cacheable", false));
        
        $def(self, '$user', function $$user(value) {
          var self = this;

          
          if (value == null) value = nil;
          if ($truthy(value)) {
            return (self.user = value)
          } else {
            return self.user
          };
        }, -1);
        
        $def(self, '$password', function $$password(value) {
          var self = this;

          
          if (value == null) value = nil;
          if ($truthy(value)) {
            return (self.password = value)
          } else {
            return self.password
          };
        }, -1);
        
        $def(self, '$mime_type', function $$mime_type(value) {
          var self = this;

          
          if (value == null) value = nil;
          if ($truthy(value)) {
            return (self.mime_type = value)
          } else {
            return self.mime_type
          };
        }, -1);
        
        $def(self, '$content_type', function $$content_type(value) {
          var self = this;

          
          if (value == null) value = nil;
          if ($truthy(value)) {
            return (self.content_type = value)
          } else {
            return self.content_type
          };
        }, -1);
        
        $def(self, '$encoding', function $$encoding(value) {
          var self = this;

          
          if (value == null) value = nil;
          if ($truthy(value)) {
            return (self.encoding = value)
          } else {
            return self.encoding
          };
        }, -1);
        
        $def(self, '$parameters', function $$parameters(hash) {
          var self = this;

          
          if (hash == null) hash = nil;
          if ($truthy(hash)) {
            return (self.parameters = hash)
          } else {
            return self.parameters
          };
        }, -1);
        
        $def(self, '$query', function $$query(hash) {
          var self = this;

          
          if (hash == null) hash = nil;
          if ($truthy(hash)) {
            return (self.query = hash)
          } else {
            return self.query
          };
        }, -1);
        
        $def(self, '$on', function $$on(what, $a) {
          var block = $$on.$$p || nil, $post_args, $fwd_rest, self = this;

          $$on.$$p = null;
          
          ;
          $post_args = $slice(arguments, 1);
          $fwd_rest = $post_args;
          if ((($truthy($$('STATES')['$include?'](what)) || ($truthy(["success", "failure"]['$include?'](what)))) || ($eqeqeq($$('Integer'), what)))) {
            return self.callbacks['$[]'](what)['$<<'](block)
          } else {
            return $send2(self, $find_super(self, 'on', $$on, false, true), 'on', [what].concat($to_a($fwd_rest)), block)
          };
        }, -2);
        
        $def(self, '$open', function $$open(method, url, asynchronous, user, password) {
          var self = this;

          
          if (method == null) method = nil;
          if (url == null) url = nil;
          if (asynchronous == null) asynchronous = nil;
          if (user == null) user = nil;
          if (password == null) password = nil;
          if ($truthy(self['$opened?']())) {
            self.$raise("the request has already been opened")
          };
          if (!$truthy(method['$nil?']())) {
            self.method = method
          };
          if (!$truthy(url['$nil?']())) {
            self.url = url
          };
          if (!$truthy(asynchronous['$nil?']())) {
            self.asynchronous = asynchronous
          };
          if (!$truthy(user['$nil?']())) {
            self.user = user
          };
          if (!$truthy(password['$nil?']())) {
            self.password = password
          };
          url = self.url;
          if (!$truthy(self['$cacheable?']())) {
            self.query['$[]=']("_", self.$rand())
          };
          if (!$truthy(self.query['$empty?']())) {
            
            if ($truthy(url['$include?']("?"))) {
              url = $rb_plus(url, "&")
            } else {
              url = $rb_plus(url, "?")
            };
            url = $rb_plus(url, $$('FormData').$build_query(self.query));
          };
          self["native"].open(self.method.$to_s().$upcase(), url.$to_s(), self.asynchronous, self.user.$to_n(), self.password.$to_n());
          if (!$truthy(self.callbacks['$empty?']())) {
            self["native"].onreadystatechange = self.$callback()
          };
          self.opened = true;
          return self;
        }, -1);
        
        $def(self, '$send', function $$send(parameters) {
          var self = this, header = nil, data = nil;

          
          if (parameters == null) parameters = self.parameters;
          if (!$truthy(self['$opened?']())) {
            self.$raise("the request has not been opened")
          };
          if ($truthy(self['$sent?']())) {
            self.$raise("the request has already been sent")
          };
          if (!$truthy(self['$cacheable?']())) {
            self["native"].setRequestHeader("If-Modified-Since", "Tue, 11 Sep 2001 12:46:00 GMT")
          };
          $send(self.headers, 'each', [], function $$3(name, value){var self = $$3.$$s == null ? this : $$3.$$s;
            if (self["native"] == null) self["native"] = nil;

            
            if (name == null) name = nil;
            if (value == null) value = nil;
            return self["native"].setRequestHeader(name.$to_s(), value.$to_s());}, {$$s: self});
          if ($truthy(self.content_type)) {
            
            header = self.content_type;
            if ($truthy(self.encoding)) {
              header = $rb_plus(header, "; charset=" + (self.encoding))
            };
            self["native"].setRequestHeader('Content-Type', header);
          };
          if ($truthy(self['$binary?']())) {
            if ($truthy($$('Buffer')['$supported?']())) {
              self["native"].responseType = 'arraybuffer'
            } else {
              self["native"].overrideMimeType('text/plain; charset=x-user-defined')
            }
          };
          if (($truthy(self.$mime_type()) && ($not(self['$binary?']())))) {
            self["native"].overrideMimeType(self.mime_type)
          };
          self.sent = true;
          self.response = $$('Response').$new(self);
          if ($eqeqeq($$('String'), parameters)) {
            data = parameters
          } else if ((($eqeqeq($$('Hash'), parameters) && ($not(parameters['$empty?']()))) || ($eqeqeq($$('FormData'), parameters)))) {
            
            data = ($eqeqeq($$('Hash'), parameters) ? (($truthy($$('FormData')['$contain_files?'](parameters)) ? ($$('FormData').$build_form_data(parameters)) : ($$('FormData').$build_query(parameters)))) : (parameters));
            if (!$truthy(self.content_type)) {
              if (!$eqeqeq($$('FormData'), data)) {
                self["native"].setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')
              }
            };
            data = data.$to_n();
          } else {
            data = null
          };
          self["native"].send(data);
          return self.response;
        }, -1);
        
        $def(self, '$abort', function $$abort() {
          var self = this;

          return self["native"].abort()
        });
        self.$private();
        return $def(self, '$callback', function $$callback() {
          var self = this;

          return $lambda(function $$4(event){var self = $$4.$$s == null ? this : $$4.$$s, state = nil, res = nil;
            if (self["native"] == null) self["native"] = nil;
            if (self.callbacks == null) self.callbacks = nil;

            
            if (event == null) event = nil;
            state = $$('STATES')['$[]'](self["native"].readyState);
            res = self.$response();
            $send(self.callbacks['$[]'](state), 'each', [], function $$5(b){
              
              if (b == null) b = nil;
              return b.$call(res);});
            if ($eqeq(state, "complete")) {
              
              self.completed = true;
              $send(self.callbacks['$[]'](res.$status().$code()), 'each', [], function $$6(b){
                
                if (b == null) b = nil;
                return b.$call(res);});
              if ($truthy(res['$success?']())) {
                return $send(self.callbacks['$[]']("success"), 'each', [], function $$7(b){
                  
                  if (b == null) b = nil;
                  return b.$call(res);})
              } else {
                return $send(self.callbacks['$[]']("failure"), 'each', [], function $$8(b){
                  
                  if (b == null) b = nil;
                  return b.$call(res);})
              };
            } else {
              return nil
            };}, {$$s: self})
        });
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["json"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $Object = Opal.Object, $eqeqeq = Opal.eqeqeq, $defs = Opal.defs, $truthy = Opal.truthy, $def = Opal.def, $return_val = Opal.return_val, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('raise,new,push,[]=,[],create_id,json_create,const_get,attr_accessor,create_id=,===,parse,generate,from_object,merge,to_json,responds_to?,to_io,write,to_s,to_a,strftime');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'JSON');

    var $a, $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $klass($nesting[0], $$('StandardError'), 'JSONError');
    $klass($nesting[0], $$('JSONError'), 'ParserError');
    
    var $hasOwn = Opal.hasOwnProperty;

    function $parse(source) {
      try {
        return JSON.parse(source);
      } catch (e) {
        self.$raise($$$($$('JSON'), 'ParserError'), e.message);
      }
    };

    function to_opal(value, options) {
      var klass, arr, hash, i, ii, k;

      switch (typeof value) {
        case 'string':
          return value;

        case 'number':
          return value;

        case 'boolean':
          return !!value;

        case 'undefined':
          return nil;

        case 'object':
          if (!value) return nil;

          if (value.$$is_array) {
            arr = (Opal.hash_get(options, 'array_class')).$new();

            for (i = 0, ii = value.length; i < ii; i++) {
              (arr).$push(to_opal(value[i], options));
            }

            return arr;
          }
          else {
            hash = (Opal.hash_get(options, 'object_class')).$new();

            for (k in value) {
              if ($hasOwn.call(value, k)) {
                ($a = [k, to_opal(value[k], options)], $send((hash), '[]=', $a), $a[$a.length - 1]);
              }
            }

            if (!Opal.hash_get(options, 'parse') && (klass = (hash)['$[]']($$('JSON').$create_id())) != nil) {
              return $Object.$const_get(klass).$json_create(hash);
            }
            else {
              return hash;
            }
          }
        }
    };
  ;
    (function(self, $parent_nesting) {
      
      return self.$attr_accessor("create_id")
    })(Opal.get_singleton_class(self), $nesting);
    self['$create_id=']("json_class");
    $defs(self, '$[]', function $JSON_$$$1(value, options) {
      var self = this;

      
      if (options == null) options = (new Map());
      if ($eqeqeq($$('String'), value)) {
        return self.$parse(value, options)
      } else {
        return self.$generate(value, options)
      };
    }, -2);
    $defs(self, '$parse', function $$parse(source, options) {
      var self = this;

      
      if (options == null) options = (new Map());
      return self.$from_object($parse(source), options.$merge((new Map([["parse", true]]))));
    }, -2);
    $defs(self, '$parse!', function $JSON_parse$excl$2(source, options) {
      var self = this;

      
      if (options == null) options = (new Map());
      return self.$parse(source, options);
    }, -2);
    $defs(self, '$load', function $$load(source, options) {
      var self = this;

      
      if (options == null) options = (new Map());
      return self.$from_object($parse(source), options);
    }, -2);
    $defs(self, '$from_object', function $$from_object(js_object, options) {
      var $ret_or_1 = nil;

      
      if (options == null) options = (new Map());
      if ($truthy(($ret_or_1 = options['$[]']("object_class")))) {
        $ret_or_1
      } else {
        options['$[]=']("object_class", $$('Hash'))
      };
      if ($truthy(($ret_or_1 = options['$[]']("array_class")))) {
        $ret_or_1
      } else {
        options['$[]=']("array_class", $$('Array'))
      };
      return to_opal(js_object, options);;
    }, -2);
    $defs(self, '$generate', function $$generate(obj, options) {
      
      
      if (options == null) options = (new Map());
      return obj.$to_json(options);
    }, -2);
    return $defs(self, '$dump', function $$dump(obj, io, limit) {
      var self = this, string = nil;

      
      if (io == null) io = nil;
      if (limit == null) limit = nil;
      string = self.$generate(obj);
      if ($truthy(io)) {
        
        if ($truthy(io['$responds_to?']("to_io"))) {
          io = io.$to_io()
        };
        io.$write(string);
        return io;
      } else {
        return string
      };
    }, -2);
  })($nesting[0], $nesting);
  (function($base, $super) {
    var self = $klass($base, $super, 'Object');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      return self.$to_s().$to_json()
    })
  })($nesting[0], null);
  (function($base) {
    var self = $module($base, 'Enumerable');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      return self.$to_a().$to_json()
    })
  })($nesting[0]);
  (function($base, $super) {
    var self = $klass($base, $super, 'Array');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        result.push((self[i]).$to_json());
      }

      return '[' + result.join(',') + ']';
    
    })
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Boolean');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      return (self == true) ? 'true' : 'false';
    })
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Hash');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      
      var result = [];

      Opal.hash_each(self, false, function(key, value) {
        result.push((key).$to_s().$to_json() + ':' + (value).$to_json());
        return [false, false];
      });

      return '{' + result.join(',') + '}';
    
    })
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'NilClass');

    
    return $def(self, '$to_json', $return_val("null"))
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Numeric');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      return self.toString();
    })
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      return JSON.stringify(self);
    })
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Time');

    
    return $def(self, '$to_json', function $$to_json() {
      var self = this;

      return self.$strftime("%FT%T%z").$to_json()
    })
  })($nesting[0], null);
  return (function($base, $super) {
    var self = $klass($base, $super, 'Date');

    
    
    
    $def(self, '$to_json', function $$to_json() {
      var self = this;

      return self.$to_s().$to_json()
    });
    return $def(self, '$as_json', function $$as_json() {
      var self = this;

      return self.$to_s()
    });
  })($nesting[0], null);
};

Opal.modules["browser/http/response"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $truthy = Opal.truthy, $rb_ge = Opal.rb_ge, $rb_lt = Opal.rb_lt, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,new,attr_reader,to_n,parse,code,status,>=,<,==,!,success?,alias_native,DOM,binary?,request,supported?,text');
  
  self.$require("json");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'HTTP');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Response');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.headers = $proto["native"] = nil;
        
        self.$include($$$($$('Native'), 'Wrapper'));
        $const_set($nesting[0], 'Status', $$('Struct').$new("code", "text"));
        self.$attr_reader("request");
        
        $def(self, '$initialize', function $$initialize(request) {
          var $yield = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [request.$to_n()], null);
          return (self.request = request);
        });
        
        $def(self, '$headers', function $$headers() {
          var self = this, $ret_or_1 = nil;

          return (self.headers = ($truthy(($ret_or_1 = self.headers)) ? ($ret_or_1) : ($$('Headers').$parse(self["native"].getAllResponseHeaders()))))
        });
        
        $def(self, '$status', function $$status() {
          var self = this;

          return $$('Status').$new(self["native"].status || nil, self["native"].statusText || nil)
        });
        
        $def(self, '$success?', function $Response_success$ques$1() {
          var self = this, code = nil, $ret_or_1 = nil, $ret_or_2 = nil;

          if ($truthy((code = self.$status().$code()))) {
            if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = $rb_ge(code, 200))) ? ($rb_lt(code, 300)) : ($ret_or_2))))) {
              return $ret_or_1
            } else {
              return code['$=='](304)
            }
          } else {
            return false
          }
        });
        
        $def(self, '$failure?', function $Response_failure$ques$2() {
          var self = this;

          return self['$success?']()['$!']()
        });
        self.$alias_native("url", "responseURL");
        
        $def(self, '$text', function $$text() {
          var self = this;

          
      var result = self["native"].responseText;

      if (!result) {
        return nil;
      }

      return result;
    
        });
        
        $def(self, '$json', function $$json() {
          var self = this;

          
      var result = self["native"].responseText;

      if (!result) {
        return nil;
      }

      return $$('JSON').$parse(result);
    
        });
        
        $def(self, '$xml', function $$xml() {
          var self = this;

          
          
      var result = self["native"].responseXML;

      if (!result) {
        return nil;
      }
    ;
          return self.$DOM(result);
        });
        return $def(self, '$binary', function $$binary() {
          var self = this;

          
          if (!$truthy(self.$request()['$binary?']())) {
            return nil
          };
          if ($truthy($$('Buffer')['$supported?']())) {
            
            
        var result = self["native"].response;

        if (!result) {
          return nil;
        }
      ;
            return $$('Binary').$new($$('Buffer').$new(result));
          } else {
            
            if (!$truthy(self.$text())) {
              return nil
            };
            return $$('Binary').$new(self.$text());
          };
        });
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["browser/http"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $truthy = Opal.truthy, $defs = Opal.defs, $send = Opal.send, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,supports?,tap,new,send,open,to_proc,on,resolve,reject,send!');
  
  self.$require("browser/http/binary");
  self.$require("browser/http/headers");
  self.$require("browser/http/request");
  self.$require("browser/http/response");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'HTTP');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $defs(self, '$supported?', function $HTTP_supported$ques$1() {
        var $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = $$('Browser')['$supports?']("XHR")))) {
          return $ret_or_1
        } else {
          return $$('Browser')['$supports?']("ActiveXObject")
        }
      });
      $defs(self, '$send', function $$send(method, url, data) {
        var block = $$send.$$p || nil;

        $$send.$$p = null;
        
        ;
        if (data == null) data = nil;
        return $send($$('Promise').$new(), 'tap', [], function $$2(promise){
          
          if (promise == null) promise = nil;
          return $send($send($$('Request'), 'new', [], block.$to_proc()), 'tap', [], function $$3(req){
            
            if (req == null) req = nil;
            $send(req, 'on', ["success"], function $$4(res){
              
              if (res == null) res = nil;
              return promise.$resolve(res);});
            return $send(req, 'on', ["failure"], function $$5(res){
              
              if (res == null) res = nil;
              return promise.$reject(res);});}).$open(method, url).$send(data);});
      }, -3);
      $defs(self, '$get', function $$get(url) {
        var block = $$get.$$p || nil, self = this;

        $$get.$$p = null;
        
        ;
        return $send(self, 'send', ["get", url], block.$to_proc());
      });
      $defs(self, '$head', function $$head(url) {
        var block = $$head.$$p || nil, self = this;

        $$head.$$p = null;
        
        ;
        return $send(self, 'send', ["head", url], block.$to_proc());
      });
      $defs(self, '$post', function $$post(url, data) {
        var block = $$post.$$p || nil, self = this;

        $$post.$$p = null;
        
        ;
        if (data == null) data = nil;
        return $send(self, 'send', ["post", url, data], block.$to_proc());
      }, -2);
      $defs(self, '$put', function $$put(url, data) {
        var block = $$put.$$p || nil, self = this;

        $$put.$$p = null;
        
        ;
        if (data == null) data = nil;
        return $send(self, 'send', ["put", url, data], block.$to_proc());
      }, -2);
      $defs(self, '$delete', function $HTTP_delete$6(url, data) {
        var block = $HTTP_delete$6.$$p || nil, self = this;

        $HTTP_delete$6.$$p = null;
        
        ;
        if (data == null) data = nil;
        return $send(self, 'send', ["delete", url, data], block.$to_proc());
      }, -2);
      $defs(self, '$send!', function $HTTP_send$excl$7(method, url, data) {
        var block = $HTTP_send$excl$7.$$p || nil;

        $HTTP_send$excl$7.$$p = null;
        
        ;
        if (data == null) data = nil;
        return $send($$('Request'), 'new', [], block.$to_proc()).$open(method, url, false).$send(data);
      }, -3);
      $defs(self, '$get!', function $HTTP_get$excl$8(url) {
        var block = $HTTP_get$excl$8.$$p || nil, self = this;

        $HTTP_get$excl$8.$$p = null;
        
        ;
        return $send(self, 'send!', ["get", url], block.$to_proc());
      });
      $defs(self, '$head!', function $HTTP_head$excl$9(url) {
        var block = $HTTP_head$excl$9.$$p || nil, self = this;

        $HTTP_head$excl$9.$$p = null;
        
        ;
        return $send(self, 'send!', ["head", url], block.$to_proc());
      });
      $defs(self, '$post!', function $HTTP_post$excl$10(url, data) {
        var block = $HTTP_post$excl$10.$$p || nil, self = this;

        $HTTP_post$excl$10.$$p = null;
        
        ;
        if (data == null) data = nil;
        return $send(self, 'send!', ["post", url, data], block.$to_proc());
      }, -2);
      $defs(self, '$put!', function $HTTP_put$excl$11(url, data) {
        var block = $HTTP_put$excl$11.$$p || nil, self = this;

        $HTTP_put$excl$11.$$p = null;
        
        ;
        if (data == null) data = nil;
        return $send(self, 'send!', ["put", url, data], block.$to_proc());
      }, -2);
      return $defs(self, '$delete!', function $HTTP_delete$excl$12(url, data) {
        var block = $HTTP_delete$excl$12.$$p || nil, self = this;

        $HTTP_delete$excl$12.$$p = null;
        
        ;
        if (data == null) data = nil;
        return $send(self, 'send!', ["delete", url, data], block.$to_proc());
      }, -2);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["browser/delay"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $send = Opal.send, $gvars = Opal.gvars, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('attr_reader,convert,to_n,tap,new,to_proc,start,resolve,after,after!,resolve_after');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Delay');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.window = $proto.id = $proto.block = $proto.after = nil;
      
      self.$attr_reader("after");
      
      $def(self, '$initialize', function $$initialize(window, time) {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        self.window = $$('Native').$convert(window);
        self.after = time;
        return (self.block = block);
      });
      
      $def(self, '$abort', function $$abort() {
        var self = this;

        return self.window.clearTimeout(self.id)
      });
      return $def(self, '$start', function $$start() {
        var self = this;

        return (self.id = self.window.setTimeout(self.block.$to_n(), self.after * 1000))
      });
    })($nesting[0], null, $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Window');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = nil;
      
      
      $def(self, '$after', function $$after(time) {
        var block = $$after.$$p || nil, self = this;

        $$after.$$p = null;
        
        ;
        return $send($send($$('Delay'), 'new', [self["native"], time], block.$to_proc()), 'tap', [], "start".$to_proc());
      });
      
      $def(self, '$after!', function $Window_after$excl$1(time) {
        var block = $Window_after$excl$1.$$p || nil, self = this;

        $Window_after$excl$1.$$p = null;
        
        ;
        return $send($$('Delay'), 'new', [self["native"], time], block.$to_proc());
      });
      return $def(self, '$resolve_after', function $$resolve_after(time) {
        var self = this, promise = nil;

        
        promise = $$('Promise').$new();
        $send($$('Delay'), 'new', [self["native"], time], function $$2(){
          return promise.$resolve()}).$start();
        return promise;
      });
    })($nesting[0], null, $nesting);
  })($nesting[0], $nesting);
  (function($base) {
    var self = $module($base, 'Kernel');

    
    
    
    $def(self, '$after', function $$after(time) {
      var block = $$after.$$p || nil;
      if ($gvars.window == null) $gvars.window = nil;

      $$after.$$p = null;
      
      ;
      return $send($gvars.window, 'after', [time], block.$to_proc());
    });
    
    $def(self, '$after!', function $Kernel_after$excl$3(time) {
      var block = $Kernel_after$excl$3.$$p || nil;
      if ($gvars.window == null) $gvars.window = nil;

      $Kernel_after$excl$3.$$p = null;
      
      ;
      return $send($gvars.window, 'after!', [time], block.$to_proc());
    });
    return $def(self, '$resolve_after', function $$resolve_after(time) {
            if ($gvars.window == null) $gvars.window = nil;

      return $gvars.window.$resolve_after(time)
    });
  })($nesting[0]);
  return (function($base, $super) {
    var self = $klass($base, $super, 'Proc');

    
    
    
    $def(self, '$after', function $$after(time) {
      var self = this;
      if ($gvars.window == null) $gvars.window = nil;

      return $send($gvars.window, 'after', [time], self.$to_proc())
    });
    return $def(self, '$after!', function $Proc_after$excl$4(time) {
      var self = this;
      if ($gvars.window == null) $gvars.window = nil;

      return $send($gvars.window, 'after!', [time], self.$to_proc())
    });
  })($nesting[0], null);
};

Opal.modules["browser/interval"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $return_ivar = Opal.return_ivar, $truthy = Opal.truthy, $send = Opal.send, $gvars = Opal.gvars, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('attr_reader,convert,nil?,stopped?,aborted?,raise,call,tap,new,to_proc,every,every!');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Interval');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.id = $proto.window = $proto.block = $proto.every = nil;
      
      self.$attr_reader("every");
      
      $def(self, '$initialize', function $$initialize(window, time) {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        self.window = $$('Native').$convert(window);
        self.every = time;
        self.block = block;
        return (self.aborted = false);
      });
      
      $def(self, '$stopped?', function $Interval_stopped$ques$1() {
        var self = this;

        return self.id['$nil?']()
      });
      
      $def(self, '$aborted?', $return_ivar("aborted"));
      
      $def(self, '$abort', function $$abort() {
        var self = this;

        
        self.window.clearInterval(self.id);
        self.aborted = true;
        return (self.id = nil);
      });
      
      $def(self, '$stop', function $$stop() {
        var self = this;

        
        if ($truthy(self['$stopped?']())) {
          return nil
        };
        self.window.clearInterval(self.id);
        self.stopped = true;
        return (self.id = nil);
      });
      
      $def(self, '$start', function $$start() {
        var self = this;

        
        if ($truthy(self['$aborted?']())) {
          self.$raise("the interval has been aborted")
        };
        if (!$truthy(self['$stopped?']())) {
          return nil
        };
        return (self.id = self.window.setInterval(self.block, self.every * 1000));
      });
      return $def(self, '$call', function $$call() {
        var self = this;

        return self.block.$call()
      });
    })($nesting[0], null, $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Window');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = nil;
      
      
      $def(self, '$every', function $$every(time) {
        var block = $$every.$$p || nil, self = this;

        $$every.$$p = null;
        
        ;
        return $send($send($$('Interval'), 'new', [self["native"], time], block.$to_proc()), 'tap', [], "start".$to_proc());
      });
      return $def(self, '$every!', function $Window_every$excl$2(time) {
        var block = $Window_every$excl$2.$$p || nil, self = this;

        $Window_every$excl$2.$$p = null;
        
        ;
        return $send($$('Interval'), 'new', [self["native"], time], block.$to_proc());
      });
    })($nesting[0], null, $nesting);
  })($nesting[0], $nesting);
  (function($base) {
    var self = $module($base, 'Kernel');

    
    
    
    $def(self, '$every', function $$every(time) {
      var block = $$every.$$p || nil;
      if ($gvars.window == null) $gvars.window = nil;

      $$every.$$p = null;
      
      ;
      return $send($gvars.window, 'every', [time], block.$to_proc());
    });
    return $def(self, '$every!', function $Kernel_every$excl$3(time) {
      var block = $Kernel_every$excl$3.$$p || nil;
      if ($gvars.window == null) $gvars.window = nil;

      $Kernel_every$excl$3.$$p = null;
      
      ;
      return $send($gvars.window, 'every!', [time], block.$to_proc());
    });
  })($nesting[0]);
  return (function($base, $super) {
    var self = $klass($base, $super, 'Proc');

    
    
    
    $def(self, '$every', function $$every(time) {
      var self = this;
      if ($gvars.window == null) $gvars.window = nil;

      return $send($gvars.window, 'every', [time], self.$to_proc())
    });
    return $def(self, '$every!', function $Proc_every$excl$4(time) {
      var self = this;
      if ($gvars.window == null) $gvars.window = nil;

      return $send($gvars.window, 'every!', [time], self.$to_proc())
    });
  })($nesting[0], null);
};

Opal.modules["browser/immediate"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $send = Opal.send, $to_a = Opal.to_a, $class_variable_set = Opal.class_variable_set, $gvars = Opal.gvars, $class_variable_get = Opal.class_variable_get, $eqeqeq = Opal.eqeqeq, $return_val = Opal.return_val, $return_ivar = Opal.return_ivar, $slice = Opal.slice, $defs = Opal.defs, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('supports?,call,to_proc,rand,on,start_with?,data,===,delete,[],length,to_s,[]=,send,aborted?,prevent,tap,new,defer,proc,resolve,reject');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Immediate');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;
      if ($gvars.window == null) $gvars.window = nil;

      $proto["function"] = $proto["arguments"] = $proto.block = $proto.id = nil;
      
      
      $def(self, '$initialize', function $$initialize(func, args) {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        self.aborted = false;
        self["function"] = func;
        self["arguments"] = args;
        return (self.block = block);
      });
      if ($truthy($$('Browser')['$supports?']("Immediate"))) {
        
        
        $def(self, '$dispatch', function $$dispatch() {
          var self = this;

          return (self.id = window.setImmediate(function() {
        $send(self["function"], 'call', $to_a(self["arguments"]), self.block.$to_proc());
      }))
        });
        
        $def(self, '$prevent', function $$prevent() {
          var self = this;

          return window.clearImmediate(self.id)
        });
      } else if ($truthy($$('Browser')['$supports?']("Immediate (Internet Explorer)"))) {
        
        
        $def(self, '$dispatch', function $$dispatch() {
          var self = this;

          return (self.id = window.msSetImmediate(function() {
        $send(self["function"], 'call', $to_a(self["arguments"]), self.block.$to_proc());
      }))
        });
        
        $def(self, '$prevent', function $$prevent() {
          var self = this;

          return window.msClearImmediate(self.id)
        });
      } else if ($truthy($$('Browser')['$supports?']("Window.send (Asynchronous)"))) {
        
        $class_variable_set($nesting[0], '@@tasks', (new Map()));
        $class_variable_set($nesting[0], '@@prefix', "opal.browser.immediate." + (self.$rand(1000000)) + ".");
        $send($gvars.window, 'on', ["message"], function $Immediate$1(e){var task = nil;

          
          if (e == null) e = nil;
          if (($eqeqeq($$('String'), e.$data()) && ($truthy(e.$data()['$start_with?']($class_variable_get($nesting[0], '@@prefix', false)))))) {
            if ($truthy((task = $class_variable_get($nesting[0], '@@tasks', false).$delete(e.$data()['$[]'](Opal.Range.$new($class_variable_get($nesting[0], '@@prefix', false).$length(), -1, false)))))) {
              return $send(task['$[]'](0), 'call', $to_a(task['$[]'](1)), task['$[]'](2).$to_proc())
            } else {
              return nil
            }
          } else {
            return nil
          };});
        
        $def(self, '$dispatch', function $$dispatch() {
          var self = this;
          if ($gvars.window == null) $gvars.window = nil;

          
          self.id = self.$rand(1000000).$to_s();
          $class_variable_get($nesting[0], '@@tasks', false)['$[]='](self.id, [self["function"], self["arguments"], self.block]);
          return $gvars.window.$send("" + ($class_variable_get($nesting[0], '@@prefix', false)) + (self.id));
        });
        
        $def(self, '$prevent', function $$prevent() {
          var self = this;

          return $class_variable_get($nesting[0], '@@tasks', false).$delete(self.id)
        });
      } else if ($truthy($$('Browser')['$supports?']("Event.readystatechange"))) {
        
        
        $def(self, '$dispatch', function $$dispatch() {
          var self = this;

          
        var script = document.createElement("script");

        script.onreadystatechange = function() {
          if (!self['$aborted?']()) {
            $send(self["function"], 'call', $to_a(self["arguments"]), self.block.$to_proc());
          }

          script.onreadystatechange = null;
          script.parentNode.removeChild(script);
        };

        document.documentElement.appendChild(script);
      
        });
        
        $def(self, '$prevent', $return_val(nil));
      } else {
        
        
        $def(self, '$dispatch', function $$dispatch() {
          var self = this;

          return (self.id = window.setTimeout(function() {
        $send(self["function"], 'call', $to_a(self["arguments"]), self.block.$to_proc());
      }, 0))
        });
        
        $def(self, '$prevent', function $$prevent() {
          var self = this;

          return window.clearTimeout(self.id)
        });
      };
      
      $def(self, '$abort', function $$abort() {
        var self = this;

        
        if ($truthy(self['$aborted?']())) {
          return nil
        };
        self.aborted = true;
        self.$prevent();
        return self;
      });
      return $def(self, '$aborted?', $return_ivar("aborted"));
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$defer', function $$defer($a) {
      var block = $$defer.$$p || nil, $post_args, args;

      $$defer.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      return $send($$$($$('Browser'), 'Immediate').$new(block, args), 'tap', [], "dispatch".$to_proc());
    }, -1)
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Proc');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$defer', function $$defer($a) {
      var block = $$defer.$$p || nil, $post_args, args, self = this;

      $$defer.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      return $send($send($$$($$('Browser'), 'Immediate'), 'new', [self, args], block.$to_proc()), 'tap', [], "dispatch".$to_proc());
    }, -1)
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Promise');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $defs(self, '$defer', function $$defer($a) {
      var block = $$defer.$$p || nil, $post_args, args, self = this;

      $$defer.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      return $send(self.$new(), 'tap', [], function $$2(promise){var self = $$2.$$s == null ? this : $$2.$$s;

        
        if (promise == null) promise = nil;
        return $send(self, 'proc', [], function $$3(){var e = nil;

          try {
            return promise.$resolve($send(block, 'call', $to_a(args)))
          } catch ($err) {
            if (Opal.rescue($err, [$$('Exception')])) {(e = $err)
              try {
                return promise.$reject(e)
              } finally { Opal.pop_exception($err); }
            } else { throw $err; }
          }}).$defer();}, {$$s: self});
    }, -1)
  })($nesting[0], null, $nesting);
};

Opal.modules["browser/storage"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $defs = Opal.defs, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $return_ivar = Opal.return_ivar, $assign_ivar_val = Opal.assign_ivar_val, $truthy = Opal.truthy, $slice = Opal.slice, $to_a = Opal.to_a, $eqeqeq = Opal.eqeqeq, $gvars = Opal.gvars, $rb_times = Opal.rb_times, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,delete,create_id,[],map,parse,attr_reader,autosave!,reload,include,enum_for,each,to_proc,__send__,[]=,autosave?,save,tap,clear,===,replace,call,raise,supports?,dump,options,cookies,*,<<,new,to_json,name,class,to_s,seek,string,to_n');
  
  self.$require("json");
  self.$require("stringio");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Storage');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.data = $proto.autosave = $proto.window = $proto.name = $proto.element = nil;
      
      $defs(self, '$json_create', function $$json_create(data) {
        
        
        data.$delete($$('JSON').$create_id());
        return $$('Hash')['$[]']($send(data, 'map', [], function $$1(key, value){
          
          if (key == null) key = nil;
          if (value == null) value = nil;
          return [$$('JSON').$parse(key), value];}));
      });
      self.$attr_reader("name");
      
      $def(self, '$initialize', function $$initialize(window, name) {
        var $yield = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [], null);
        self.window = window;
        self.name = name;
        self.data = (new Map());
        self['$autosave!']();
        return self.$reload();
      });
      
      $def(self, '$autosave?', $return_ivar("autosave"));
      
      $def(self, '$autosave!', $assign_ivar_val("autosave", true));
      
      $def(self, '$no_autosave!', $assign_ivar_val("autosave", false));
      self.$include($$('Enumerable'));
      
      $def(self, '$each', function $$each() {
        var block = $$each.$$p || nil, self = this;

        $$each.$$p = null;
        
        ;
        if (!$truthy(block)) {
          return self.$enum_for("each")
        };
        $send(self.data, 'each', [], block.$to_proc());
        return self;
      });
      
      $def(self, '$method_missing', function $$method_missing($a) {
        var block = $$method_missing.$$p || nil, $post_args, args, self = this;

        $$method_missing.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        args = $post_args;
        return $send(self.data, '__send__', $to_a(args), block.$to_proc());
      }, -1);
      
      $def(self, '$[]=', function $Storage_$$$eq$2(key, value) {
        var self = this;

        
        self.data['$[]='](key, value);
        if ($truthy(self['$autosave?']())) {
          return self.$save()
        } else {
          return nil
        };
      });
      
      $def(self, '$delete', function $Storage_delete$3(key) {
        var self = this;

        return $send(self.data.$delete(key), 'tap', [], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

          if ($truthy(self['$autosave?']())) {
            return self.$save()
          } else {
            return nil
          }}, {$$s: self})
      });
      
      $def(self, '$clear', function $$clear() {
        var self = this;

        return $send(self.data.$clear(), 'tap', [], function $$5(){var self = $$5.$$s == null ? this : $$5.$$s;

          if ($truthy(self['$autosave?']())) {
            return self.$save()
          } else {
            return nil
          }}, {$$s: self})
      });
      
      $def(self, '$replace', function $$replace(new$) {
        var self = this;

        if ($eqeqeq($$('String'), new$)) {
          return self.data.$replace($$('JSON').$parse(new$))
        } else {
          return self.data.$replace(new$)
        }
      });
      
      $def(self, '$commit', function $$commit() {
        var block = $$commit.$$p || nil, self = this, autosave = nil, result = nil;

        $$commit.$$p = null;
        
        ;
        autosave = self.autosave;
        self.autosave = false;
        result = nil;
        self.$reload();
        
        try {
        try {
          
          result = block.$call();
          self.$save();
        } catch ($err) {
          if (Opal.rescue($err, [$$('StandardError')])) {
            try {
              
              self.$reload();
              self.$raise();
            } finally { Opal.pop_exception($err); }
          } else { throw $err; }
        }
        } finally {
          self.autosave = autosave
        };;
        return result;
      });
      
      $def(self, '$to_h', $return_ivar("data"));
      if ($truthy($$('Browser')['$supports?']("Storage.local"))) {
        
        
        $def(self, '$reload', function $$reload() {
          var self = this;

          return self.$replace(self.window.localStorage[self.name] || '{}')
        });
        
        $def(self, '$save', function $$save() {
          var self = this;

          return self.window.localStorage[self.name] = $$('JSON').$dump(self)
        });
      } else if ($truthy($$('Browser')['$supports?']("Storage.global"))) {
        
        
        $def(self, '$reload', function $$reload() {
          var self = this;

          return self.$replace(self.window.globalStorage[self.window.location.hostname][self.name] || '{}')
        });
        
        $def(self, '$save', function $$save() {
          var self = this;

          return self.window.globalStorage[self.window.location.hostname][self.name] = $$('JSON').$dump(self)
        });
      } else if ($truthy($$('Browser')['$supports?']("Element.addBehavior"))) {
        
        
        $def(self, '$reload', function $$reload() {
          var self = this;

          
          
        self.element = self.window.document.createElement('link');
        self.element.addBehavior('#default#userData');

        self.window.document.getElementsByTagName('head')[0].appendChild(self.element);

        self.element.load(self.name);
      ;
          return self.$replace(self.element.getAttribute(self.name) || '{}');
        });
        
        $def(self, '$save', function $$save() {
          var self = this;

          
        self.element.setAttribute(self.name, $$('JSON').$dump(self));
        self.element.save(self.name);
      
        });
      } else {
        
        
        $def(self, '$reload', function $$reload() {
          var self = this;
          if ($gvars.document == null) $gvars.document = nil;

          
          $gvars.document.$cookies().$options((new Map([["expires", $rb_times($rb_times($rb_times(60, 60), 24), 365)]])));
          return self.$replace($gvars.document.$cookies()['$[]'](self.name));
        });
        
        $def(self, '$save', function $$save() {
          var $a, self = this;
          if ($gvars.document == null) $gvars.document = nil;

          return ($a = [self.name, $$('JSON').$dump(self)], $send($gvars.document.$cookies(), '[]=', $a), $a[$a.length - 1])
        });
      };
      return $def(self, '$to_json', function $$to_json() {
        var self = this, io = nil;

        
        io = $$('StringIO').$new()['$<<']("{");
        io['$<<']($$('JSON').$create_id().$to_json())['$<<'](":")['$<<'](self.$class().$name().$to_json())['$<<'](",");
        $send(self.data, 'each', [], function $$6(key, value){
          
          if (key == null) key = nil;
          if (value == null) value = nil;
          return io['$<<'](key.$to_json().$to_s())['$<<'](":")['$<<'](value.$to_json())['$<<'](",");});
        io.$seek(-1, $$$($$('IO'), 'SEEK_CUR'));
        io['$<<']("}");
        return io.$string();
      });
    })($nesting[0], null, $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'SessionStorage');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.window = $proto.name = nil;
      
      $defs(self, '$supported?', function $SessionStorage_supported$ques$7() {
        
        return $$('Browser')['$supports?']("Storage.session")
      });
      
      $def(self, '$reload', function $$reload() {
        var self = this;

        return self.$replace(self.window.sessionStorage[self.name] || '{}')
      });
      return $def(self, '$save', function $$save() {
        var self = this;

        return self.window.sessionStorage[self.name] = $$('JSON').$dump(self)
      });
    })($nesting[0], $$('Storage'), $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Window');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$storage', function $$storage(name) {
        var self = this;

        
        if (name == null) name = "default";
        return $$('Storage').$new(self.$to_n(), name);
      }, -1);
      return $def(self, '$session_storage', function $$session_storage(name) {
        var self = this;

        
        if (name == null) name = "default";
        return $$('SessionStorage').$new(self.$to_n(), name);
      }, -1);
    })($nesting[0], null, $nesting);
  })($nesting[0], $nesting);
};

Opal.modules["browser/blob"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $send = Opal.send, $gvars = Opal.gvars, $truthy = Opal.truthy, $rb_divide = Opal.rb_divide, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('include,new,convert,to_n,proc,resolve,call,create,type,respond_to?,last_modified,now,at,/');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Blob');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = nil;
      
      self.$include($$('NativeCachedWrapper'));
      $defs(self, '$create', function $$create(from, options) {
        var self = this;

        
        if (options == null) options = (new Map());
        return self.$new(new Blob($$('Native').$convert(from), options.$to_n()));
      }, -2);
      
      $def(self, '$size', function $$size() {
        var self = this;

        return self["native"].size
      });
      
      $def(self, '$type', function $$type() {
        var self = this;

        return self["native"].type
      });
      
      $def(self, '$text', function $$text() {
        var block = $$text.$$p || nil, self = this, promise = nil;

        $$text.$$p = null;
        
        ;
        promise = nil;
        if (!(block !== nil)) {
          
          promise = $$('Promise').$new();
          block = $send(self, 'proc', [], function $$1(i){
            
            if (i == null) i = nil;
            return promise.$resolve(i);});
        };
        self["native"].text().then(block.$to_n());
        return promise;
      });
      
      $def(self, '$buffer', function $$buffer() {
        var $yield = $$buffer.$$p || nil, self = this, promise = nil, block = nil, resblock = nil;

        $$buffer.$$p = null;
        
        promise = nil;
        if (!($yield !== nil)) {
          
          promise = $$('Promise').$new();
          block = $send(self, 'proc', [], function $$2(i){
            
            if (i == null) i = nil;
            return promise.$resolve(i);});
        };
        resblock = $send(self, 'proc', [], function $$3(i){
          
          if (i == null) i = nil;
          return block.$call($$('Buffer').$new(i));});
        self["native"].arrayBuffer().then(resblock.$to_n());
        return promise;
      });
      
      $def(self, '$slice', function $$slice(start, finish) {
        var self = this;

        
        if (finish == null) finish = nil;
        return $$('Blob').$new(self["native"].slice(start, finish));
      }, -2);
      
      $def(self, '$to_url', function $$to_url(window) {
        var self = this;
        if ($gvars.window == null) $gvars.window = nil;

        
        if (window == null) window = $gvars.window;
        return window.$to_n().URL.createObjectURL(self["native"]);
      }, -1);
      return $def(self, '$rename', function $$rename(new_filename) {
        var self = this;

        return $$('File').$create([self], new_filename, (new Map([["type", self.$type()], ["lastModified", ($truthy(self['$respond_to?']("last_modified")) ? (self.$last_modified()) : ($$('Time').$now()))]])))
      });
    })($nesting[0], null, $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'File');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = nil;
      
      $defs(self, '$create', function $$create(from, name, options) {
        var self = this;

        
        if (options == null) options = (new Map());
        return self.$new(new File($$('Native').$convert(from), name, options.$to_n()));
      }, -3);
      
      $def(self, '$last_modified', function $$last_modified() {
        var self = this;

        return $$('Time').$at($rb_divide(self["native"].lastModified, 1000.0))
      });
      return $def(self, '$name', function $$name() {
        var self = this;

        return self["native"].name
      });
    })($nesting[0], $$('Blob'), $nesting);
  })($nesting[0], $nesting)
};

Opal.modules["browser/socket"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $truthy = Opal.truthy, $send = Opal.send, $send2 = Opal.send2, $find_super = Opal.find_super, $eqeq = Opal.eqeq, $def = Opal.def, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('supports?,include,target,is_a?,new,native?,to_s,to_n,==,arity,instance_exec,to_proc,call,alias_native,split,state,write');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Socket');

      var $a, $b, $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = nil;
      
      $defs(self, '$supported?', function $Socket_supported$ques$1() {
        
        return $$('Browser')['$supports?']("WebSocket")
      });
      self.$include($$$($$('Native'), 'Wrapper'));
      if ($truthy((($b = $$('IO', 'skip_raise')) && ($a = $$$($b, 'Writable', 'skip_raise')) ? 'constant' : nil))) {
        self.$include($$$($$('IO'), 'Writable'))
      };
      self.$include($$$($$('Event'), 'Target'));
      $send(self, 'target', [], function $Socket$2(value){
        
        if (value == null) value = nil;
        if ($truthy($$('Native')['$is_a?'](value, window.WebSocket))) {
          return $$('Socket').$new(value)
        } else {
          return nil
        };});
      
      $def(self, '$initialize', function $$initialize(url, protocol) {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        if (protocol == null) protocol = nil;
        if ($truthy(self['$native?'](url))) {
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [url], null)
        } else if ($truthy(protocol)) {
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [new window.WebSocket(url.$to_s(), protocol.$to_n())], null)
        } else {
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [new window.WebSocket(url.$to_s())], null)
        };
        if ($truthy(block)) {
          if ($eqeq(block.$arity(), 0)) {
            return $send(self, 'instance_exec', [], block.$to_proc())
          } else {
            return block.$call(self)
          }
        } else {
          return nil
        };
      }, -2);
      self.$alias_native("protocol");
      self.$alias_native("url");
      self.$alias_native("buffered", "bufferedAmount");
      
      $def(self, '$type', function $$type() {
        var self = this;

        
      switch (self["native"].binaryType) {
        case "blob":
          return "blob";

        case "arraybuffer":
          return "buffer";

        default:
          return "string";
      }
    
      });
      
      $def(self, '$state', function $$state() {
        var self = this;

        
      switch (self["native"].readyState) {
        case window.WebSocket.CONNECTING:
          return "connecting";

        case window.WebSocket.OPEN:
          return "open";

        case window.WebSocket.CLOSING:
          return "closing";

        case window.WebSocket.CLOSED:
          return "closed";
      }
    
      });
      
      $def(self, '$extensions', function $$extensions() {
        var self = this;

        return (self["native"].extensions).$split(/\s*,\s*/)
      });
      
      $def(self, '$alive?', function $Socket_alive$ques$3() {
        var self = this;

        return self.$state()['$==']("open")
      });
      
      $def(self, '$write', function $$write(data) {
        var self = this;

        return self["native"].send(data.$to_n())
      });
      $alias(self, "<<", "write");
      $alias(self, "send", "write");
      return $def(self, '$close', function $$close(code, reason) {
        var self = this;

        
        if (code == null) code = nil;
        if (reason == null) reason = nil;
        return self["native"].close(code.$to_n(), reason.$to_n());
      }, -1);
    })($nesting[0], $$('IO'), $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/location"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $rb_plus = Opal.rb_plus, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,to_s,alias_native,+,path,query,fragment,new');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Location');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = nil;
      
      self.$include($$$($$('Browser'), 'NativeCachedWrapper'));
      
      $def(self, '$assign', function $$assign(url) {
        var self = this;

        return self["native"].assign(url.$to_s())
      });
      
      $def(self, '$replace', function $$replace(url) {
        var self = this;

        return self["native"].replace(url.$to_s())
      });
      
      $def(self, '$reload', function $$reload(force) {
        var self = this;

        
        if (force == null) force = false;
        return self["native"].reload(force);
      }, -1);
      
      $def(self, '$to_s', function $$to_s() {
        var self = this;

        return self["native"].toString()
      });
      self.$alias_native("fragment", "hash");
      self.$alias_native("fragment=", "hash=");
      self.$alias_native("host");
      self.$alias_native("host=");
      self.$alias_native("uri", "href");
      self.$alias_native("uri=", "href=");
      self.$alias_native("path", "pathname");
      self.$alias_native("path=", "pathname=");
      self.$alias_native("port");
      self.$alias_native("port=");
      self.$alias_native("scheme", "protocol");
      self.$alias_native("scheme=", "protocol=");
      self.$alias_native("query", "search");
      self.$alias_native("query=", "search=");
      return $def(self, '$full_path', function $$full_path() {
        var self = this;

        return $rb_plus($rb_plus(self.$path(), self.$query()), self.$fragment())
      });
    })($nesting[0], null, $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Window');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = nil;
      return $def(self, '$location', function $$location() {
        var self = this;

        if ($truthy(self["native"].location)) {
          return $$('Location').$new(self["native"].location)
        } else {
          return nil
        }
      })
    })($nesting[0], null, $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Document');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = nil;
      return $def(self, '$location', function $$location() {
        var self = this;

        if ($truthy(self["native"].location)) {
          return $$('Location').$new(self["native"].location)
        } else {
          return nil
        }
      })
    })($$('DOM'), $$$($$('DOM'), 'Element'), $nesting);
  })($nesting[0], $nesting)
};

Opal.modules["browser/history"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $gvars = Opal.gvars, $truthy = Opal.truthy, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,supports?,include,alias_native,to_n,full_path,location,raise,new');
  
  self.$require("browser/location");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'History');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = nil;
      
      $defs(self, '$supported?', function $History_supported$ques$1() {
        
        return $$('Browser')['$supports?']("History")
      });
      self.$include($$$($$('Browser'), 'NativeCachedWrapper'));
      self.$alias_native("length");
      
      $def(self, '$back', function $$back(number) {
        var self = this;

        
        if (number == null) number = 1;
        return self["native"].go(-number);
      }, -1);
      
      $def(self, '$forward', function $$forward(number) {
        var self = this;

        
        if (number == null) number = 1;
        return self["native"].go(number);
      }, -1);
      
      $def(self, '$push', function $$push(item, data) {
        var self = this;

        
        if (data == null) data = nil;
        return self["native"].pushState(data.$to_n(), null, item);
      }, -2);
      
      $def(self, '$replace', function $$replace(item, data) {
        var self = this;

        
        if (data == null) data = nil;
        return self["native"].replaceState(data.$to_n(), null, item);
      }, -2);
      
      $def(self, '$current', function $$current() {
                if ($gvars.window == null) $gvars.window = nil;

        return $gvars.window.$location().$full_path()
      });
      if ($truthy($$('Browser')['$supports?']("History.state"))) {
        return $def(self, '$state', function $$state() {
          var self = this;

          
        var state = self["native"].state;

        if (state == null) {
          return nil;
        }
        else {
          return state;
        }
      
        })
      } else {
        return $def(self, '$state', function $$state() {
          var self = this;

          return self.$raise($$('NotImplementedError'), "history state unsupported")
        })
      };
    })($nesting[0], null, $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Window');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = nil;
      return $def(self, '$history', function $$history() {
        var self = this;

        if ($truthy(self["native"].history)) {
          return $$('History').$new(self["native"].history)
        } else {
          return nil
        }
      })
    })($nesting[0], null, $nesting);
  })($nesting[0], $nesting);
};

Opal.modules["browser/navigator"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $def = Opal.def, $send2 = Opal.send2, $find_super = Opal.find_super, $send = Opal.send, $alias = Opal.alias, $truthy = Opal.truthy, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,new,alias_native,split,operating_system,proc,resolve,reject,Native,to_n,call');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Navigator');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = nil;
      
      self.$include($$$($$('Browser'), 'NativeCachedWrapper'));
      $const_set($nesting[0], 'Version', $$('Struct').$new("major", "minor", "build"));
      $const_set($nesting[0], 'Product', $$('Struct').$new("name", "version"));
      $const_set($nesting[0], 'Vendor', $$('Struct').$new("name", "version"));
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'MimeType');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$include($$$($$('Browser'), 'NativeCachedWrapper'));
        
        $def(self, '$plugin', function $$plugin() {
          var self = this;

          return $$('Plugin').$new(self["native"].enabledPlugin)
        });
        self.$alias_native("description");
        
        $def(self, '$extensions', function $$extensions() {
          var self = this;

          return (self["native"].suffixes).$split(/\s*/)
        });
        return self.$alias_native("type");
      })($nesting[0], null, $nesting);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Plugin');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        
        $def(self, '$initialize', function $$initialize(plugin) {
          var $yield = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [plugin], function $$1(m){
            
            if (m == null) m = nil;
            return $$('MimeType').$new(m);})
        });
        self.$alias_native("description");
        self.$alias_native("file", "filename");
        self.$alias_native("name");
        return self.$alias_native("version");
      })($nesting[0], $$$($$('Native'), 'Array'), $nesting);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Plugins');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        
        $def(self, '$initialize', function $$initialize(plugins) {
          var $yield = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [plugins], function $$2(p){
            
            if (p == null) p = nil;
            return $$('Plugin').$new(p);})
        });
        
        $def(self, '$refresh', function $$refresh() {
          var self = this;

          return self["native"].refresh(false)
        });
        return $def(self, '$refresh!', function $Plugins_refresh$excl$3() {
          var self = this;

          return self["native"].refresh(true)
        });
      })($nesting[0], $$$($$('Native'), 'Array'), $nesting);
      self.$alias_native("code", "appCodeName");
      self.$alias_native("name", "appName");
      
      $def(self, '$version', function $$version() {
        var self = this;

        return $$('Version').$new(self["native"].appVersion, self["native"].appMinorVersion, self["native"].buildID)
      });
      self.$alias_native("cookies?", "cookieEnabled");
      
      $def(self, '$track?', function $Navigator_track$ques$4() {
        var self = this;

        return !self["native"].doNotTrack
      });
      self.$alias_native("language");
      
      $def(self, '$mime_types', function $$mime_types() {
        var self = this;

        return $send($$$($$('Native'), 'Array'), 'new', [self["native"].mimeTypes, (new Map([["get", "item"], ["named", "namedItem"]]))], function $$5(m){
          
          if (m == null) m = nil;
          return $$('MimeType').$new(m);})
      });
      
      $def(self, '$offline?', function $Navigator_offline$ques$6() {
        var self = this;

        return !self["native"].onLine
      });
      self.$alias_native("operating_system", "oscpu");
      $alias(self, "os", "operating_system");
      self.$alias_native("platform");
      
      $def(self, '$plugins', function $$plugins() {
        var self = this;

        return $$('Plugins').$new(self["native"].plugins)
      });
      
      $def(self, '$product', function $$product() {
        var self = this;

        return $$('Product').$new(self["native"].product, self["native"].productSub)
      });
      self.$alias_native("user_agent", "userAgent");
      
      $def(self, '$vendor', function $$vendor() {
        var self = this;

        return $$('Vendor').$new(self["native"].vendor, self["native"].vendorSub)
      });
      
      $def(self, '$java?', function $Navigator_java$ques$7() {
        var self = this;

        try {
          return self["native"].javaEnabled()
        } catch ($err) {
          if (Opal.rescue($err, [$$('StandardError')])) {
            try {
              return false
            } finally { Opal.pop_exception($err); }
          } else { throw $err; }
        }
      });
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Position');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.coords = $proto["native"] = nil;
        
        self.$include($$$($$('Browser'), 'NativeCachedWrapper'));
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Coords');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

          
          self.$include($$$($$('Native'), 'Wrapper'));
          self.$alias_native("latitude");
          self.$alias_native("longitude");
          self.$alias_native("altitude");
          self.$alias_native("accuracy");
          self.$alias_native("altitude_accuracy", "altitudeAccuracy");
          self.$alias_native("heading");
          return self.$alias_native("speed");
        })($nesting[0], null, $nesting);
        self.$alias_native("timestamp");
        return $def(self, '$coords', function $$coords() {
          var self = this, $ret_or_1 = nil;

          return (self.coords = ($truthy(($ret_or_1 = self.coords)) ? ($ret_or_1) : ($$('Coords').$new(self["native"].coords))))
        });
      })($nesting[0], null, $nesting);
      
      $def(self, '$geolocate', function $$geolocate($kwargs) {
        var max_age, timeout, high_accuracy, self = this, promise = nil, succ = nil, fail = nil, opts = nil;

        
        $kwargs = $ensure_kwargs($kwargs);
        
        max_age = $hash_get($kwargs, "max_age");if (max_age == null) max_age = 0;
        
        timeout = $hash_get($kwargs, "timeout");if (timeout == null) timeout = $$$($$('Float'), 'INFINITY');
        
        high_accuracy = $hash_get($kwargs, "high_accuracy");if (high_accuracy == null) high_accuracy = false;
        promise = $$('Promise').$new();
        succ = $send(self, 'proc', [], function $$8(i){
          
          if (i == null) i = nil;
          return promise.$resolve($$('Position').$new(i));});
        fail = $send(self, 'proc', [], function $$9(i){var self = $$9.$$s == null ? this : $$9.$$s;

          
          if (i == null) i = nil;
          return promise.$reject(self.$Native(i));}, {$$s: self});
        opts = (new Map([["maxAge", max_age], ["timeout", timeout], ["enableHighAccuracy", high_accuracy]]));
        self["native"].geolocation.getCurrentPosition(succ.$to_n(), fail.$to_n(), opts.$to_n());
        return promise;
      }, -1);
      
      $def(self, '$track', function $$track($kwargs) {
        var block = $$track.$$p || nil, max_age, timeout, high_accuracy, error, self = this, opts = nil, succ = nil, fail = nil;

        $$track.$$p = null;
        
        ;
        $kwargs = $ensure_kwargs($kwargs);
        
        max_age = $hash_get($kwargs, "max_age");if (max_age == null) max_age = 0;
        
        timeout = $hash_get($kwargs, "timeout");if (timeout == null) timeout = $$$($$('Float'), 'INFINITY');
        
        high_accuracy = $hash_get($kwargs, "high_accuracy");if (high_accuracy == null) high_accuracy = false;
        
        error = $hash_get($kwargs, "error");if (error == null) error = $send(self, 'proc', [], function $$10(i){
          
          if (i == null) i = nil;
          return nil;});
        opts = (new Map([["maxAge", max_age], ["timeout", timeout], ["enableHighAccuracy", high_accuracy]]));
        succ = $send(self, 'proc', [], function $$11(i){
          
          if (i == null) i = nil;
          return block.$call($$('Position').$new(i));});
        fail = $send(self, 'proc', [], function $$12(i){var self = $$12.$$s == null ? this : $$12.$$s;

          
          if (i == null) i = nil;
          return error.$call(self.$Native(i));}, {$$s: self});
        return self["native"].geolocation.watchPosition(succ.$to_n(), fail.$to_n(), opts.$to_n());
      }, -1);
      
      $def(self, '$stop_tracking', function $$stop_tracking(id) {
        var self = this;

        return self["native"].geolocation.clearWatch(id)
      });
      
      $def(self, '$vibrate', function $$vibrate(pattern) {
        var self = this;

        return self["native"].vibrate(pattern.$to_n())
      });
      
      $def(self, '$get_battery', function $$get_battery() {
        var self = this, promise = nil, yes = nil, no = nil;

        
        promise = $$('Promise').$new();
        yes = $send(self, 'proc', [], function $$13(r){var self = $$13.$$s == null ? this : $$13.$$s;

          
          if (r == null) r = nil;
          return promise.$resolve(self.$Native(r));}, {$$s: self});
        no = $send(self, 'proc', [], function $$14(r){var self = $$14.$$s == null ? this : $$14.$$s;

          
          if (r == null) r = nil;
          return promise.$reject(self.$Native(r));}, {$$s: self});
        self["native"].getBattery().then(yes.$to_n()).catch(no.$to_n());
        return promise;
      });
      return $def(self, '$send_beacon', function $$send_beacon(url, payload) {
        var self = this;

        
        if (payload == null) payload = nil;
        return self["native"].sendBeacon(url, payload.$to_n());
      }, -2);
    })($nesting[0], null, $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Window');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = $proto.navigator = nil;
      return $def(self, '$navigator', function $$navigator() {
        var self = this, $ret_or_1 = nil;

        if ($truthy(self["native"].navigator)) {
          return (self.navigator = ($truthy(($ret_or_1 = self.navigator)) ? ($ret_or_1) : ($$('Navigator').$new(self["native"].navigator))))
        } else {
          return nil
        }
      })
    })($nesting[0], null, $nesting);
  })($nesting[0], $nesting)
};

Opal.modules["browser/setup/large"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var self = Opal.top, nil = Opal.nil;

  Opal.add_stubs('require');
  
  self.$require("browser/setup/mini");
  self.$require("browser/effects");
  self.$require("browser/http");
  self.$require("browser/delay");
  self.$require("browser/interval");
  self.$require("browser/immediate");
  self.$require("browser/storage");
  self.$require("browser/blob");
  self.$require("browser/animation_frame");
  self.$require("browser/socket");
  self.$require("browser/history");
  return self.$require("browser/navigator");
};

Opal.modules["browser/event/focus"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('handles,supports?,convert,supported?,DOM');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Focus');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$handles("blur", "focus", "focusin", "focusout");
        $defs(self, '$supported?', function $Focus_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.Focus")
        });
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$view=', function $Definition_view$eq$2(value) {
            var self = this;

            return self["native"].view = $$('Native').$convert(value)
          });
          return $def(self, '$related=', function $Definition_related$eq$3(elem) {
            var self = this;

            return self["native"].relatedTarget = $$('Native').$convert(elem)
          });
        })($nesting[0], $$$($$('UI'), 'Definition'), $nesting);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new FocusEvent(name, desc)
            })
          } else if ($truthy($$('Browser')['$supports?']("Event.create"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              
        var event = document.createEvent("FocusEvent");
            event.initFocusEvent(name, desc.bubbles, desc.cancelable,
              desc.view || window, 0, desc.relatedTarget);

        return event;
      
            })
          }
        };
        return $def(self, '$related', function $$related() {
          var self = this;

          return self.$DOM(self["native"].relatedTarget)
        });
      })($nesting[0], $$('UI'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/wheel"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $gvars = Opal.gvars, $defs = Opal.defs, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,!,nil?,[],===,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Wheel');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$handles("wheel", "mousewheel");
        $defs(self, '$supported?', function $Wheel_supported$ques$1() {
                    if ($gvars.$ == null) $gvars.$ = nil;

          return $gvars.$['$[]']("WheelEvent")['$nil?']()['$!']()
        });
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$x=', function $Definition_x$eq$2(value) {
            var self = this;

            return self["native"].deltaX = value
          });
          
          $def(self, '$y=', function $Definition_y$eq$3(value) {
            var self = this;

            return self["native"].deltaY = value
          });
          
          $def(self, '$z=', function $Definition_z$eq$4(value) {
            var self = this;

            return self["native"].deltaZ = value
          });
          return $def(self, '$mode=', function $Definition_mode$eq$5(value) {
            var self = this, $ret_or_1 = nil;

            
            value = ($eqeqeq("pixel", ($ret_or_1 = value)) ? (WheelEvent.DOM_DELTA_PIXEL) : ($eqeqeq("line", $ret_or_1) ? (WheelEvent.DOM_DELTA_LINE) : ($eqeqeq("page", $ret_or_1) ? (WheelEvent.DOM_DELTA_PAGE) : (nil))));
            return self["native"].deltaMode = value;
          });
        })($nesting[0], $$('Definition'));
        $defs(self, '$construct', function $$construct(name, desc) {
          
          return new WheelEvent(name, desc)
        });
        self.$alias_native("x", "deltaX");
        self.$alias_native("y", "deltaY");
        self.$alias_native("z", "deltaZ");
        return $def(self, '$mode', function $$mode() {
          var self = this, $ret_or_1 = nil;

          if ($eqeqeq(WheelEvent.DOM_DELTA_PIXEL, ($ret_or_1 = self["native"].deltaMode))) {
            return "pixel"
          } else if ($eqeqeq(WheelEvent.DOM_DELTA_LINE, $ret_or_1)) {
            return "line"
          } else if ($eqeqeq(WheelEvent.DOM_DELTA_PAGE, $ret_or_1)) {
            return "page"
          } else {
            return nil
          }
        });
      })($nesting[0], $$('UI'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/data_transfer"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $send = Opal.send, $truthy = Opal.truthy, $not = Opal.not, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,convert,to_n,map,new,==,kind,to_file,!,proc,resolve');
  
  self.$require("browser/blob");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'DataTransfer');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$include($$('NativeCachedWrapper'));
        
        $def(self, '$effect', function $$effect() {
          var self = this;

          return self["native"].dropEffect
        });
        
        $def(self, '$effect=', function $DataTransfer_effect$eq$1(effect) {
          var self = this;

          return self["native"].dropEffect = effect
        });
        
        $def(self, '$[]', function $DataTransfer_$$$2(type) {
          var self = this;

          return self["native"].getData(type)
        });
        
        $def(self, '$[]=', function $DataTransfer_$$$eq$3(type, value) {
          var self = this;

          return self["native"].setData(type, $$('Native').$convert(value))
        });
        
        $def(self, '$clear', function $$clear(type) {
          var self = this;

          
          if (type == null) type = nil;
          return self["native"].clearData(type.$to_n());
        }, -1);
        
        $def(self, '$drag_image=', function $DataTransfer_drag_image$eq$4(image) {
          var self = this;

          return self["native"].setDragImage($$('Native').$convert(image))
        });
        
        $def(self, '$files', function $$files() {
          var self = this;

          return $send($$$($$('Native'), 'Array').$new(self["native"].files), 'map', [], function $$5(f){
            
            if (f == null) f = nil;
            return $$('File').$new(f.$to_n());})
        });
        
        $def(self, '$items', function $$items() {
          var self = this;

          return $send($$$($$('Native'), 'Array').$new(self["native"].items), 'map', [], function $$6(i){
            
            if (i == null) i = nil;
            return $$('Item').$new(i.$to_n());})
        });
        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Item');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$include($$('NativeCachedWrapper'));
          
          $def(self, '$kind', function $$kind() {
            var self = this;

            return self["native"].kind
          });
          
          $def(self, '$string?', function $Item_string$ques$7() {
            var self = this;

            return self.$kind()['$==']("string")
          });
          
          $def(self, '$file?', function $Item_file$ques$8() {
            var self = this, $ret_or_1 = nil;

            if ($truthy(($ret_or_1 = self.$kind()['$==']("file")))) {
              return self.$to_file()
            } else {
              return $ret_or_1
            }
          });
          
          $def(self, '$type', function $$type() {
            var self = this;

            return self["native"].type
          });
          
          $def(self, '$to_string', function $$to_string() {
            var block = $$to_string.$$p || nil, self = this, promise = nil;

            $$to_string.$$p = null;
            
            ;
            promise = nil;
            if ($not(block)) {
              
              promise = $$('Promise').$new();
              block = $send(self, 'proc', [], function $$9(i){
                
                if (i == null) i = nil;
                return promise.$resolve(i);});
            };
            self["native"].getAsString(block.$to_n());
            return promise;
          });
          return $def(self, '$to_file', function $$to_file() {
            var self = this, as_file = nil;

            
            as_file = self["native"].getAsFile();
            if ($truthy(as_file)) {
              return $$('File').$new(as_file)
            } else {
              return nil
            };
          });
        })($nesting[0], null, $nesting);
      })($nesting[0], null, $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["browser/event/composition"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('handles,supports?,supported?,alias_native,==,downcase,name');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Composition');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("compositionend", "compositionstart", "compositionupdate");
        $defs(self, '$supported?', function $Composition_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.Composition")
        });
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$data=', function $Definition_data$eq$2(value) {
            var self = this;

            return self["native"].data = value
          });
          return $def(self, '$locale=', function $Definition_locale$eq$3(value) {
            var self = this;

            return self["native"].locale = value
          });
        })($nesting[0], $$$($$('UI'), 'Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new CompositionEvent(name, desc)
            })
          } else if ($truthy($$('Browser')['$supports?']("Event.create"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              
        var event = document.createEvent("CompositionEvent");
            event.initCompositionEvent(name, desc.bubbles, desc.cancelable,
              desc.view || window, desc.data, desc.locale);

        return event;
      
            })
          }
        };
        self.$alias_native("data");
        self.$alias_native("locale");
        
        $def(self, '$start?', function $Composition_start$ques$4() {
          var self = this;

          return self.$name().$downcase()['$==']("compositionstart")
        });
        
        $def(self, '$update?', function $Composition_update$ques$5() {
          var self = this;

          return self.$name().$downcase()['$==']("compositionupdate")
        });
        return $def(self, '$end?', function $Composition_end$ques$6() {
          var self = this;

          return self.$name().$downcase()['$==']("compositionend")
        });
      })($nesting[0], $$('UI'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/animation"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Animation');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("animationend", "animationiteration", "animationstart");
        $defs(self, '$supported?', function $Animation_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.Animation")
        });
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$animation=', function $Definition_animation$eq$2(value) {
            var self = this;

            return self["native"].animationName = value
          });
          return $def(self, '$elapsed=', function $Definition_elapsed$eq$3(value) {
            var self = this;

            return self["native"].elapsedTime = value
          });
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new AnimationEvent(name, desc)
            })
          } else if ($truthy($$('Browser')['$supports?']("Event.create"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              
        var event = document.createEvent("AnimationEvent");
            event.initAnimationEvent(name, desc.bubbles, desc.cancelable,
              desc.animationName, desc.elapsedTime);

        return event;
      
            })
          }
        };
        self.$alias_native("name", "animationName");
        return self.$alias_native("elapsed", "elapsedTime");
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/audio_processing"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'AudioProcessing');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("audioprocess");
        $defs(self, '$supported?', function $AudioProcessing_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.AudioProcessing")
        });
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$time=', function $Definition_time$eq$2(value) {
            var self = this;

            return self["native"].playbackTime = value
          });
          
          $def(self, '$input=', function $Definition_input$eq$3(value) {
            var self = this;

            return self["native"].inputBuffer = value
          });
          return $def(self, '$output=', function $Definition_output$eq$4(value) {
            var self = this;

            return self["native"].outputBuffer = value
          });
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new AudioProcessingEvent(name, desc)
            })
          }
        };
        self.$alias_native("time", "playbackTime");
        self.$alias_native("input", "inputBuffer");
        return self.$alias_native("output", "outputBuffer");
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/before_unload"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'BeforeUnload');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("beforeunload");
        $defs(self, '$supported?', function $BeforeUnload_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.BeforeUnload")
        });
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            return $defs(self, '$construct', function $$construct(name, desc) {
              
              return new BeforeUnloadEvent(name, desc)
            })
          } else {
            return nil
          }
        } else {
          return nil
        };
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/clipboard"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?,alias_native,new');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Clipboard');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$handles("copy", "cut", "paste");
        $defs(self, '$supported?', function $Clipboard_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.Clipboard")
        });
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$data=', function $Definition_data$eq$2(value) {
            var self = this;

            return self["native"].data = value
          });
          return $def(self, '$type=', function $Definition_type$eq$3(value) {
            var self = this;

            return self["native"].dataType = value
          });
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new ClipboardEvent(name, desc)
            })
          }
        };
        self.$alias_native("data");
        self.$alias_native("type", "dataType");
        return $def(self, '$transfer', function $$transfer() {
          var self = this;

          return $$('DataTransfer').$new(self["native"].clipboardData)
        });
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/device_light"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'DeviceLight');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("devicelight");
        $defs(self, '$supported?', function $DeviceLight_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.DeviceLight")
        });
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          return $def(self, '$value=', function $Definition_value$eq$2(value) {
            var self = this;

            return self["native"].value = value
          })
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new DeviceLightEvent(name, desc)
            })
          }
        };
        return self.$alias_native("value");
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/device_motion"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $const_set = Opal.const_set, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,new,to_n,supported?,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'DeviceMotion');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("devicemotion");
        $defs(self, '$supported?', function $DeviceMotion_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.DeviceMotion")
        });
        $const_set($nesting[0], 'Acceleration', $$('Struct').$new("x", "y", "z"));
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$acceleration=', function $Definition_acceleration$eq$2(value) {
            var self = this;

            return self["native"].acceleration = value.$to_n()
          });
          
          $def(self, '$acceleration_with_gravity=', function $Definition_acceleration_with_gravity$eq$3(value) {
            var self = this;

            return self["native"].accelerationIncludingGravity = value.$to_n()
          });
          
          $def(self, '$rotation=', function $Definition_rotation$eq$4(value) {
            var self = this;

            return self["native"].rotationRate = value
          });
          return $def(self, '$interval=', function $Definition_interval$eq$5(value) {
            var self = this;

            return self["native"].interval = value
          });
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new DeviceMotionEvent(name, desc)
            })
          } else if ($truthy($$('Browser')['$supports?']("Event.create"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              
        var event = document.createEvent("DeviceMotionEvent");
            event.initDeviceMotionEvent(name, desc.bubbles, desc.cancelable,
              desc.acceleration, desc.accelerationIncludingGravity,
              desc.rotationRate, desc.interval);

        return event;
      
            })
          }
        };
        self.$alias_native("acceleration");
        self.$alias_native("acceleration_with_gravity", "accelerationIncludingGravity");
        self.$alias_native("rotation", "rotationRate");
        return self.$alias_native("interval");
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/device_orientation"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'DeviceOrientation');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("deviceorientation");
        $defs(self, '$supported?', function $DeviceOrientation_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.DeviceOrientation")
        });
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$absolute=', function $Definition_absolute$eq$2(value) {
            var self = this;

            return self["native"].absolute = value
          });
          
          $def(self, '$alpha=', function $Definition_alpha$eq$3(value) {
            var self = this;

            return self["native"].alpha = value
          });
          
          $def(self, '$beta=', function $Definition_beta$eq$4(value) {
            var self = this;

            return self["native"].beta = value
          });
          return $def(self, '$gamma=', function $Definition_gamma$eq$5(value) {
            var self = this;

            return self["native"].gamma = value
          });
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new DeviceOrientationEvent(name, desc)
            })
          } else if ($truthy($$('Browser')['$supports?']("Event.create"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              
        var event = document.createEvent("DeviceOrientationEvent");
            event.initDeviceOrientationEvent(name, desc.bubbles, desc.cancelable,
              desc.alpha, desc.beta, desc.gamma, desc.absolute);

        return event;
      
            })
          }
        };
        self.$alias_native("absolute");
        self.$alias_native("alpha");
        self.$alias_native("beta");
        return self.$alias_native("gamma");
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/device_proximity"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'DeviceProximity');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("deviceproximity");
        $defs(self, '$supported?', function $DeviceProximity_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.DeviceProximity")
        });
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$value=', function $Definition_value$eq$2(value) {
            var self = this;

            return self["native"].value = value
          });
          
          $def(self, '$min=', function $Definition_min$eq$3(value) {
            var self = this;

            return self["native"].min = value
          });
          return $def(self, '$max=', function $Definition_max$eq$4(value) {
            var self = this;

            return self["native"].max = value
          });
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new DeviceProximityEvent(name, desc)
            })
          }
        };
        self.$alias_native("value");
        self.$alias_native("min");
        return self.$alias_native("max");
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/drag"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('handles,supports?,include,new,convert,supported?,alias_native,x,screen,y,DOM');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Drag');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$handles("drag", "dragend", "dragenter", "dragexit", "dragleave", "dragover", "dragstart", "drop");
        $defs(self, '$supported?', function $Drag_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.Drag")
        });
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto["native"] = nil;
          
          (function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'Client');

            var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

            $proto["native"] = nil;
            
            self.$include($$$($$('Native'), 'Wrapper'));
            
            $def(self, '$x=', function $Client_x$eq$2(value) {
              var self = this;

              return self["native"].clientX = value
            });
            return $def(self, '$y=', function $Client_y$eq$3(value) {
              var self = this;

              return self["native"].clientY = value
            });
          })($nesting[0], null, $nesting);
          (function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'Screen');

            var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

            $proto["native"] = nil;
            
            self.$include($$$($$('Native'), 'Wrapper'));
            
            $def(self, '$x=', function $Screen_x$eq$4(value) {
              var self = this;

              return self["native"].screenX = value
            });
            return $def(self, '$y=', function $Screen_y$eq$5(value) {
              var self = this;

              return self["native"].screenY = value
            });
          })($nesting[0], null, $nesting);
          
          $def(self, '$alt!', function $Definition_alt$excl$6() {
            var self = this;

            return self["native"].altKey = true
          });
          
          $def(self, '$ctrl!', function $Definition_ctrl$excl$7() {
            var self = this;

            return self["native"].ctrlKey = true
          });
          
          $def(self, '$meta!', function $Definition_meta$excl$8() {
            var self = this;

            return self["native"].metaKey = true
          });
          
          $def(self, '$button=', function $Definition_button$eq$9(value) {
            var self = this;

            return self["native"].button = value
          });
          
          $def(self, '$client', function $$client() {
            var self = this;

            return $$('Client').$new(self["native"])
          });
          
          $def(self, '$screen', function $$screen() {
            var self = this;

            return $$('Screen').$new(self["native"])
          });
          
          $def(self, '$related=', function $Definition_related$eq$10(elem) {
            var self = this;

            return self["native"].relatedTarget = $$('Native').$convert(elem)
          });
          return $def(self, '$transfer=', function $Definition_transfer$eq$11(value) {
            var self = this;

            return self["native"].dataTransfer = $$('Native').$convert(value)
          });
        })($nesting[0], $$('Definition'), $nesting);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new DragEvent(name, desc)
            })
          } else if ($truthy($$('Browser')['$supports?']("Event.create"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              
        var event = document.createEvent("DragEvent");
            event.initDragEvent(name, desc.bubbles, desc.cancelable,
              desc.view || window, 0,
              desc.screenX || 0, desc.screenY || 0,
              desc.clientX || 0, desc.clientY || 0,
              desc.ctrlKey, desc.altKey, desc.shiftKey, desc.metaKey,
              desc.button || 0, desc.relatedTarget, desc.dataTransfer);

        return event;
      
            })
          }
        };
        self.$alias_native("alt?", "altKey");
        self.$alias_native("ctrl?", "ctrlKey");
        self.$alias_native("meta?", "metaKey");
        self.$alias_native("shift?", "shiftKey");
        self.$alias_native("button");
        
        $def(self, '$client', function $$client() {
          var self = this;

          return $$('Position').$new(self["native"].clientX, self["native"].clientY)
        });
        
        $def(self, '$screen', function $$screen() {
          var self = this;

          if ($truthy((typeof(self["native"].screenX) !== "undefined"))) {
            return $$('Position').$new(self["native"].screenX, self["native"].screenY)
          } else {
            return nil
          }
        });
        
        $def(self, '$x', function $$x() {
          var self = this;

          return self.$screen().$x()
        });
        
        $def(self, '$y', function $$y() {
          var self = this;

          return self.$screen().$y()
        });
        
        $def(self, '$related', function $$related() {
          var self = this;

          return self.$DOM(self["native"].relatedTarget)
        });
        return $def(self, '$transfer', function $$transfer() {
          var self = this;

          return $$('DataTransfer').$new(self["native"].dataTransfer)
        });
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/gamepad"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Gamepad');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$handles("gamepadconnected", "gamepaddisconnected");
        $defs(self, '$supported?', function $Gamepad_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.Gamepad")
        });
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$id=', function $Definition_id$eq$2(value) {
            var self = this;

            return self["native"].id = value
          });
          
          $def(self, '$index=', function $Definition_index$eq$3(value) {
            var self = this;

            return self["native"].index = value
          });
          
          $def(self, '$at=', function $Definition_at$eq$4(value) {
            var self = this;

            return self["native"].timestamp = value
          });
          
          $def(self, '$axes=', function $Definition_axes$eq$5(value) {
            var self = this;

            return self["native"].axes = value
          });
          return $def(self, '$buttons=', function $Definition_buttons$eq$6(value) {
            var self = this;

            return self["native"].buttons = value
          });
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new GamepadEvent(name, {
        bubbles:    desc.bubbles,
        cancelable: desc.cancelable,
        gamepad:    desc })
            })
          }
        };
        
        $def(self, '$id', function $$id() {
          var self = this;

          return self["native"].gamepad.id
        });
        
        $def(self, '$index', function $$index() {
          var self = this;

          return self["native"].gamepad.index
        });
        
        $def(self, '$at', function $$at() {
          var self = this;

          return self["native"].gamepad.timestamp
        });
        
        $def(self, '$axes', function $$axes() {
          var self = this;

          return self["native"].gamepad.axes
        });
        return $def(self, '$buttons', function $$buttons() {
          var self = this;

          return self["native"].gamepad.buttons
        });
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/hash_change"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'HashChange');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("hashchange");
        $defs(self, '$supported?', function $HashChange_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.HashChange")
        });
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$old=', function $Definition_old$eq$2(value) {
            var self = this;

            return self["native"].oldURL = value
          });
          return $def(self, '$new=', function $Definition_new$eq$3(value) {
            var self = this;

            return self["native"].newURL = value
          });
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new HashChangeEvent(name, desc)
            })
          }
        };
        self.$alias_native("old", "oldURL");
        return self.$alias_native("new", "newURL");
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/progress"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Progress');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("progress", "load", "loadend", "loadstart");
        $defs(self, '$supported?', function $Progress_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.Progress")
        });
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$computable=', function $Definition_computable$eq$2(value) {
            var self = this;

            return self["native"].computableLength = value
          });
          
          $def(self, '$loaded=', function $Definition_loaded$eq$3(value) {
            var self = this;

            return self["native"].loaded = value
          });
          return $def(self, '$total=', function $Definition_total$eq$4(value) {
            var self = this;

            return self["native"].total = value
          });
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new ProgressEvent(name, desc)
            })
          } else if ($truthy($$('Browser')['$supports?']("Event.create"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              
        var event = document.createEvent("ProgressEvent");
            event.initProgressEvent(name, desc.bubbles, desc.cancelable,
              desc.computable, desc.loaded, desc.total);

        return event;
      
            })
          }
        };
        self.$alias_native("computable?", "computableLength");
        self.$alias_native("loaded");
        return self.$alias_native("total");
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/page_transition"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'PageTransition');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("pagehide", "pageshow");
        $defs(self, '$supported?', function $PageTransition_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.PageTransition")
        });
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          return $def(self, '$persisted=', function $Definition_persisted$eq$2(value) {
            var self = this;

            return self["native"].persisted = value
          })
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.PageTransition"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new PageTransitionEvent(name, desc);
            })
          }
        };
        return self.$alias_native("persisted?", "persisted");
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/pop_state"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'PopState');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("popstate");
        $defs(self, '$supported?', function $PopState_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.PopState")
        });
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          return $def(self, '$state=', function $Definition_state$eq$2(value) {
            var self = this;

            return self["native"].state = value
          })
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new PopStateEvent(name, desc)
            })
          } else if ($truthy($$('Browser')['$supports?']("Event.create"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              
        var event = document.createEvent('PopStateEvent');
            event.initPopStateEvent(name, desc.bubbles, desc.cancelable,
              desc.state);

        return event;
      
            })
          }
        };
        return self.$alias_native("state");
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/storage"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Storage');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("storage");
        $defs(self, '$supported?', function $Storage_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.Storage")
        });
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$key=', function $Definition_key$eq$2(value) {
            var self = this;

            return self["native"].key = value
          });
          
          $def(self, '$new=', function $Definition_new$eq$3(value) {
            var self = this;

            return self["native"].newValue = value
          });
          
          $def(self, '$old=', function $Definition_old$eq$4(value) {
            var self = this;

            return self["native"].oldValue = value
          });
          
          $def(self, '$area=', function $Definition_area$eq$5(value) {
            var self = this;

            return self["native"].storageArea = value
          });
          return $def(self, '$url=', function $Definition_url$eq$6(value) {
            var self = this;

            return self["native"].url = value
          });
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new StorageEvent(name, desc)
            })
          }
        };
        self.$alias_native("key");
        self.$alias_native("new", "newValue");
        self.$alias_native("old", "oldValue");
        self.$alias_native("area", "storageArea");
        return self.$alias_native("url");
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/touch"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?,alias_native,==,downcase,name');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Touch');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("touchcancel", "touchend", "touchleave", "touchmove", "touchstart");
        $defs(self, '$supported?', function $Touch_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.Touch")
        });
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$alt!', function $Definition_alt$excl$2() {
            var self = this;

            return self["native"].altKey = true
          });
          
          $def(self, '$ctrl!', function $Definition_ctrl$excl$3() {
            var self = this;

            return self["native"].ctrlKey = true
          });
          
          $def(self, '$meta!', function $Definition_meta$excl$4() {
            var self = this;

            return self["native"].metaKey = true
          });
          return $def(self, '$shift!', function $Definition_shift$excl$5() {
            var self = this;

            return self["native"].shiftKey = true
          });
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new TouchEvent(name, desc)
            })
          }
        };
        self.$alias_native("alt?", "altKey");
        self.$alias_native("ctrl?", "ctrlKey");
        self.$alias_native("meta?", "metaKey");
        self.$alias_native("shift?", "shiftKey");
        
        $def(self, '$cancel?', function $Touch_cancel$ques$6() {
          var self = this;

          return self.$name().$downcase()['$==']("touchcancel")
        });
        
        $def(self, '$end?', function $Touch_end$ques$7() {
          var self = this;

          return self.$name().$downcase()['$==']("touchend")
        });
        
        $def(self, '$leave?', function $Touch_leave$ques$8() {
          var self = this;

          return self.$name().$downcase()['$==']("touchleave")
        });
        
        $def(self, '$move?', function $Touch_move$ques$9() {
          var self = this;

          return self.$name().$downcase()['$==']("touchmove")
        });
        return $def(self, '$start?', function $Touch_start$ques$10() {
          var self = this;

          return self.$name().$downcase()['$==']("touchstart")
        });
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/sensor"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Sensor');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("compassneedscalibration", "userproximity");
        $defs(self, '$supported?', function $Sensor_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.Sensor")
        });
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            return $defs(self, '$construct', function $$construct(name, desc) {
              
              return new SensorEvent(name, desc)
            })
          } else {
            return nil
          }
        } else {
          return nil
        };
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["buffer/array"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $gvars = Opal.gvars, $defs = Opal.defs, $eqeq = Opal.eqeq, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $truthy = Opal.truthy, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,[],name_for,attr_reader,==,for,to_n,enum_for,length');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Buffer');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Array');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = nil;
      
      self.$include($$$($$('Native'), 'Wrapper'));
      $defs(self, '$for', function $Array_for$1(bits, type) {
                if ($gvars.$ == null) $gvars.$ = nil;

        return $gvars.$['$[]']("" + ($$('Buffer').$name_for(bits, type)) + "Array")
      });
      self.$include($$('Enumerable'));
      self.$attr_reader("buffer", "type");
      
      $def(self, '$initialize', function $$initialize(buffer, bits, type) {
        var $yield = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        if (bits == null) bits = nil;
        if (type == null) type = nil;
        if ($eqeq($$('Native'), buffer)) {
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [buffer], null)
        } else {
          
          var klass = $$('Array').$for(bits, type);

          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [new klass(buffer.$to_n())], null)
        
        };
        self.buffer = buffer;
        return (self.type = type);
      }, -2);
      
      $def(self, '$bits', function $$bits() {
        var self = this;

        return self["native"].BYTES_PER_ELEMENT * 8
      });
      
      $def(self, '$[]', function $Array_$$$2(index, offset) {
        var self = this;

        
        if (offset == null) offset = nil;
        if ($truthy(offset)) {
          return self["native"].subarray(index, offset)
        } else {
          return self["native"][index]
        };
      }, -2);
      
      $def(self, '$[]=', function $Array_$$$eq$3(index, value) {
        var self = this;

        return self["native"][index] = value
      });
      
      $def(self, '$bytesize', function $$bytesize() {
        var self = this;

        return self["native"].byteLength
      });
      
      $def(self, '$each', function $$each() {
        var $yield = $$each.$$p || nil, self = this;

        $$each.$$p = null;
        
        if (!($yield !== nil)) {
          return self.$enum_for("each")
        };
        
        for (var i = 0, length = self["native"].length; i < length; i++) {
          Opal.yield1($yield, self["native"][i])
        }
      ;
        return self;
      });
      
      $def(self, '$length', function $$length() {
        var self = this;

        return self["native"].length
      });
      
      $def(self, '$merge!', function $Array_merge$excl$4(other, offset) {
        var self = this;

        
        ;
        return self["native"].set(other.$to_n(), offset);
      }, -2);
      return $alias(self, "size", "length");
    })($nesting[0], null, $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["buffer/view"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $gvars = Opal.gvars, $defs = Opal.defs, $truthy = Opal.truthy, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,!,nil?,[],attr_reader,native?,to_n,name_for,get,set,length');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Buffer');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'View');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto["native"] = nil;
      
      self.$include($$$($$('Native'), 'Wrapper'));
      $defs(self, '$supported?', function $View_supported$ques$1() {
                if ($gvars.$ == null) $gvars.$ = nil;

        return $gvars.$['$[]']("DataView")['$nil?']()['$!']()
      });
      self.$attr_reader("buffer", "offset");
      
      $def(self, '$initialize', function $$initialize(buffer, offset, length) {
        var $yield = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        if (offset == null) offset = nil;
        if (length == null) length = nil;
        if ($truthy(self['$native?'](buffer))) {
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [buffer], null)
        } else if (($truthy(offset) && ($truthy(length)))) {
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [new DataView(buffer.$to_n(), offset.$to_n(), length.$to_n())], null)
        } else if ($truthy(offset)) {
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [new DataView(buffer.$to_n(), offset.$to_n())], null)
        } else {
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [new DataView(buffer.$to_n())], null)
        };
        self.buffer = buffer;
        return (self.offset = offset);
      }, -2);
      
      $def(self, '$length', function $$length() {
        var self = this;

        return self["native"].byteLength
      });
      
      $def(self, '$get', function $$get(offset, bits, type, little) {
        var self = this;

        
        if (bits == null) bits = 8;
        if (type == null) type = "unsigned";
        if (little == null) little = false;
        return self["native"]["get" + $$('Buffer').$name_for(bits, type)](offset, little);
      }, -2);
      $alias(self, "[]", "get");
      
      $def(self, '$set', function $$set(offset, value, bits, type, little) {
        var self = this;

        
        if (bits == null) bits = 8;
        if (type == null) type = "unsigned";
        if (little == null) little = false;
        return self["native"]["set" + $$('Buffer').$name_for(bits, type)](offset, value, little);
      }, -3);
      $alias(self, "[]=", "set");
      
      $def(self, '$get_int8', function $$get_int8(offset, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].getInt8(offset, little);
      }, -2);
      
      $def(self, '$set_int8', function $$set_int8(offset, value, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].setInt8(offset, value, little);
      }, -3);
      
      $def(self, '$get_uint8', function $$get_uint8(offset, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].getUint8(offset, little);
      }, -2);
      
      $def(self, '$set_uint8', function $$set_uint8(offset, value, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].setUint8(offset, value, little);
      }, -3);
      
      $def(self, '$get_int16', function $$get_int16(offset, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].getInt16(offset, little);
      }, -2);
      
      $def(self, '$set_int16', function $$set_int16(offset, value, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].setInt16(offset, value, little);
      }, -3);
      
      $def(self, '$get_uint16', function $$get_uint16(offset, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].getUint16(offset, little);
      }, -2);
      
      $def(self, '$set_uint16', function $$set_uint16(offset, value, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].setUint16(offset, value, little);
      }, -3);
      
      $def(self, '$get_int32', function $$get_int32(offset, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].getInt32(offset, little);
      }, -2);
      
      $def(self, '$set_int32', function $$set_int32(offset, value, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].setInt32(offset, value, little);
      }, -3);
      
      $def(self, '$get_uint32', function $$get_uint32(offset, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].getUint32(offset, little);
      }, -2);
      
      $def(self, '$set_uint32', function $$set_uint32(offset, value, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].setUint32(offset, value, little);
      }, -3);
      
      $def(self, '$get_float32', function $$get_float32(offset, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].getFloat32(offset, little);
      }, -2);
      
      $def(self, '$set_float32', function $$set_float32(offset, value, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].setFloat32(offset, value, little);
      }, -3);
      
      $def(self, '$get_float64', function $$get_float64(offset, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].getFloat64(offset, little);
      }, -2);
      
      $def(self, '$set_float64', function $$set_float64(offset, value, little) {
        var self = this;

        
        if (little == null) little = false;
        return self["native"].setFloat64(offset, value, little);
      }, -3);
      return $alias(self, "size", "length");
    })($nesting[0], null, $nesting)
  })($nesting[0], null, $nesting)
};

Opal.modules["buffer"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $gvars = Opal.gvars, $defs = Opal.defs, $eqeqeq = Opal.eqeqeq, $truthy = Opal.truthy, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,!,nil?,[],===,native?,new,pack,to_a,length');
  
  self.$require("native");
  self.$require("buffer/array");
  self.$require("buffer/view");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Buffer');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto["native"] = nil;
    
    self.$include($$$($$('Native'), 'Wrapper'));
    $defs(self, '$supported?', function $Buffer_supported$ques$1() {
            if ($gvars.$ == null) $gvars.$ = nil;

      return $gvars.$['$[]']("ArrayBuffer")['$nil?']()['$!']()
    });
    $defs(self, '$name_for', function $$name_for(bits, type) {
      var part = nil, $ret_or_1 = nil;

      
      part = ($eqeqeq("unsigned", ($ret_or_1 = type)) ? ("Uint") : ($eqeqeq("signed", $ret_or_1) ? ("Int") : ($eqeqeq("float", $ret_or_1) ? ("Float") : (nil))));
      return "" + (part) + (bits);
    });
    
    $def(self, '$initialize', function $$initialize(size, bits) {
      var $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      if (bits == null) bits = 8;
      if ($truthy(self['$native?'](size))) {
        return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [size], null)
      } else {
        return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [new ArrayBuffer(size * (bits / 8))], null)
      };
    }, -2);
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self["native"].byteLength
    });
    
    $def(self, '$to_a', function $$to_a(bits, type) {
      var self = this;

      
      if (bits == null) bits = 8;
      if (type == null) type = "unsigned";
      return $$('Array').$new(self, bits, type);
    }, -1);
    
    $def(self, '$view', function $$view(offset, length) {
      var self = this;

      
      if (offset == null) offset = nil;
      if (length == null) length = nil;
      return $$('View').$new(self, offset, length);
    }, -1);
    
    $def(self, '$to_s', function $$to_s() {
      var self = this;

      return self.$to_a().$to_a().$pack("c*")
    });
    return $alias(self, "size", "length");
  })($nesting[0], null, $nesting);
};

Opal.modules["browser/event/message"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,handles,supports?,convert,supported?,new,alias_native');
  
  self.$require("buffer");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Message');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        self.$handles("message");
        $defs(self, '$supported?', function $Message_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.Message")
        });
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$data=', function $Definition_data$eq$2(value) {
            var self = this;

            return self["native"].data = value
          });
          
          $def(self, '$origin=', function $Definition_origin$eq$3(value) {
            var self = this;

            return self["native"].origin = value
          });
          return $def(self, '$source=', function $Definition_source$eq$4(value) {
            var self = this;

            return self["native"].source = $$('Native').$convert(value)
          });
        })($nesting[0], $$('Definition'), $nesting);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new MessageEvent(name, desc)
            })
          } else if ($truthy($$('Browser')['$supports?']("Event.create"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              
        var event = document.createEvent("MessageEvent");
            event.initMessageEvent(name, desc.bubbles, desc.cancelable,
              desc.data, desc.origin, "", desc.source || window);

        return event;
      
            })
          }
        };
        
        $def(self, '$data', function $$data() {
          var self = this;

          
      if (window.ArrayBuffer && self["native"].data instanceof ArrayBuffer) {
        return $$('Buffer').$new(self["native"].data);
      }
      else if (window.Blob && self["native"].data instanceof Blob) {
        return $$('Blob').$new(self["native"].data);
      }
      else {
        return self["native"].data;
      }
    
        });
        self.$alias_native("origin");
        return $def(self, '$source', function $$source() {
          var self = this;

          
      var source = self["native"].source;

      if (window.Window && source instanceof window.Window) {
        return $$('Window').$new(source);
      }
      else {
        return nil;
      }
    
        });
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["browser/event/close"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handles,supports?,supported?,alias_native');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Close');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handles("close");
        $defs(self, '$supported?', function $Close_supported$ques$1() {
          
          return $$('Browser')['$supports?']("Event.Close")
        });
        (function($base, $super) {
          var self = $klass($base, $super, 'Definition');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          
          $def(self, '$code=', function $Definition_code$eq$2(value) {
            var self = this;

            return self["native"].code = value
          });
          
          $def(self, '$reason=', function $Definition_reason$eq$3(value) {
            var self = this;

            return self["native"].reason = value
          });
          
          $def(self, '$clean!', function $Definition_clean$excl$4(value) {
            var self = this;

            return self["native"].wasClean = true
          });
          return $def(self, '$not_clean!', function $Definition_not_clean$excl$5(value) {
            var self = this;

            return self["native"].wasClean = false
          });
        })($nesting[0], $$('Definition'));
        if ($truthy(self['$supported?']())) {
          if ($truthy($$('Browser')['$supports?']("Event.constructor"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              return new CloseEvent(name, desc)
            })
          } else if ($truthy($$('Browser')['$supports?']("Event.create"))) {
            $defs(self, '$construct', function $$construct(name, desc) {
              
              
        var event = document.createEvent("CloseEvent");
            event.initCloseEvent(name, desc.bubbles, desc.cancelable,
              desc.wasClean, desc.code, desc.reason);

        return event;
      
            })
          }
        };
        self.$alias_native("code");
        self.$alias_native("reason");
        return self.$alias_native("clean?", "wasClean");
      })($nesting[0], $$('Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/event/all"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var self = Opal.top, nil = Opal.nil;

  Opal.add_stubs('require');
  
  self.$require("browser/event/focus");
  self.$require("browser/event/wheel");
  self.$require("browser/event/data_transfer");
  self.$require("browser/event/composition");
  self.$require("browser/event/animation");
  self.$require("browser/event/audio_processing");
  self.$require("browser/event/before_unload");
  self.$require("browser/event/composition");
  self.$require("browser/event/clipboard");
  self.$require("browser/event/device_light");
  self.$require("browser/event/device_motion");
  self.$require("browser/event/device_orientation");
  self.$require("browser/event/device_proximity");
  self.$require("browser/event/drag");
  self.$require("browser/event/gamepad");
  self.$require("browser/event/hash_change");
  self.$require("browser/event/progress");
  self.$require("browser/event/page_transition");
  self.$require("browser/event/pop_state");
  self.$require("browser/event/storage");
  self.$require("browser/event/touch");
  self.$require("browser/event/sensor");
  self.$require("browser/event/message");
  return self.$require("browser/event/close");
};

Opal.modules["browser/dom/builder"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $defs = Opal.defs, $klass = Opal.klass, $slice = Opal.slice, $truthy = Opal.truthy, $def = Opal.def, $send = Opal.send, $eqeqeq = Opal.eqeqeq, $thrower = Opal.thrower, $const_set = Opal.const_set, $return_ivar = Opal.return_ivar, $to_a = Opal.to_a, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('<<,[]=,to_h,[],each,===,call,raise,attr_reader,instance_method,new,to_proc,proc,build!,!,map,build,extend!,for,create_text,document,create_element,on,inner_html=');
  
  (function($base) {
    var self = $module($base, 'Utils');

    
    return $defs(self, '$heredoc', function $$heredoc(string) {
      
      return string
    })
  })($$('Paggio'));
  (function($base, $super) {
    var self = $klass($base, $super, 'Element');

    var $proto = self.$$prototype;

    $proto.on = nil;
    return $def(self, '$on', function $$on($a) {
      var block = $$on.$$p || nil, $post_args, args, self = this, $ret_or_1 = nil;

      $$on.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      args = $post_args;
      return (self.on = ($truthy(($ret_or_1 = self.on)) ? ($ret_or_1) : ([])))['$<<']([args, block]);
    }, -1)
  })($$$($$('Paggio'), 'HTML'), $$('BasicObject'));
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Builder');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.builder = nil;
        
        $defs(self, '$to_h', function $$to_h() {
          var self = this, $ret_or_1 = nil;
          if (self.builders == null) self.builders = nil;

          return (self.builders = ($truthy(($ret_or_1 = self.builders)) ? ($ret_or_1) : ((new Map()))))
        });
        $defs(self, '$for', function $Builder_for$1(klass) {
          var block = $Builder_for$1.$$p || nil, $a, self = this;

          $Builder_for$1.$$p = null;
          
          ;
          if ($truthy(block)) {
            return ($a = [klass, block], $send(self.$to_h(), '[]=', $a), $a[$a.length - 1])
          } else {
            return self.$to_h()['$[]'](klass)
          };
        });
        $defs(self, '$build', function $$build(builder, item) {try { var $t_return = $thrower('return'); 
          var self = this;

          
          $send(self.$to_h(), 'each', [], function $$2(klass, block){
            
            if (klass == null) klass = nil;
            if (block == null) block = nil;
            if ($eqeqeq(klass, item)) {
              $t_return.$throw(block.$call(builder, item), $$2.$$is_lambda)
            } else {
              return nil
            };}, {$$ret: $t_return});
          return self.$raise($$('ArgumentError'), "cannot build unknown item " + (item));} catch($e) {
            if ($e === $t_return) return $e.$v;
            throw $e;
          } finally {$t_return.is_orphan = true;}
        });
        self.$attr_reader("document", "element");
        $const_set($nesting[0], 'NEW_PAGGIO', (function() { try {
          return $$$($$('Paggio'), 'HTML').$instance_method("build!")
        } catch ($err) {
          if (Opal.rescue($err, [$$('StandardError')])) {
            try {
              return false
            } finally { Opal.pop_exception($err); }
          } else { throw $err; }
        }})());
        
        $def(self, '$initialize', function $$initialize(document, builder) {
          var block = $$initialize.$$p || nil, self = this, build = nil;

          $$initialize.$$p = null;
          
          ;
          if (builder == null) builder = nil;
          self.document = document;
          if ($truthy($$('NEW_PAGGIO'))) {
            
            self.builder = $send($$$($$('Paggio'), 'HTML'), 'new', [(new Map([["defer", true]]))], block.$to_proc());
            build = $send(self, 'proc', [], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;
              if (self.builder == null) self.builder = nil;

              
              self.builder['$build!']((new Map([["force_call", builder['$!']()['$!']()]])));
              return (self.roots = $send(self.builder.$each(), 'map', [], function $$4(e){var self = $$4.$$s == null ? this : $$4.$$s;

                
                if (e == null) e = nil;
                return $$('Builder').$build(self, e);}, {$$s: self}));}, {$$s: self});
            if ($truthy(builder)) {
              return $send(builder, 'extend!', [self.builder], build.$to_proc())
            } else {
              return build.$call()
            };
          } else {
            
            self.builder = $send($$$($$('Paggio'), 'HTML'), 'new', [], block.$to_proc());
            return (self.roots = $send(self.builder.$each(), 'map', [], function $$5(e){var self = $$5.$$s == null ? this : $$5.$$s;

              
              if (e == null) e = nil;
              return $$('Builder').$build(self, e);}, {$$s: self}));
          };
        }, -2);
        return $def(self, '$to_a', $return_ivar("roots"));
      })($nesting[0], null, $nesting);
      $send($$('Builder'), 'for', [$$('String')], function $DOM$6(b, item){
        
        if (b == null) b = nil;
        if (item == null) item = nil;
        return b.$document().$create_text(item);});
      $send($$('Builder'), 'for', [$$$($$$($$('Paggio'), 'HTML'), 'Element')], function $DOM$7(b, item){var options = nil, dom = nil, on = nil, inner = nil;

        
        if (b == null) b = nil;
        if (item == null) item = nil;
        options = (new Map());
        if ($eqeqeq($$('Hash'), item.attributes)) {
          options['$[]=']("attrs", item.attributes)
        };
        options['$[]=']("classes", item.class_names);
        dom = b.$document().$create_element(item.name, Opal.to_hash(options));
        if ($truthy((on = item.on || nil))) {
          $send(on, 'each', [], function $$8(args, block){
            
            if (args == null) args = nil;
            if (block == null) block = nil;
            return $send(dom, 'on', $to_a(args), block.$to_proc());})
        };
        if ($truthy((inner = item.inner_html || nil))) {
          dom['$inner_html='](inner)
        } else {
          $send(item, 'each', [], function $$9(child){
            
            if (child == null) child = nil;
            return dom['$<<']($$('Builder').$build(b, child));})
        };
        return dom;});
      return $send($$('Builder'), 'for', [$$$($$('DOM'), 'Node')], function $DOM$10(b, item){
        
        if (b == null) b = nil;
        if (item == null) item = nil;
        return item;});
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["browser/dom/element/custom"] = function(Opal) {/* Generated by Opal 1.8.2 */
  "use strict";
  var $truthy = Opal.truthy, $module = Opal.module, $klass = Opal.klass, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $eqeq = Opal.eqeq, $def = Opal.def, $send = Opal.send, $eqeqeq = Opal.eqeqeq, $gvars = Opal.gvars, $defs = Opal.defs, $return_val = Opal.return_val, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('supports?,==,superclass,include?,ancestors,raise,def_selector,observe,new,each,target,type,observed_attributes,class,name,===,attribute_changed,old,[],added,attached_once,removed,detached_once,css,body,_dispatch_constructor,to_n,private,attr_accessor,attr_reader,extend,attached,detached,include');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Custom');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

          
          if ($truthy($$('Browser')['$supports?']("Custom Elements"))) {
            
    var make_custom_class = Function('self,base_class',
      '"use strict"; \
      var klass = class extends base_class { \
        constructor() { \
          super(); \
          self.$_dispatch_constructor(this); \
        } \
        connectedCallback() { \
          return this.$$opal_native_cached.$attached(); \
        } \
        disconnectedCallback() { \
          return this.$$opal_native_cached.$detached(); \
        } \
        adoptedCallback() { \
          return this.$$opal_native_cached.$adopted(); \
        } \
        attributeChangedCallback(attr, from, to) { \
          if (from === null) from = Opal.nil; \
          if (to === null) to = Opal.nil; \
          return this.$$opal_native_cached.$attribute_changed(attr, from, to); \
        } \
        \
        static get observedAttributes() { \
          return self.$observed_attributes(); \
        } \
      }; \
      klass.$$opal_class = self; \
      return klass;'
    );
  
          };
          (function($base, $parent_nesting) {
            var self = $module($base, 'ClassMethods');

            var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);
            if ($gvars.document == null) $gvars.document = nil;

            
            if ($truthy($$('Browser')['$supports?']("Custom Elements"))) {
              
              $def(self, '$def_custom', function $$def_custom(tag_name, $kwargs) {
                var base_class, extends$, self = this, $ret_or_1 = nil;
                if (self.observed_attributes == null) self.observed_attributes = nil;
                if (self.custom_class == null) self.custom_class = nil;

                
                $kwargs = $ensure_kwargs($kwargs);
                
                base_class = $hash_get($kwargs, "base_class");if (base_class == null) base_class = nil;
                
                extends$ = $hash_get($kwargs, "extends");if (extends$ == null) extends$ = nil;
                if (!$truthy(base_class !== nil)) {
                  if ($eqeq(self.$superclass(), $$('Custom'))) {
                    base_class = HTMLElement
                  } else if ($truthy(self.$ancestors()['$include?']($$('Custom')))) {
                    base_class = self.$superclass().custom_class
                  } else {
                    self.$raise($$('ArgumentError'), "You must define base_class")
                  }
                };
                self.custom_class = make_custom_class(self, base_class);
                self.observed_attributes = ($truthy(($ret_or_1 = self.observed_attributes)) ? ($ret_or_1) : ([]));
                self.$def_selector(tag_name);
                
          if ($truthy(extends$)) customElements.define(tag_name, self.custom_class, {extends: extends$});
          else customElements.define(tag_name, self.custom_class);
        ;
              }, -2)
            } else if ($truthy($$('Browser')['$supports?']("MutationObserver"))) {
              $send($$$($$$($$('Browser'), 'DOM'), 'MutationObserver'), 'new', [], function $ClassMethods$1(obs){
                
                if (obs == null) obs = nil;
                return $send(obs, 'each', [], function $$2(e){var target = nil;

                  
                  if (e == null) e = nil;
                  target = e.$target();
                  
                  switch (e.$type().valueOf()) {
                    case "attribute":
                      if (($eqeqeq($$$($$('Custom'), 'Mixin'), target) && ($truthy(target.$class().$observed_attributes()['$include?'](e.$name()))))) {
                        return target.$attribute_changed(e.$name(), e.$old(), target['$[]'](e.$name()))
                      } else {
                        return nil
                      }
                      break;
                    case "tree":
                      
                      $send(e.$added(), 'each', [], function $$3(n){
                        
                        if (n == null) n = nil;
                        if ($eqeqeq($$$($$('Custom'), 'Mixin'), n)) {
                          return n.$attached_once()
                        } else {
                          return nil
                        };});
                      return $send(e.$removed(), 'each', [], function $$4(n){
                        
                        if (n == null) n = nil;
                        if ($eqeqeq($$$($$('Custom'), 'Mixin'), n)) {
                          return n.$detached_once()
                        } else {
                          return nil
                        };});
                    default:
                      return nil
                  };});}).$observe($gvars.document, (new Map([["tree", true], ["children", true], ["attributes", "old"]])))
            };
            if (!$truthy($$('Browser')['$supports?']("Custom Elements"))) {
              
              $def(self, '$def_custom', function $$def_custom(tag_name, $kwargs) {
                var base_class, extends$, self = this;
                if ($gvars.document == null) $gvars.document = nil;

                
                $kwargs = $ensure_kwargs($kwargs);
                
                base_class = $hash_get($kwargs, "base_class");if (base_class == null) base_class = nil;
                
                extends$ = $hash_get($kwargs, "extends");if (extends$ == null) extends$ = nil;
                self.$def_selector(tag_name);
                return $send($gvars.document.$body().$css(tag_name), 'each', [], function $$5(elem){var $a, self = $$5.$$s == null ? this : $$5.$$s;

                  
                  if (elem == null) elem = nil;
                  return ($a = self.$_dispatch_constructor(elem.$to_n()), ($a === nil || $a == null) ? nil : $a.$attached_once());}, {$$s: self});
              }, -2)
            };
            self.$private($def(self, '$_dispatch_constructor', function $$_dispatch_constructor(obj) {
              var self = this;

              
        if (typeof obj.$$opal_native_cached !== 'undefined') {
          delete obj.$$opal_native_cached;
          return self.$new(obj);
        }
        else {
          self.$new(obj);
          return nil;
        }
      
            }));
            self.$attr_accessor("observed_attributes");
            return self.$attr_reader("custom_class");
          })($nesting[0], $nesting);
          (function($base, $parent_nesting) {
            var self = $module($base, 'Mixin');

            var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

            
            $defs(self, '$included', function $$included(klass) {
              
              return klass.$extend($$('ClassMethods'))
            });
            
            $def(self, '$attached', $return_val(nil));
            
            $def(self, '$detached', $return_val(nil));
            
            $def(self, '$adopted', $return_val(nil));
            
            $def(self, '$attribute_changed', $return_val(nil));
            
            $def(self, '$custom?', $return_val(true));
            if ($truthy($$('Browser')['$supports?']("Custom Elements"))) {
              return nil
            } else {
              
              
              $def(self, '$attached_once', function $$attached_once() {
                var self = this;
                if (self._polyfill_attached == null) self._polyfill_attached = nil;

                
                if (!$truthy(self._polyfill_attached)) {
                  self.$attached()
                };
                return (self._polyfill_attached = true);
              });
              return $def(self, '$detached_once', function $$detached_once() {
                var self = this;
                if (self._polyfill_attached == null) self._polyfill_attached = nil;

                
                if ($truthy(self._polyfill_attached)) {
                  self.$detached()
                };
                return (self._polyfill_attached = false);
              });
            };
          })($nesting[0], $nesting);
          return self.$include($$('Mixin'));
        })($nesting[0], $$('Element'), $nesting)
      })($nesting[0], $$('Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/canvas/style"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,attr_reader,to_n,smooth,[],new');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Canvas');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'StyleObject');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.context = nil;
        
        self.$include($$$($$('Native'), 'Wrapper'));
        self.$attr_reader("context");
        return $def(self, '$initialize', function $$initialize(context) {
          var $yield = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          
          self.context = context;
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [self.context.$to_n()], null);
        });
      })($nesting[0], null, $nesting);
      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Style');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto["native"] = nil;
        
        (function($base, $super) {
          var self = $klass($base, $super, 'Line');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$attr_reader("width", "cap", "join", "miter_limit");
          
          $def(self, '$width=', function $Line_width$eq$1(value) {
            var self = this;

            return self["native"].lineWidth = (self.width = value)
          });
          
          $def(self, '$cap=', function $Line_cap$eq$2(value) {
            var self = this;

            return self["native"].lineCap = (self.cap = value)
          });
          
          $def(self, '$join=', function $Line_join$eq$3(value) {
            var self = this;

            return self["native"].lineJoin = (self.join = value)
          });
          return $def(self, '$miter_limit=', function $Line_miter_limit$eq$4(value) {
            var self = this;

            return self["native"].miterLimit = (self.miter_limit = value)
          });
        })($nesting[0], $$('StyleObject'));
        (function($base, $super) {
          var self = $klass($base, $super, 'Text');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$attr_reader("font", "align", "baseline");
          
          $def(self, '$font=', function $Text_font$eq$5(value) {
            var self = this;

            return self["native"].font = (self.font = value)
          });
          
          $def(self, '$align=', function $Text_align$eq$6(value) {
            var self = this;

            return self["native"].textAlign = (self.align = value)
          });
          return $def(self, '$baseline=', function $Text_baseline$eq$7(value) {
            var self = this;

            return self["native"].textBaseline = (self.baseline = value)
          });
        })($nesting[0], $$('StyleObject'));
        (function($base, $super) {
          var self = $klass($base, $super, 'Image');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$attr_reader("smooth");
          $alias(self, "smooth?", "smooth");
          
          $def(self, '$smooth!', function $Image_smooth$excl$8() {
            var self = this;

            
            self["native"].mozImageSmoothingEnabled = (self.smooth = true);
            return self["native"].imageSmoothingEnabled = (self.smooth = true);
          });
          return $def(self, '$no_smooth!', function $Image_no_smooth$excl$9() {
            var self = this;

            
            self["native"].mozImageSmoothingEnabled = (self.smooth = false);
            return self["native"].imageSmoothingEnabled = (self.smooth = false);
          });
        })($nesting[0], $$('StyleObject'));
        (function($base, $super) {
          var self = $klass($base, $super, 'Shadow');

          var $proto = self.$$prototype;

          $proto["native"] = nil;
          
          self.$attr_reader("offset", "blur", "color");
          
          $def(self, '$offset=', function $Shadow_offset$eq$10(value) {
            var self = this;

            
            self["native"].shadowOffsetX = value['$[]']("x");
            self["native"].shadowOffsetY = value['$[]']("y");
            return (self.offset = value);
          });
          
          $def(self, '$blur=', function $Shadow_blur$eq$11(value) {
            var self = this;

            return self["native"].shadowBlur = (self.blur = value)
          });
          return $def(self, '$color=', function $Shadow_color$eq$12(value) {
            var self = this;

            return self["native"].shadowColor = (self.color = value)
          });
        })($nesting[0], $$('StyleObject'));
        self.$attr_reader("line", "text", "image", "shadow", "fill", "stroke", "alpha", "composite_operation");
        
        $def(self, '$initialize', function $$initialize(context) {
          var $yield = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [context], null);
          self.line = $$('Line').$new(context);
          self.text = $$('Text').$new(context);
          self.image = $$('Image').$new(context);
          return (self.shadow = $$('Shadow').$new(context));
        });
        
        $def(self, '$fill=', function $Style_fill$eq$13(value) {
          var self = this;

          return self["native"].fillStyle = (self.fill = value).$to_n()
        });
        
        $def(self, '$stroke=', function $Style_stroke$eq$14(value) {
          var self = this;

          return self["native"].strokeStyle = (self.stroke = value).$to_n()
        });
        
        $def(self, '$alpha=', function $Style_alpha$eq$15(value) {
          var self = this;

          return self["native"].globalAlpha = (self.alpha = value)
        });
        return $def(self, '$composite_operation=', function $Style_composite_operation$eq$16(value) {
          var self = this;

          return self["native"].globalCompositeOperation = (self.composite_operation = value)
        });
      })($nesting[0], $$('StyleObject'), $nesting);
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/canvas/text"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,attr_reader,to_n');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Canvas');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Text');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.context = $proto["native"] = nil;
        
        self.$include($$$($$('Native'), 'Wrapper'));
        self.$attr_reader("context");
        
        $def(self, '$initialize', function $$initialize(context) {
          var $yield = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          
          self.context = context;
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [self.context.$to_n()], null);
        });
        
        $def(self, '$measure', function $$measure(text) {
          var self = this;

          return self["native"].measureText(text)
        });
        
        $def(self, '$fill', function $$fill(text, x, y, max_width) {
          var self = this, $ret_or_1 = nil;

          
          if (x == null) x = nil;
          if (y == null) y = nil;
          if (max_width == null) max_width = nil;
          x = ($truthy(($ret_or_1 = x)) ? ($ret_or_1) : (0));
          y = ($truthy(($ret_or_1 = y)) ? ($ret_or_1) : (0));
          if ($truthy(max_width)) {
            self["native"].fillText(text, x, y, max_width)
          } else {
            self["native"].fillText(text, x, y)
          };
          return self.context;
        }, -2);
        return $def(self, '$stroke', function $$stroke(text, x, y, max_width) {
          var self = this, $ret_or_1 = nil;

          
          if (x == null) x = nil;
          if (y == null) y = nil;
          if (max_width == null) max_width = nil;
          x = ($truthy(($ret_or_1 = x)) ? ($ret_or_1) : (0));
          y = ($truthy(($ret_or_1 = y)) ? ($ret_or_1) : (0));
          if ($truthy(max_width)) {
            self["native"].strokeText(text, x, y, max_width)
          } else {
            self["native"].strokeText(text, x, y)
          };
          return self.context;
        }, -2);
      })($nesting[0], null, $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/canvas/data"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $defs = Opal.defs, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $truthy = Opal.truthy, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('allocate,instance_eval,to_a,to_n,include,attr_reader,length');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Canvas');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Data');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.canvas = $proto["native"] = nil;
        
        $defs(self, '$create', function $$create(canvas, width, height) {
          var self = this, data = nil;

          
          data = self.$allocate();
          $send(data, 'instance_eval', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

            
            self.canvas = canvas.$to_a();
            self.x = 0;
            self.y = 0;
            self.width = width;
            self.height = height;
            return (self["native"] = canvas.$to_n().createImageData(width, height));}, {$$s: self});
          return data;
        });
        self.$include($$$($$('Native'), 'Wrapper'));
        self.$attr_reader("x", "y", "width", "height");
        
        $def(self, '$initialize', function $$initialize(canvas, x, y, width, height) {
          var $yield = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          
          self.canvas = canvas.$to_n();
          self.x = x;
          self.y = y;
          self.width = width;
          self.height = height;
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [self.canvas.getImageData(x, y, width, height)], null);
        });
        
        $def(self, '$length', function $$length() {
          var self = this;

          return self["native"].data.length
        });
        
        $def(self, '$[]', function $Data_$$$2(index) {
          var self = this;

          return self["native"].data[index]
        });
        
        $def(self, '$[]=', function $Data_$$$eq$3(index, value) {
          var self = this;

          return self["native"].data[index] = value
        });
        
        $def(self, '$save', function $$save(x, y) {
          var self = this, $ret_or_1 = nil;

          
          if (x == null) x = nil;
          if (y == null) y = nil;
          x = ($truthy(($ret_or_1 = x)) ? ($ret_or_1) : (0));
          y = ($truthy(($ret_or_1 = y)) ? ($ret_or_1) : (0));
          return self.canvas.putImageData(self["native"], x, y);
        }, -1);
        
        $def(self, '$save_to', function $$save_to(canvas, x, y) {
          var self = this, $ret_or_1 = nil;

          
          if (x == null) x = nil;
          if (y == null) y = nil;
          x = ($truthy(($ret_or_1 = x)) ? ($ret_or_1) : (0));
          y = ($truthy(($ret_or_1 = y)) ? ($ret_or_1) : (0));
          return canvas.$to_n().putImageData(self["native"], x, y);
        }, -2);
        return $alias(self, "size", "length");
      })($nesting[0], null, $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/canvas/gradient"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $slice = Opal.slice, $send2 = Opal.send2, $find_super = Opal.find_super, $eqeqeq = Opal.eqeqeq, $send = Opal.send, $def = Opal.def, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,attr_reader,===,length,to_n,raise,instance_eval,to_proc');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Canvas');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Gradient');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.context = nil;
        
        self.$include($$$($$('Native'), 'Wrapper'));
        self.$attr_reader("context");
        
        $def(self, '$initialize', function $$initialize(context, $a) {
          var block = $$initialize.$$p || nil, $post_args, args, self = this, $ret_or_1 = nil;

          $$initialize.$$p = null;
          
          ;
          $post_args = $slice(arguments, 1);
          args = $post_args;
          self.context = context;
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [($eqeqeq(4, ($ret_or_1 = args.$length())) ? (self.context.$to_n().createLinearGradient.apply(self, args)) : ($eqeqeq(6, $ret_or_1) ? (self.context.$to_n().createRadialGradient.apply(self, args)) : (self.$raise($$('ArgumentError'), "don't know where to dispatch"))))], null);
          return $send(self, 'instance_eval', [], block.$to_proc());
        }, -2);
        return $def(self, '$add', function $$add(position, color) {
          var self = this;

          
          self.context.$to_n().addColorStop(position, color);
          return self;
        });
      })($nesting[0], null, $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["browser/canvas"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $slice = Opal.slice, $eqeqeq = Opal.eqeqeq, $truthy = Opal.truthy, $gvars = Opal.gvars, $neqeq = Opal.neqeq, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $send = Opal.send, $to_a = Opal.to_a, $alias = Opal.alias, $to_ary = Opal.to_ary, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,attr_reader,===,first,shift,create_element,[]=,width,height,!=,node_name,raise,to_n,new,draw_image,to_i,[],append_to,on,resolve,DOM,to_proc,move_to,line_to,length,quadratic_curve_to,bezier_curve_to,element,is_a?,save,instance_eval,restore,path,one,off,for');
  
  self.$require("browser/canvas/style");
  self.$require("browser/canvas/text");
  self.$require("browser/canvas/data");
  self.$require("browser/canvas/gradient");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Canvas');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.element = $proto.image = $proto["native"] = nil;
      
      self.$include($$$($$('Native'), 'Wrapper'));
      self.$attr_reader("element", "style", "text");
      
      $def(self, '$initialize', function $$initialize($a) {
        var $post_args, args, $yield = $$initialize.$$p || nil, self = this, element = nil;
        if ($gvars.document == null) $gvars.document = nil;

        $$initialize.$$p = null;
        
        $post_args = $slice(arguments);
        args = $post_args;
        if ($eqeqeq($$$($$('DOM'), 'Element'), args.$first())) {
          
          element = args.$shift();
          if ($eqeqeq($$$($$$($$('DOM'), 'Element'), 'Image'), element)) {
            self.image = element
          } else {
            self.element = element
          };
        } else if ($eqeqeq($$('Canvas'), args.$first())) {
          self.image = args.$first()
        };
        if (!$truthy(self.element)) {
          
          self.element = $gvars.document.$create_element("canvas");
          if ($truthy(self.image)) {
            
            self.element['$[]=']("width", self.image.$width());
            self.element['$[]=']("height", self.image.$height());
          } else {
            
            self.element['$[]=']("width", args.$shift());
            self.element['$[]=']("height", args.$shift());
          };
        };
        if ($neqeq(self.element.$node_name(), "CANVAS")) {
          self.$raise($$('ArgumentError'), "the element isn't a <canvas> element")
        };
        $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [self.element.$to_n().getContext('2d')], null);
        self.style = $$('Style').$new(self);
        self.text = $$('Text').$new(self);
        if ($truthy(self.image)) {
          return self.$draw_image(self.image)
        } else {
          return nil
        };
      }, -1);
      
      $def(self, '$width', function $$width() {
        var self = this;

        return self.element['$[]']("width").$to_i()
      });
      
      $def(self, '$height', function $$height() {
        var self = this;

        return self.element['$[]']("height").$to_i()
      });
      
      $def(self, '$width=', function $Canvas_width$eq$1(new_width) {
        var $a, self = this;

        return ($a = ["width", new_width.$to_i()], $send(self.element, '[]=', $a), $a[$a.length - 1])
      });
      
      $def(self, '$height=', function $Canvas_height$eq$2(new_height) {
        var $a, self = this;

        return ($a = ["height", new_height.$to_i()], $send(self.element, '[]=', $a), $a[$a.length - 1])
      });
      
      $def(self, '$append_to', function $$append_to(parent) {
        var self = this;

        return self.element.$append_to(parent)
      });
      
      $def(self, '$load', function $$load(path) {
        var promise = nil, image = nil;
        if ($gvars.document == null) $gvars.document = nil;

        
        promise = $$('Promise').$new();
        image = $gvars.document.$create_element("img");
        $send(image, 'on', ["load"], function $$3(){
          return promise.$resolve(image)});
        image['$[]=']("src", path);
        return promise;
      });
      
      $def(self, '$data', function $$data(x, y, width, height) {
        var self = this, $ret_or_1 = nil;

        
        if (x == null) x = nil;
        if (y == null) y = nil;
        if (width == null) width = nil;
        if (height == null) height = nil;
        x = ($truthy(($ret_or_1 = x)) ? ($ret_or_1) : (0));
        y = ($truthy(($ret_or_1 = y)) ? ($ret_or_1) : (0));
        width = ($truthy(($ret_or_1 = width)) ? ($ret_or_1) : (self.$width()));
        height = ($truthy(($ret_or_1 = height)) ? ($ret_or_1) : (self.$height()));
        return $$('Data').$new(self, x, y, width, height);
      }, -1);
      
      $def(self, '$pattern', function $$pattern(image, type) {
        var self = this;

        
        if (type == null) type = "repeat";
        return self["native"].createPattern(self.$DOM(image).$to_n(), type);
      }, -2);
      
      $def(self, '$gradient', function $$gradient($a) {
        var block = $$gradient.$$p || nil, $post_args, args, self = this;

        $$gradient.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        args = $post_args;
        return $send($$('Gradient'), 'new', [self].concat($to_a(args)), block.$to_proc());
      }, -1);
      
      $def(self, '$clear', function $$clear(x, y, width, height) {
        var self = this, $ret_or_1 = nil;

        
        if (x == null) x = nil;
        if (y == null) y = nil;
        if (width == null) width = nil;
        if (height == null) height = nil;
        x = ($truthy(($ret_or_1 = x)) ? ($ret_or_1) : (0));
        y = ($truthy(($ret_or_1 = y)) ? ($ret_or_1) : (0));
        width = ($truthy(($ret_or_1 = width)) ? ($ret_or_1) : (self.$width()));
        height = ($truthy(($ret_or_1 = height)) ? ($ret_or_1) : (self.$height()));
        return self["native"].clearRect(x, y, width, height);
      }, -1);
      
      $def(self, '$begin', function $$begin() {
        var self = this;

        
        self["native"].beginPath();
        return self;
      });
      
      $def(self, '$close', function $$close() {
        var self = this;

        
        self["native"].closePath();
        return self;
      });
      
      $def(self, '$save', function $$save() {
        var self = this;

        
        self["native"].save();
        return self;
      });
      
      $def(self, '$restore', function $$restore() {
        var self = this;

        
        self["native"].restore();
        return self;
      });
      
      $def(self, '$move_to', function $$move_to(x, y) {
        var self = this;

        
        self["native"].moveTo(x, y);
        return self;
      });
      $alias(self, "move", "move_to");
      
      $def(self, '$line_to', function $$line_to(x, y) {
        var self = this;

        
        self["native"].lineTo(x, y);
        return self;
      });
      
      $def(self, '$line', function $$line(x1, y1, x2, y2) {
        var self = this;

        
        self.$move_to(x1, y1);
        return self.$line_to(x2, y2);
      });
      
      $def(self, '$rect', function $$rect(x, y, width, height) {
        var self = this;

        
        self["native"].rect(x, y, width, height);
        return self;
      });
      
      $def(self, '$arc', function $$arc(x, y, radius, angle, clockwise) {
        var self = this;

        
        if (clockwise == null) clockwise = false;
        self["native"].arc(x, y, radius, angle['$[]']("start"), angle['$[]']("end"), !clockwise);
        return self;
      }, -5);
      
      $def(self, '$quadratic_curve_to', function $$quadratic_curve_to(cp1x, cp1y, x, y) {
        var self = this;

        
        self["native"].quadraticCurveTo(cp1x, cp1y, x, y);
        return self;
      });
      
      $def(self, '$bezier_curve_to', function $$bezier_curve_to(cp1x, cp1y, cp2x, cp2y, x, y) {
        var self = this;

        
        self["native"].bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
        return self;
      });
      
      $def(self, '$curve_to', function $$curve_to($a) {
        var $post_args, args, self = this;

        
        $post_args = $slice(arguments);
        args = $post_args;
        
        switch (args.$length().valueOf()) {
          case 4:
            $send(self, 'quadratic_curve_to', $to_a(args))
            break;
          case 6:
            $send(self, 'bezier_curve_to', $to_a(args))
            break;
          default:
            self.$raise($$('ArgumentError'), "don't know where to dispatch")
        };
        return self;
      }, -1);
      
      $def(self, '$draw_image', function $$draw_image(image, $a) {
        var $post_args, args, $b, $c, self = this, source = nil, destination = nil;

        
        $post_args = $slice(arguments, 1);
        args = $post_args;
        if ($eqeqeq($$('Canvas'), image)) {
          image = image.$element()
        } else {
          image = self.$DOM(image)
        };
        if ($truthy(args.$first()['$is_a?']($$('Hash')))) {
          
          $c = args, $b = $to_ary($c), (source = ($b[0] == null ? nil : $b[0])), (destination = ($b[1] == null ? nil : $b[1])), $c;
          self["native"].drawImage(image.$to_n(), source['$[]']("x"), source['$[]']("y"), source['$[]']("width"), source['$[]']("height"), destination['$[]']("x"), destination['$[]']("y"), destination['$[]']("width"), destination['$[]']("height"));
        } else 
        switch (args.$length().valueOf()) {
          case 0:
            self["native"].drawImage(image.$to_n(), 0, 0)
            break;
          case 2:
            self["native"].drawImage(image.$to_n(), args['$[]'](0), args['$[]'](1))
            break;
          case 4:
            self["native"].drawImage(image.$to_n(), args['$[]'](0), args['$[]'](1), args['$[]'](2), args['$[]'](3))
            break;
          default:
            nil
        };
        return self;
      }, -2);
      
      $def(self, '$translate', function $$translate(x, y) {
        var block = $$translate.$$p || nil, self = this;

        $$translate.$$p = null;
        
        ;
        if ($truthy(block)) {
          
          self.$save();
          self["native"].translate(x, y);
          $send(self, 'instance_eval', [], block.$to_proc());
          self.$restore();
        } else {
          self["native"].translate(x, y)
        };
        return self;
      });
      
      $def(self, '$rotate', function $$rotate(angle) {
        var block = $$rotate.$$p || nil, self = this;

        $$rotate.$$p = null;
        
        ;
        if ($truthy(block)) {
          
          self.$save();
          self["native"].rotate(angle);
          $send(self, 'instance_eval', [], block.$to_proc());
          self.$restore();
        } else {
          self["native"].rotate(angle)
        };
        return self;
      });
      
      $def(self, '$scale', function $$scale(x, y) {
        var block = $$scale.$$p || nil, self = this;

        $$scale.$$p = null;
        
        ;
        if ($truthy(block)) {
          
          self.$save();
          self["native"].scale(x, y);
          $send(self, 'instance_eval', [], block.$to_proc());
          self.$restore();
        } else {
          self["native"].scale(x, y)
        };
        return self;
      });
      
      $def(self, '$transform', function $$transform(m11, m12, m21, m22, dx, dy) {
        var block = $$transform.$$p || nil, self = this;

        $$transform.$$p = null;
        
        ;
        if ($truthy(block)) {
          
          self.$save();
          self["native"].transform(m11, m12, m21, m22, dx, dy);
          $send(self, 'instance_eval', [], block.$to_proc());
          self.$restore();
        } else {
          self["native"].transform(m11, m12, m21, m22, dx, dy)
        };
        return self;
      });
      
      $def(self, '$path', function $$path() {
        var block = $$path.$$p || nil, self = this;

        $$path.$$p = null;
        
        ;
        self["native"].beginPath();
        $send(self, 'instance_eval', [], block.$to_proc());
        self["native"].closePath();
        return self;
      });
      
      $def(self, '$fill', function $$fill() {
        var block = $$fill.$$p || nil, self = this;

        $$fill.$$p = null;
        
        ;
        if ($truthy(block)) {
          $send(self, 'path', [], block.$to_proc())
        };
        self["native"].fill();
        return self;
      });
      
      $def(self, '$stroke', function $$stroke() {
        var block = $$stroke.$$p || nil, self = this;

        $$stroke.$$p = null;
        
        ;
        if ($truthy(block)) {
          $send(self, 'path', [], block.$to_proc())
        };
        self["native"].stroke();
        return self;
      });
      
      $def(self, '$clip', function $$clip() {
        var block = $$clip.$$p || nil, self = this;

        $$clip.$$p = null;
        
        ;
        if ($truthy(block)) {
          $send(self, 'path', [], block.$to_proc())
        };
        self["native"].clip();
        return self;
      });
      
      $def(self, '$point_in_path?', function $Canvas_point_in_path$ques$4(x, y) {
        var self = this;

        return self["native"].isPointInPath(x, y)
      });
      
      $def(self, '$to_data', function $$to_data(type) {
        var self = this;

        
        ;
        return self.element.$to_n().toDataUrl(type);
      }, -1);
      
      $def(self, '$to_dom', function $$to_dom($a) {
        var $post_args, $fwd_rest, self = this;

        
        $post_args = $slice(arguments);
        $fwd_rest = $post_args;
        return self.element;
      }, -1);
      
      $def(self, '$on', function $$on($a) {
        var block = $$on.$$p || nil, $post_args, args, self = this;

        $$on.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        args = $post_args;
        return $send(self.element, 'on', $to_a(args), block.$to_proc());
      }, -1);
      
      $def(self, '$one', function $$one($a) {
        var block = $$one.$$p || nil, $post_args, args, self = this;

        $$one.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        args = $post_args;
        return $send(self.element, 'one', $to_a(args), block.$to_proc());
      }, -1);
      return $def(self, '$off', function $$off($a) {
        var block = $$off.$$p || nil, $post_args, args, self = this;

        $$off.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        args = $post_args;
        return $send(self.element, 'off', $to_a(args), block.$to_proc());
      }, -1);
    })($nesting[0], null, $nesting);
    return $send($$$($$$($$('Browser'), 'DOM'), 'Builder'), 'for', [$$('Canvas')], function $Browser$5(b, item){
      
      if (b == null) b = nil;
      if (item == null) item = nil;
      return item.$element();});
  })($nesting[0], $nesting);
};

Opal.modules["browser/setup/full"] = function(Opal) {/* Generated by Opal 1.8.2 */
  var self = Opal.top, nil = Opal.nil;

  Opal.add_stubs('require');
  
  self.$require("paggio");
  self.$require("browser/setup/large");
  self.$require("browser/event/all");
  self.$require("browser/dom/builder");
  self.$require("browser/dom/mutation_observer");
  self.$require("browser/dom/element/custom");
  return self.$require("browser/canvas");
};

Opal.queue(function(Opal) {/* Generated by Opal 1.8.2 */
  var $gvars = Opal.gvars, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $truthy = Opal.truthy, $send = Opal.send, $rb_plus = Opal.rb_plus, self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$, d = nil, all = nil;
  if ($gvars.document == null) $gvars.document = nil;

  Opal.add_stubs('require,<<,body,create_element,DOM,inner_html=,observed_attributes=,[],[]=,on,increase!,render,off,+,to_i,def_custom,new,e,each,css');
  
  self.$require("opal");
  self.$require("console");
  self.$require("promise");
  self.$require("browser/setup/full");
  $gvars.document.$body()['$<<']($gvars.document.$create_element("app-mycounter"));
  d = self.$DOM("<div>");
  $gvars.document.$body()['$<<'](d);
  d['$inner_html=']("<app-mycounter>");
  (function($base, $super) {
    var self = $klass($base, $super, 'MyCounter');

    
    
    self['$observed_attributes='](["value"]);
    
    $def(self, '$initialize', function $$initialize(node) {
      var $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [node], $yield)
    });
    
    $def(self, '$attached', function $$attached() {
      var self = this, $ret_or_1 = nil;

      
      if ($truthy(($ret_or_1 = self['$[]']("value")))) {
        $ret_or_1
      } else {
        self['$[]=']("value", "0")
      };
      $send(self, 'on', ["click"], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

        return self['$increase!']()}, {$$s: self});
      return self.$render();
    });
    
    $def(self, '$detached', function $$detached() {
      var self = this;

      return self.$off("click")
    });
    
    $def(self, '$attribute_changed', function $$attribute_changed(attr, from, to) {
      var self = this;

      return self.$render()
    });
    
    $def(self, '$increase!', function $MyCounter_increase$excl$2() {
      var $a, self = this;

      return ($a = ["value", $rb_plus(self['$[]']("value").$to_i(), 1)], $send(self, '[]=', $a), $a[$a.length - 1])
    });
    
    $def(self, '$render', function $$render() {
      var $a, self = this;

      return ($a = ["<h1>[" + (self['$[]']("value")) + "]</h1>"], $send(self, 'inner_html=', $a), $a[$a.length - 1])
    });
    return self.$def_custom("app-mycounter");
  })($nesting[0], $$$($$$($$$($$('Browser'), 'DOM'), 'Element'), 'Custom'));
  $gvars.document.$body()['$<<'](self.$DOM("<app-mycounter></app-mycounter>"));
  $gvars.document.$body()['$<<']($gvars.document.$create_element("app-mycounter"));
  $gvars.document.$body()['$<<']($$('MyCounter').$new());
  $gvars.document.$body()['$<<']($send(self, 'DOM', [], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;

    return self.$e("app-mycounter")}, {$$s: self}));
  all = self.$DOM("<h1>Increase all!</h1>");
  $send(all, 'on', ["click"], function $$4(){    if ($gvars.document == null) $gvars.document = nil;

    return $send($gvars.document.$css("app-mycounter"), 'each', [], function $$5(c){
      
      if (c == null) c = nil;
      return c['$increase!']();})});
  return $gvars.document.$body()['$<<'](all);
});

Opal.queue(function(Opal) {/* Generated by Opal 1.8.2 */
  var $Kernel = Opal.Kernel, nil = Opal.nil;

  Opal.add_stubs('exit');
  return $Kernel.$exit()
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzZWN0aW9ucyI6W3sib2Zmc2V0Ijp7ImxpbmUiOjAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3J1bnRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKGdsb2JhbF9vYmplY3QpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgLy8gQG5vdGVcbiAgLy8gICBBIGZldyBjb252ZW50aW9ucyBmb3IgdGhlIGRvY3VtZW50YXRpb24gb2YgdGhpcyBmaWxlOlxuICAvLyAgIDEuIEFsd2F5cyB1c2UgXCIvL1wiIChpbiBjb250cmFzdCB3aXRoIFwiLyoqL1wiKVxuICAvLyAgIDIuIFRoZSBzeW50YXggdXNlZCBpcyBZYXJkb2MgKHlhcmRvYy5vcmcpLCB3aGljaCBpcyBpbnRlbmRlZCBmb3IgUnVieSAoc2UgYmVsb3cpXG4gIC8vICAgMy4gYEBwYXJhbWAgYW5kIGBAcmV0dXJuYCB0eXBlcyBzaG91bGQgYmUgcHJlY2VkZWQgYnkgYEpTLmAgd2hlbiByZWZlcnJpbmcgdG9cbiAgLy8gICAgICBKYXZhU2NyaXB0IGNvbnN0cnVjdG9ycyAoZS5nLiBgSlMuRnVuY3Rpb25gKSBvdGhlcndpc2UgUnVieSBpcyBhc3N1bWVkLlxuICAvLyAgIDQuIGBuaWxgIGFuZCBgbnVsbGAgYmVpbmcgdW5hbWJpZ3VvdXMgcmVmZXIgdG8gdGhlIHJlc3BlY3RpdmVcbiAgLy8gICAgICBvYmplY3RzL3ZhbHVlcyBpbiBSdWJ5IGFuZCBKYXZhU2NyaXB0XG4gIC8vICAgNS4gVGhpcyBpcyBzdGlsbCBXSVAgOikgc28gcGxlYXNlIGdpdmUgZmVlZGJhY2sgYW5kIHN1Z2dlc3Rpb25zIG9uIGhvd1xuICAvLyAgICAgIHRvIGltcHJvdmUgb3IgZm9yIGFsdGVybmF0aXZlIHNvbHV0aW9uc1xuICAvL1xuICAvLyAgIFRoZSB3YXkgdGhlIGNvZGUgaXMgZGlnZXN0ZWQgYmVmb3JlIGdvaW5nIHRocm91Z2ggWWFyZG9jIGlzIGEgc2VjcmV0IGtlcHRcbiAgLy8gICBpbiB0aGUgZG9jcyByZXBvIChodHRwczovL2dpdGh1Yi5jb20vb3BhbC9kb2NzL3RyZWUvbWFzdGVyKS5cblxuICB2YXIgY29uc29sZTtcblxuICAvLyBEZXRlY3QgdGhlIGdsb2JhbCBvYmplY3RcbiAgaWYgKHR5cGVvZihnbG9iYWxUaGlzKSAhPT0gJ3VuZGVmaW5lZCcpIHsgZ2xvYmFsX29iamVjdCA9IGdsb2JhbFRoaXM7IH1cbiAgZWxzZSBpZiAodHlwZW9mKGdsb2JhbCkgIT09ICd1bmRlZmluZWQnKSB7IGdsb2JhbF9vYmplY3QgPSBnbG9iYWw7IH1cbiAgZWxzZSBpZiAodHlwZW9mKHdpbmRvdykgIT09ICd1bmRlZmluZWQnKSB7IGdsb2JhbF9vYmplY3QgPSB3aW5kb3c7IH1cblxuICAvLyBTZXR1cCBhIGR1bW15IGNvbnNvbGUgb2JqZWN0IGlmIG1pc3NpbmdcbiAgaWYgKGdsb2JhbF9vYmplY3QuY29uc29sZSA9PSBudWxsKSB7XG4gICAgZ2xvYmFsX29iamVjdC5jb25zb2xlID0ge307XG4gIH1cblxuICBpZiAodHlwZW9mKGdsb2JhbF9vYmplY3QuY29uc29sZSkgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc29sZSA9IGdsb2JhbF9vYmplY3QuY29uc29sZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlID0ge307XG4gIH1cblxuICBpZiAoISgnbG9nJyBpbiBjb25zb2xlKSkgeyBjb25zb2xlLmxvZyA9IGZ1bmN0aW9uICgpIHt9OyB9XG4gIGlmICghKCd3YXJuJyBpbiBjb25zb2xlKSkgeyBjb25zb2xlLndhcm4gPSBjb25zb2xlLmxvZzsgfVxuXG4gIGlmICh0eXBlb2YoZ2xvYmFsX29iamVjdC5PcGFsKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLndhcm4oJ09wYWwgYWxyZWFkeSBsb2FkZWQuIExvYWRpbmcgdHdpY2UgY2FuIGNhdXNlIHRyb3VibGVzLCBwbGVhc2UgZml4IHlvdXIgc2V0dXAuJyk7XG4gICAgcmV0dXJuIGdsb2JhbF9vYmplY3QuT3BhbDtcbiAgfVxuXG4gIHZhciBuaWw7XG5cbiAgLy8gVGhlIGFjdHVhbCBjbGFzcyBmb3IgQmFzaWNPYmplY3RcbiAgdmFyIEJhc2ljT2JqZWN0O1xuXG4gIC8vIFRoZSBhY3R1YWwgT2JqZWN0IGNsYXNzLlxuICAvLyBUaGUgbGVhZGluZyB1bmRlcnNjb3JlIGlzIHRvIGF2b2lkIGNvbmZ1c2lvbiB3aXRoIHdpbmRvdy5PYmplY3QoKVxuICB2YXIgX09iamVjdDtcblxuICAvLyBUaGUgYWN0dWFsIE1vZHVsZSBjbGFzc1xuICB2YXIgTW9kdWxlO1xuXG4gIC8vIFRoZSBhY3R1YWwgQ2xhc3MgY2xhc3NcbiAgdmFyIENsYXNzO1xuXG4gIC8vIFRoZSBPcGFsLk9wYWwgY2xhc3MgKGhlbHBlcnMgZXRjLilcbiAgdmFyIF9PcGFsO1xuXG4gIC8vIFRoZSBLZXJuZWwgbW9kdWxlXG4gIHZhciBLZXJuZWw7XG5cbiAgLy8gVGhlIE9wYWwgb2JqZWN0IHRoYXQgaXMgZXhwb3NlZCBnbG9iYWxseVxuICB2YXIgT3BhbCA9IGdsb2JhbF9vYmplY3QuT3BhbCA9IHt9O1xuXG4gIC8vIFRoaXMgaXMgYSB1c2VmdWwgcmVmZXJlbmNlIHRvIGdsb2JhbCBvYmplY3QgaW5zaWRlIHJ1YnkgZmlsZXNcbiAgT3BhbC5nbG9iYWwgPSBnbG9iYWxfb2JqZWN0O1xuXG4gIC8vIENvbmZpZ3VyZSBydW50aW1lIGJlaGF2aW9yIHdpdGggcmVnYXJkcyB0byByZXF1aXJlIGFuZCB1bnN1cHBvcnRlZCBmZWF0dXJlc1xuICBPcGFsLmNvbmZpZyA9IHtcbiAgICBtaXNzaW5nX3JlcXVpcmVfc2V2ZXJpdHk6ICdlcnJvcicsICAgICAgICAvLyBlcnJvciwgd2FybmluZywgaWdub3JlXG4gICAgdW5zdXBwb3J0ZWRfZmVhdHVyZXNfc2V2ZXJpdHk6ICd3YXJuaW5nJywgLy8gZXJyb3IsIHdhcm5pbmcsIGlnbm9yZVxuICAgIGV4cGVyaW1lbnRhbF9mZWF0dXJlc19zZXZlcml0eTogJ3dhcm5pbmcnLC8vIHdhcm5pbmcsIGlnbm9yZVxuICAgIGVuYWJsZV9zdGFja190cmFjZTogdHJ1ZSAgICAgICAgICAgICAgICAgIC8vIHRydWUsIGZhbHNlXG4gIH07XG5cbiAgLy8gTWluaWZ5IGNvbW1vbiBmdW5jdGlvbiBjYWxsc1xuICB2YXIgJGNhbGwgICAgICA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsO1xuICB2YXIgJGJpbmQgICAgICA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kO1xuICB2YXIgJGhhc19vd24gICA9IE9iamVjdC5oYXNPd24gfHwgJGNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbiAgdmFyICRzZXRfcHJvdG8gPSBPYmplY3Quc2V0UHJvdG90eXBlT2Y7XG4gIHZhciAkc2xpY2UgICAgID0gJGNhbGwuYmluZChBcnJheS5wcm90b3R5cGUuc2xpY2UpO1xuICB2YXIgJHNwbGljZSAgICA9ICRjYWxsLmJpbmQoQXJyYXkucHJvdG90eXBlLnNwbGljZSk7XG5cbiAgLy8gTmlsIG9iamVjdCBpZCBpcyBhbHdheXMgNFxuICB2YXIgbmlsX2lkID0gNDtcblxuICAvLyBHZW5lcmF0ZXMgZXZlbiBzZXF1ZW50aWFsIG51bWJlcnMgZ3JlYXRlciB0aGFuIDRcbiAgLy8gKG5pbF9pZCkgdG8gc2VydmUgYXMgdW5pcXVlIGlkcyBmb3IgcnVieSBvYmplY3RzXG4gIHZhciB1bmlxdWVfaWQgPSBuaWxfaWQ7XG5cbiAgLy8gUmV0dXJuIG5leHQgdW5pcXVlIGlkXG4gIGZ1bmN0aW9uICR1aWQoKSB7XG4gICAgdW5pcXVlX2lkICs9IDI7XG4gICAgcmV0dXJuIHVuaXF1ZV9pZDtcbiAgfTtcbiAgT3BhbC51aWQgPSAkdWlkO1xuXG4gIC8vIFJldHJpZXZlIG9yIGFzc2lnbiB0aGUgaWQgb2YgYW4gb2JqZWN0XG4gIE9wYWwuaWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqLiQkaXNfbnVtYmVyKSByZXR1cm4gKG9iaiAqIDIpKzE7XG4gICAgaWYgKG9iai4kJGlkID09IG51bGwpIHtcbiAgICAgICRwcm9wKG9iaiwgJyQkaWQnLCAkdWlkKCkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqLiQkaWQ7XG4gIH07XG5cbiAgLy8gR2xvYmFscyB0YWJsZVxuICB2YXIgJGd2YXJzID0gT3BhbC5ndmFycyA9IHt9O1xuXG4gIC8vIEV4aXQgZnVuY3Rpb24sIHRoaXMgc2hvdWxkIGJlIHJlcGxhY2VkIGJ5IHBsYXRmb3JtIHNwZWNpZmljIGltcGxlbWVudGF0aW9uXG4gIC8vIChTZWUgbm9kZWpzIGFuZCBjaHJvbWUgZm9yIGV4YW1wbGVzKVxuICBPcGFsLmV4aXQgPSBmdW5jdGlvbihzdGF0dXMpIHsgaWYgKCRndmFycy5ERUJVRykgY29uc29sZS5sb2coJ0V4aXRlZCB3aXRoIHN0YXR1cyAnK3N0YXR1cyk7IH07XG5cbiAgLy8ga2VlcHMgdHJhY2sgb2YgZXhjZXB0aW9ucyBmb3IgJCFcbiAgT3BhbC5leGNlcHRpb25zID0gW107XG5cbiAgLy8gQHByaXZhdGVcbiAgLy8gUG9wcyBhbiBleGNlcHRpb24gZnJvbSB0aGUgc3RhY2sgYW5kIHVwZGF0ZXMgYCQhYC5cbiAgT3BhbC5wb3BfZXhjZXB0aW9uID0gZnVuY3Rpb24ocmVzY3VlZF9leGNlcHRpb24pIHtcbiAgICB2YXIgZXhjZXB0aW9uID0gT3BhbC5leGNlcHRpb25zLnBvcCgpO1xuICAgIGlmIChleGNlcHRpb24gPT09IHJlc2N1ZWRfZXhjZXB0aW9uKSB7XG4gICAgICAvLyBDdXJyZW50ICQhIGlzIHJhaXNlZCBpbiB0aGUgcmVzY3VlIGJsb2NrLCBzbyB3ZSBkb24ndCB1cGRhdGUgaXRcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhjZXB0aW9uKSB7XG4gICAgICAkZ3ZhcnNbXCIhXCJdID0gZXhjZXB0aW9uO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICRndmFyc1tcIiFcIl0gPSBuaWw7XG4gICAgfVxuICB9O1xuXG4gIC8vIEEgaGVscGVyIGZ1bmN0aW9uIGZvciByYWlzaW5nIHRoaW5ncywgdGhhdCBncmFjZWZ1bGx5IGRlZ3JhZGVzIGlmIG5lY2Vzc2FyeVxuICAvLyBmdW5jdGlvbmFsaXR5IGlzIG5vdCB5ZXQgbG9hZGVkLlxuICBmdW5jdGlvbiAkcmFpc2Uoa2xhc3MsIG1lc3NhZ2UpIHtcbiAgICAvLyBSYWlzZSBFeGNlcHRpb24sIHNvIHdlIGNhbiBrbm93IHRoYXQgc29tZXRoaW5nIHdyb25nIGlzIGdvaW5nIG9uLlxuICAgIGlmICgha2xhc3MpIGtsYXNzID0gT3BhbC5FeGNlcHRpb24gfHwgRXJyb3I7XG5cbiAgICBpZiAoS2VybmVsICYmIEtlcm5lbC4kcmFpc2UpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICBLZXJuZWwuJHJhaXNlKGtsYXNzLiRuZXcuYXBwbHkoa2xhc3MsICRzbGljZShhcmd1bWVudHMsIDEpKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgS2VybmVsLiRyYWlzZShrbGFzcywgbWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCFrbGFzcy4kbmV3KSB7XG4gICAgICB0aHJvdyBuZXcga2xhc3MobWVzc2FnZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cga2xhc3MuJG5ldyhtZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXVzZSB0aGUgc2FtZSBvYmplY3QgZm9yIHBlcmZvcm1hbmNlL21lbW9yeSBzYWtlXG4gIHZhciBwcm9wX29wdGlvbnMgPSB7XG4gICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfTtcblxuICBmdW5jdGlvbiAkcHJvcChvYmplY3QsIG5hbWUsIGluaXRpYWxWYWx1ZSkge1xuICAgIGlmICh0eXBlb2Yob2JqZWN0KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvcjpcbiAgICAgIC8vICAgcyA9IFwic3RyaW5nXCJcbiAgICAgIC8vICAgZGVmIHMubTsgZW5kXG4gICAgICAvLyBTdHJpbmcgY2xhc3MgaXMgdGhlIG9ubHkgY2xhc3MgdGhhdDpcbiAgICAgIC8vICsgY29tcGlsZXMgdG8gSlMgcHJpbWl0aXZlXG4gICAgICAvLyArIGFsbG93cyBtZXRob2QgZGVmaW5pdGlvbiBkaXJlY3RseSBvbiBpbnN0YW5jZXNcbiAgICAgIC8vIG51bWJlcnMsIHRydWUsIGZhbHNlIGFuZCBudWxsIGRvIG5vdCBzdXBwb3J0IGl0LlxuICAgICAgb2JqZWN0W25hbWVdID0gaW5pdGlhbFZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wX29wdGlvbnMudmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCBwcm9wX29wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIE9wYWwucHJvcCA9ICRwcm9wO1xuXG4gIC8vIEBkZXByZWNhdGVkXG4gIE9wYWwuZGVmaW5lUHJvcGVydHkgPSBPcGFsLnByb3A7XG5cbiAgT3BhbC5zbGljZSA9ICRzbGljZTtcblxuICAvLyBIZWxwZXJzXG4gIC8vIC0tLS0tXG5cbiAgdmFyICR0cnV0aHkgPSBPcGFsLnRydXRoeSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHJldHVybiBmYWxzZSAhPT0gdmFsICYmIG5pbCAhPT0gdmFsICYmIHVuZGVmaW5lZCAhPT0gdmFsICYmIG51bGwgIT09IHZhbCAmJiAoISh2YWwgaW5zdGFuY2VvZiBCb29sZWFuKSB8fCB0cnVlID09PSB2YWwudmFsdWVPZigpKTtcbiAgfTtcblxuICBPcGFsLmZhbHN5ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgcmV0dXJuICEkdHJ1dGh5KHZhbCk7XG4gIH07XG5cbiAgT3BhbC50eXBlX2Vycm9yID0gZnVuY3Rpb24ob2JqZWN0LCB0eXBlLCBtZXRob2QsIGNvZXJjZWQpIHtcbiAgICBvYmplY3QgPSBvYmplY3QuJCRjbGFzcztcblxuICAgIGlmIChjb2VyY2VkICYmIG1ldGhvZCkge1xuICAgICAgY29lcmNlZCA9IGNvZXJjZWQuJCRjbGFzcztcbiAgICAgICRyYWlzZShPcGFsLlR5cGVFcnJvcixcbiAgICAgICAgXCJjYW4ndCBjb252ZXJ0IFwiICsgb2JqZWN0ICsgXCIgaW50byBcIiArIHR5cGUgK1xuICAgICAgICBcIiAoXCIgKyBvYmplY3QgKyBcIiNcIiArIG1ldGhvZCArIFwiIGdpdmVzIFwiICsgY29lcmNlZCArIFwiKVwiXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgICRyYWlzZShPcGFsLlR5cGVFcnJvcixcbiAgICAgICAgXCJubyBpbXBsaWNpdCBjb252ZXJzaW9uIG9mIFwiICsgb2JqZWN0ICsgXCIgaW50byBcIiArIHR5cGVcbiAgICAgIClcbiAgICB9XG4gIH07XG5cbiAgT3BhbC5jb2VyY2VfdG8gPSBmdW5jdGlvbihvYmplY3QsIHR5cGUsIG1ldGhvZCwgYXJncykge1xuICAgIHZhciBib2R5O1xuXG4gICAgaWYgKG1ldGhvZCA9PT0gJ3RvX2ludCcgJiYgdHlwZSA9PT0gT3BhbC5JbnRlZ2VyICYmIG9iamVjdC4kJGlzX251bWJlcilcbiAgICAgIHJldHVybiBvYmplY3QgPCAwID8gTWF0aC5jZWlsKG9iamVjdCkgOiBNYXRoLmZsb29yKG9iamVjdCk7XG5cbiAgICBpZiAobWV0aG9kID09PSAndG9fc3RyJyAmJiB0eXBlID09PSBPcGFsLlN0cmluZyAmJiBvYmplY3QuJCRpc19zdHJpbmcpXG4gICAgICByZXR1cm4gb2JqZWN0O1xuXG4gICAgaWYgKE9wYWwuaXNfYShvYmplY3QsIHR5cGUpKSByZXR1cm4gb2JqZWN0O1xuXG4gICAgLy8gRmFzdCBwYXRoIGZvciB0aGUgbW9zdCBjb21tb24gc2l0dWF0aW9uXG4gICAgaWYgKG9iamVjdFsnJHJlc3BvbmRfdG8/J10uJCRwcmlzdGluZSAmJiBvYmplY3QuJG1ldGhvZF9taXNzaW5nLiQkcHJpc3RpbmUpIHtcbiAgICAgIGJvZHkgPSBvYmplY3RbJGpzaWQobWV0aG9kKV07XG4gICAgICBpZiAoYm9keSA9PSBudWxsIHx8IGJvZHkuJCRzdHViKSBPcGFsLnR5cGVfZXJyb3Iob2JqZWN0LCB0eXBlKTtcbiAgICAgIHJldHVybiBib2R5LmFwcGx5KG9iamVjdCwgYXJncyk7XG4gICAgfVxuXG4gICAgaWYgKCFvYmplY3RbJyRyZXNwb25kX3RvPyddKG1ldGhvZCkpIHtcbiAgICAgIE9wYWwudHlwZV9lcnJvcihvYmplY3QsIHR5cGUpO1xuICAgIH1cblxuICAgIGlmIChhcmdzID09IG51bGwpIGFyZ3MgPSBbXTtcbiAgICByZXR1cm4gT3BhbC5zZW5kKG9iamVjdCwgbWV0aG9kLCBhcmdzKTtcbiAgfVxuXG4gIE9wYWwucmVzcG9uZF90byA9IGZ1bmN0aW9uKG9iaiwganNpZCwgaW5jbHVkZV9hbGwpIHtcbiAgICBpZiAob2JqID09IG51bGwgfHwgIW9iai4kJGNsYXNzKSByZXR1cm4gZmFsc2U7XG4gICAgaW5jbHVkZV9hbGwgPSAhIWluY2x1ZGVfYWxsO1xuICAgIHZhciBib2R5ID0gb2JqW2pzaWRdO1xuXG4gICAgaWYgKG9ialsnJHJlc3BvbmRfdG8/J10uJCRwcmlzdGluZSkge1xuICAgICAgaWYgKHR5cGVvZihib2R5KSA9PT0gXCJmdW5jdGlvblwiICYmICFib2R5LiQkc3R1Yikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghb2JqWyckcmVzcG9uZF90b19taXNzaW5nPyddLiQkcHJpc3RpbmUpIHtcbiAgICAgICAgcmV0dXJuIE9wYWwuc2VuZChvYmosIG9ialsnJHJlc3BvbmRfdG9fbWlzc2luZz8nXSwgW2pzaWQuc3Vic3RyKDEpLCBpbmNsdWRlX2FsbF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gT3BhbC5zZW5kKG9iaiwgb2JqWyckcmVzcG9uZF90bz8nXSwgW2pzaWQuc3Vic3RyKDEpLCBpbmNsdWRlX2FsbF0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRyYWNlUG9pbnQgc3VwcG9ydFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gU3VwcG9ydCBmb3IgYFRyYWNlUG9pbnQudHJhY2UoOmNsYXNzKSBkbyAuLi4gZW5kYFxuICBPcGFsLnRyYWNlX2NsYXNzID0gZmFsc2U7XG4gIE9wYWwudHJhY2Vyc19mb3JfY2xhc3MgPSBbXTtcblxuICBmdW5jdGlvbiBpbnZva2VfdHJhY2Vyc19mb3JfY2xhc3Moa2xhc3Nfb3JfbW9kdWxlKSB7XG4gICAgdmFyIGksIGlpLCB0cmFjZXI7XG5cbiAgICBmb3IoaSA9IDAsIGlpID0gT3BhbC50cmFjZXJzX2Zvcl9jbGFzcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICB0cmFjZXIgPSBPcGFsLnRyYWNlcnNfZm9yX2NsYXNzW2ldO1xuICAgICAgdHJhY2VyLnRyYWNlX29iamVjdCA9IGtsYXNzX29yX21vZHVsZTtcbiAgICAgIHRyYWNlci5ibG9jay4kY2FsbCh0cmFjZXIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZV9hdXRvbG9hZChjcmVmLCBuYW1lKSB7XG4gICAgaWYgKCFjcmVmLiQkYXV0b2xvYWRbbmFtZV0ubG9hZGVkKSB7XG4gICAgICBjcmVmLiQkYXV0b2xvYWRbbmFtZV0ubG9hZGVkID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIE9wYWwuS2VybmVsLiRyZXF1aXJlKGNyZWYuJCRhdXRvbG9hZFtuYW1lXS5wYXRoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY3JlZi4kJGF1dG9sb2FkW25hbWVdLmV4Y2VwdGlvbiA9IGU7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICBjcmVmLiQkYXV0b2xvYWRbbmFtZV0ucmVxdWlyZWQgPSB0cnVlO1xuICAgICAgaWYgKGNyZWYuJCRjb25zdFtuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgIGNyZWYuJCRhdXRvbG9hZFtuYW1lXS5zdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGNyZWYuJCRjb25zdFtuYW1lXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNyZWYuJCRhdXRvbG9hZFtuYW1lXS5sb2FkZWQgJiYgIWNyZWYuJCRhdXRvbG9hZFtuYW1lXS5yZXF1aXJlZCkge1xuICAgICAgaWYgKGNyZWYuJCRhdXRvbG9hZFtuYW1lXS5leGNlcHRpb24pIHsgdGhyb3cgY3JlZi4kJGF1dG9sb2FkW25hbWVdLmV4Y2VwdGlvbjsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENvbnN0YW50c1xuICAvLyAtLS0tLS0tLS1cbiAgLy9cbiAgLy8gRm9yIGZ1dHVyZSByZWZlcmVuY2U6XG4gIC8vIC0gVGhlIFJhaWxzIGF1dG9sb2FkaW5nIGd1aWRlIChodHRwOi8vZ3VpZGVzLnJ1YnlvbnJhaWxzLm9yZy92NS4wL2F1dG9sb2FkaW5nX2FuZF9yZWxvYWRpbmdfY29uc3RhbnRzLmh0bWwpXG4gIC8vIC0gQENvbnJhZElyd2luJ3MgMjAxMiBwb3N0IG9uIOKAnEV2ZXJ5dGhpbmcgeW91IGV2ZXIgd2FudGVkIHRvIGtub3cgYWJvdXQgY29uc3RhbnQgbG9va3VwIGluIFJ1YnnigJ0gKGh0dHA6Ly9jaXJ3LmluL2Jsb2cvY29uc3RhbnQtbG9va3VwLmh0bWwpXG4gIC8vXG4gIC8vIExlZ2VuZCBvZiBNUkkgY29uY2VwdHMvbmFtZXM6XG4gIC8vIC0gY29uc3RhbnQgcmVmZXJlbmNlIChjcmVmKTogdGhlIG1vZHVsZS9jbGFzcyB0aGF0IGFjdHMgYXMgYSBuYW1lc3BhY2VcbiAgLy8gLSBuZXN0aW5nOiB0aGUgbmFtZXNwYWNlcyB3cmFwcGluZyB0aGUgY3VycmVudCBzY29wZSwgZS5nLiBuZXN0aW5nIGluc2lkZVxuICAvLyAgICAgICAgICAgIGBtb2R1bGUgQTsgbW9kdWxlIEI6OkM7IGVuZDsgZW5kYCBpcyBgW0I6OkMsIEFdYFxuXG4gIC8vIEdldCB0aGUgY29uc3RhbnQgaW4gdGhlIHNjb3BlIG9mIHRoZSBjdXJyZW50IGNyZWZcbiAgZnVuY3Rpb24gY29uc3RfZ2V0X25hbWUoY3JlZiwgbmFtZSkge1xuICAgIGlmIChjcmVmKSB7XG4gICAgICBpZiAoY3JlZi4kJGNvbnN0W25hbWVdICE9IG51bGwpIHsgcmV0dXJuIGNyZWYuJCRjb25zdFtuYW1lXTsgfVxuICAgICAgaWYgKGNyZWYuJCRhdXRvbG9hZCAmJiBjcmVmLiQkYXV0b2xvYWRbbmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZV9hdXRvbG9hZChjcmVmLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBXYWxrIHVwIHRoZSBuZXN0aW5nIGFycmF5IGxvb2tpbmcgZm9yIHRoZSBjb25zdGFudFxuICBmdW5jdGlvbiBjb25zdF9sb29rdXBfbmVzdGluZyhuZXN0aW5nLCBuYW1lKSB7XG4gICAgdmFyIGksIGlpLCBjb25zdGFudDtcblxuICAgIGlmIChuZXN0aW5nLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgLy8gSWYgdGhlIG5lc3RpbmcgaXMgbm90IGVtcHR5IHRoZSBjb25zdGFudCBpcyBsb29rZWQgdXAgaW4gaXRzIGVsZW1lbnRzXG4gICAgLy8gYW5kIGluIG9yZGVyLiBUaGUgYW5jZXN0b3JzIG9mIHRob3NlIGVsZW1lbnRzIGFyZSBpZ25vcmVkLlxuICAgIGZvciAoaSA9IDAsIGlpID0gbmVzdGluZy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBjb25zdGFudCA9IG5lc3RpbmdbaV0uJCRjb25zdFtuYW1lXTtcbiAgICAgIGlmIChjb25zdGFudCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBjb25zdGFudDtcbiAgICAgIH0gZWxzZSBpZiAobmVzdGluZ1tpXS4kJGF1dG9sb2FkICYmIG5lc3RpbmdbaV0uJCRhdXRvbG9hZFtuYW1lXSkge1xuICAgICAgICByZXR1cm4gaGFuZGxlX2F1dG9sb2FkKG5lc3RpbmdbaV0sIG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFdhbGsgdXAgdGhlIGFuY2VzdG9ycyBjaGFpbiBsb29raW5nIGZvciB0aGUgY29uc3RhbnRcbiAgZnVuY3Rpb24gY29uc3RfbG9va3VwX2FuY2VzdG9ycyhjcmVmLCBuYW1lKSB7XG4gICAgdmFyIGksIGlpLCBhbmNlc3RvcnM7XG5cbiAgICBpZiAoY3JlZiA9PSBudWxsKSByZXR1cm47XG5cbiAgICBhbmNlc3RvcnMgPSAkYW5jZXN0b3JzKGNyZWYpO1xuXG4gICAgZm9yIChpID0gMCwgaWkgPSBhbmNlc3RvcnMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgaWYgKGFuY2VzdG9yc1tpXS4kJGNvbnN0ICYmICRoYXNfb3duKGFuY2VzdG9yc1tpXS4kJGNvbnN0LCBuYW1lKSkge1xuICAgICAgICByZXR1cm4gYW5jZXN0b3JzW2ldLiQkY29uc3RbbmFtZV07XG4gICAgICB9IGVsc2UgaWYgKGFuY2VzdG9yc1tpXS4kJGF1dG9sb2FkICYmIGFuY2VzdG9yc1tpXS4kJGF1dG9sb2FkW25hbWVdKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVfYXV0b2xvYWQoYW5jZXN0b3JzW2ldLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBXYWxrIHVwIE9iamVjdCdzIGFuY2VzdG9ycyBjaGFpbiBsb29raW5nIGZvciB0aGUgY29uc3RhbnQsXG4gIC8vIGJ1dCBvbmx5IGlmIGNyZWYgaXMgbWlzc2luZyBvciBhIG1vZHVsZS5cbiAgZnVuY3Rpb24gY29uc3RfbG9va3VwX09iamVjdChjcmVmLCBuYW1lKSB7XG4gICAgaWYgKGNyZWYgPT0gbnVsbCB8fCBjcmVmLiQkaXNfbW9kdWxlKSB7XG4gICAgICByZXR1cm4gY29uc3RfbG9va3VwX2FuY2VzdG9ycyhfT2JqZWN0LCBuYW1lKTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsIGNvbnN0X21pc3NpbmcgaWYgbm90aGluZyBlbHNlIHdvcmtlZFxuICBmdW5jdGlvbiBjb25zdF9taXNzaW5nKGNyZWYsIG5hbWUpIHtcbiAgICByZXR1cm4gKGNyZWYgfHwgX09iamVjdCkuJGNvbnN0X21pc3NpbmcobmFtZSk7XG4gIH1cblxuICAvLyBMb29rIGZvciB0aGUgY29uc3RhbnQganVzdCBpbiB0aGUgY3VycmVudCBjcmVmIG9yIGNhbGwgYCNjb25zdF9taXNzaW5nYFxuICBPcGFsLmNvbnN0X2dldF9sb2NhbCA9IGZ1bmN0aW9uKGNyZWYsIG5hbWUsIHNraXBfbWlzc2luZykge1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICBpZiAoY3JlZiA9PSBudWxsKSByZXR1cm47XG5cbiAgICBpZiAoY3JlZiA9PT0gJzo6JykgY3JlZiA9IF9PYmplY3Q7XG5cbiAgICBpZiAoIWNyZWYuJCRpc19tb2R1bGUgJiYgIWNyZWYuJCRpc19jbGFzcykge1xuICAgICAgJHJhaXNlKE9wYWwuVHlwZUVycm9yLCBjcmVmLnRvU3RyaW5nKCkgKyBcIiBpcyBub3QgYSBjbGFzcy9tb2R1bGVcIik7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gY29uc3RfZ2V0X25hbWUoY3JlZiwgbmFtZSk7XG4gICAgcmV0dXJuIHJlc3VsdCAhPSBudWxsIHx8IHNraXBfbWlzc2luZyA/IHJlc3VsdCA6IGNvbnN0X21pc3NpbmcoY3JlZiwgbmFtZSk7XG4gIH07XG5cbiAgLy8gTG9vayBmb3IgdGhlIGNvbnN0YW50IHJlbGF0aXZlIHRvIGEgY3JlZiBvciBjYWxsIGAjY29uc3RfbWlzc2luZ2AgKHdoZW4gdGhlXG4gIC8vIGNvbnN0YW50IGlzIHByZWZpeGVkIGJ5IGA6OmApLlxuICBPcGFsLmNvbnN0X2dldF9xdWFsaWZpZWQgPSBmdW5jdGlvbihjcmVmLCBuYW1lLCBza2lwX21pc3NpbmcpIHtcbiAgICB2YXIgcmVzdWx0LCBjYWNoZSwgY2FjaGVkLCBjdXJyZW50X3ZlcnNpb24gPSBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb247XG5cbiAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAvLyBBIHNob3J0cGF0aCBmb3IgY2FsbHMgbGlrZSA6OlN0cmluZyA9PiAkJCQoXCJTdHJpbmdcIilcbiAgICAgIHJlc3VsdCA9IGNvbnN0X2dldF9uYW1lKF9PYmplY3QsIGNyZWYpO1xuXG4gICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgICByZXR1cm4gT3BhbC5jb25zdF9nZXRfcXVhbGlmaWVkKF9PYmplY3QsIGNyZWYsIHNraXBfbWlzc2luZyk7XG4gICAgfVxuXG4gICAgaWYgKGNyZWYgPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgaWYgKGNyZWYgPT09ICc6OicpIGNyZWYgPSBfT2JqZWN0O1xuXG4gICAgaWYgKCFjcmVmLiQkaXNfbW9kdWxlICYmICFjcmVmLiQkaXNfY2xhc3MpIHtcbiAgICAgICRyYWlzZShPcGFsLlR5cGVFcnJvciwgY3JlZi50b1N0cmluZygpICsgXCIgaXMgbm90IGEgY2xhc3MvbW9kdWxlXCIpO1xuICAgIH1cblxuICAgIGlmICgoY2FjaGUgPSBjcmVmLiQkY29uc3RfY2FjaGUpID09IG51bGwpIHtcbiAgICAgICRwcm9wKGNyZWYsICckJGNvbnN0X2NhY2hlJywgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICBjYWNoZSA9IGNyZWYuJCRjb25zdF9jYWNoZTtcbiAgICB9XG4gICAgY2FjaGVkID0gY2FjaGVbbmFtZV07XG5cbiAgICBpZiAoY2FjaGVkID09IG51bGwgfHwgY2FjaGVkWzBdICE9PSBjdXJyZW50X3ZlcnNpb24pIHtcbiAgICAgICgocmVzdWx0ID0gY29uc3RfZ2V0X25hbWUoY3JlZiwgbmFtZSkpICAgICAgICAgICAgICAhPSBudWxsKSB8fFxuICAgICAgKChyZXN1bHQgPSBjb25zdF9sb29rdXBfYW5jZXN0b3JzKGNyZWYsIG5hbWUpKSAgICAgICE9IG51bGwpO1xuICAgICAgY2FjaGVbbmFtZV0gPSBbY3VycmVudF92ZXJzaW9uLCByZXN1bHRdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBjYWNoZWRbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdCAhPSBudWxsIHx8IHNraXBfbWlzc2luZyA/IHJlc3VsdCA6IGNvbnN0X21pc3NpbmcoY3JlZiwgbmFtZSk7XG4gIH07XG5cbiAgLy8gSW5pdGlhbGl6ZSB0aGUgdG9wIGxldmVsIGNvbnN0YW50IGNhY2hlIGdlbmVyYXRpb24gY291bnRlclxuICBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb24gPSAxO1xuXG4gIC8vIExvb2sgZm9yIHRoZSBjb25zdGFudCBpbiB0aGUgb3BlbiB1c2luZyB0aGUgY3VycmVudCBuZXN0aW5nIGFuZCB0aGUgbmVhcmVzdFxuICAvLyBjcmVmIGFuY2VzdG9ycyBvciBjYWxsIGAjY29uc3RfbWlzc2luZ2AgKHdoZW4gdGhlIGNvbnN0YW50IGhhcyBubyA6OiBwcmVmaXgpLlxuICBPcGFsLmNvbnN0X2dldF9yZWxhdGl2ZSA9IGZ1bmN0aW9uKG5lc3RpbmcsIG5hbWUsIHNraXBfbWlzc2luZykge1xuICAgIHZhciBjcmVmID0gbmVzdGluZ1swXSwgcmVzdWx0LCBjdXJyZW50X3ZlcnNpb24gPSBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb24sIGNhY2hlLCBjYWNoZWQ7XG5cbiAgICBpZiAoKGNhY2hlID0gbmVzdGluZy4kJGNvbnN0X2NhY2hlKSA9PSBudWxsKSB7XG4gICAgICAkcHJvcChuZXN0aW5nLCAnJCRjb25zdF9jYWNoZScsIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgY2FjaGUgPSBuZXN0aW5nLiQkY29uc3RfY2FjaGU7XG4gICAgfVxuICAgIGNhY2hlZCA9IGNhY2hlW25hbWVdO1xuXG4gICAgaWYgKGNhY2hlZCA9PSBudWxsIHx8IGNhY2hlZFswXSAhPT0gY3VycmVudF92ZXJzaW9uKSB7XG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2dldF9uYW1lKGNyZWYsIG5hbWUpKSAgICAgICAgICAgICAgIT0gbnVsbCkgfHxcbiAgICAgICgocmVzdWx0ID0gY29uc3RfbG9va3VwX25lc3RpbmcobmVzdGluZywgbmFtZSkpICAgICAhPSBudWxsKSB8fFxuICAgICAgKChyZXN1bHQgPSBjb25zdF9sb29rdXBfYW5jZXN0b3JzKGNyZWYsIG5hbWUpKSAgICAgICE9IG51bGwpIHx8XG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2xvb2t1cF9PYmplY3QoY3JlZiwgbmFtZSkpICAgICAgICAgIT0gbnVsbCk7XG5cbiAgICAgIGNhY2hlW25hbWVdID0gW2N1cnJlbnRfdmVyc2lvbiwgcmVzdWx0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gY2FjaGVkWzFdO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQgIT0gbnVsbCB8fCBza2lwX21pc3NpbmcgPyByZXN1bHQgOiBjb25zdF9taXNzaW5nKGNyZWYsIG5hbWUpO1xuICB9O1xuXG4gIC8vIFJlZ2lzdGVyIHRoZSBjb25zdGFudCBvbiBhIGNyZWYgYW5kIG9wcG9ydHVuaXN0aWNhbGx5IHNldCB0aGUgbmFtZSBvZlxuICAvLyB1bm5hbWVkIGNsYXNzZXMvbW9kdWxlcy5cbiAgZnVuY3Rpb24gJGNvbnN0X3NldChjcmVmLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBuZXdfY29uc3QgPSB0cnVlO1xuXG4gICAgaWYgKGNyZWYgPT0gbnVsbCB8fCBjcmVmID09PSAnOjonKSBjcmVmID0gX09iamVjdDtcblxuICAgIGlmICh2YWx1ZS4kJGlzX2FfbW9kdWxlKSB7XG4gICAgICBpZiAodmFsdWUuJCRuYW1lID09IG51bGwgfHwgdmFsdWUuJCRuYW1lID09PSBuaWwpIHZhbHVlLiQkbmFtZSA9IG5hbWU7XG4gICAgICBpZiAodmFsdWUuJCRiYXNlX21vZHVsZSA9PSBudWxsKSB2YWx1ZS4kJGJhc2VfbW9kdWxlID0gY3JlZjtcbiAgICB9XG5cbiAgICBjcmVmLiQkY29uc3QgPSAoY3JlZi4kJGNvbnN0IHx8IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXG4gICAgaWYgKG5hbWUgaW4gY3JlZi4kJGNvbnN0IHx8IChcIiQkYXV0b2xvYWRcIiBpbiBjcmVmICYmIG5hbWUgaW4gY3JlZi4kJGF1dG9sb2FkKSkge1xuICAgICAgbmV3X2NvbnN0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgY3JlZi4kJGNvbnN0W25hbWVdID0gdmFsdWU7XG5cbiAgICAvLyBBZGQgYSBzaG9ydCBoZWxwZXIgdG8gbmF2aWdhdGUgY29uc3RhbnRzIG1hbnVhbGx5LlxuICAgIC8vIEBleGFtcGxlXG4gICAgLy8gICBPcGFsLiQkLlJlZ2V4cC4kJC5JR05PUkVDQVNFXG4gICAgY3JlZi4kJCA9IGNyZWYuJCRjb25zdDtcblxuICAgIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbisrO1xuXG4gICAgLy8gRXhwb3NlIHRvcCBsZXZlbCBjb25zdGFudHMgb250byB0aGUgT3BhbCBvYmplY3RcbiAgICBpZiAoY3JlZiA9PT0gX09iamVjdCkgT3BhbFtuYW1lXSA9IHZhbHVlO1xuXG4gICAgLy8gTmFtZSBuZXcgY2xhc3MgZGlyZWN0bHkgb250byBjdXJyZW50IHNjb3BlIChPcGFsLkZvby5CYXogPSBrbGFzcylcbiAgICAkcHJvcChjcmVmLCBuYW1lLCB2YWx1ZSk7XG5cbiAgICBpZiAobmV3X2NvbnN0ICYmIGNyZWYuJGNvbnN0X2FkZGVkICYmICFjcmVmLiRjb25zdF9hZGRlZC4kJHByaXN0aW5lKSB7XG4gICAgICBjcmVmLiRjb25zdF9hZGRlZChuYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgT3BhbC5jb25zdF9zZXQgPSAkY29uc3Rfc2V0O1xuXG4gIC8vIEdldCBhbGwgdGhlIGNvbnN0YW50cyByZWFjaGFibGUgZnJvbSBhIGdpdmVuIGNyZWYsIGJ5IGRlZmF1bHQgd2lsbCBpbmNsdWRlXG4gIC8vIGluaGVyaXRlZCBjb25zdGFudHMuXG4gIE9wYWwuY29uc3RhbnRzID0gZnVuY3Rpb24oY3JlZiwgaW5oZXJpdCkge1xuICAgIGlmIChpbmhlcml0ID09IG51bGwpIGluaGVyaXQgPSB0cnVlO1xuXG4gICAgdmFyIG1vZHVsZSwgbW9kdWxlcyA9IFtjcmVmXSwgaSwgaWksIGNvbnN0YW50cyA9IHt9LCBjb25zdGFudDtcblxuICAgIGlmIChpbmhlcml0KSBtb2R1bGVzID0gbW9kdWxlcy5jb25jYXQoJGFuY2VzdG9ycyhjcmVmKSk7XG4gICAgaWYgKGluaGVyaXQgJiYgY3JlZi4kJGlzX21vZHVsZSkgbW9kdWxlcyA9IG1vZHVsZXMuY29uY2F0KFtPcGFsLk9iamVjdF0pLmNvbmNhdCgkYW5jZXN0b3JzKE9wYWwuT2JqZWN0KSk7XG5cbiAgICBmb3IgKGkgPSAwLCBpaSA9IG1vZHVsZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgbW9kdWxlID0gbW9kdWxlc1tpXTtcblxuICAgICAgLy8gRG8gbm90IHNob3cgT2JqZWN0cyBjb25zdGFudHMgdW5sZXNzIHdlJ3JlIHF1ZXJ5aW5nIE9iamVjdCBpdHNlbGZcbiAgICAgIGlmIChjcmVmICE9PSBfT2JqZWN0ICYmIG1vZHVsZSA9PSBfT2JqZWN0KSBicmVhaztcblxuICAgICAgZm9yIChjb25zdGFudCBpbiBtb2R1bGUuJCRjb25zdCkge1xuICAgICAgICBjb25zdGFudHNbY29uc3RhbnRdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChtb2R1bGUuJCRhdXRvbG9hZCkge1xuICAgICAgICBmb3IgKGNvbnN0YW50IGluIG1vZHVsZS4kJGF1dG9sb2FkKSB7XG4gICAgICAgICAgY29uc3RhbnRzW2NvbnN0YW50XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoY29uc3RhbnRzKTtcbiAgfTtcblxuICAvLyBSZW1vdmUgYSBjb25zdGFudCBmcm9tIGEgY3JlZi5cbiAgT3BhbC5jb25zdF9yZW1vdmUgPSBmdW5jdGlvbihjcmVmLCBuYW1lKSB7XG4gICAgT3BhbC5jb25zdF9jYWNoZV92ZXJzaW9uKys7XG5cbiAgICBpZiAoY3JlZi4kJGNvbnN0W25hbWVdICE9IG51bGwpIHtcbiAgICAgIHZhciBvbGQgPSBjcmVmLiQkY29uc3RbbmFtZV07XG4gICAgICBkZWxldGUgY3JlZi4kJGNvbnN0W25hbWVdO1xuICAgICAgcmV0dXJuIG9sZDtcbiAgICB9XG5cbiAgICBpZiAoY3JlZi4kJGF1dG9sb2FkICYmIGNyZWYuJCRhdXRvbG9hZFtuYW1lXSkge1xuICAgICAgZGVsZXRlIGNyZWYuJCRhdXRvbG9hZFtuYW1lXTtcbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuXG4gICAgJHJhaXNlKE9wYWwuTmFtZUVycm9yLCBcImNvbnN0YW50IFwiK2NyZWYrXCI6OlwiK2NyZWYuJG5hbWUoKStcIiBub3QgZGVmaW5lZFwiKTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIGEgY3VycmllZCBjb25zdF9nZXRfcmVsYXRpdmUuXG4gIE9wYWwuY29uc3RfZ2V0X3JlbGF0aXZlX2ZhY3RvcnkgPSBmdW5jdGlvbihuZXN0aW5nKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUsIHNraXBfbWlzc2luZykge1xuICAgICAgcmV0dXJuIE9wYWwuJCQobmVzdGluZywgbmFtZSwgc2tpcF9taXNzaW5nKTtcbiAgICB9XG4gIH1cblxuICAvLyBTZXR1cCBzb21lIHNob3J0Y3V0cyB0byByZWR1Y2UgY29tcGlsZWQgc2l6ZVxuICBPcGFsLiQkID0gT3BhbC5jb25zdF9nZXRfcmVsYXRpdmU7XG4gIE9wYWwuJCQkID0gT3BhbC5jb25zdF9nZXRfcXVhbGlmaWVkO1xuICBPcGFsLiRyID0gT3BhbC5jb25zdF9nZXRfcmVsYXRpdmVfZmFjdG9yeTtcblxuICBmdW5jdGlvbiBkZXNjZW5kc19mcm9tX2JyaWRnZWRfY2xhc3Moa2xhc3MpIHtcbiAgICBpZiAoa2xhc3MgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChrbGFzcy4kJGJyaWRnZSkgcmV0dXJuIGtsYXNzO1xuICAgIGlmIChrbGFzcy4kJHN1cGVyKSByZXR1cm4gZGVzY2VuZHNfZnJvbV9icmlkZ2VkX2NsYXNzKGtsYXNzLiQkc3VwZXIpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIE1vZHVsZXMgJiBDbGFzc2VzXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gQSBgY2xhc3MgRm9vOyBlbmRgIGV4cHJlc3Npb24gaW4gcnVieSBpcyBjb21waWxlZCB0byBjYWxsIHRoaXMgcnVudGltZVxuICAvLyBtZXRob2Qgd2hpY2ggZWl0aGVyIHJldHVybnMgYW4gZXhpc3RpbmcgY2xhc3Mgb2YgdGhlIGdpdmVuIG5hbWUsIG9yIGNyZWF0ZXNcbiAgLy8gYSBuZXcgY2xhc3MgaW4gdGhlIGdpdmVuIGBiYXNlYCBzY29wZS5cbiAgLy9cbiAgLy8gSWYgYSBjb25zdGFudCB3aXRoIHRoZSBnaXZlbiBuYW1lIGV4aXN0cywgdGhlbiB3ZSBjaGVjayB0byBtYWtlIHN1cmUgdGhhdFxuICAvLyBpdCBpcyBhIGNsYXNzIGFuZCBhbHNvIHRoYXQgdGhlIHN1cGVyY2xhc3NlcyBtYXRjaC4gSWYgZWl0aGVyIG9mIHRoZXNlXG4gIC8vIGZhaWwsIHRoZW4gd2UgcmFpc2UgYSBgVHlwZUVycm9yYC4gTm90ZSwgYHN1cGVyY2xhc3NgIG1heSBiZSBudWxsIGlmIG9uZVxuICAvLyB3YXMgbm90IHNwZWNpZmllZCBpbiB0aGUgcnVieSBjb2RlLlxuICAvL1xuICAvLyBXZSBwYXNzIGEgY29uc3RydWN0b3IgdG8gdGhpcyBtZXRob2Qgb2YgdGhlIGZvcm0gYGZ1bmN0aW9uIENsYXNzTmFtZSgpIHt9YFxuICAvLyBzaW1wbHkgc28gdGhhdCBjbGFzc2VzIHNob3cgdXAgd2l0aCBuaWNlbHkgZm9ybWF0dGVkIG5hbWVzIGluc2lkZSBkZWJ1Z2dlcnNcbiAgLy8gaW4gdGhlIHdlYiBicm93c2VyIChvciBub2RlL3Nwcm9ja2V0cykuXG4gIC8vXG4gIC8vIFRoZSBgc2NvcGVgIGlzIHRoZSBjdXJyZW50IGBzZWxmYCB2YWx1ZSB3aGVyZSB0aGUgY2xhc3MgaXMgYmVpbmcgY3JlYXRlZFxuICAvLyBmcm9tLiBXZSB1c2UgdGhpcyB0byBnZXQgdGhlIHNjb3BlIGZvciB3aGVyZSB0aGUgY2xhc3Mgc2hvdWxkIGJlIGNyZWF0ZWQuXG4gIC8vIElmIGBzY29wZWAgaXMgYW4gb2JqZWN0IChub3QgYSBjbGFzcy9tb2R1bGUpLCB3ZSBzaW1wbGUgZ2V0IGl0cyBjbGFzcyBhbmRcbiAgLy8gdXNlIHRoYXQgYXMgdGhlIHNjb3BlIGluc3RlYWQuXG4gIC8vXG4gIC8vIEBwYXJhbSBzY29wZSAgICAgICAgW09iamVjdF0gd2hlcmUgdGhlIGNsYXNzIGlzIGJlaW5nIGNyZWF0ZWRcbiAgLy8gQHBhcmFtIHN1cGVyY2xhc3MgICBbQ2xhc3MsbnVsbF0gc3VwZXJjbGFzcyBvZiB0aGUgbmV3IGNsYXNzIChtYXkgYmUgbnVsbClcbiAgLy8gQHBhcmFtIHNpbmdsZXRvbiAgICBbQm9vbGVhbixudWxsXSBhIHRydWUgdmFsdWUgZGVub3RlcyB3ZSB3YW50IHRvIGFsbG9jYXRlXG4gIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBzaW5nbGV0b25cbiAgLy9cbiAgLy8gQHJldHVybiBuZXcgW0NsYXNzXSAgb3IgZXhpc3RpbmcgcnVieSBjbGFzc1xuICAvL1xuICBmdW5jdGlvbiAkYWxsb2NhdGVfY2xhc3MobmFtZSwgc3VwZXJjbGFzcywgc2luZ2xldG9uKSB7XG4gICAgdmFyIGtsYXNzLCBicmlkZ2VkX2Rlc2NlbmRhbnQ7XG5cbiAgICBpZiAoYnJpZGdlZF9kZXNjZW5kYW50ID0gZGVzY2VuZHNfZnJvbV9icmlkZ2VkX2NsYXNzKHN1cGVyY2xhc3MpKSB7XG4gICAgICAvLyBJbmhlcml0YW5jZSBmcm9tIGJyaWRnZWQgY2xhc3NlcyByZXF1aXJlc1xuICAgICAgLy8gY2FsbGluZyBvcmlnaW5hbCBKUyBjb25zdHJ1Y3RvcnNcbiAgICAgIGtsYXNzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gbmV3ICgkYmluZC5hcHBseShicmlkZ2VkX2Rlc2NlbmRhbnQuJCRjb25zdHJ1Y3RvciwgJHByZXBlbmQobnVsbCwgYXJndW1lbnRzKSkpKCk7XG5cbiAgICAgICAgLy8gYW5kIHJlcGxhY2luZyBhIF9fcHJvdG9fXyBtYW51YWxseVxuICAgICAgICAkc2V0X3Byb3RvKHNlbGYsIGtsYXNzLiQkcHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGtsYXNzID0gZnVuY3Rpb24oKXt9O1xuICAgIH1cblxuICAgIGlmIChuYW1lICYmIG5hbWUgIT09IG5pbCkge1xuICAgICAgJHByb3Aoa2xhc3MsICdkaXNwbGF5TmFtZScsICc6OicrbmFtZSk7XG4gICAgfVxuXG4gICAgJHByb3Aoa2xhc3MsICckJG5hbWUnLCBuYW1lKTtcbiAgICAkcHJvcChrbGFzcywgJyQkY29uc3RydWN0b3InLCBrbGFzcyk7XG4gICAgJHByb3Aoa2xhc3MsICckJHByb3RvdHlwZScsIGtsYXNzLnByb3RvdHlwZSk7XG4gICAgJHByb3Aoa2xhc3MsICckJGNvbnN0Jywge30pO1xuICAgICRwcm9wKGtsYXNzLCAnJCRpc19jbGFzcycsIHRydWUpO1xuICAgICRwcm9wKGtsYXNzLCAnJCRpc19hX21vZHVsZScsIHRydWUpO1xuICAgICRwcm9wKGtsYXNzLCAnJCRzdXBlcicsIHN1cGVyY2xhc3MpO1xuICAgICRwcm9wKGtsYXNzLCAnJCRjdmFycycsIHt9KTtcbiAgICAkcHJvcChrbGFzcywgJyQkb3duX2luY2x1ZGVkX21vZHVsZXMnLCBbXSk7XG4gICAgJHByb3Aoa2xhc3MsICckJG93bl9wcmVwZW5kZWRfbW9kdWxlcycsIFtdKTtcbiAgICAkcHJvcChrbGFzcywgJyQkYW5jZXN0b3JzJywgW10pO1xuICAgICRwcm9wKGtsYXNzLCAnJCRhbmNlc3RvcnNfY2FjaGVfdmVyc2lvbicsIG51bGwpO1xuICAgICRwcm9wKGtsYXNzLCAnJCRzdWJjbGFzc2VzJywgW10pO1xuICAgICRwcm9wKGtsYXNzLCAnJCRjbG9uZWRfZnJvbScsIFtdKTtcblxuICAgICRwcm9wKGtsYXNzLiQkcHJvdG90eXBlLCAnJCRjbGFzcycsIGtsYXNzKTtcblxuICAgIC8vIEJ5IGRlZmF1bHQgaWYgdGhlcmUgYXJlIG5vIHNpbmdsZXRvbiBjbGFzcyBtZXRob2RzXG4gICAgLy8gX19wcm90b19fIGlzIENsYXNzLnByb3RvdHlwZVxuICAgIC8vIExhdGVyIHNpbmdsZXRvbiBtZXRob2RzIGdlbmVyYXRlIGEgc2luZ2xldG9uX2NsYXNzXG4gICAgLy8gYW5kIGluamVjdCBpdCBpbnRvIGFuY2VzdG9ycyBjaGFpblxuICAgIGlmIChPcGFsLkNsYXNzKSB7XG4gICAgICAkc2V0X3Byb3RvKGtsYXNzLCBPcGFsLkNsYXNzLnByb3RvdHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHN1cGVyY2xhc3MgIT0gbnVsbCkge1xuICAgICAgJHNldF9wcm90byhrbGFzcy4kJHByb3RvdHlwZSwgc3VwZXJjbGFzcy4kJHByb3RvdHlwZSk7XG5cbiAgICAgIGlmIChzaW5nbGV0b24gIT09IHRydWUpIHtcbiAgICAgICAgLy8gTGV0J3Mgbm90IGZvcmJpZCBHQyBmcm9tIGNsZWFuaW5nIHVwIG91clxuICAgICAgICAvLyBzdWJjbGFzc2VzLlxuICAgICAgICBpZiAodHlwZW9mIFdlYWtSZWYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gRmlyc3QsIGxldCdzIGNsZWFuIHVwIG91ciBhcnJheSBmcm9tIGVtcHR5IG9iamVjdHMuXG4gICAgICAgICAgdmFyIGksIHN1YmNsYXNzLCByZWJ1aWx0X3N1YmNsYXNzZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3VwZXJjbGFzcy4kJHN1YmNsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN1YmNsYXNzID0gc3VwZXJjbGFzcy4kJHN1YmNsYXNzZXNbaV07XG4gICAgICAgICAgICBpZiAoc3ViY2xhc3MuZGVyZWYoKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJlYnVpbHRfc3ViY2xhc3Nlcy5wdXNoKHN1YmNsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gTm93LCBsZXQncyBhZGQgb3VyIGNsYXNzLlxuICAgICAgICAgIHJlYnVpbHRfc3ViY2xhc3Nlcy5wdXNoKG5ldyBXZWFrUmVmKGtsYXNzKSk7XG4gICAgICAgICAgc3VwZXJjbGFzcy4kJHN1YmNsYXNzZXMgPSByZWJ1aWx0X3N1YmNsYXNzZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3VwZXJjbGFzcy4kJHN1YmNsYXNzZXMucHVzaChrbGFzcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN1cGVyY2xhc3MuJCRtZXRhKSB7XG4gICAgICAgIC8vIElmIHN1cGVyY2xhc3MgaGFzIG1ldGFjbGFzcyB0aGVuIHdlIGhhdmUgZXhwbGljaXRlbHkgaW5oZXJpdCBpdC5cbiAgICAgICAgT3BhbC5idWlsZF9jbGFzc19zaW5nbGV0b25fY2xhc3Moa2xhc3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBrbGFzcztcbiAgfTtcbiAgT3BhbC5hbGxvY2F0ZV9jbGFzcyA9ICRhbGxvY2F0ZV9jbGFzcztcblxuXG4gIGZ1bmN0aW9uIGZpbmRfZXhpc3RpbmdfY2xhc3Moc2NvcGUsIG5hbWUpIHtcbiAgICAvLyBUcnkgdG8gZmluZCB0aGUgY2xhc3MgaW4gdGhlIGN1cnJlbnQgc2NvcGVcbiAgICB2YXIga2xhc3MgPSBjb25zdF9nZXRfbmFtZShzY29wZSwgbmFtZSk7XG5cbiAgICAvLyBJZiB0aGUgY2xhc3MgZXhpc3RzIGluIHRoZSBzY29wZSwgdGhlbiB3ZSBtdXN0IHVzZSB0aGF0XG4gICAgaWYgKGtsYXNzKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIGV4aXN0aW5nIGNvbnN0YW50IGlzIGEgY2xhc3MsIG9yIHJhaXNlIGVycm9yXG4gICAgICBpZiAoIWtsYXNzLiQkaXNfY2xhc3MpIHtcbiAgICAgICAgJHJhaXNlKE9wYWwuVHlwZUVycm9yLCBuYW1lICsgXCIgaXMgbm90IGEgY2xhc3NcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBrbGFzcztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbnN1cmVTdXBlcmNsYXNzTWF0Y2goa2xhc3MsIHN1cGVyY2xhc3MpIHtcbiAgICBpZiAoa2xhc3MuJCRzdXBlciAhPT0gc3VwZXJjbGFzcykge1xuICAgICAgJHJhaXNlKE9wYWwuVHlwZUVycm9yLCBcInN1cGVyY2xhc3MgbWlzbWF0Y2ggZm9yIGNsYXNzIFwiICsga2xhc3MuJCRuYW1lKTtcbiAgICB9XG4gIH1cblxuICBPcGFsLmtsYXNzID0gZnVuY3Rpb24oc2NvcGUsIHN1cGVyY2xhc3MsIG5hbWUpIHtcbiAgICB2YXIgYnJpZGdlZDtcblxuICAgIGlmIChzY29wZSA9PSBudWxsIHx8IHNjb3BlID09ICc6OicpIHtcbiAgICAgIC8vIEdsb2JhbCBzY29wZVxuICAgICAgc2NvcGUgPSBfT2JqZWN0O1xuICAgIH0gZWxzZSBpZiAoIXNjb3BlLiQkaXNfY2xhc3MgJiYgIXNjb3BlLiQkaXNfbW9kdWxlKSB7XG4gICAgICAvLyBTY29wZSBpcyBhbiBvYmplY3QsIHVzZSBpdHMgY2xhc3NcbiAgICAgIHNjb3BlID0gc2NvcGUuJCRjbGFzcztcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgc3VwZXJjbGFzcyBpcyBub3QgYW4gT3BhbC1nZW5lcmF0ZWQgY2xhc3MgdGhlbiB3ZSdyZSBicmlkZ2luZyBhIG5hdGl2ZSBKUyBjbGFzc1xuICAgIGlmIChcbiAgICAgIHN1cGVyY2xhc3MgIT0gbnVsbCAmJiAoIXN1cGVyY2xhc3MuaGFzT3duUHJvcGVydHkgfHwgKFxuICAgICAgICBzdXBlcmNsYXNzLmhhc093blByb3BlcnR5ICYmICFzdXBlcmNsYXNzLmhhc093blByb3BlcnR5KCckJGlzX2NsYXNzJylcbiAgICAgICkpXG4gICAgKSB7XG4gICAgICBpZiAoc3VwZXJjbGFzcy5jb25zdHJ1Y3RvciAmJiBzdXBlcmNsYXNzLmNvbnN0cnVjdG9yLm5hbWUgPT0gXCJGdW5jdGlvblwiKSB7XG4gICAgICAgIGJyaWRnZWQgPSBzdXBlcmNsYXNzO1xuICAgICAgICBzdXBlcmNsYXNzID0gX09iamVjdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRyYWlzZShPcGFsLlR5cGVFcnJvciwgXCJzdXBlcmNsYXNzIG11c3QgYmUgYSBDbGFzcyAoXCIgKyAoXG4gICAgICAgICAgKHN1cGVyY2xhc3MuY29uc3RydWN0b3IgJiYgKHN1cGVyY2xhc3MuY29uc3RydWN0b3IubmFtZSB8fCBzdXBlcmNsYXNzLmNvbnN0cnVjdG9yLiQkbmFtZSkpIHx8XG4gICAgICAgICAgdHlwZW9mKHN1cGVyY2xhc3MpXG4gICAgICAgICkgKyBcIiBnaXZlbilcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGtsYXNzID0gZmluZF9leGlzdGluZ19jbGFzcyhzY29wZSwgbmFtZSk7XG5cbiAgICBpZiAoa2xhc3MgIT0gbnVsbCkge1xuICAgICAgaWYgKHN1cGVyY2xhc3MpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIGV4aXN0aW5nIGNsYXNzIGhhcyBzYW1lIHN1cGVyY2xhc3NcbiAgICAgICAgZW5zdXJlU3VwZXJjbGFzc01hdGNoKGtsYXNzLCBzdXBlcmNsYXNzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBDbGFzcyBkb2Vzbid0IGV4aXN0LCBjcmVhdGUgYSBuZXcgb25lIHdpdGggZ2l2ZW4gc3VwZXJjbGFzcy4uLlxuXG4gICAgICAvLyBOb3Qgc3BlY2lmeWluZyBhIHN1cGVyY2xhc3MgbWVhbnMgd2UgY2FuIGFzc3VtZSBpdCB0byBiZSBPYmplY3RcbiAgICAgIGlmIChzdXBlcmNsYXNzID09IG51bGwpIHtcbiAgICAgICAgc3VwZXJjbGFzcyA9IF9PYmplY3Q7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSB0aGUgY2xhc3Mgb2JqZWN0IChpbnN0YW5jZSBvZiBDbGFzcylcbiAgICAgIGtsYXNzID0gJGFsbG9jYXRlX2NsYXNzKG5hbWUsIHN1cGVyY2xhc3MpO1xuICAgICAgJGNvbnN0X3NldChzY29wZSwgbmFtZSwga2xhc3MpO1xuXG4gICAgICAvLyBDYWxsIC5pbmhlcml0ZWQoKSBob29rIHdpdGggbmV3IGNsYXNzIG9uIHRoZSBzdXBlcmNsYXNzXG4gICAgICBpZiAoc3VwZXJjbGFzcy4kaW5oZXJpdGVkKSB7XG4gICAgICAgIHN1cGVyY2xhc3MuJGluaGVyaXRlZChrbGFzcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChicmlkZ2VkKSB7XG4gICAgICAgIE9wYWwuYnJpZGdlKGJyaWRnZWQsIGtsYXNzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoT3BhbC50cmFjZV9jbGFzcykgeyBpbnZva2VfdHJhY2Vyc19mb3JfY2xhc3Moa2xhc3MpOyB9XG5cbiAgICByZXR1cm4ga2xhc3M7XG4gIH07XG5cbiAgLy8gRGVmaW5lIG5ldyBtb2R1bGUgKG9yIHJldHVybiBleGlzdGluZyBtb2R1bGUpLiBUaGUgZ2l2ZW4gYHNjb3BlYCBpcyBiYXNpY2FsbHlcbiAgLy8gdGhlIGN1cnJlbnQgYHNlbGZgIHZhbHVlIHRoZSBgbW9kdWxlYCBzdGF0ZW1lbnQgd2FzIGRlZmluZWQgaW4uIElmIHRoaXMgaXNcbiAgLy8gYSBydWJ5IG1vZHVsZSBvciBjbGFzcywgdGhlbiBpdCBpcyB1c2VkLCBvdGhlcndpc2UgaWYgdGhlIHNjb3BlIGlzIGEgcnVieVxuICAvLyBvYmplY3QgdGhlbiB0aGF0IG9iamVjdHMgcmVhbCBydWJ5IGNsYXNzIGlzIHVzZWQgKGUuZy4gaWYgdGhlIHNjb3BlIGlzIHRoZVxuICAvLyBtYWluIG9iamVjdCwgdGhlbiB0aGUgdG9wIGxldmVsIGBPYmplY3RgIGNsYXNzIGlzIHVzZWQgYXMgdGhlIHNjb3BlKS5cbiAgLy9cbiAgLy8gSWYgYSBtb2R1bGUgb2YgdGhlIGdpdmVuIG5hbWUgaXMgYWxyZWFkeSBkZWZpbmVkIGluIHRoZSBzY29wZSwgdGhlbiB0aGF0XG4gIC8vIGluc3RhbmNlIGlzIGp1c3QgcmV0dXJuZWQuXG4gIC8vXG4gIC8vIElmIHRoZXJlIGlzIGEgY2xhc3Mgb2YgdGhlIGdpdmVuIG5hbWUgaW4gdGhlIHNjb3BlLCB0aGVuIGFuIGVycm9yIGlzXG4gIC8vIGdlbmVyYXRlZCBpbnN0ZWFkIChjYW5ub3QgaGF2ZSBhIGNsYXNzIGFuZCBtb2R1bGUgb2Ygc2FtZSBuYW1lIGluIHNhbWUgc2NvcGUpLlxuICAvL1xuICAvLyBPdGhlcndpc2UsIGEgbmV3IG1vZHVsZSBpcyBjcmVhdGVkIGluIHRoZSBzY29wZSB3aXRoIHRoZSBnaXZlbiBuYW1lLCBhbmQgdGhhdFxuICAvLyBuZXcgaW5zdGFuY2UgaXMgcmV0dXJuZWQgYmFjayAodG8gYmUgcmVmZXJlbmNlZCBhdCBydW50aW1lKS5cbiAgLy9cbiAgLy8gQHBhcmFtICBzY29wZSBbTW9kdWxlLCBDbGFzc10gY2xhc3Mgb3IgbW9kdWxlIHRoaXMgZGVmaW5pdGlvbiBpcyBpbnNpZGVcbiAgLy8gQHBhcmFtICBpZCAgIFtTdHJpbmddIHRoZSBuYW1lIG9mIHRoZSBuZXcgKG9yIGV4aXN0aW5nKSBtb2R1bGVcbiAgLy9cbiAgLy8gQHJldHVybiBbTW9kdWxlXVxuICBmdW5jdGlvbiAkYWxsb2NhdGVfbW9kdWxlKG5hbWUpIHtcbiAgICB2YXIgY29uc3RydWN0b3IgPSBmdW5jdGlvbigpe307XG4gICAgdmFyIG1vZHVsZSA9IGNvbnN0cnVjdG9yO1xuXG4gICAgaWYgKG5hbWUpXG4gICAgICAkcHJvcChjb25zdHJ1Y3RvciwgJ2Rpc3BsYXlOYW1lJywgbmFtZSsnLmNvbnN0cnVjdG9yJyk7XG5cbiAgICAkcHJvcChtb2R1bGUsICckJG5hbWUnLCBuYW1lKTtcbiAgICAkcHJvcChtb2R1bGUsICckJHByb3RvdHlwZScsIGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgJHByb3AobW9kdWxlLCAnJCRjb25zdCcsIHt9KTtcbiAgICAkcHJvcChtb2R1bGUsICckJGlzX21vZHVsZScsIHRydWUpO1xuICAgICRwcm9wKG1vZHVsZSwgJyQkaXNfYV9tb2R1bGUnLCB0cnVlKTtcbiAgICAkcHJvcChtb2R1bGUsICckJGN2YXJzJywge30pO1xuICAgICRwcm9wKG1vZHVsZSwgJyQkaWNsYXNzZXMnLCBbXSk7XG4gICAgJHByb3AobW9kdWxlLCAnJCRvd25faW5jbHVkZWRfbW9kdWxlcycsIFtdKTtcbiAgICAkcHJvcChtb2R1bGUsICckJG93bl9wcmVwZW5kZWRfbW9kdWxlcycsIFtdKTtcbiAgICAkcHJvcChtb2R1bGUsICckJGFuY2VzdG9ycycsIFttb2R1bGVdKTtcbiAgICAkcHJvcChtb2R1bGUsICckJGFuY2VzdG9yc19jYWNoZV92ZXJzaW9uJywgbnVsbCk7XG4gICAgJHByb3AobW9kdWxlLCAnJCRjbG9uZWRfZnJvbScsIFtdKTtcblxuICAgICRzZXRfcHJvdG8obW9kdWxlLCBPcGFsLk1vZHVsZS5wcm90b3R5cGUpO1xuXG4gICAgcmV0dXJuIG1vZHVsZTtcbiAgfTtcbiAgT3BhbC5hbGxvY2F0ZV9tb2R1bGUgPSAkYWxsb2NhdGVfbW9kdWxlO1xuXG4gIGZ1bmN0aW9uIGZpbmRfZXhpc3RpbmdfbW9kdWxlKHNjb3BlLCBuYW1lKSB7XG4gICAgdmFyIG1vZHVsZSA9IGNvbnN0X2dldF9uYW1lKHNjb3BlLCBuYW1lKTtcbiAgICBpZiAobW9kdWxlID09IG51bGwgJiYgc2NvcGUgPT09IF9PYmplY3QpIG1vZHVsZSA9IGNvbnN0X2xvb2t1cF9hbmNlc3RvcnMoX09iamVjdCwgbmFtZSk7XG5cbiAgICBpZiAobW9kdWxlKSB7XG4gICAgICBpZiAoIW1vZHVsZS4kJGlzX21vZHVsZSAmJiBtb2R1bGUgIT09IF9PYmplY3QpIHtcbiAgICAgICAgJHJhaXNlKE9wYWwuVHlwZUVycm9yLCBuYW1lICsgXCIgaXMgbm90IGEgbW9kdWxlXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtb2R1bGU7XG4gIH1cblxuICBPcGFsLm1vZHVsZSA9IGZ1bmN0aW9uKHNjb3BlLCBuYW1lKSB7XG4gICAgdmFyIG1vZHVsZTtcblxuICAgIGlmIChzY29wZSA9PSBudWxsIHx8IHNjb3BlID09ICc6OicpIHtcbiAgICAgIC8vIEdsb2JhbCBzY29wZVxuICAgICAgc2NvcGUgPSBfT2JqZWN0O1xuICAgIH0gZWxzZSBpZiAoIXNjb3BlLiQkaXNfY2xhc3MgJiYgIXNjb3BlLiQkaXNfbW9kdWxlKSB7XG4gICAgICAvLyBTY29wZSBpcyBhbiBvYmplY3QsIHVzZSBpdHMgY2xhc3NcbiAgICAgIHNjb3BlID0gc2NvcGUuJCRjbGFzcztcbiAgICB9XG5cbiAgICBtb2R1bGUgPSBmaW5kX2V4aXN0aW5nX21vZHVsZShzY29wZSwgbmFtZSk7XG5cbiAgICBpZiAobW9kdWxlID09IG51bGwpIHtcbiAgICAgIC8vIE1vZHVsZSBkb2VzbnQgZXhpc3QsIGNyZWF0ZSBhIG5ldyBvbmUuLi5cbiAgICAgIG1vZHVsZSA9ICRhbGxvY2F0ZV9tb2R1bGUobmFtZSk7XG4gICAgICAkY29uc3Rfc2V0KHNjb3BlLCBuYW1lLCBtb2R1bGUpO1xuICAgIH1cblxuICAgIGlmIChPcGFsLnRyYWNlX2NsYXNzKSB7IGludm9rZV90cmFjZXJzX2Zvcl9jbGFzcyhtb2R1bGUpOyB9XG5cbiAgICByZXR1cm4gbW9kdWxlO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgc2luZ2xldG9uIGNsYXNzIGZvciB0aGUgcGFzc2VkIG9iamVjdC5cbiAgLy9cbiAgLy8gSWYgdGhlIGdpdmVuIG9iamVjdCBhbHJlZHkgaGFzIGEgc2luZ2xldG9uIGNsYXNzLCB0aGVuIGl0IHdpbGwgYmUgc3RvcmVkIG9uXG4gIC8vIHRoZSBvYmplY3QgYXMgdGhlIGAkJG1ldGFgIHByb3BlcnR5LiBJZiB0aGlzIGV4aXN0cywgdGhlbiBpdCBpcyBzaW1wbHlcbiAgLy8gcmV0dXJuZWQgYmFjay5cbiAgLy9cbiAgLy8gT3RoZXJ3aXNlLCBhIG5ldyBzaW5nbGV0b24gb2JqZWN0IGZvciB0aGUgY2xhc3Mgb3Igb2JqZWN0IGlzIGNyZWF0ZWQsIHNldCBvblxuICAvLyB0aGUgb2JqZWN0IGF0IGAkJG1ldGFgIGZvciBmdXR1cmUgdXNlLCBhbmQgdGhlbiByZXR1cm5lZC5cbiAgLy9cbiAgLy8gQHBhcmFtIG9iamVjdCBbT2JqZWN0XSB0aGUgcnVieSBvYmplY3RcbiAgLy8gQHJldHVybiBbQ2xhc3NdIHRoZSBzaW5nbGV0b24gY2xhc3MgZm9yIG9iamVjdFxuICBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3MgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0LiQkaXNfbnVtYmVyKSB7XG4gICAgICAkcmFpc2UoT3BhbC5UeXBlRXJyb3IsIFwiY2FuJ3QgZGVmaW5lIHNpbmdsZXRvblwiKTtcbiAgICB9XG4gICAgaWYgKG9iamVjdC4kJG1ldGEpIHtcbiAgICAgIHJldHVybiBvYmplY3QuJCRtZXRhO1xuICAgIH1cblxuICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoJyQkaXNfY2xhc3MnKSkge1xuICAgICAgcmV0dXJuIE9wYWwuYnVpbGRfY2xhc3Nfc2luZ2xldG9uX2NsYXNzKG9iamVjdCk7XG4gICAgfSBlbHNlIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoJyQkaXNfbW9kdWxlJykpIHtcbiAgICAgIHJldHVybiBPcGFsLmJ1aWxkX21vZHVsZV9zaW5nbGV0b25fY2xhc3Mob2JqZWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE9wYWwuYnVpbGRfb2JqZWN0X3NpbmdsZXRvbl9jbGFzcyhvYmplY3QpO1xuICAgIH1cbiAgfTtcblxuICAvLyBoZWxwZXIgdG8gc2V0ICQkbWV0YSBvbiBrbGFzcywgbW9kdWxlIG9yIGluc3RhbmNlXG4gIGZ1bmN0aW9uIHNldF9tZXRhKG9iaiwgbWV0YSkge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoJyQkbWV0YScpKSB7XG4gICAgICBvYmouJCRtZXRhID0gbWV0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgJHByb3Aob2JqLCAnJCRtZXRhJywgbWV0YSk7XG4gICAgfVxuICAgIGlmIChvYmouJCRmcm96ZW4pIHtcbiAgICAgIC8vIElmIGEgb2JqZWN0IGlzIGZyb3plbiAoc2VhbGVkKSwgZnJlZXplICQkbWV0YSB0b28uXG4gICAgICAvLyBObyBuZWVkIHRvIGluamVjdCAkJG1ldGEuJCRwcm90b3R5cGUgaW4gdGhlIHByb3RvdHlwZSBjaGFpbixcbiAgICAgIC8vIGFzICQkbWV0YSBjYW5ub3QgYmUgbW9kaWZpZWQgYW55d2F5LlxuICAgICAgb2JqLiQkbWV0YS4kZnJlZXplKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRzZXRfcHJvdG8ob2JqLCBtZXRhLiQkcHJvdG90eXBlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQnVpbGQgdGhlIHNpbmdsZXRvbiBjbGFzcyBmb3IgYW4gZXhpc3RpbmcgY2xhc3MuIENsYXNzIG9iamVjdCBhcmUgYnVpbHRcbiAgLy8gd2l0aCB0aGVpciBzaW5nbGV0b24gY2xhc3MgYWxyZWFkeSBpbiB0aGUgcHJvdG90eXBlIGNoYWluIGFuZCBpbmhlcml0aW5nXG4gIC8vIGZyb20gdGhlaXIgc3VwZXJjbGFzcyBvYmplY3QgKHVwIHRvIGBDbGFzc2AgaXRzZWxmKS5cbiAgLy9cbiAgLy8gTk9URTogQWN0dWFsbHkgaW4gTVJJIGEgY2xhc3MnIHNpbmdsZXRvbiBjbGFzcyBpbmhlcml0cyBmcm9tIGl0c1xuICAvLyBzdXBlcmNsYXNzJyBzaW5nbGV0b24gY2xhc3Mgd2hpY2ggaW4gdHVybiBpbmhlcml0cyBmcm9tIENsYXNzLlxuICAvL1xuICAvLyBAcGFyYW0ga2xhc3MgW0NsYXNzXVxuICAvLyBAcmV0dXJuIFtDbGFzc11cbiAgT3BhbC5idWlsZF9jbGFzc19zaW5nbGV0b25fY2xhc3MgPSBmdW5jdGlvbihrbGFzcykge1xuICAgIGlmIChrbGFzcy4kJG1ldGEpIHtcbiAgICAgIHJldHVybiBrbGFzcy4kJG1ldGE7XG4gICAgfVxuXG4gICAgLy8gVGhlIHNpbmdsZXRvbl9jbGFzcyBzdXBlcmNsYXNzIGlzIHRoZSBzaW5nbGV0b25fY2xhc3Mgb2YgaXRzIHN1cGVyY2xhc3M7XG4gICAgLy8gYnV0IEJhc2ljT2JqZWN0IGhhcyBubyBzdXBlcmNsYXNzIChpdHMgYCQkc3VwZXJgIGlzIG51bGwpLCB0aHVzIHdlXG4gICAgLy8gZmFsbGJhY2sgb24gYENsYXNzYC5cbiAgICB2YXIgc3VwZXJjbGFzcyA9IGtsYXNzID09PSBCYXNpY09iamVjdCA/IENsYXNzIDogT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzKGtsYXNzLiQkc3VwZXIpO1xuXG4gICAgdmFyIG1ldGEgPSAkYWxsb2NhdGVfY2xhc3MobnVsbCwgc3VwZXJjbGFzcywgdHJ1ZSk7XG5cbiAgICAkcHJvcChtZXRhLCAnJCRpc19zaW5nbGV0b24nLCB0cnVlKTtcbiAgICAkcHJvcChtZXRhLCAnJCRzaW5nbGV0b25fb2YnLCBrbGFzcyk7XG4gICAgc2V0X21ldGEoa2xhc3MsIG1ldGEpO1xuICAgIC8vIFJlc3RvcmluZyBDbGFzc05hbWUuY2xhc3NcbiAgICAkcHJvcChrbGFzcywgJyQkY2xhc3MnLCBPcGFsLkNsYXNzKTtcblxuICAgIHJldHVybiBtZXRhO1xuICB9O1xuXG4gIE9wYWwuYnVpbGRfbW9kdWxlX3NpbmdsZXRvbl9jbGFzcyA9IGZ1bmN0aW9uKG1vZCkge1xuICAgIGlmIChtb2QuJCRtZXRhKSB7XG4gICAgICByZXR1cm4gbW9kLiQkbWV0YTtcbiAgICB9XG5cbiAgICB2YXIgbWV0YSA9ICRhbGxvY2F0ZV9jbGFzcyhudWxsLCBPcGFsLk1vZHVsZSwgdHJ1ZSk7XG5cbiAgICAkcHJvcChtZXRhLCAnJCRpc19zaW5nbGV0b24nLCB0cnVlKTtcbiAgICAkcHJvcChtZXRhLCAnJCRzaW5nbGV0b25fb2YnLCBtb2QpO1xuICAgIHNldF9tZXRhKG1vZCwgbWV0YSk7XG4gICAgLy8gUmVzdG9yaW5nIE1vZHVsZU5hbWUuY2xhc3NcbiAgICAkcHJvcChtb2QsICckJGNsYXNzJywgT3BhbC5Nb2R1bGUpO1xuXG4gICAgcmV0dXJuIG1ldGE7XG4gIH07XG5cbiAgLy8gQnVpbGQgdGhlIHNpbmdsZXRvbiBjbGFzcyBmb3IgYSBSdWJ5IChub24gY2xhc3MpIE9iamVjdC5cbiAgLy9cbiAgLy8gQHBhcmFtIG9iamVjdCBbT2JqZWN0XVxuICAvLyBAcmV0dXJuIFtDbGFzc11cbiAgT3BhbC5idWlsZF9vYmplY3Rfc2luZ2xldG9uX2NsYXNzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIHN1cGVyY2xhc3MgPSBvYmplY3QuJCRjbGFzcyxcbiAgICAgICAga2xhc3MgPSAkYWxsb2NhdGVfY2xhc3MobmlsLCBzdXBlcmNsYXNzLCB0cnVlKTtcblxuICAgICRwcm9wKGtsYXNzLCAnJCRpc19zaW5nbGV0b24nLCB0cnVlKTtcbiAgICAkcHJvcChrbGFzcywgJyQkc2luZ2xldG9uX29mJywgb2JqZWN0KTtcblxuICAgIGRlbGV0ZSBrbGFzcy4kJHByb3RvdHlwZS4kJGNsYXNzO1xuXG4gICAgc2V0X21ldGEob2JqZWN0LCBrbGFzcyk7XG5cbiAgICByZXR1cm4ga2xhc3M7XG4gIH07XG5cbiAgT3BhbC5pc19tZXRob2QgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgcmV0dXJuIChwcm9wWzBdID09PSAnJCcgJiYgcHJvcFsxXSAhPT0gJyQnKTtcbiAgfTtcblxuICBPcGFsLmluc3RhbmNlX21ldGhvZHMgPSBmdW5jdGlvbihtb2QpIHtcbiAgICB2YXIgcHJvY2Vzc2VkID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgcmVzdWx0cyA9IFtdLCBhbmNlc3RvcnMgPSAkYW5jZXN0b3JzKG1vZCk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFuY2VzdG9ycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IGFuY2VzdG9yc1tpXSxcbiAgICAgICAgICBwcm90byA9IGFuY2VzdG9yLiQkcHJvdG90eXBlO1xuXG4gICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKTtcblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGxsID0gcHJvcHMubGVuZ3RoOyBqIDwgbGw7IGorKykge1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2pdO1xuXG4gICAgICAgIGlmIChwcm9jZXNzZWRbcHJvcF0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoT3BhbC5pc19tZXRob2QocHJvcCkpIHtcbiAgICAgICAgICB2YXIgbWV0aG9kID0gcHJvdG9bcHJvcF07XG5cbiAgICAgICAgICBpZiAoIW1ldGhvZC4kJHN0dWIpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2RfbmFtZSA9IHByb3Auc2xpY2UoMSk7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gobWV0aG9kX25hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzZWRbcHJvcF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMgPSBmdW5jdGlvbihtb2QpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdLFxuICAgICAgICBwcm90byA9IG1vZC4kJHByb3RvdHlwZTtcblxuICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgfVxuXG4gICAgdmFyIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHByb3BzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuXG4gICAgICBpZiAoT3BhbC5pc19tZXRob2QocHJvcCkpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IHByb3RvW3Byb3BdO1xuXG4gICAgICAgIGlmICghbWV0aG9kLiQkc3R1Yikge1xuICAgICAgICAgIHZhciBtZXRob2RfbmFtZSA9IHByb3Auc2xpY2UoMSk7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKG1ldGhvZF9uYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIE9wYWwubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBPcGFsLmluc3RhbmNlX21ldGhvZHMob2JqLiQkbWV0YSB8fCBvYmouJCRjbGFzcyk7XG4gIH07XG5cbiAgT3BhbC5vd25fbWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmouJCRtZXRhID8gT3BhbC5vd25faW5zdGFuY2VfbWV0aG9kcyhvYmouJCRtZXRhKSA6IFtdO1xuICB9O1xuXG4gIE9wYWwucmVjZWl2ZXJfbWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBtb2QgPSBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob2JqKTtcbiAgICB2YXIgc2luZ2xldG9uX21ldGhvZHMgPSBPcGFsLm93bl9pbnN0YW5jZV9tZXRob2RzKG1vZCk7XG4gICAgdmFyIGluc3RhbmNlX21ldGhvZHMgPSBPcGFsLm93bl9pbnN0YW5jZV9tZXRob2RzKG1vZC4kJHN1cGVyKTtcbiAgICByZXR1cm4gc2luZ2xldG9uX21ldGhvZHMuY29uY2F0KGluc3RhbmNlX21ldGhvZHMpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHBhaXJzIG9mIG5hbWVzL3ZhbHVlc1xuICAvLyBmb3IgYWxsIGNsYXNzIHZhcmlhYmxlcyBkZWZpbmVkIGluIHByb3ZpZGVkICttb2R1bGUrXG4gIC8vIGFuZCBpdHMgYW5jZXN0b3JzLlxuICAvL1xuICAvLyBAcGFyYW0gbW9kdWxlIFtNb2R1bGVdXG4gIC8vIEByZXR1cm4gW09iamVjdF1cbiAgT3BhbC5jbGFzc192YXJpYWJsZXMgPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICB2YXIgYW5jZXN0b3JzID0gJGFuY2VzdG9ycyhtb2R1bGUpLFxuICAgICAgICBpLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgIGZvciAoaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBhbmNlc3RvcnNbaV07XG5cbiAgICAgIGZvciAodmFyIGN2YXIgaW4gYW5jZXN0b3IuJCRjdmFycykge1xuICAgICAgICByZXN1bHRbY3Zhcl0gPSBhbmNlc3Rvci4kJGN2YXJzW2N2YXJdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2V0cyBjbGFzcyB2YXJpYWJsZSB3aXRoIHNwZWNpZmllZCArbmFtZSsgdG8gK3ZhbHVlK1xuICAvLyBpbiBwcm92aWRlZCArbW9kdWxlK1xuICAvL1xuICAvLyBAcGFyYW0gbW9kdWxlIFtNb2R1bGVdXG4gIC8vIEBwYXJhbSBuYW1lIFtTdHJpbmddXG4gIC8vIEBwYXJhbSB2YWx1ZSBbT2JqZWN0XVxuICBPcGFsLmNsYXNzX3ZhcmlhYmxlX3NldCA9IGZ1bmN0aW9uKG1vZHVsZSwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgYW5jZXN0b3JzID0gJGFuY2VzdG9ycyhtb2R1bGUpLFxuICAgICAgICBpLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoIC0gMjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IGFuY2VzdG9yc1tpXTtcblxuICAgICAgaWYgKCRoYXNfb3duKGFuY2VzdG9yLiQkY3ZhcnMsIG5hbWUpKSB7XG4gICAgICAgIGFuY2VzdG9yLiQkY3ZhcnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS4kJGN2YXJzW25hbWVdID0gdmFsdWU7XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gR2V0cyBjbGFzcyB2YXJpYWJsZSB3aXRoIHNwZWNpZmllZCArbmFtZSsgZnJvbSBwcm92aWRlZCArbW9kdWxlK1xuICAvL1xuICAvLyBAcGFyYW0gbW9kdWxlIFtNb2R1bGVdXG4gIC8vIEBwYXJhbSBuYW1lIFtTdHJpbmddXG4gIE9wYWwuY2xhc3NfdmFyaWFibGVfZ2V0ID0gZnVuY3Rpb24obW9kdWxlLCBuYW1lLCB0b2xlcmFudCkge1xuICAgIGlmICgkaGFzX293bihtb2R1bGUuJCRjdmFycywgbmFtZSkpXG4gICAgICByZXR1cm4gbW9kdWxlLiQkY3ZhcnNbbmFtZV07XG5cbiAgICB2YXIgYW5jZXN0b3JzID0gJGFuY2VzdG9ycyhtb2R1bGUpLFxuICAgICAgaSwgbGVuZ3RoID0gYW5jZXN0b3JzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFuY2VzdG9yID0gYW5jZXN0b3JzW2ldO1xuXG4gICAgICBpZiAoJGhhc19vd24oYW5jZXN0b3IuJCRjdmFycywgbmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9yLiQkY3ZhcnNbbmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0b2xlcmFudClcbiAgICAgICRyYWlzZShPcGFsLk5hbWVFcnJvciwgJ3VuaW5pdGlhbGl6ZWQgY2xhc3MgdmFyaWFibGUgJytuYW1lKycgaW4gJyttb2R1bGUuJG5hbWUoKSk7XG5cbiAgICByZXR1cm4gbmlsO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNSb290KHByb3RvKSB7XG4gICAgcmV0dXJuIHByb3RvLmhhc093blByb3BlcnR5KCckJGljbGFzcycpICYmIHByb3RvLmhhc093blByb3BlcnR5KCckJHJvb3QnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG93bl9pbmNsdWRlZF9tb2R1bGVzKG1vZHVsZSkge1xuICAgIHZhciByZXN1bHQgPSBbXSwgbW9kLCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihtb2R1bGUuJCRwcm90b3R5cGUpO1xuXG4gICAgd2hpbGUgKHByb3RvKSB7XG4gICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkY2xhc3MnKSkge1xuICAgICAgICAvLyBzdXBlcmNsYXNzXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbW9kID0gcHJvdG9Ub01vZHVsZShwcm90byk7XG4gICAgICBpZiAobW9kKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1vZCk7XG4gICAgICB9XG4gICAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG93bl9wcmVwZW5kZWRfbW9kdWxlcyhtb2R1bGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gW10sIG1vZCwgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobW9kdWxlLiQkcHJvdG90eXBlKTtcblxuICAgIGlmIChtb2R1bGUuJCRwcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgd2hpbGUgKHByb3RvKSB7XG4gICAgICAgIGlmIChwcm90byA9PT0gbW9kdWxlLiQkcHJvdG90eXBlLiQkZGVmaW5lX21ldGhvZHNfb24pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIG1vZCA9IHByb3RvVG9Nb2R1bGUocHJvdG8pO1xuICAgICAgICBpZiAobW9kKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2gobW9kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cblxuICAvLyBUaGUgYWN0dWFsIGluY2x1c2lvbiBvZiBhIG1vZHVsZSBpbnRvIGEgY2xhc3MuXG4gIC8vXG4gIC8vICMjIENsYXNzIGAkJHBhcmVudGAgYW5kIGBpY2xhc3NgXG4gIC8vXG4gIC8vIFRvIGhhbmRsZSBgc3VwZXJgIGNhbGxzLCBldmVyeSBjbGFzcyBoYXMgYSBgJCRwYXJlbnRgLiBUaGlzIHBhcmVudCBpc1xuICAvLyB1c2VkIHRvIHJlc29sdmUgdGhlIG5leHQgY2xhc3MgZm9yIGEgc3VwZXIgY2FsbC4gQSBub3JtYWwgY2xhc3Mgd291bGRcbiAgLy8gaGF2ZSB0aGlzIHBvaW50IHRvIGl0cyBzdXBlcmNsYXNzLiBIb3dldmVyLCBpZiBhIGNsYXNzIGluY2x1ZGVzIGEgbW9kdWxlXG4gIC8vIHRoZW4gdGhpcyB3b3VsZCBuZWVkIHRvIHRha2UgaW50byBhY2NvdW50IHRoZSBtb2R1bGUuIFRoZSBtb2R1bGUgd291bGRcbiAgLy8gYWxzbyBoYXZlIHRvIHRoZW4gcG9pbnQgaXRzIGAkJHBhcmVudGAgdG8gdGhlIGFjdHVhbCBzdXBlcmNsYXNzLiBXZVxuICAvLyBjYW5ub3QgbW9kaWZ5IG1vZHVsZXMgbGlrZSB0aGlzLCBiZWNhdXNlIGl0IG1pZ2h0IGJlIGluY2x1ZGVkIGluIG1vcmVcbiAgLy8gdGhlbiBvbmUgY2xhc3MuIFRvIGZpeCB0aGlzLCB3ZSBhY3R1YWxseSBpbnNlcnQgYW4gYGljbGFzc2AgYXMgdGhlIGNsYXNzJ1xuICAvLyBgJCRwYXJlbnRgIHdoaWNoIGNhbiB0aGVuIHBvaW50IHRvIHRoZSBzdXBlcmNsYXNzLiBUaGUgYGljbGFzc2AgYWN0cyBhc1xuICAvLyBhIHByb3h5IHRvIHRoZSBhY3R1YWwgbW9kdWxlLCBzbyB0aGUgYHN1cGVyYCBjaGFpbiBjYW4gdGhlbiBzZWFyY2ggaXQgZm9yXG4gIC8vIHRoZSByZXF1aXJlZCBtZXRob2QuXG4gIC8vXG4gIC8vIEBwYXJhbSBtb2R1bGUgW01vZHVsZV0gdGhlIG1vZHVsZSB0byBpbmNsdWRlXG4gIC8vIEBwYXJhbSBpbmNsdWRlciBbTW9kdWxlXSB0aGUgdGFyZ2V0IGNsYXNzIHRvIGluY2x1ZGUgbW9kdWxlIGludG9cbiAgLy8gQHJldHVybiBbbnVsbF1cbiAgT3BhbC5hcHBlbmRfZmVhdHVyZXMgPSBmdW5jdGlvbihtb2R1bGUsIGluY2x1ZGVyKSB7XG4gICAgdmFyIG1vZHVsZV9hbmNlc3RvcnMgPSAkYW5jZXN0b3JzKG1vZHVsZSk7XG4gICAgdmFyIGljbGFzc2VzID0gW107XG5cbiAgICBpZiAobW9kdWxlX2FuY2VzdG9ycy5pbmRleE9mKGluY2x1ZGVyKSAhPT0gLTEpIHtcbiAgICAgICRyYWlzZShPcGFsLkFyZ3VtZW50RXJyb3IsICdjeWNsaWMgaW5jbHVkZSBkZXRlY3RlZCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBtb2R1bGVfYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBtb2R1bGVfYW5jZXN0b3JzW2ldLCBpY2xhc3MgPSBjcmVhdGVfaWNsYXNzKGFuY2VzdG9yKTtcbiAgICAgICRwcm9wKGljbGFzcywgJyQkaW5jbHVkZWQnLCB0cnVlKTtcbiAgICAgIGljbGFzc2VzLnB1c2goaWNsYXNzKTtcbiAgICB9XG4gICAgdmFyIGluY2x1ZGVyX2FuY2VzdG9ycyA9ICRhbmNlc3RvcnMoaW5jbHVkZXIpLFxuICAgICAgICBjaGFpbiA9IGNoYWluX2ljbGFzc2VzKGljbGFzc2VzKSxcbiAgICAgICAgc3RhcnRfY2hhaW5fYWZ0ZXIsXG4gICAgICAgIGVuZF9jaGFpbl9vbjtcblxuICAgIGlmIChpbmNsdWRlcl9hbmNlc3RvcnMuaW5kZXhPZihtb2R1bGUpID09PSAtMSkge1xuICAgICAgLy8gZmlyc3QgdGltZSBpbmNsdWRlXG5cbiAgICAgIC8vIGluY2x1ZGVyIC0+IGNoYWluLmZpcnN0IC0+IC4uLmNoYWluLi4uIC0+IGNoYWluLmxhc3QgLT4gaW5jbHVkZXIucGFyZW50XG4gICAgICBzdGFydF9jaGFpbl9hZnRlciA9IGluY2x1ZGVyLiQkcHJvdG90eXBlO1xuICAgICAgZW5kX2NoYWluX29uID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGluY2x1ZGVyLiQkcHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIG1vZHVsZSBoYXMgYmVlbiBhbHJlYWR5IGluY2x1ZGVkLFxuICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0byBwdXQgaXQgaW50byB0aGUgYW5jZXN0b3JzIGNoYWluIGFnYWluLFxuICAgICAgLy8gYnV0IHRoaXMgbW9kdWxlIG1heSBoYXZlIG5ldyBpbmNsdWRlZCBtb2R1bGVzLlxuICAgICAgLy8gSWYgaXQncyB0cnVlIHdlIG5lZWQgdG8gY29weSB0aGVtLlxuICAgICAgLy9cbiAgICAgIC8vIFRoZSBzaW1wbGVzdCB3YXkgaXMgdG8gcmVwbGFjZSBhbmNlc3RvcnMgY2hhaW4gZnJvbVxuICAgICAgLy8gICAgICAgICAgcGFyZW50XG4gICAgICAvLyAgICAgICAgICAgIHxcbiAgICAgIC8vICAgYG1vZHVsZWAgaWNsYXNzIChoYXMgYSAkJHJvb3QgZmxhZylcbiAgICAgIC8vICAgICAgICAgICAgfFxuICAgICAgLy8gICAuLi5wcmV2aW9zIGNoYWluIG9mIG1vZHVsZS5pbmNsdWRlZF9tb2R1bGVzIC4uLlxuICAgICAgLy8gICAgICAgICAgICB8XG4gICAgICAvLyAgXCJuZXh0IGFuY2VzdG9yXCIgKGhhcyBhICQkcm9vdCBmbGFnIG9yIGlzIGEgcmVhbCBjbGFzcylcbiAgICAgIC8vXG4gICAgICAvLyB0b1xuICAgICAgLy8gICAgICAgICAgcGFyZW50XG4gICAgICAvLyAgICAgICAgICAgIHxcbiAgICAgIC8vICAgIGBtb2R1bGVgIGljbGFzcyAoaGFzIGEgJCRyb290IGZsYWcpXG4gICAgICAvLyAgICAgICAgICAgIHxcbiAgICAgIC8vICAgLi4ucmVnZW5lcmF0ZWQgY2hhaW4gb2YgbW9kdWxlLmluY2x1ZGVkX21vZHVsZXNcbiAgICAgIC8vICAgICAgICAgICAgfFxuICAgICAgLy8gICBcIm5leHQgYW5jZXN0b3JcIiAoaGFzIGEgJCRyb290IGZsYWcgb3IgaXMgYSByZWFsIGNsYXNzKVxuICAgICAgLy9cbiAgICAgIC8vIGJlY2F1c2UgdGhlcmUgYXJlIG5vIGludGVybWVkaWF0ZSBjbGFzc2VzIGJldHdlZW4gYHBhcmVudGAgYW5kIGBuZXh0IGFuY2VzdG9yYC5cbiAgICAgIC8vIEl0IGRvZXNuJ3QgYnJlYWsgYW55IHByb3RvdHlwZXMgb2Ygb3RoZXIgb2JqZWN0cyBhcyB3ZSBkb24ndCBjaGFuZ2UgY2xhc3MgcmVmZXJlbmNlcy5cblxuICAgICAgdmFyIHBhcmVudCA9IGluY2x1ZGVyLiQkcHJvdG90eXBlLCBtb2R1bGVfaWNsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHBhcmVudCk7XG5cbiAgICAgIHdoaWxlIChtb2R1bGVfaWNsYXNzICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG1vZHVsZV9pY2xhc3MuJCRtb2R1bGUgPT09IG1vZHVsZSAmJiBpc1Jvb3QobW9kdWxlX2ljbGFzcykpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudCA9IG1vZHVsZV9pY2xhc3M7XG4gICAgICAgIG1vZHVsZV9pY2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobW9kdWxlX2ljbGFzcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2R1bGVfaWNsYXNzKSB7XG4gICAgICAgIC8vIG1vZHVsZSBoYXMgYmVlbiBkaXJlY3RseSBpbmNsdWRlZFxuICAgICAgICB2YXIgbmV4dF9hbmNlc3RvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihtb2R1bGVfaWNsYXNzKTtcblxuICAgICAgICAvLyBza2lwIG5vbi1yb290IGljbGFzc2VzICh0aGF0IHdlcmUgcmVjdXJzaXZlbHkgaW5jbHVkZWQpXG4gICAgICAgIHdoaWxlIChuZXh0X2FuY2VzdG9yLmhhc093blByb3BlcnR5KCckJGljbGFzcycpICYmICFpc1Jvb3QobmV4dF9hbmNlc3RvcikpIHtcbiAgICAgICAgICBuZXh0X2FuY2VzdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5leHRfYW5jZXN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnRfY2hhaW5fYWZ0ZXIgPSBwYXJlbnQ7XG4gICAgICAgIGVuZF9jaGFpbl9vbiA9IG5leHRfYW5jZXN0b3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBtb2R1bGUgaGFzIG5vdCBiZWVuIGRpcmVjdGx5IGluY2x1ZGVkIGJ1dCB3YXMgaW4gYW5jZXN0b3IgY2hhaW4gYmVjYXVzZSBpdCB3YXMgaW5jbHVkZWQgYnkgYW5vdGhlciBtb2R1bGVcbiAgICAgICAgLy8gaW5jbHVkZSBpdCBkaXJlY3RseVxuICAgICAgICBzdGFydF9jaGFpbl9hZnRlciA9IGluY2x1ZGVyLiQkcHJvdG90eXBlO1xuICAgICAgICBlbmRfY2hhaW5fb24gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5jbHVkZXIuJCRwcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgICRzZXRfcHJvdG8oc3RhcnRfY2hhaW5fYWZ0ZXIsIGNoYWluLmZpcnN0KTtcbiAgICAkc2V0X3Byb3RvKGNoYWluLmxhc3QsIGVuZF9jaGFpbl9vbik7XG5cbiAgICAvLyByZWNhbGN1bGF0ZSBvd25faW5jbHVkZWRfbW9kdWxlcyBjYWNoZVxuICAgIGluY2x1ZGVyLiQkb3duX2luY2x1ZGVkX21vZHVsZXMgPSBvd25faW5jbHVkZWRfbW9kdWxlcyhpbmNsdWRlcik7XG5cbiAgICBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb24rKztcbiAgfTtcblxuICBPcGFsLnByZXBlbmRfZmVhdHVyZXMgPSBmdW5jdGlvbihtb2R1bGUsIHByZXBlbmRlcikge1xuICAgIC8vIEhlcmUgd2UgY2hhbmdlIHRoZSBhbmNlc3RvcnMgY2hhaW4gZnJvbVxuICAgIC8vXG4gICAgLy8gICBwcmVwZW5kZXJcbiAgICAvLyAgICAgIHxcbiAgICAvLyAgICBwYXJlbnRcbiAgICAvL1xuICAgIC8vIHRvOlxuICAgIC8vXG4gICAgLy8gZHVtbXkocHJlcGVuZGVyKVxuICAgIC8vICAgICAgfFxuICAgIC8vICBpY2xhc3MobW9kdWxlKVxuICAgIC8vICAgICAgfFxuICAgIC8vIGljbGFzcyhwcmVwZW5kZXIpXG4gICAgLy8gICAgICB8XG4gICAgLy8gICAgcGFyZW50XG4gICAgdmFyIG1vZHVsZV9hbmNlc3RvcnMgPSAkYW5jZXN0b3JzKG1vZHVsZSk7XG4gICAgdmFyIGljbGFzc2VzID0gW107XG5cbiAgICBpZiAobW9kdWxlX2FuY2VzdG9ycy5pbmRleE9mKHByZXBlbmRlcikgIT09IC0xKSB7XG4gICAgICAkcmFpc2UoT3BhbC5Bcmd1bWVudEVycm9yLCAnY3ljbGljIHByZXBlbmQgZGV0ZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbW9kdWxlX2FuY2VzdG9ycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFuY2VzdG9yID0gbW9kdWxlX2FuY2VzdG9yc1tpXSwgaWNsYXNzID0gY3JlYXRlX2ljbGFzcyhhbmNlc3Rvcik7XG4gICAgICAkcHJvcChpY2xhc3MsICckJHByZXBlbmRlZCcsIHRydWUpO1xuICAgICAgaWNsYXNzZXMucHVzaChpY2xhc3MpO1xuICAgIH1cblxuICAgIHZhciBjaGFpbiA9IGNoYWluX2ljbGFzc2VzKGljbGFzc2VzKSxcbiAgICAgICAgZHVtbXlfcHJlcGVuZGVyID0gcHJlcGVuZGVyLiQkcHJvdG90eXBlLFxuICAgICAgICBwcmV2aW91c19wYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZHVtbXlfcHJlcGVuZGVyKSxcbiAgICAgICAgcHJlcGVuZGVyX2ljbGFzcyxcbiAgICAgICAgc3RhcnRfY2hhaW5fYWZ0ZXIsXG4gICAgICAgIGVuZF9jaGFpbl9vbjtcblxuICAgIGlmIChkdW1teV9wcmVwZW5kZXIuaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgLy8gVGhlIG1vZHVsZSBhbHJlYWR5IGhhcyBzb21lIHByZXBlbmRlZCBtb2R1bGVzXG4gICAgICAvLyB3aGljaCBtZWFucyB0aGF0IHdlIGRvbid0IG5lZWQgdG8gbWFrZSBpdCBcImR1bW15XCJcbiAgICAgIHByZXBlbmRlcl9pY2xhc3MgPSBkdW1teV9wcmVwZW5kZXIuJCRkZWZpbmVfbWV0aG9kc19vbjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTWFraW5nIHRoZSBtb2R1bGUgXCJkdW1teVwiXG4gICAgICBwcmVwZW5kZXJfaWNsYXNzID0gY3JlYXRlX2R1bW15X2ljbGFzcyhwcmVwZW5kZXIpO1xuICAgICAgZmx1c2hfbWV0aG9kc19pbihwcmVwZW5kZXIpO1xuICAgICAgJHByb3AoZHVtbXlfcHJlcGVuZGVyLCAnJCRkdW1teScsIHRydWUpO1xuICAgICAgJHByb3AoZHVtbXlfcHJlcGVuZGVyLCAnJCRkZWZpbmVfbWV0aG9kc19vbicsIHByZXBlbmRlcl9pY2xhc3MpO1xuXG4gICAgICAvLyBDb252ZXJ0aW5nXG4gICAgICAvLyAgIGR1bW15KHByZXBlbmRlcikgLT4gcHJldmlvdXNfcGFyZW50XG4gICAgICAvLyB0b1xuICAgICAgLy8gICBkdW1teShwcmVwZW5kZXIpIC0+IGljbGFzcyhwcmVwZW5kZXIpIC0+IHByZXZpb3VzX3BhcmVudFxuICAgICAgJHNldF9wcm90byhkdW1teV9wcmVwZW5kZXIsIHByZXBlbmRlcl9pY2xhc3MpO1xuICAgICAgJHNldF9wcm90byhwcmVwZW5kZXJfaWNsYXNzLCBwcmV2aW91c19wYXJlbnQpO1xuICAgIH1cblxuICAgIHZhciBwcmVwZW5kZXJfYW5jZXN0b3JzID0gJGFuY2VzdG9ycyhwcmVwZW5kZXIpO1xuXG4gICAgaWYgKHByZXBlbmRlcl9hbmNlc3RvcnMuaW5kZXhPZihtb2R1bGUpID09PSAtMSkge1xuICAgICAgLy8gZmlyc3QgdGltZSBwcmVwZW5kXG5cbiAgICAgIHN0YXJ0X2NoYWluX2FmdGVyID0gZHVtbXlfcHJlcGVuZGVyO1xuXG4gICAgICAvLyBuZXh0ICQkcm9vdCBvciBwcmVwZW5kZXJfaWNsYXNzIG9yIG5vbi0kJGljbGFzc1xuICAgICAgZW5kX2NoYWluX29uID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGR1bW15X3ByZXBlbmRlcik7XG4gICAgICB3aGlsZSAoZW5kX2NoYWluX29uICE9IG51bGwpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGVuZF9jaGFpbl9vbi5oYXNPd25Qcm9wZXJ0eSgnJCRyb290JykgfHxcbiAgICAgICAgICBlbmRfY2hhaW5fb24gPT09IHByZXBlbmRlcl9pY2xhc3MgfHxcbiAgICAgICAgICAhZW5kX2NoYWluX29uLmhhc093blByb3BlcnR5KCckJGljbGFzcycpXG4gICAgICAgICkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5kX2NoYWluX29uID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGVuZF9jaGFpbl9vbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICRyYWlzZShPcGFsLlJ1bnRpbWVFcnJvciwgXCJQcmVwZW5kaW5nIGEgbW9kdWxlIG11bHRpcGxlIHRpbWVzIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuXG4gICAgJHNldF9wcm90byhzdGFydF9jaGFpbl9hZnRlciwgY2hhaW4uZmlyc3QpO1xuICAgICRzZXRfcHJvdG8oY2hhaW4ubGFzdCwgZW5kX2NoYWluX29uKTtcblxuICAgIC8vIHJlY2FsY3VsYXRlIG93bl9wcmVwZW5kZWRfbW9kdWxlcyBjYWNoZVxuICAgIHByZXBlbmRlci4kJG93bl9wcmVwZW5kZWRfbW9kdWxlcyA9IG93bl9wcmVwZW5kZWRfbW9kdWxlcyhwcmVwZW5kZXIpO1xuXG4gICAgT3BhbC5jb25zdF9jYWNoZV92ZXJzaW9uKys7XG4gIH07XG5cbiAgZnVuY3Rpb24gZmx1c2hfbWV0aG9kc19pbihtb2R1bGUpIHtcbiAgICB2YXIgcHJvdG8gPSBtb2R1bGUuJCRwcm90b3R5cGUsXG4gICAgICAgIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIGlmIChPcGFsLmlzX21ldGhvZChwcm9wKSkge1xuICAgICAgICBkZWxldGUgcHJvdG9bcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlX2ljbGFzcyhtb2R1bGUpIHtcbiAgICB2YXIgaWNsYXNzID0gY3JlYXRlX2R1bW15X2ljbGFzcyhtb2R1bGUpO1xuXG4gICAgaWYgKG1vZHVsZS4kJGlzX21vZHVsZSkge1xuICAgICAgbW9kdWxlLiQkaWNsYXNzZXMucHVzaChpY2xhc3MpO1xuICAgIH1cblxuICAgIHJldHVybiBpY2xhc3M7XG4gIH1cblxuICAvLyBEdW1teSBpY2xhc3MgZG9lc24ndCByZWNlaXZlIHVwZGF0ZXMgd2hlbiB0aGUgbW9kdWxlIGdldHMgYSBuZXcgbWV0aG9kLlxuICBmdW5jdGlvbiBjcmVhdGVfZHVtbXlfaWNsYXNzKG1vZHVsZSkge1xuICAgIHZhciBpY2xhc3MgPSB7fSxcbiAgICAgICAgcHJvdG8gPSBtb2R1bGUuJCRwcm90b3R5cGU7XG5cbiAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgcHJvdG8gPSBwcm90by4kJGRlZmluZV9tZXRob2RzX29uO1xuICAgIH1cblxuICAgIHZhciBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgJHByb3AoaWNsYXNzLCBwcm9wLCBwcm90b1twcm9wXSk7XG4gICAgfVxuXG4gICAgJHByb3AoaWNsYXNzLCAnJCRpY2xhc3MnLCB0cnVlKTtcbiAgICAkcHJvcChpY2xhc3MsICckJG1vZHVsZScsIG1vZHVsZSk7XG5cbiAgICByZXR1cm4gaWNsYXNzO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hhaW5faWNsYXNzZXMoaWNsYXNzZXMpIHtcbiAgICB2YXIgbGVuZ3RoID0gaWNsYXNzZXMubGVuZ3RoLCBmaXJzdCA9IGljbGFzc2VzWzBdO1xuXG4gICAgJHByb3AoZmlyc3QsICckJHJvb3QnLCB0cnVlKTtcblxuICAgIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB7IGZpcnN0OiBmaXJzdCwgbGFzdDogZmlyc3QgfTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXMgPSBmaXJzdDtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjdXJyZW50ID0gaWNsYXNzZXNbaV07XG4gICAgICAkc2V0X3Byb3RvKHByZXZpb3VzLCBjdXJyZW50KTtcbiAgICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgICB9XG5cblxuICAgIHJldHVybiB7IGZpcnN0OiBpY2xhc3Nlc1swXSwgbGFzdDogaWNsYXNzZXNbbGVuZ3RoIC0gMV0gfTtcbiAgfVxuXG4gIC8vIEZvciBwZXJmb3JtYW5jZSwgc29tZSBjb3JlIFJ1YnkgY2xhc3NlcyBhcmUgdG9sbC1mcmVlIGJyaWRnZWQgdG8gdGhlaXJcbiAgLy8gbmF0aXZlIEphdmFTY3JpcHQgY291bnRlcnBhcnRzIChlLmcuIGEgUnVieSBBcnJheSBpcyBhIEphdmFTY3JpcHQgQXJyYXkpLlxuICAvL1xuICAvLyBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIHNldHVwIGEgbmF0aXZlIGNvbnN0cnVjdG9yIChlLmcuIEFycmF5KSwgdG8gaGF2ZVxuICAvLyBpdHMgcHJvdG90eXBlIGFjdCBsaWtlIGEgbm9ybWFsIFJ1YnkgY2xhc3MuIEZpcnN0bHksIGEgbmV3IFJ1YnkgY2xhc3MgaXNcbiAgLy8gY3JlYXRlZCB1c2luZyB0aGUgbmF0aXZlIGNvbnN0cnVjdG9yIHNvIHRoYXQgaXRzIHByb3RvdHlwZSBpcyBzZXQgYXMgdGhlXG4gIC8vIHRhcmdldCBmb3IgdGhlIG5ldyBjbGFzcy4gTm90ZTogYWxsIGJyaWRnZWQgY2xhc3NlcyBhcmUgc2V0IHRvIGluaGVyaXRcbiAgLy8gZnJvbSBPYmplY3QuXG4gIC8vXG4gIC8vIEV4YW1wbGU6XG4gIC8vXG4gIC8vICAgIE9wYWwuYnJpZGdlKHNlbGYsIEZ1bmN0aW9uKTtcbiAgLy9cbiAgLy8gQHBhcmFtIGtsYXNzICAgICAgIFtDbGFzc10gdGhlIFJ1YnkgY2xhc3MgdG8gYnJpZGdlXG4gIC8vIEBwYXJhbSBjb25zdHJ1Y3RvciBbSlMuRnVuY3Rpb25dIG5hdGl2ZSBKYXZhU2NyaXB0IGNvbnN0cnVjdG9yIHRvIHVzZVxuICAvLyBAcmV0dXJuIFtDbGFzc10gcmV0dXJucyB0aGUgcGFzc2VkIFJ1YnkgY2xhc3NcbiAgLy9cbiAgT3BhbC5icmlkZ2UgPSBmdW5jdGlvbihuYXRpdmVfa2xhc3MsIGtsYXNzKSB7XG4gICAgaWYgKG5hdGl2ZV9rbGFzcy5oYXNPd25Qcm9wZXJ0eSgnJCRicmlkZ2UnKSkge1xuICAgICAgJHJhaXNlKE9wYWwuQXJndW1lbnRFcnJvciwgXCJhbHJlYWR5IGJyaWRnZWRcIik7XG4gICAgfVxuXG4gICAgLy8gY29uc3RydWN0b3IgaXMgYSBKUyBmdW5jdGlvbiB3aXRoIGEgcHJvdG90eXBlIGNoYWluIGxpa2U6XG4gICAgLy8gLSBjb25zdHJ1Y3RvclxuICAgIC8vICAgLSBzdXBlclxuICAgIC8vXG4gICAgLy8gV2hhdCB3ZSBuZWVkIHRvIGRvIGlzIHRvIGluamVjdCBvdXIgY2xhc3MgKHdpdGggaXRzIHByb3RvdHlwZSBjaGFpbilcbiAgICAvLyBiZXR3ZWVuIGNvbnN0cnVjdG9yIGFuZCBzdXBlci4gRm9yIGV4YW1wbGUsIGFmdGVyIGluamVjdGluZyA6Ok9iamVjdFxuICAgIC8vIGludG8gSlMgU3RyaW5nIHdlIGdldDpcbiAgICAvL1xuICAgIC8vIC0gY29uc3RydWN0b3IgKHdpbmRvdy5TdHJpbmcpXG4gICAgLy8gICAtIE9wYWwuT2JqZWN0XG4gICAgLy8gICAgIC0gT3BhbC5LZXJuZWxcbiAgICAvLyAgICAgICAtIE9wYWwuQmFzaWNPYmplY3RcbiAgICAvLyAgICAgICAgIC0gc3VwZXIgKHdpbmRvdy5PYmplY3QpXG4gICAgLy8gICAgICAgICAgIC0gbnVsbFxuICAgIC8vXG4gICAgJHByb3AobmF0aXZlX2tsYXNzLCAnJCRicmlkZ2UnLCBrbGFzcyk7XG4gICAgJHNldF9wcm90byhuYXRpdmVfa2xhc3MucHJvdG90eXBlLCAoa2xhc3MuJCRzdXBlciB8fCBPcGFsLk9iamVjdCkuJCRwcm90b3R5cGUpO1xuICAgICRwcm9wKGtsYXNzLCAnJCRwcm90b3R5cGUnLCBuYXRpdmVfa2xhc3MucHJvdG90eXBlKTtcblxuICAgICRwcm9wKGtsYXNzLiQkcHJvdG90eXBlLCAnJCRjbGFzcycsIGtsYXNzKTtcbiAgICAkcHJvcChrbGFzcywgJyQkY29uc3RydWN0b3InLCBuYXRpdmVfa2xhc3MpO1xuICAgICRwcm9wKGtsYXNzLCAnJCRicmlkZ2UnLCB0cnVlKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwcm90b1RvTW9kdWxlKHByb3RvKSB7XG4gICAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KCckJGR1bW15JykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHByb3RvLmhhc093blByb3BlcnR5KCckJGljbGFzcycpKSB7XG4gICAgICByZXR1cm4gcHJvdG8uJCRtb2R1bGU7XG4gICAgfSBlbHNlIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRjbGFzcycpKSB7XG4gICAgICByZXR1cm4gcHJvdG8uJCRjbGFzcztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvd25fYW5jZXN0b3JzKG1vZHVsZSkge1xuICAgIHJldHVybiBtb2R1bGUuJCRvd25fcHJlcGVuZGVkX21vZHVsZXMuY29uY2F0KFttb2R1bGVdKS5jb25jYXQobW9kdWxlLiQkb3duX2luY2x1ZGVkX21vZHVsZXMpO1xuICB9XG5cbiAgLy8gVGhlIEFycmF5IG9mIGFuY2VzdG9ycyBmb3IgYSBnaXZlbiBtb2R1bGUvY2xhc3NcbiAgZnVuY3Rpb24gJGFuY2VzdG9ycyhtb2R1bGUpIHtcbiAgICBpZiAoIW1vZHVsZSkgeyByZXR1cm4gW107IH1cblxuICAgIGlmIChtb2R1bGUuJCRhbmNlc3RvcnNfY2FjaGVfdmVyc2lvbiA9PT0gT3BhbC5jb25zdF9jYWNoZV92ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gbW9kdWxlLiQkYW5jZXN0b3JzO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBbXSwgaSwgbW9kcywgbGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMCwgbW9kcyA9IG93bl9hbmNlc3RvcnMobW9kdWxlKSwgbGVuZ3RoID0gbW9kcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0LnB1c2gobW9kc1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKG1vZHVsZS4kJHN1cGVyKSB7XG4gICAgICBmb3IgKGkgPSAwLCBtb2RzID0gJGFuY2VzdG9ycyhtb2R1bGUuJCRzdXBlciksIGxlbmd0aCA9IG1vZHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobW9kc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLiQkYW5jZXN0b3JzX2NhY2hlX3ZlcnNpb24gPSBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb247XG4gICAgbW9kdWxlLiQkYW5jZXN0b3JzID0gcmVzdWx0O1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgT3BhbC5hbmNlc3RvcnMgPSAkYW5jZXN0b3JzO1xuXG4gIE9wYWwuaW5jbHVkZWRfbW9kdWxlcyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgIHZhciByZXN1bHQgPSBbXSwgbW9kID0gbnVsbCwgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobW9kdWxlLiQkcHJvdG90eXBlKTtcblxuICAgIGZvciAoOyBwcm90byAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pOyBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykpIHtcbiAgICAgIG1vZCA9IHByb3RvVG9Nb2R1bGUocHJvdG8pO1xuICAgICAgaWYgKG1vZCAmJiBtb2QuJCRpc19tb2R1bGUgJiYgcHJvdG8uJCRpY2xhc3MgJiYgcHJvdG8uJCRpbmNsdWRlZCkge1xuICAgICAgICByZXN1bHQucHVzaChtb2QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cblxuICAvLyBNZXRob2QgTWlzc2luZ1xuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIE1ldGhvZHMgc3R1YnMgYXJlIHVzZWQgdG8gZmFjaWxpdGF0ZSBtZXRob2RfbWlzc2luZyBpbiBvcGFsLiBBIHN0dWIgaXMgYVxuICAvLyBwbGFjZWhvbGRlciBmdW5jdGlvbiB3aGljaCBqdXN0IGNhbGxzIGBtZXRob2RfbWlzc2luZ2Agb24gdGhlIHJlY2VpdmVyLlxuICAvLyBJZiBubyBtZXRob2Qgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpcyBhY3R1YWxseSBkZWZpbmVkIG9uIGFuIG9iamVjdCwgdGhlbiBpdFxuICAvLyBpcyBvYnZpb3VzIHRvIHNheSB0aGF0IHRoZSBzdHViIHdpbGwgYmUgY2FsbGVkIGluc3RlYWQsIGFuZCB0aGVuIGluIHR1cm5cbiAgLy8gbWV0aG9kX21pc3Npbmcgd2lsbCBiZSBjYWxsZWQuXG4gIC8vXG4gIC8vIFdoZW4gYSBmaWxlIGluIHJ1YnkgZ2V0cyBjb21waWxlZCB0byBqYXZhc2NyaXB0LCBpdCBpbmNsdWRlcyBhIGNhbGwgdG9cbiAgLy8gdGhpcyBmdW5jdGlvbiB3aGljaCBhZGRzIHN0dWJzIGZvciBldmVyeSBtZXRob2QgbmFtZSBpbiB0aGUgY29tcGlsZWQgZmlsZS5cbiAgLy8gSXQgc2hvdWxkIHRoZW4gYmUgc2FmZSB0byBhc3N1bWUgdGhhdCBtZXRob2RfbWlzc2luZyB3aWxsIHdvcmsgZm9yIGFueVxuICAvLyBtZXRob2QgY2FsbCBkZXRlY3RlZC5cbiAgLy9cbiAgLy8gTWV0aG9kIHN0dWJzIGFyZSBhZGRlZCB0byB0aGUgQmFzaWNPYmplY3QgcHJvdG90eXBlLCB3aGljaCBldmVyeSBvdGhlclxuICAvLyBydWJ5IG9iamVjdCBpbmhlcml0cywgc28gYWxsIG9iamVjdHMgc2hvdWxkIGhhbmRsZSBtZXRob2QgbWlzc2luZy4gQSBzdHViXG4gIC8vIGlzIG9ubHkgYWRkZWQgaWYgdGhlIGdpdmVuIHByb3BlcnR5IG5hbWUgKG1ldGhvZCBuYW1lKSBpcyBub3QgYWxyZWFkeVxuICAvLyBkZWZpbmVkLlxuICAvL1xuICAvLyBOb3RlOiBhbGwgcnVieSBtZXRob2RzIGhhdmUgYSBgJGAgcHJlZml4IGluIGphdmFzY3JpcHQsIHNvIGFsbCBzdHVicyB3aWxsXG4gIC8vIGhhdmUgdGhpcyBwcmVmaXggYXMgd2VsbCAodG8gbWFrZSB0aGlzIG1ldGhvZCBtb3JlIHBlcmZvcm1hbnQpLlxuICAvL1xuICAvLyAgICBPcGFsLmFkZF9zdHVicyhcImZvbyxiYXIsYmF6PVwiKTtcbiAgLy9cbiAgLy8gQWxsIHN0dWIgZnVuY3Rpb25zIHdpbGwgaGF2ZSBhIHByaXZhdGUgYCQkc3R1YmAgcHJvcGVydHkgc2V0IHRvIHRydWUgc29cbiAgLy8gdGhhdCBvdGhlciBpbnRlcm5hbCBtZXRob2RzIGNhbiBkZXRlY3QgaWYgYSBtZXRob2QgaXMganVzdCBhIHN0dWIgb3Igbm90LlxuICAvLyBgS2VybmVsI3Jlc3BvbmRfdG8/YCB1c2VzIHRoaXMgcHJvcGVydHkgdG8gZGV0ZWN0IGEgbWV0aG9kcyBwcmVzZW5jZS5cbiAgLy9cbiAgLy8gQHBhcmFtIHN0dWJzIFtBcnJheV0gYW4gYXJyYXkgb2YgbWV0aG9kIHN0dWJzIHRvIGFkZFxuICAvLyBAcmV0dXJuIFt1bmRlZmluZWRdXG4gIE9wYWwuYWRkX3N0dWJzID0gZnVuY3Rpb24oc3R1YnMpIHtcbiAgICB2YXIgcHJvdG8gPSBPcGFsLkJhc2ljT2JqZWN0LiQkcHJvdG90eXBlO1xuICAgIHZhciBzdHViLCBleGlzdGluZ19tZXRob2Q7XG4gICAgc3R1YnMgPSBzdHVicy5zcGxpdCgnLCcpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0dWJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBzdHViID0gJGpzaWQoc3R1YnNbaV0pLCBleGlzdGluZ19tZXRob2QgPSBwcm90b1tzdHViXTtcblxuICAgICAgaWYgKGV4aXN0aW5nX21ldGhvZCA9PSBudWxsIHx8IGV4aXN0aW5nX21ldGhvZC4kJHN0dWIpIHtcbiAgICAgICAgT3BhbC5hZGRfc3R1Yl9mb3IocHJvdG8sIHN0dWIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBBZGQgYSBtZXRob2RfbWlzc2luZyBzdHViIGZ1bmN0aW9uIHRvIHRoZSBnaXZlbiBwcm90b3R5cGUgZm9yIHRoZVxuICAvLyBnaXZlbiBuYW1lLlxuICAvL1xuICAvLyBAcGFyYW0gcHJvdG90eXBlIFtQcm90b3R5cGVdIHRoZSB0YXJnZXQgcHJvdG90eXBlXG4gIC8vIEBwYXJhbSBzdHViIFtTdHJpbmddIHN0dWIgbmFtZSB0byBhZGQgKGUuZy4gXCIkZm9vXCIpXG4gIC8vIEByZXR1cm4gW3VuZGVmaW5lZF1cbiAgT3BhbC5hZGRfc3R1Yl9mb3IgPSBmdW5jdGlvbihwcm90b3R5cGUsIHN0dWIpIHtcbiAgICAvLyBPcGFsLnN0dWJfZm9yKHN0dWIpIGlzIHRoZSBtZXRob2RfbWlzc2luZ19zdHViXG4gICAgJHByb3AocHJvdG90eXBlLCBzdHViLCBPcGFsLnN0dWJfZm9yKHN0dWIpKTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSB0aGUgbWV0aG9kX21pc3Npbmcgc3R1YiBmb3IgYSBnaXZlbiBtZXRob2QgbmFtZS5cbiAgLy9cbiAgLy8gQHBhcmFtIG1ldGhvZF9uYW1lIFtTdHJpbmddIFRoZSBqcy1uYW1lIG9mIHRoZSBtZXRob2QgdG8gc3R1YiAoZS5nLiBcIiRmb29cIilcbiAgLy8gQHJldHVybiBbdW5kZWZpbmVkXVxuICBPcGFsLnN0dWJfZm9yID0gZnVuY3Rpb24obWV0aG9kX25hbWUpIHtcbiAgICBmdW5jdGlvbiBtZXRob2RfbWlzc2luZ19zdHViKCkge1xuICAgICAgLy8gQ29weSBhbnkgZ2l2ZW4gYmxvY2sgb250byB0aGUgbWV0aG9kX21pc3NpbmcgZGlzcGF0Y2hlclxuICAgICAgdGhpcy4kbWV0aG9kX21pc3NpbmcuJCRwID0gbWV0aG9kX21pc3Npbmdfc3R1Yi4kJHA7XG5cbiAgICAgIC8vIFNldCBibG9jayBwcm9wZXJ0eSB0byBudWxsIHJlYWR5IGZvciB0aGUgbmV4dCBjYWxsIChzdG9wIGZhbHNlLXBvc2l0aXZlcylcbiAgICAgIG1ldGhvZF9taXNzaW5nX3N0dWIuJCRwID0gbnVsbDtcblxuICAgICAgLy8gY2FsbCBtZXRob2QgbWlzc2luZyB3aXRoIGNvcnJlY3QgYXJncyAocmVtb3ZlICckJyBwcmVmaXggb24gbWV0aG9kIG5hbWUpXG4gICAgICByZXR1cm4gdGhpcy4kbWV0aG9kX21pc3NpbmcuYXBwbHkodGhpcywgJHByZXBlbmQobWV0aG9kX25hbWUuc2xpY2UoMSksIGFyZ3VtZW50cykpO1xuICAgIH07XG5cbiAgICBtZXRob2RfbWlzc2luZ19zdHViLiQkc3R1YiA9IHRydWU7XG5cbiAgICByZXR1cm4gbWV0aG9kX21pc3Npbmdfc3R1YjtcbiAgfTtcblxuXG4gIC8vIE1ldGhvZHNcbiAgLy8gLS0tLS0tLVxuXG4gIC8vIEFyaXR5IGNvdW50IGVycm9yIGRpc3BhdGNoZXIgZm9yIG1ldGhvZHNcbiAgLy9cbiAgLy8gQHBhcmFtIGFjdHVhbCBbRml4bnVtXSBudW1iZXIgb2YgYXJndW1lbnRzIGdpdmVuIHRvIG1ldGhvZFxuICAvLyBAcGFyYW0gZXhwZWN0ZWQgW0ZpeG51bV0gZXhwZWN0ZWQgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICAvLyBAcGFyYW0gb2JqZWN0IFtPYmplY3RdIG93bmVyIG9mIHRoZSBtZXRob2QgK21ldGgrXG4gIC8vIEBwYXJhbSBtZXRoIFtTdHJpbmddIG1ldGhvZCBuYW1lIHRoYXQgZ290IHdyb25nIG51bWJlciBvZiBhcmd1bWVudHNcbiAgLy8gQHJhaXNlIFtBcmd1bWVudEVycm9yXVxuICBPcGFsLmFjID0gZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCwgb2JqZWN0LCBtZXRoKSB7XG4gICAgdmFyIGluc3BlY3QgPSAnJztcbiAgICBpZiAob2JqZWN0LiQkaXNfYV9tb2R1bGUpIHtcbiAgICAgIGluc3BlY3QgKz0gb2JqZWN0LiQkbmFtZSArICcuJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpbnNwZWN0ICs9IG9iamVjdC4kJGNsYXNzLiQkbmFtZSArICcjJztcbiAgICB9XG4gICAgaW5zcGVjdCArPSBtZXRoO1xuXG4gICAgJHJhaXNlKE9wYWwuQXJndW1lbnRFcnJvciwgJ1snICsgaW5zcGVjdCArICddIHdyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKGdpdmVuICcgKyBhY3R1YWwgKyAnLCBleHBlY3RlZCAnICsgZXhwZWN0ZWQgKyAnKScpO1xuICB9O1xuXG4gIC8vIEFyaXR5IGNvdW50IGVycm9yIGRpc3BhdGNoZXIgZm9yIGJsb2Nrc1xuICAvL1xuICAvLyBAcGFyYW0gYWN0dWFsIFtGaXhudW1dIG51bWJlciBvZiBhcmd1bWVudHMgZ2l2ZW4gdG8gYmxvY2tcbiAgLy8gQHBhcmFtIGV4cGVjdGVkIFtGaXhudW1dIGV4cGVjdGVkIG51bWJlciBvZiBhcmd1bWVudHNcbiAgLy8gQHBhcmFtIGNvbnRleHQgW09iamVjdF0gY29udGV4dCBvZiB0aGUgYmxvY2sgZGVmaW5pdGlvblxuICAvLyBAcmFpc2UgW0FyZ3VtZW50RXJyb3JdXG4gIE9wYWwuYmxvY2tfYWMgPSBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkLCBjb250ZXh0KSB7XG4gICAgdmFyIGluc3BlY3QgPSBcImBibG9jayBpbiBcIiArIGNvbnRleHQgKyBcIidcIjtcblxuICAgICRyYWlzZShPcGFsLkFyZ3VtZW50RXJyb3IsIGluc3BlY3QgKyAnOiB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIChnaXZlbiAnICsgYWN0dWFsICsgJywgZXhwZWN0ZWQgJyArIGV4cGVjdGVkICsgJyknKTtcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRfYW5jZXN0b3JzKG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoJyQkbWV0YScpICYmIG9iai4kJG1ldGEgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiAkYW5jZXN0b3JzKG9iai4kJG1ldGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJGFuY2VzdG9ycyhvYmouJCRjbGFzcyk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFN1cGVyIGRpc3BhdGNoZXJcbiAgT3BhbC5maW5kX3N1cGVyID0gZnVuY3Rpb24ob2JqLCBtaWQsIGN1cnJlbnRfZnVuYywgZGVmY2hlY2ssIGFsbG93X3N0dWJzKSB7XG4gICAgdmFyIGpzaWQgPSAkanNpZChtaWQpLCBhbmNlc3RvcnMsIGFuY2VzdG9yLCBzdXBlcl9tZXRob2QsIG1ldGhvZF9vd25lciwgY3VycmVudF9pbmRleCA9IC0xLCBpO1xuXG4gICAgYW5jZXN0b3JzID0gZ2V0X2FuY2VzdG9ycyhvYmopO1xuICAgIG1ldGhvZF9vd25lciA9IGN1cnJlbnRfZnVuYy4kJG93bmVyO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgYW5jZXN0b3IgPSBhbmNlc3RvcnNbaV07XG4gICAgICBpZiAoYW5jZXN0b3IgPT09IG1ldGhvZF9vd25lciB8fCBhbmNlc3Rvci4kJGNsb25lZF9mcm9tLmluZGV4T2YobWV0aG9kX293bmVyKSAhPT0gLTEpIHtcbiAgICAgICAgY3VycmVudF9pbmRleCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IGN1cnJlbnRfaW5kZXggKyAxOyBpIDwgYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhbmNlc3RvciA9IGFuY2VzdG9yc1tpXTtcbiAgICAgIHZhciBwcm90byA9IGFuY2VzdG9yLiQkcHJvdG90eXBlO1xuXG4gICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eShqc2lkKSkge1xuICAgICAgICBzdXBlcl9tZXRob2QgPSBwcm90b1tqc2lkXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFkZWZjaGVjayAmJiBzdXBlcl9tZXRob2QgJiYgc3VwZXJfbWV0aG9kLiQkc3R1YiAmJiBvYmouJG1ldGhvZF9taXNzaW5nLiQkcHJpc3RpbmUpIHtcbiAgICAgIC8vIG1ldGhvZF9taXNzaW5nIGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgZGVmaW5lZFxuICAgICAgJHJhaXNlKE9wYWwuTm9NZXRob2RFcnJvciwgJ3N1cGVyOiBubyBzdXBlcmNsYXNzIG1ldGhvZCBgJyttaWQrXCInIGZvciBcIitvYmosIG1pZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChzdXBlcl9tZXRob2QuJCRzdHViICYmICFhbGxvd19zdHVicykgPyBudWxsIDogc3VwZXJfbWV0aG9kO1xuICB9O1xuXG4gIC8vIEl0ZXIgZGlzcGF0Y2hlciBmb3Igc3VwZXIgaW4gYSBibG9ja1xuICBPcGFsLmZpbmRfYmxvY2tfc3VwZXIgPSBmdW5jdGlvbihvYmosIGpzaWQsIGN1cnJlbnRfZnVuYywgZGVmY2hlY2ssIGltcGxpY2l0KSB7XG4gICAgdmFyIGNhbGxfanNpZCA9IGpzaWQ7XG5cbiAgICBpZiAoIWN1cnJlbnRfZnVuYykge1xuICAgICAgJHJhaXNlKE9wYWwuUnVudGltZUVycm9yLCBcInN1cGVyIGNhbGxlZCBvdXRzaWRlIG9mIG1ldGhvZFwiKTtcbiAgICB9XG5cbiAgICBpZiAoaW1wbGljaXQgJiYgY3VycmVudF9mdW5jLiQkZGVmaW5lX21ldGgpIHtcbiAgICAgICRyYWlzZShPcGFsLlJ1bnRpbWVFcnJvcixcbiAgICAgICAgXCJpbXBsaWNpdCBhcmd1bWVudCBwYXNzaW5nIG9mIHN1cGVyIGZyb20gbWV0aG9kIGRlZmluZWQgYnkgZGVmaW5lX21ldGhvZCgpIGlzIG5vdCBzdXBwb3J0ZWQuIFwiICtcbiAgICAgICAgXCJTcGVjaWZ5IGFsbCBhcmd1bWVudHMgZXhwbGljaXRseVwiXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50X2Z1bmMuJCRkZWYpIHtcbiAgICAgIGNhbGxfanNpZCA9IGN1cnJlbnRfZnVuYy4kJGpzaWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9wYWwuZmluZF9zdXBlcihvYmosIGNhbGxfanNpZCwgY3VycmVudF9mdW5jLCBkZWZjaGVjayk7XG4gIH07XG5cbiAgLy8gQGRlcHJlY2F0ZWRcbiAgT3BhbC5maW5kX3N1cGVyX2Rpc3BhdGNoZXIgPSBPcGFsLmZpbmRfc3VwZXI7XG5cbiAgLy8gQGRlcHJlY2F0ZWRcbiAgT3BhbC5maW5kX2l0ZXJfc3VwZXJfZGlzcGF0Y2hlciA9IE9wYWwuZmluZF9ibG9ja19zdXBlcjtcblxuICBmdW5jdGlvbiBjYWxsX2xhbWJkYShibG9jaywgYXJnLCByZXQpIHtcbiAgICB0cnkge1xuICAgICAgYmxvY2soYXJnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZSA9PT0gcmV0KSB7XG4gICAgICAgIHJldHVybiByZXQuJHY7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIC8vIGhhbmRsZXMgeWllbGQgY2FsbHMgZm9yIDEgeWllbGRlZCBhcmdcbiAgT3BhbC55aWVsZDEgPSBmdW5jdGlvbihibG9jaywgYXJnKSB7XG4gICAgaWYgKHR5cGVvZihibG9jaykgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgJHJhaXNlKE9wYWwuTG9jYWxKdW1wRXJyb3IsIFwibm8gYmxvY2sgZ2l2ZW5cIik7XG4gICAgfVxuXG4gICAgdmFyIGhhc19tbGhzID0gYmxvY2suJCRoYXNfdG9wX2xldmVsX21saHNfYXJnLFxuICAgICAgICBoYXNfdHJhaWxpbmdfY29tbWEgPSBibG9jay4kJGhhc190cmFpbGluZ19jb21tYV9pbl9hcmdzLFxuICAgICAgICBpc19yZXR1cm5pbmdfbGFtYmRhID0gYmxvY2suJCRpc19sYW1iZGEgJiYgYmxvY2suJCRyZXQ7XG5cbiAgICBpZiAoYmxvY2subGVuZ3RoID4gMSB8fCAoKGhhc19tbGhzIHx8IGhhc190cmFpbGluZ19jb21tYSkgJiYgYmxvY2subGVuZ3RoID09PSAxKSkge1xuICAgICAgYXJnID0gT3BhbC50b19hcnkoYXJnKTtcbiAgICB9XG5cbiAgICBpZiAoKGJsb2NrLmxlbmd0aCA+IDEgfHwgKGhhc190cmFpbGluZ19jb21tYSAmJiBibG9jay5sZW5ndGggPT09IDEpKSAmJiBhcmcuJCRpc19hcnJheSkge1xuICAgICAgaWYgKGlzX3JldHVybmluZ19sYW1iZGEpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxfbGFtYmRhKGJsb2NrLmFwcGx5LmJpbmQoYmxvY2ssIG51bGwpLCBhcmcsIGJsb2NrLiQkcmV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBibG9jay5hcHBseShudWxsLCBhcmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChpc19yZXR1cm5pbmdfbGFtYmRhKSB7XG4gICAgICAgIHJldHVybiBjYWxsX2xhbWJkYShibG9jaywgYXJnLCBibG9jay4kJHJldCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmxvY2soYXJnKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gaGFuZGxlcyB5aWVsZCBmb3IgPiAxIHlpZWxkZWQgYXJnXG4gIE9wYWwueWllbGRYID0gZnVuY3Rpb24oYmxvY2ssIGFyZ3MpIHtcbiAgICBpZiAodHlwZW9mKGJsb2NrKSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAkcmFpc2UoT3BhbC5Mb2NhbEp1bXBFcnJvciwgXCJubyBibG9jayBnaXZlblwiKTtcbiAgICB9XG5cbiAgICBpZiAoYmxvY2subGVuZ3RoID4gMSAmJiBhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKGFyZ3NbMF0uJCRpc19hcnJheSkge1xuICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYmxvY2suJCRpc19sYW1iZGEgJiYgYmxvY2suJCRyZXQpIHtcbiAgICAgIHJldHVybiBjYWxsX2xhbWJkYShibG9jay5hcHBseS5iaW5kKGJsb2NrLCBudWxsKSwgYXJncywgYmxvY2suJCRyZXQpO1xuICAgIH1cbiAgICByZXR1cm4gYmxvY2suYXBwbHkobnVsbCwgYXJncyk7XG4gIH07XG5cbiAgLy8gRmluZHMgdGhlIGNvcnJlc3BvbmRpbmcgZXhjZXB0aW9uIG1hdGNoIGluIGNhbmRpZGF0ZXMuICBFYWNoIGNhbmRpZGF0ZSBjYW5cbiAgLy8gYmUgYSB2YWx1ZSwgb3IgYW4gYXJyYXkgb2YgdmFsdWVzLiAgUmV0dXJucyBudWxsIGlmIG5vdCBmb3VuZC5cbiAgT3BhbC5yZXNjdWUgPSBmdW5jdGlvbihleGNlcHRpb24sIGNhbmRpZGF0ZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbmRpZGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjYW5kaWRhdGUgPSBjYW5kaWRhdGVzW2ldO1xuXG4gICAgICBpZiAoY2FuZGlkYXRlLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IE9wYWwucmVzY3VlKGV4Y2VwdGlvbiwgY2FuZGlkYXRlKTtcblxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY2FuZGlkYXRlID09PSBPcGFsLkpTLkVycm9yIHx8IGNhbmRpZGF0ZVsnJD09PSddKGV4Y2VwdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBPcGFsLmlzX2EgPSBmdW5jdGlvbihvYmplY3QsIGtsYXNzKSB7XG4gICAgaWYgKGtsYXNzICE9IG51bGwgJiYgb2JqZWN0LiQkbWV0YSA9PT0ga2xhc3MgfHwgb2JqZWN0LiQkY2xhc3MgPT09IGtsYXNzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob2JqZWN0LiQkaXNfbnVtYmVyICYmIGtsYXNzLiQkaXNfbnVtYmVyX2NsYXNzKSB7XG4gICAgICByZXR1cm4gKGtsYXNzLiQkaXNfaW50ZWdlcl9jbGFzcykgPyAob2JqZWN0ICUgMSkgPT09IDAgOiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBhbmNlc3RvcnMgPSAkYW5jZXN0b3JzKG9iamVjdC4kJGlzX2NsYXNzID8gT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzKG9iamVjdCkgOiAob2JqZWN0LiQkbWV0YSB8fCBvYmplY3QuJCRjbGFzcykpO1xuXG4gICAgcmV0dXJuIGFuY2VzdG9ycy5pbmRleE9mKGtsYXNzKSAhPT0gLTE7XG4gIH07XG5cbiAgLy8gSGVscGVycyBmb3IgZXh0cmFjdGluZyBrd3NwbGF0c1xuICAvLyBVc2VkIGZvcjogeyAqKmggfVxuICBPcGFsLnRvX2hhc2ggPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS4kJGlzX2hhc2gpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWVbJyRyZXNwb25kX3RvPyddKCd0b19oYXNoJywgdHJ1ZSkpIHtcbiAgICAgIHZhciBoYXNoID0gdmFsdWUuJHRvX2hhc2goKTtcbiAgICAgIGlmIChoYXNoLiQkaXNfaGFzaCkge1xuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAkcmFpc2UoT3BhbC5UeXBlRXJyb3IsIFwiQ2FuJ3QgY29udmVydCBcIiArIHZhbHVlLiQkY2xhc3MgK1xuICAgICAgICAgIFwiIHRvIEhhc2ggKFwiICsgdmFsdWUuJCRjbGFzcyArIFwiI3RvX2hhc2ggZ2l2ZXMgXCIgKyBoYXNoLiQkY2xhc3MgKyBcIilcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgJHJhaXNlKE9wYWwuVHlwZUVycm9yLCBcIm5vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgXCIgKyB2YWx1ZS4kJGNsYXNzICsgXCIgaW50byBIYXNoXCIpO1xuICAgIH1cbiAgfTtcblxuICAvLyBIZWxwZXJzIGZvciBpbXBsZW1lbnRpbmcgbXVsdGlwbGUgYXNzaWdubWVudFxuICAvLyBPdXIgY29kZSBmb3IgZXh0cmFjdGluZyB0aGUgdmFsdWVzIGFuZCBhc3NpZ25pbmcgdGhlbSBvbmx5IHdvcmtzIGlmIHRoZVxuICAvLyByZXR1cm4gdmFsdWUgaXMgYSBKUyBhcnJheS5cbiAgLy8gU28gaWYgd2UgZ2V0IGFuIEFycmF5IHN1YmNsYXNzLCBleHRyYWN0IHRoZSB3cmFwcGVkIEpTIGFycmF5IGZyb20gaXRcblxuICAvLyBVc2VkIGZvcjogYSwgYiA9IHNvbWV0aGluZyAobm8gc3BsYXQpXG4gIE9wYWwudG9fYXJ5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUuJCRpc19hcnJheSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZVsnJHJlc3BvbmRfdG8/J10oJ3RvX2FyeScsIHRydWUpKSB7XG4gICAgICB2YXIgYXJ5ID0gdmFsdWUuJHRvX2FyeSgpO1xuICAgICAgaWYgKGFyeSA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBbdmFsdWVdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYXJ5LiQkaXNfYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFyeTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAkcmFpc2UoT3BhbC5UeXBlRXJyb3IsIFwiQ2FuJ3QgY29udmVydCBcIiArIHZhbHVlLiQkY2xhc3MgK1xuICAgICAgICAgIFwiIHRvIEFycmF5IChcIiArIHZhbHVlLiQkY2xhc3MgKyBcIiN0b19hcnkgZ2l2ZXMgXCIgKyBhcnkuJCRjbGFzcyArIFwiKVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVXNlZCBmb3I6IGEsIGIgPSAqc29tZXRoaW5nICh3aXRoIHNwbGF0KVxuICBPcGFsLnRvX2EgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS4kJGlzX2FycmF5KSB7XG4gICAgICAvLyBBIHNwbGF0dGVkIGFycmF5IG11c3QgYmUgY29waWVkXG4gICAgICByZXR1cm4gdmFsdWUuc2xpY2UoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWVbJyRyZXNwb25kX3RvPyddKCd0b19hJywgdHJ1ZSkpIHtcbiAgICAgIHZhciBhcnkgPSB2YWx1ZS4kdG9fYSgpO1xuICAgICAgaWYgKGFyeSA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBbdmFsdWVdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYXJ5LiQkaXNfYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFyeTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAkcmFpc2UoT3BhbC5UeXBlRXJyb3IsIFwiQ2FuJ3QgY29udmVydCBcIiArIHZhbHVlLiQkY2xhc3MgK1xuICAgICAgICAgIFwiIHRvIEFycmF5IChcIiArIHZhbHVlLiQkY2xhc3MgKyBcIiN0b19hIGdpdmVzIFwiICsgYXJ5LiQkY2xhc3MgKyBcIilcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgfVxuICB9O1xuXG4gIC8vIFVzZWQgZm9yIGV4dHJhY3Rpbmcga2V5d29yZCBhcmd1bWVudHMgZnJvbSBhcmd1bWVudHMgcGFzc2VkIHRvXG4gIC8vIEpTIGZ1bmN0aW9uLlxuICAvL1xuICAvLyBAcGFyYW0gcGFyYW1ldGVycyBbQXJyYXldXG4gIC8vIEByZXR1cm4gW0hhc2hdIG9yIHVuZGVmaW5lZFxuICAvL1xuICBPcGFsLmV4dHJhY3Rfa3dhcmdzID0gZnVuY3Rpb24ocGFyYW1ldGVycykge1xuICAgIHZhciBrd2FyZ3MgPSBwYXJhbWV0ZXJzW3BhcmFtZXRlcnMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGt3YXJncyAhPSBudWxsICYmIE9wYWwucmVzcG9uZF90byhrd2FyZ3MsICckdG9faGFzaCcsIHRydWUpKSB7XG4gICAgICAkc3BsaWNlKHBhcmFtZXRlcnMsIHBhcmFtZXRlcnMubGVuZ3RoIC0gMSk7XG4gICAgICByZXR1cm4ga3dhcmdzO1xuICAgIH1cbiAgfTtcblxuICAvLyBVc2VkIHRvIGdldCBhIGxpc3Qgb2YgcmVzdCBrZXl3b3JkIGFyZ3VtZW50cy4gTWV0aG9kIHRha2VzIHRoZSBnaXZlblxuICAvLyBrZXl3b3JkIGFyZ3MsIGkuZS4gdGhlIGhhc2ggbGl0ZXJhbCBwYXNzZWQgdG8gdGhlIG1ldGhvZCBjb250YWluaW5nIGFsbFxuICAvLyBrZXl3b3JkIGFyZ3VtZW50cyBwYXNzZWQgdG8gbWV0aG9kLCBhcyB3ZWxsIGFzIHRoZSB1c2VkIGFyZ3Mgd2hpY2ggYXJlXG4gIC8vIHRoZSBuYW1lcyBvZiByZXF1aXJlZCBhbmQgb3B0aW9uYWwgYXJndW1lbnRzIGRlZmluZWQuIFRoaXMgbWV0aG9kIHRoZW5cbiAgLy8ganVzdCByZXR1cm5zIGFsbCBrZXkvdmFsdWUgcGFpcnMgd2hpY2ggaGF2ZSBub3QgYmVlbiB1c2VkLCBpbiBhIG5ld1xuICAvLyBoYXNoIGxpdGVyYWwuXG4gIC8vXG4gIC8vIEBwYXJhbSBnaXZlbl9hcmdzIFtIYXNoXSBhbGwga3dhcmdzIGdpdmVuIHRvIG1ldGhvZFxuICAvLyBAcGFyYW0gdXNlZF9hcmdzIFtPYmplY3Q8U3RyaW5nOiB0cnVlPl0gYWxsIGtleXMgdXNlZCBhcyBuYW1lZCBrd2FyZ3NcbiAgLy8gQHJldHVybiBbSGFzaF1cbiAgLy9cbiAgT3BhbC5rd3Jlc3RhcmdzID0gZnVuY3Rpb24oZ2l2ZW5fYXJncywgdXNlZF9hcmdzKSB7XG4gICAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcblxuICAgIE9wYWwuaGFzaF9lYWNoKGdpdmVuX2FyZ3MsIGZhbHNlLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoIXVzZWRfYXJnc1trZXldKSB7XG4gICAgICAgIE9wYWwuaGFzaF9wdXQobWFwLCBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbZmFsc2UsIGZhbHNlXTtcbiAgICB9KTtcblxuICAgIHJldHVybiBtYXA7XG4gIH07XG5cbiAgZnVuY3Rpb24gYXBwbHlfYmxvY2tvcHRzKGJsb2NrLCBibG9ja29wdHMpIHtcbiAgICBpZiAodHlwZW9mKGJsb2Nrb3B0cykgPT09ICdudW1iZXInKSB7XG4gICAgICBibG9jay4kJGFyaXR5ID0gYmxvY2tvcHRzO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YoYmxvY2tvcHRzKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oYmxvY2ssIGJsb2Nrb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgLy8gT3B0aW1pemF0aW9uIGZvciBhIGNvc3RseSBvcGVyYXRpb24gb2YgcHJlcGVuZGluZyAnJCcgdG8gbWV0aG9kIG5hbWVzXG4gIHZhciBqc2lkX2NhY2hlID0gbmV3IE1hcCgpO1xuICBmdW5jdGlvbiAkanNpZChuYW1lKSB7XG4gICAgdmFyIGpzaWQgPSBqc2lkX2NhY2hlLmdldChuYW1lKTtcbiAgICBpZiAoIWpzaWQpIHtcbiAgICAgIGpzaWQgPSAnJCcgKyBuYW1lO1xuICAgICAganNpZF9jYWNoZS5zZXQobmFtZSwganNpZCk7XG4gICAgfVxuICAgIHJldHVybiBqc2lkO1xuICB9XG4gIE9wYWwuanNpZCA9ICRqc2lkO1xuXG4gIGZ1bmN0aW9uICRwcmVwZW5kKGZpcnN0LCBzZWNvbmQpIHtcbiAgICBpZiAoIXNlY29uZC4kJGlzX2FycmF5KSBzZWNvbmQgPSAkc2xpY2Uoc2Vjb25kKTtcbiAgICByZXR1cm4gW2ZpcnN0XS5jb25jYXQoc2Vjb25kKTtcbiAgfVxuXG4gIC8vIENhbGxzIHBhc3NlZCBtZXRob2Qgb24gYSBydWJ5IG9iamVjdCB3aXRoIGFyZ3VtZW50cyBhbmQgYmxvY2s6XG4gIC8vXG4gIC8vIENhbiB0YWtlIGEgbWV0aG9kIG9yIGEgbWV0aG9kIG5hbWUuXG4gIC8vXG4gIC8vIDEuIFdoZW4gbWV0aG9kIG5hbWUgZ2V0cyBwYXNzZWQgaXQgaW52b2tlcyBpdCBieSBpdHMgbmFtZVxuICAvLyAgICBhbmQgY2FsbHMgJ21ldGhvZF9taXNzaW5nJyB3aGVuIG9iamVjdCBkb2Vzbid0IGhhdmUgdGhpcyBtZXRob2QuXG4gIC8vICAgIFVzZWQgaW50ZXJuYWxseSBieSBPcGFsIHRvIGludm9rZSBtZXRob2QgdGhhdCB0YWtlcyBhIGJsb2NrIG9yIGEgc3BsYXQuXG4gIC8vIDIuIFdoZW4gbWV0aG9kIChpLmUuIG1ldGhvZCBib2R5KSBnZXRzIHBhc3NlZCwgaXQgZG9lc24ndCB0cmlnZ2VyICdtZXRob2RfbWlzc2luZydcbiAgLy8gICAgYmVjYXVzZSBpdCBkb2Vzbid0IGtub3cgdGhlIG5hbWUgb2YgdGhlIGFjdHVhbCBtZXRob2QuXG4gIC8vICAgIFVzZWQgaW50ZXJuYWxseSBieSBPcGFsIHRvIGludm9rZSAnc3VwZXInLlxuICAvL1xuICAvLyBAZXhhbXBsZVxuICAvLyAgIHZhciBteV9hcnJheSA9IFsxLCAyLCAzLCA0XVxuICAvLyAgIE9wYWwuc2VuZChteV9hcnJheSwgJ2xlbmd0aCcpICAgICAgICAgICAgICAgICAgICAjID0+IDRcbiAgLy8gICBPcGFsLnNlbmQobXlfYXJyYXksIG15X2FycmF5LiRsZW5ndGgpICAgICAgICAgICAgIyA9PiA0XG4gIC8vXG4gIC8vICAgT3BhbC5zZW5kKG15X2FycmF5LCAncmV2ZXJzZSEnKSAgICAgICAgICAgICAgICAgICMgPT4gWzQsIDMsIDIsIDFdXG4gIC8vICAgT3BhbC5zZW5kKG15X2FycmF5LCBteV9hcnJheVsnJHJldmVyc2UhJ10nKSAgICAgICMgPT4gWzQsIDMsIDIsIDFdXG4gIC8vXG4gIC8vIEBwYXJhbSByZWN2IFtPYmplY3RdIHJ1Ynkgb2JqZWN0XG4gIC8vIEBwYXJhbSBtZXRob2QgW0Z1bmN0aW9uLCBTdHJpbmddIG1ldGhvZCBib2R5IG9yIG5hbWUgb2YgdGhlIG1ldGhvZFxuICAvLyBAcGFyYW0gYXJncyBbQXJyYXldIGFyZ3VtZW50cyB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBtZXRob2QgY2FsbFxuICAvLyBAcGFyYW0gYmxvY2sgW0Z1bmN0aW9uXSBydWJ5IGJsb2NrXG4gIC8vIEBwYXJhbSBibG9ja29wdHMgW09iamVjdCwgTnVtYmVyXSBvcHRpb25hbCBwcm9wZXJ0aWVzIHRvIHNldCBvbiB0aGUgYmxvY2tcbiAgLy8gQHJldHVybiBbT2JqZWN0XSByZXR1cm5pbmcgdmFsdWUgb2YgdGhlIG1ldGhvZCBjYWxsXG4gIE9wYWwuc2VuZCA9IGZ1bmN0aW9uKHJlY3YsIG1ldGhvZCwgYXJncywgYmxvY2ssIGJsb2Nrb3B0cykge1xuICAgIHZhciBib2R5O1xuXG4gICAgaWYgKHR5cGVvZihtZXRob2QpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBib2R5ID0gbWV0aG9kO1xuICAgICAgbWV0aG9kID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZihtZXRob2QpID09PSAnc3RyaW5nJykge1xuICAgICAgYm9keSA9IHJlY3ZbJGpzaWQobWV0aG9kKV07XG4gICAgfSBlbHNlIHtcbiAgICAgICRyYWlzZShPcGFsLk5hbWVFcnJvciwgXCJQYXNzZWQgbWV0aG9kIHNob3VsZCBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBPcGFsLnNlbmQyKHJlY3YsIGJvZHksIG1ldGhvZCwgYXJncywgYmxvY2ssIGJsb2Nrb3B0cyk7XG4gIH07XG5cbiAgT3BhbC5zZW5kMiA9IGZ1bmN0aW9uKHJlY3YsIGJvZHksIG1ldGhvZCwgYXJncywgYmxvY2ssIGJsb2Nrb3B0cykge1xuICAgIGlmIChib2R5ID09IG51bGwgJiYgbWV0aG9kICE9IG51bGwgJiYgcmVjdi4kbWV0aG9kX21pc3NpbmcpIHtcbiAgICAgIGJvZHkgPSByZWN2LiRtZXRob2RfbWlzc2luZztcbiAgICAgIGFyZ3MgPSAkcHJlcGVuZChtZXRob2QsIGFyZ3MpO1xuICAgIH1cblxuICAgIGFwcGx5X2Jsb2Nrb3B0cyhibG9jaywgYmxvY2tvcHRzKTtcblxuICAgIGlmICh0eXBlb2YgYmxvY2sgPT09ICdmdW5jdGlvbicpIGJvZHkuJCRwID0gYmxvY2s7XG4gICAgcmV0dXJuIGJvZHkuYXBwbHkocmVjdiwgYXJncyk7XG4gIH07XG5cbiAgT3BhbC5yZWZpbmVkX3NlbmQgPSBmdW5jdGlvbihyZWZpbmVtZW50X2dyb3VwcywgcmVjdiwgbWV0aG9kLCBhcmdzLCBibG9jaywgYmxvY2tvcHRzKSB7XG4gICAgdmFyIGksIGosIGssIGFuY2VzdG9ycywgYW5jZXN0b3IsIHJlZmluZW1lbnRzLCByZWZpbmVtZW50LCByZWZpbmVfbW9kdWxlcywgcmVmaW5lX21vZHVsZSwgYm9keTtcblxuICAgIGFuY2VzdG9ycyA9IGdldF9hbmNlc3RvcnMocmVjdik7XG5cbiAgICAvLyBGb3IgYWxsIGFuY2VzdG9ycyB0aGF0IHRoZXJlIGFyZSwgc3RhcnRpbmcgZnJvbSB0aGUgY2xvc2VzdCB0byB0aGUgZnVydGhlc3QuLi5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhbmNlc3RvciA9IE9wYWwuaWQoYW5jZXN0b3JzW2ldKTtcblxuICAgICAgLy8gRm9yIGFsbCByZWZpbmVtZW50IGdyb3VwcyB0aGVyZSBhcmUsIHN0YXJ0aW5nIGZyb20gdGhlIGNsb3Nlc3Qgc2NvcGUgdG8gdGhlIGZ1cnRoZXN0Li4uXG4gICAgICBmb3IgKGogPSAwOyBqIDwgcmVmaW5lbWVudF9ncm91cHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcmVmaW5lbWVudHMgPSByZWZpbmVtZW50X2dyb3Vwc1tqXTtcblxuICAgICAgICAvLyBGb3IgYWxsIHJlZmluZW1lbnRzIHRoZXJlIGFyZSwgc3RhcnRpbmcgZnJvbSB0aGUgbGFzdCBgdXNpbmdgIGNhbGwgdG8gdGhlIGZ1cnRoZXN0Li4uXG4gICAgICAgIGZvciAoayA9IHJlZmluZW1lbnRzLmxlbmd0aCAtIDE7IGsgPj0gMDsgay0tKSB7XG4gICAgICAgICAgcmVmaW5lbWVudCA9IHJlZmluZW1lbnRzW2tdO1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVmaW5lbWVudC4kJHJlZmluZV9tb2R1bGVzID09PSAndW5kZWZpbmVkJykgY29udGludWU7XG5cbiAgICAgICAgICAvLyBBIHNpbmdsZSBtb2R1bGUgYmVpbmcgZ2l2ZW4gYXMgYW4gYXJndW1lbnQgb2YgdGhlIGB1c2luZ2AgY2FsbCBjb250YWlucyBtdWx0aXBsZVxuICAgICAgICAgIC8vIHJlZmluZW1lbnQgbW9kdWxlc1xuICAgICAgICAgIHJlZmluZV9tb2R1bGVzID0gcmVmaW5lbWVudC4kJHJlZmluZV9tb2R1bGVzO1xuXG4gICAgICAgICAgLy8gRG9lcyB0aGlzIG1vZHVsZSByZWZpbmUgYSBnaXZlbiBjYWxsIGZvciBhIGdpdmVuIGFuY2VzdG9yIG1vZHVsZT9cbiAgICAgICAgICBpZiAodHlwZW9mIHJlZmluZV9tb2R1bGVzW2FuY2VzdG9yXSA9PT0gJ3VuZGVmaW5lZCcpIGNvbnRpbnVlO1xuICAgICAgICAgIHJlZmluZV9tb2R1bGUgPSByZWZpbmVfbW9kdWxlc1thbmNlc3Rvcl07XG5cbiAgICAgICAgICAvLyBEb2VzIHRoaXMgbW9kdWxlIGRlZmluZSBhIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGw/XG4gICAgICAgICAgaWYgKHR5cGVvZiByZWZpbmVfbW9kdWxlLiQkcHJvdG90eXBlWyRqc2lkKG1ldGhvZCldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgYm9keSA9IHJlZmluZV9tb2R1bGUuJCRwcm90b3R5cGVbJGpzaWQobWV0aG9kKV07XG4gICAgICAgICAgICByZXR1cm4gT3BhbC5zZW5kMihyZWN2LCBib2R5LCBtZXRob2QsIGFyZ3MsIGJsb2NrLCBibG9ja29wdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBPcGFsLnNlbmQocmVjdiwgbWV0aG9kLCBhcmdzLCBibG9jaywgYmxvY2tvcHRzKTtcbiAgfTtcblxuICBPcGFsLmxhbWJkYSA9IGZ1bmN0aW9uKGJsb2NrLCBibG9ja29wdHMpIHtcbiAgICBibG9jay4kJGlzX2xhbWJkYSA9IHRydWU7XG5cbiAgICBhcHBseV9ibG9ja29wdHMoYmxvY2ssIGJsb2Nrb3B0cyk7XG5cbiAgICByZXR1cm4gYmxvY2s7XG4gIH07XG5cbiAgLy8gVXNlZCB0byBkZWZpbmUgbWV0aG9kcyBvbiBhbiBvYmplY3QuIFRoaXMgaXMgYSBoZWxwZXIgbWV0aG9kLCB1c2VkIGJ5IHRoZVxuICAvLyBjb21waWxlZCBzb3VyY2UgdG8gZGVmaW5lIG1ldGhvZHMgb24gc3BlY2lhbCBjYXNlIG9iamVjdHMgd2hlbiB0aGUgY29tcGlsZXJcbiAgLy8gY2FuIG5vdCBkZXRlcm1pbmUgdGhlIGRlc3RpbmF0aW9uIG9iamVjdCwgb3IgdGhlIG9iamVjdCBpcyBhIE1vZHVsZVxuICAvLyBpbnN0YW5jZS4gVGhpcyBjYW4gZ2V0IGNhbGxlZCBieSBgTW9kdWxlI2RlZmluZV9tZXRob2RgIGFzIHdlbGwuXG4gIC8vXG4gIC8vICMjIE1vZHVsZXNcbiAgLy9cbiAgLy8gQW55IG1ldGhvZCBkZWZpbmVkIG9uIGEgbW9kdWxlIHdpbGwgY29tZSB0aHJvdWdoIHRoaXMgcnVudGltZSBoZWxwZXIuXG4gIC8vIFRoZSBtZXRob2QgaXMgYWRkZWQgdG8gdGhlIG1vZHVsZSBib2R5LCBhbmQgdGhlIG93bmVyIG9mIHRoZSBtZXRob2QgaXNcbiAgLy8gc2V0IHRvIGJlIHRoZSBtb2R1bGUgaXRzZWxmLiBUaGlzIGlzIHVzZWQgbGF0ZXIgd2hlbiBjaG9vc2luZyB3aGljaFxuICAvLyBtZXRob2Qgc2hvdWxkIHNob3cgb24gYSBjbGFzcyBpZiBtb3JlIHRoYW4gMSBpbmNsdWRlZCBtb2R1bGVzIGRlZmluZVxuICAvLyB0aGUgc2FtZSBtZXRob2QuIEZpbmFsbHksIGlmIHRoZSBtb2R1bGUgaXMgaW4gYG1vZHVsZV9mdW5jdGlvbmAgbW9kZSxcbiAgLy8gdGhlbiB0aGUgbWV0aG9kIGlzIGFsc28gZGVmaW5lZCBvbnRvIHRoZSBtb2R1bGUgaXRzZWxmLlxuICAvL1xuICAvLyAjIyBDbGFzc2VzXG4gIC8vXG4gIC8vIFRoaXMgaGVscGVyIHdpbGwgb25seSBiZSBjYWxsZWQgZm9yIGNsYXNzZXMgd2hlbiBhIG1ldGhvZCBpcyBiZWluZ1xuICAvLyBkZWZpbmVkIGluZGlyZWN0bHk7IGVpdGhlciB0aHJvdWdoIGBNb2R1bGUjZGVmaW5lX21ldGhvZGAsIG9yIGJ5IGFcbiAgLy8gbGl0ZXJhbCBgZGVmYCBtZXRob2QgaW5zaWRlIGFuIGBpbnN0YW5jZV9ldmFsYCBvciBgY2xhc3NfZXZhbGAgYm9keS4gSW5cbiAgLy8gZWl0aGVyIGNhc2UsIHRoZSBtZXRob2QgaXMgc2ltcGx5IGFkZGVkIHRvIHRoZSBjbGFzcycgcHJvdG90eXBlLiBBIHNwZWNpYWxcbiAgLy8gZXhjZXB0aW9uIGV4aXN0cyBmb3IgYEJhc2ljT2JqZWN0YCBhbmQgYE9iamVjdGAuIFRoZXNlIHR3byBjbGFzc2VzIGFyZVxuICAvLyBzcGVjaWFsIGJlY2F1c2UgdGhleSBhcmUgdXNlZCBpbiB0b2xsLWZyZWUgYnJpZGdlZCBjbGFzc2VzLiBJbiBlYWNoIG9mXG4gIC8vIHRoZXNlIHR3byBjYXNlcywgZXh0cmEgd29yayBpcyByZXF1aXJlZCB0byBkZWZpbmUgdGhlIG1ldGhvZHMgb24gdG9sbC1mcmVlXG4gIC8vIGJyaWRnZWQgY2xhc3MnIHByb3RvdHlwZXMgYXMgd2VsbC5cbiAgLy9cbiAgLy8gIyMgT2JqZWN0c1xuICAvL1xuICAvLyBJZiBhIHNpbXBsZSBydWJ5IG9iamVjdCBpcyB0aGUgb2JqZWN0LCB0aGVuIHRoZSBtZXRob2QgaXMgc2ltcGx5IGp1c3RcbiAgLy8gZGVmaW5lZCBvbiB0aGUgb2JqZWN0IGFzIGEgc2luZ2xldG9uIG1ldGhvZC4gVGhpcyB3b3VsZCBiZSB0aGUgY2FzZSB3aGVuXG4gIC8vIGEgbWV0aG9kIGlzIGRlZmluZWQgaW5zaWRlIGFuIGBpbnN0YW5jZV9ldmFsYCBibG9jay5cbiAgLy9cbiAgLy8gQHBhcmFtIG9iaiAgW09iamVjdCwgQ2xhc3NdIHRoZSBhY3R1YWwgb2JqIHRvIGRlZmluZSBtZXRob2QgZm9yXG4gIC8vIEBwYXJhbSBqc2lkIFtTdHJpbmddIHRoZSBKYXZhU2NyaXB0IGZyaWVuZGx5IG1ldGhvZCBuYW1lIChlLmcuICckZm9vJylcbiAgLy8gQHBhcmFtIGJvZHkgW0pTLkZ1bmN0aW9uXSB0aGUgbGl0ZXJhbCBKYXZhU2NyaXB0IGZ1bmN0aW9uIHVzZWQgYXMgbWV0aG9kXG4gIC8vIEBwYXJhbSBibG9ja29wdHMgW09iamVjdCwgTnVtYmVyXSBvcHRpb25hbCBwcm9wZXJ0aWVzIHRvIHNldCBvbiB0aGUgYm9keVxuICAvLyBAcmV0dXJuIFtudWxsXVxuICAvL1xuICBPcGFsLmRlZiA9IGZ1bmN0aW9uKG9iaiwganNpZCwgYm9keSwgYmxvY2tvcHRzKSB7XG4gICAgYXBwbHlfYmxvY2tvcHRzKGJvZHksIGJsb2Nrb3B0cyk7XG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgbWV0aG9kIGRlZmluaXRpb24gaW4gdGhlXG4gICAgLy8gdG9wLWxldmVsIG5hbWVzcGFjZVxuICAgIGlmIChvYmogPT09IE9wYWwudG9wKSB7XG4gICAgICByZXR1cm4gT3BhbC5kZWZuKE9wYWwuT2JqZWN0LCBqc2lkLCBib2R5KTtcbiAgICB9XG4gICAgLy8gaWYgaW5zdGFuY2VfZXZhbCBpcyBpbnZva2VkIG9uIGEgbW9kdWxlL2NsYXNzLCBpdCBzZXRzIGluc3RfZXZhbF9tb2RcbiAgICBlbHNlIGlmICghb2JqLiQkZXZhbCAmJiBvYmouJCRpc19hX21vZHVsZSkge1xuICAgICAgcmV0dXJuIE9wYWwuZGVmbihvYmosIGpzaWQsIGJvZHkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBPcGFsLmRlZnMob2JqLCBqc2lkLCBib2R5KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRGVmaW5lIG1ldGhvZCBvbiBhIG1vZHVsZSBvciBjbGFzcyAoc2VlIE9wYWwuZGVmKS5cbiAgT3BhbC5kZWZuID0gZnVuY3Rpb24obW9kdWxlLCBqc2lkLCBib2R5KSB7XG4gICAgJGRlbnlfZnJvemVuX2FjY2Vzcyhtb2R1bGUpO1xuXG4gICAgYm9keS5kaXNwbGF5TmFtZSA9IGpzaWQ7XG4gICAgYm9keS4kJG93bmVyID0gbW9kdWxlO1xuXG4gICAgdmFyIG5hbWUgPSBqc2lkLnN1YnN0cigxKTtcblxuICAgIHZhciBwcm90byA9IG1vZHVsZS4kJHByb3RvdHlwZTtcbiAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgcHJvdG8gPSBwcm90by4kJGRlZmluZV9tZXRob2RzX29uO1xuICAgIH1cbiAgICAkcHJvcChwcm90bywganNpZCwgYm9keSk7XG5cbiAgICBpZiAobW9kdWxlLiQkaXNfbW9kdWxlKSB7XG4gICAgICBpZiAobW9kdWxlLiQkbW9kdWxlX2Z1bmN0aW9uKSB7XG4gICAgICAgIE9wYWwuZGVmcyhtb2R1bGUsIGpzaWQsIGJvZHkpXG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBpY2xhc3NlcyA9IG1vZHVsZS4kJGljbGFzc2VzLCBsZW5ndGggPSBpY2xhc3Nlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWNsYXNzID0gaWNsYXNzZXNbaV07XG4gICAgICAgICRwcm9wKGljbGFzcywganNpZCwgYm9keSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNpbmdsZXRvbl9vZiA9IG1vZHVsZS4kJHNpbmdsZXRvbl9vZjtcbiAgICBpZiAobW9kdWxlLiRtZXRob2RfYWRkZWQgJiYgIW1vZHVsZS4kbWV0aG9kX2FkZGVkLiQkc3R1YiAmJiAhc2luZ2xldG9uX29mKSB7XG4gICAgICBtb2R1bGUuJG1ldGhvZF9hZGRlZChuYW1lKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2luZ2xldG9uX29mICYmIHNpbmdsZXRvbl9vZi4kc2luZ2xldG9uX21ldGhvZF9hZGRlZCAmJiAhc2luZ2xldG9uX29mLiRzaW5nbGV0b25fbWV0aG9kX2FkZGVkLiQkc3R1Yikge1xuICAgICAgc2luZ2xldG9uX29mLiRzaW5nbGV0b25fbWV0aG9kX2FkZGVkKG5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lO1xuICB9O1xuXG4gIC8vIERlZmluZSBhIHNpbmdsZXRvbiBtZXRob2Qgb24gdGhlIGdpdmVuIG9iamVjdCAoc2VlIE9wYWwuZGVmKS5cbiAgT3BhbC5kZWZzID0gZnVuY3Rpb24ob2JqLCBqc2lkLCBib2R5LCBibG9ja29wdHMpIHtcbiAgICBhcHBseV9ibG9ja29wdHMoYm9keSwgYmxvY2tvcHRzKTtcblxuICAgIGlmIChvYmouJCRpc19zdHJpbmcgfHwgb2JqLiQkaXNfbnVtYmVyKSB7XG4gICAgICAkcmFpc2UoT3BhbC5UeXBlRXJyb3IsIFwiY2FuJ3QgZGVmaW5lIHNpbmdsZXRvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIE9wYWwuZGVmbihPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob2JqKSwganNpZCwgYm9keSk7XG4gIH07XG5cbiAgLy8gU2luY2UgSmF2YVNjcmlwdCBoYXMgbm8gY29uY2VwdCBvZiBtb2R1bGVzLCB3ZSBjcmVhdGUgcHJveHkgY2xhc3Nlc1xuICAvLyBjYWxsZWQgYGljbGFzc2VzYCB0aGF0IHN0b3JlIGNvcGllcyBvZiBtZXRob2RzIGxvYWRlZC4gV2UgbmVlZCB0b1xuICAvLyB1cGRhdGUgdGhlbSBpZiB3ZSByZW1vdmUgYSBtZXRob2QuXG4gIGZ1bmN0aW9uIHJlbW92ZV9tZXRob2RfZnJvbV9pY2xhc3NlcyhvYmosIGpzaWQpIHtcbiAgICBpZiAob2JqLiQkaXNfbW9kdWxlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWNsYXNzZXMgPSBvYmouJCRpY2xhc3NlcywgbGVuZ3RoID0gaWNsYXNzZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGljbGFzcyA9IGljbGFzc2VzW2ldO1xuICAgICAgICBkZWxldGUgaWNsYXNzW2pzaWRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENhbGxlZCBmcm9tICNyZW1vdmVfbWV0aG9kLlxuICBPcGFsLnJkZWYgPSBmdW5jdGlvbihvYmosIGpzaWQpIHtcbiAgICBpZiAoISRoYXNfb3duKG9iai4kJHByb3RvdHlwZSwganNpZCkpIHtcbiAgICAgICRyYWlzZShPcGFsLk5hbWVFcnJvciwgXCJtZXRob2QgJ1wiICsganNpZC5zdWJzdHIoMSkgKyBcIicgbm90IGRlZmluZWQgaW4gXCIgKyBvYmouJG5hbWUoKSk7XG4gICAgfVxuXG4gICAgZGVsZXRlIG9iai4kJHByb3RvdHlwZVtqc2lkXTtcblxuICAgIHJlbW92ZV9tZXRob2RfZnJvbV9pY2xhc3NlcyhvYmosIGpzaWQpO1xuXG4gICAgaWYgKG9iai4kJGlzX3NpbmdsZXRvbikge1xuICAgICAgaWYgKG9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF9yZW1vdmVkICYmICFvYmouJCRwcm90b3R5cGUuJHNpbmdsZXRvbl9tZXRob2RfcmVtb3ZlZC4kJHN0dWIpIHtcbiAgICAgICAgb2JqLiQkcHJvdG90eXBlLiRzaW5nbGV0b25fbWV0aG9kX3JlbW92ZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChvYmouJG1ldGhvZF9yZW1vdmVkICYmICFvYmouJG1ldGhvZF9yZW1vdmVkLiQkc3R1Yikge1xuICAgICAgICBvYmouJG1ldGhvZF9yZW1vdmVkKGpzaWQuc3Vic3RyKDEpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gQ2FsbGVkIGZyb20gI3VuZGVmX21ldGhvZC5cbiAgT3BhbC51ZGVmID0gZnVuY3Rpb24ob2JqLCBqc2lkKSB7XG4gICAgaWYgKCFvYmouJCRwcm90b3R5cGVbanNpZF0gfHwgb2JqLiQkcHJvdG90eXBlW2pzaWRdLiQkc3R1Yikge1xuICAgICAgJHJhaXNlKE9wYWwuTmFtZUVycm9yLCBcIm1ldGhvZCAnXCIgKyBqc2lkLnN1YnN0cigxKSArIFwiJyBub3QgZGVmaW5lZCBpbiBcIiArIG9iai4kbmFtZSgpKTtcbiAgICB9XG5cbiAgICBPcGFsLmFkZF9zdHViX2ZvcihvYmouJCRwcm90b3R5cGUsIGpzaWQpO1xuXG4gICAgcmVtb3ZlX21ldGhvZF9mcm9tX2ljbGFzc2VzKG9iaiwganNpZCk7XG5cbiAgICBpZiAob2JqLiQkaXNfc2luZ2xldG9uKSB7XG4gICAgICBpZiAob2JqLiQkcHJvdG90eXBlLiRzaW5nbGV0b25fbWV0aG9kX3VuZGVmaW5lZCAmJiAhb2JqLiQkcHJvdG90eXBlLiRzaW5nbGV0b25fbWV0aG9kX3VuZGVmaW5lZC4kJHN0dWIpIHtcbiAgICAgICAgb2JqLiQkcHJvdG90eXBlLiRzaW5nbGV0b25fbWV0aG9kX3VuZGVmaW5lZChqc2lkLnN1YnN0cigxKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKG9iai4kbWV0aG9kX3VuZGVmaW5lZCAmJiAhb2JqLiRtZXRob2RfdW5kZWZpbmVkLiQkc3R1Yikge1xuICAgICAgICBvYmouJG1ldGhvZF91bmRlZmluZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBpc19tZXRob2RfYm9keShib2R5KSB7XG4gICAgcmV0dXJuICh0eXBlb2YoYm9keSkgPT09IFwiZnVuY3Rpb25cIiAmJiAhYm9keS4kJHN0dWIpO1xuICB9XG5cbiAgT3BhbC5hbGlhcyA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgb2xkKSB7XG4gICAgdmFyIGlkICAgICA9ICRqc2lkKG5hbWUpLFxuICAgICAgICBvbGRfaWQgPSAkanNpZChvbGQpLFxuICAgICAgICBib2R5LFxuICAgICAgICBhbGlhcztcblxuICAgIC8vIEFsaWFzaW5nIG9uIG1haW4gbWVhbnMgYWxpYXNpbmcgb24gT2JqZWN0Li4uXG4gICAgaWYgKHR5cGVvZiBvYmouJCRwcm90b3R5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvYmogPSBPcGFsLk9iamVjdDtcbiAgICB9XG5cbiAgICBib2R5ID0gb2JqLiQkcHJvdG90eXBlW29sZF9pZF07XG5cbiAgICAvLyBXaGVuIHJ1bm5pbmcgaW5zaWRlICNpbnN0YW5jZV9ldmFsIHRoZSBhbGlhcyByZWZlcnMgdG8gY2xhc3MgbWV0aG9kcy5cbiAgICBpZiAob2JqLiQkZXZhbCkge1xuICAgICAgcmV0dXJuIE9wYWwuYWxpYXMoT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzKG9iaiksIG5hbWUsIG9sZCk7XG4gICAgfVxuXG4gICAgaWYgKCFpc19tZXRob2RfYm9keShib2R5KSkge1xuICAgICAgdmFyIGFuY2VzdG9yID0gb2JqLiQkc3VwZXI7XG5cbiAgICAgIHdoaWxlICh0eXBlb2YoYm9keSkgIT09IFwiZnVuY3Rpb25cIiAmJiBhbmNlc3Rvcikge1xuICAgICAgICBib2R5ICAgICA9IGFuY2VzdG9yW29sZF9pZF07XG4gICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IuJCRzdXBlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc19tZXRob2RfYm9keShib2R5KSAmJiBvYmouJCRpc19tb2R1bGUpIHtcbiAgICAgICAgLy8gdHJ5IHRvIGxvb2sgaW50byBPYmplY3RcbiAgICAgICAgYm9keSA9IE9wYWwuT2JqZWN0LiQkcHJvdG90eXBlW29sZF9pZF1cbiAgICAgIH1cblxuICAgICAgaWYgKCFpc19tZXRob2RfYm9keShib2R5KSkge1xuICAgICAgICAkcmFpc2UoT3BhbC5OYW1lRXJyb3IsIFwidW5kZWZpbmVkIG1ldGhvZCBgXCIgKyBvbGQgKyBcIicgZm9yIGNsYXNzIGBcIiArIG9iai4kbmFtZSgpICsgXCInXCIpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGJvZHkgaXMgaXRzZWxmIGFuIGFsaWFzIHVzZSB0aGUgb3JpZ2luYWwgYm9keVxuICAgIC8vIHRvIGtlZXAgdGhlIG1heCBkZXB0aCBhdCAxLlxuICAgIGlmIChib2R5LiQkYWxpYXNfb2YpIGJvZHkgPSBib2R5LiQkYWxpYXNfb2Y7XG5cbiAgICAvLyBXZSBuZWVkIGEgd3JhcHBlciBiZWNhdXNlIG90aGVyd2lzZSBwcm9wZXJ0aWVzXG4gICAgLy8gd291bGQgYmUgb3ZlcndyaXR0ZW4gb24gdGhlIG9yaWdpbmFsIGJvZHkuXG4gICAgYWxpYXMgPSBPcGFsLndyYXBfbWV0aG9kX2JvZHkoYm9keSk7XG5cbiAgICAvLyBUcnkgdG8gbWFrZSB0aGUgYnJvd3NlciBwaWNrIHRoZSByaWdodCBuYW1lXG4gICAgYWxpYXMuZGlzcGxheU5hbWUgID0gbmFtZTtcbiAgICBhbGlhcy4kJGFsaWFzX29mICAgPSBib2R5O1xuICAgIGFsaWFzLiQkYWxpYXNfbmFtZSA9IG5hbWU7XG5cbiAgICBPcGFsLmRlZm4ob2JqLCBpZCwgYWxpYXMpO1xuXG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICBPcGFsLndyYXBfbWV0aG9kX2JvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgdmFyIHdyYXBwZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBibG9jayA9IHdyYXBwZWQuJCRwO1xuXG4gICAgICB3cmFwcGVkLiQkcCA9IG51bGw7XG5cbiAgICAgIHJldHVybiBPcGFsLnNlbmQodGhpcywgYm9keSwgYXJndW1lbnRzLCBibG9jayk7XG4gICAgfTtcblxuICAgIC8vIEFzc2lnbiB0aGUgJ2xlbmd0aCcgdmFsdWUgd2l0aCBkZWZpbmVQcm9wZXJ0eSBiZWNhdXNlXG4gICAgLy8gaW4gc3RyaWN0IG1vZGUgdGhlIHByb3BlcnR5IGlzIG5vdCB3cml0YWJsZS5cbiAgICAvLyBJdCBkb2Vzbid0IHdvcmsgaW4gb2xkZXIgYnJvd3NlcnMgKGxpa2UgQ2hyb21lIDM4KSwgd2hlcmVcbiAgICAvLyBhbiBleGNlcHRpb24gaXMgdGhyb3duIGJyZWFraW5nIE9wYWwgYWx0b2dldGhlci5cbiAgICB0cnkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdyYXBwZWQsICdsZW5ndGgnLCB7IHZhbHVlOiBib2R5Lmxlbmd0aCB9KTtcbiAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgd3JhcHBlZC4kJGFyaXR5ICAgICAgICAgICA9IGJvZHkuJCRhcml0eSA9PSBudWxsID8gYm9keS5sZW5ndGggOiBib2R5LiQkYXJpdHk7XG4gICAgd3JhcHBlZC4kJHBhcmFtZXRlcnMgICAgICA9IGJvZHkuJCRwYXJhbWV0ZXJzO1xuICAgIHdyYXBwZWQuJCRzb3VyY2VfbG9jYXRpb24gPSBib2R5LiQkc291cmNlX2xvY2F0aW9uO1xuXG4gICAgcmV0dXJuIHdyYXBwZWQ7XG4gIH07XG5cbiAgT3BhbC5hbGlhc19ndmFyID0gZnVuY3Rpb24obmV3X25hbWUsIG9sZF9uYW1lKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCRndmFycywgbmV3X25hbWUsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJGd2YXJzW29sZF9uYW1lXTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKG5ld192YWx1ZSkge1xuICAgICAgICAkZ3ZhcnNbb2xkX25hbWVdID0gbmV3X3ZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuaWw7XG4gIH1cblxuICBPcGFsLmFsaWFzX25hdGl2ZSA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgbmF0aXZlX25hbWUpIHtcbiAgICB2YXIgaWQgICA9ICRqc2lkKG5hbWUpLFxuICAgICAgICBib2R5ID0gb2JqLiQkcHJvdG90eXBlW25hdGl2ZV9uYW1lXTtcblxuICAgIGlmICh0eXBlb2YoYm9keSkgIT09IFwiZnVuY3Rpb25cIiB8fCBib2R5LiQkc3R1Yikge1xuICAgICAgJHJhaXNlKE9wYWwuTmFtZUVycm9yLCBcInVuZGVmaW5lZCBuYXRpdmUgbWV0aG9kIGBcIiArIG5hdGl2ZV9uYW1lICsgXCInIGZvciBjbGFzcyBgXCIgKyBvYmouJG5hbWUoKSArIFwiJ1wiKVxuICAgIH1cblxuICAgIE9wYWwuZGVmbihvYmosIGlkLCBib2R5KTtcblxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cblxuICAvLyBIYXNoZXNcbiAgLy8gLS0tLS0tXG5cbiAgT3BhbC5oYXNoX2luaXQgPSBmdW5jdGlvbiAoX2hhc2gpIHtcbiAgICBjb25zb2xlLndhcm4oXCJERVBSRUNBVElPTjogT3BhbC5oYXNoX2luaXQgaXMgZGVwcmVjYXRlZCBhbmQgaXMgbm93IGEgbm8tb3AuXCIpO1xuICB9XG5cbiAgT3BhbC5oYXNoX2Nsb25lID0gZnVuY3Rpb24oZnJvbV9oYXNoLCB0b19oYXNoKSB7XG4gICAgdG9faGFzaC4kJG5vbmUgPSBmcm9tX2hhc2guJCRub25lO1xuICAgIHRvX2hhc2guJCRwcm9jID0gZnJvbV9oYXNoLiQkcHJvYztcblxuICAgIHJldHVybiBPcGFsLmhhc2hfZWFjaChmcm9tX2hhc2gsIHRvX2hhc2gsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIE9wYWwuaGFzaF9wdXQodG9faGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICByZXR1cm4gW2ZhbHNlLCB0b19oYXNoXTtcbiAgICB9KTtcbiAgfTtcblxuICBPcGFsLmhhc2hfcHV0ID0gZnVuY3Rpb24oaGFzaCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIGtleTtcbiAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcInN5bWJvbFwiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgfHwgdHlwZSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgaGFzaC5zZXQoa2V5LCB2YWx1ZSlcbiAgICB9IGVsc2UgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgaGFzaC5zZXQoa2V5LnZhbHVlT2YoKSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWhhc2guJCRrZXlzKVxuICAgICAgICBoYXNoLiQka2V5cyA9IG5ldyBNYXAoKTtcblxuICAgICAgdmFyIGtleV9oYXNoID0ga2V5LiQkaXNfc3RyaW5nID8ga2V5LnZhbHVlT2YoKSA6IChoYXNoLiQkYnlfaWRlbnRpdHkgPyBPcGFsLmlkKGtleSkgOiBrZXkuJGhhc2goKSksXG4gICAgICAgICAga2V5cyA9IGhhc2guJCRrZXlzO1xuXG4gICAgICBpZiAoIWtleXMuaGFzKGtleV9oYXNoKSkge1xuICAgICAgICBrZXlzLnNldChrZXlfaGFzaCwgW2tleV0pO1xuICAgICAgICBoYXNoLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2JqZWN0cyA9IGtleXMuZ2V0KGtleV9oYXNoKSxcbiAgICAgICAgICBvYmplY3Q7XG5cbiAgICAgIGZvciAodmFyIGk9MDsgaTxvYmplY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG9iamVjdCA9IG9iamVjdHNbaV07XG4gICAgICAgIGlmIChrZXkgPT09IG9iamVjdCB8fCBrZXlbJyRlcWw/J10ob2JqZWN0KSkge1xuICAgICAgICAgIGhhc2guc2V0KG9iamVjdCwgdmFsdWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvYmplY3RzLnB1c2goa2V5KTtcbiAgICAgIGhhc2guc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICBPcGFsLmhhc2hfZ2V0ID0gZnVuY3Rpb24oaGFzaCwga2V5KSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2Yga2V5O1xuICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwic3ltYm9sXCIgfHwgdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIiB8fCB0eXBlID09PSBcImJpZ2ludFwiKSB7XG4gICAgICByZXR1cm4gaGFzaC5nZXQoa2V5KVxuICAgIH0gZWxzZSBpZiAoaGFzaC4kJGtleXMpIHtcbiAgICAgIHZhciBrZXlfaGFzaCA9IGtleS4kJGlzX3N0cmluZyA/IGtleS52YWx1ZU9mKCkgOiAoaGFzaC4kJGJ5X2lkZW50aXR5ID8gT3BhbC5pZChrZXkpIDoga2V5LiRoYXNoKCkpLFxuICAgICAgICAgIG9iamVjdHMgPSBoYXNoLiQka2V5cy5nZXQoa2V5X2hhc2gpLFxuICAgICAgICAgIG9iamVjdDtcblxuICAgICAgaWYgKG9iamVjdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb3IgKHZhciBpPTA7IGk8b2JqZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG9iamVjdCA9IG9iamVjdHNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gb2JqZWN0IHx8IGtleVsnJGVxbD8nXShvYmplY3QpKVxuICAgICAgICAgICAgcmV0dXJuIGhhc2guZ2V0KG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBoYXNoLmdldChrZXlfaGFzaCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgIHJldHVybiBoYXNoLmdldChrZXkudmFsdWVPZigpKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gJGhhc2hfZGVsZXRlX3N0YWdlMihoYXNoLCBrZXkpIHtcbiAgICB2YXIgdmFsdWUgPSBoYXNoLmdldChrZXkpO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBoYXNoLmRlbGV0ZShrZXkpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIE9wYWwuaGFzaF9kZWxldGUgPSBmdW5jdGlvbihoYXNoLCBrZXkpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBrZXlcbiAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcInN5bWJvbFwiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgfHwgdHlwZSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgcmV0dXJuICRoYXNoX2RlbGV0ZV9zdGFnZTIoaGFzaCwga2V5KTtcbiAgICB9IGVsc2UgaWYgKGhhc2guJCRrZXlzKSB7XG4gICAgICB2YXIga2V5X2hhc2ggPSBrZXkuJCRpc19zdHJpbmcgPyBrZXkudmFsdWVPZigpIDogKGhhc2guJCRieV9pZGVudGl0eSA/IE9wYWwuaWQoa2V5KSA6IGtleS4kaGFzaCgpKSxcbiAgICAgICAgICBvYmplY3RzID0gaGFzaC4kJGtleXMuZ2V0KGtleV9oYXNoKSxcbiAgICAgICAgICBvYmplY3Q7XG5cbiAgICAgIGlmIChvYmplY3RzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPG9iamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBvYmplY3QgPSBvYmplY3RzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09IG9iamVjdCB8fCBrZXlbJyRlcWw/J10ob2JqZWN0KSkge1xuICAgICAgICAgICAgb2JqZWN0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBpZiAob2JqZWN0cy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgIGhhc2guJCRrZXlzLmRlbGV0ZShrZXlfaGFzaCk7XG4gICAgICAgICAgICByZXR1cm4gJGhhc2hfZGVsZXRlX3N0YWdlMihoYXNoLCBvYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuICRoYXNoX2RlbGV0ZV9zdGFnZTIoaGFzaCwga2V5X2hhc2gpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICByZXR1cm4gJGhhc2hfZGVsZXRlX3N0YWdlMihoYXNoLCBrZXkudmFsdWVPZigpKTtcbiAgICB9XG4gIH07XG5cbiAgT3BhbC5oYXNoX3JlaGFzaCA9IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICB2YXIga2V5cyA9IGhhc2guJCRrZXlzO1xuXG4gICAgaWYgKGtleXMpXG4gICAgICBrZXlzLmNsZWFyKCk7XG5cbiAgICBPcGFsLmhhc2hfZWFjaChoYXNoLCBmYWxzZSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2Yga2V5O1xuICAgICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZSA9PT0gXCJzeW1ib2xcIiB8fCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiIHx8IHR5cGUgPT09IFwiYmlnaW50XCIpXG4gICAgICAgIHJldHVybiBbZmFsc2UsIGZhbHNlXTsgLy8gbm90aGluZyB0byByZWhhc2hcblxuICAgICAgdmFyIGtleV9oYXNoID0ga2V5LiQkaXNfc3RyaW5nID8ga2V5LnZhbHVlT2YoKSA6IChoYXNoLiQkYnlfaWRlbnRpdHkgPyBPcGFsLmlkKGtleSkgOiBrZXkuJGhhc2goKSk7XG5cbiAgICAgIGlmICgha2V5cylcbiAgICAgICAgaGFzaC4kJGtleXMgPSBrZXlzID0gbmV3IE1hcCgpO1xuXG4gICAgICBpZiAoIWtleXMuaGFzKGtleV9oYXNoKSkge1xuICAgICAgICBrZXlzLnNldChrZXlfaGFzaCwgW2tleV0pO1xuICAgICAgICByZXR1cm4gW2ZhbHNlLCBmYWxzZV07XG4gICAgICB9XG5cbiAgICAgIHZhciBvYmplY3RzID0ga2V5cy5nZXQoa2V5X2hhc2gpLFxuICAgICAgICAgIG9iamVjdHNfY29weSA9IChvYmplY3RzLmxlbmd0aCA9PT0gMSkgPyBvYmplY3RzIDogJHNsaWNlKG9iamVjdHMpLFxuICAgICAgICAgIG9iamVjdDtcblxuICAgICAgZm9yICh2YXIgaT0wOyBpPG9iamVjdHNfY29weS5sZW5ndGg7IGkrKykge1xuICAgICAgICBvYmplY3QgPSBvYmplY3RzX2NvcHlbaV07XG4gICAgICAgIGlmIChrZXkgPT09IG9iamVjdCB8fCBrZXlbJyRlcWw/J10ob2JqZWN0KSkge1xuICAgICAgICAgIC8vIGdvdCBhIGR1cGxpY2F0ZSwgcmVtb3ZlIGl0XG4gICAgICAgICAgb2JqZWN0cy5zcGxpY2Uob2JqZWN0cy5pbmRleE9mKG9iamVjdCksIDEpO1xuICAgICAgICAgIGhhc2guZGVsZXRlKG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb2JqZWN0cy5wdXNoKGtleSk7XG5cbiAgICAgIHJldHVybiBbZmFsc2UsIGZhbHNlXVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGhhc2g7XG4gIH07XG5cbiAgT3BhbC5oYXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmd1bWVudHNfbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgIGFyZ3MsXG4gICAgICBoYXNoLFxuICAgICAgaSxcbiAgICAgIGxlbmd0aCxcbiAgICAgIGtleSxcbiAgICAgIHZhbHVlO1xuXG4gICAgaWYgKGFyZ3VtZW50c19sZW5ndGggPT09IDEgJiYgYXJndW1lbnRzWzBdLiQkaXNfaGFzaCkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICB9XG5cbiAgICBoYXNoID0gbmV3IE1hcCgpO1xuXG4gICAgaWYgKGFyZ3VtZW50c19sZW5ndGggPT09IDEpIHtcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHNbMF07XG5cbiAgICAgIGlmIChhcmd1bWVudHNbMF0uJCRpc19hcnJheSkge1xuICAgICAgICBsZW5ndGggPSBhcmdzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoYXJnc1tpXS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICRyYWlzZShPcGFsLkFyZ3VtZW50RXJyb3IsICd2YWx1ZSBub3Qgb2YgbGVuZ3RoIDI6ICcgKyBhcmdzW2ldLiRpbnNwZWN0KCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGtleSA9IGFyZ3NbaV1bMF07XG4gICAgICAgICAgdmFsdWUgPSBhcmdzW2ldWzFdO1xuXG4gICAgICAgICAgT3BhbC5oYXNoX3B1dChoYXNoLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgZm9yIChrZXkgaW4gYXJncykge1xuICAgICAgICAgIGlmICgkaGFzX293bihhcmdzLCBrZXkpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGFyZ3Nba2V5XTtcblxuICAgICAgICAgICAgT3BhbC5oYXNoX3B1dChoYXNoLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzX2xlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICRyYWlzZShPcGFsLkFyZ3VtZW50RXJyb3IsICdvZGQgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgSGFzaCcpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHNfbGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGtleSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIHZhbHVlID0gYXJndW1lbnRzW2kgKyAxXTtcblxuICAgICAgT3BhbC5oYXNoX3B1dChoYXNoLCBrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzaDtcbiAgfTtcblxuICAvLyBBIGZhc3RlciBIYXNoIGNyZWF0b3IgZm9yIGhhc2hlcyB0aGF0IGp1c3QgdXNlIHN5bWJvbHMgYW5kXG4gIC8vIHN0cmluZ3MgYXMga2V5cy4gVGhlIG1hcCBhbmQga2V5cyBhcnJheSBjYW4gYmUgY29uc3RydWN0ZWQgYXRcbiAgLy8gY29tcGlsZSB0aW1lLCBzbyB0aGV5IGFyZSBqdXN0IGFkZGVkIGhlcmUgYnkgdGhlIGNvbnN0cnVjdG9yXG4gIC8vIGZ1bmN0aW9uLlxuICAvL1xuICBPcGFsLmhhc2gyID0gZnVuY3Rpb24oa2V5cywgc21hcCkge1xuICAgIGNvbnNvbGUud2FybihcIkRFUFJFQ0FUSU9OOiBgT3BhbC5oYXNoMmAgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIE9wYWwgMi4wLiBVc2UgYG5ldyBNYXAoKWAgd2l0aCBhbiBhcnJheSBvZiBrZXkvdmFsdWUgcGFpcnMgaW5zdGVhZC5cIik7XG5cbiAgICB2YXIgaGFzaCA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbWF4ID0ga2V5cy5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xuICAgICAgaGFzaC5zZXQoa2V5c1tpXSwgc21hcFtrZXlzW2ldXSk7XG4gICAgfVxuICAgIHJldHVybiBoYXNoO1xuICB9O1xuXG4gIE9wYWwuaGFzaF9lYWNoID0gZnVuY3Rpb24gKGhhc2gsIGRyZXMsIGZ1bikge1xuICAgIC8vIGRyZXMgPSBkZWZhdWx0IHJlc3VsdCwgcmV0dXJuZWQgaWYgaGFzaCBpcyBlbXB0eVxuICAgIC8vIGZ1biBpcyBjYWxsZWQgYXMgZnVuKGtleSwgdmFsdWUpIGFuZCBtdXN0IHJldHVybiBhIGFycmF5IHdpdGggW2JyZWFrLCByZXN1bHRdXG4gICAgLy8gaWYgYnJlYWsgaXMgdHJ1ZSwgaXRlcmF0aW9uIHN0b3BzIGFuZCByZXN1bHQgaXMgcmV0dXJuZWRcbiAgICAvLyBpZiBicmVhayBpcyBmYWxzZSwgaXRlcmF0aW9uIGNvbnRpbnVlcyBhbmQgZXZlbnR1YWxseSB0aGUgbGFzdCByZXN1bHQgaXMgcmV0dXJuZWRcbiAgICB2YXIgcmVzO1xuICAgIGZvciAodmFyIGkgPSAwLCBlbnRyeSwgZW50cmllcyA9IEFycmF5LmZyb20oaGFzaC5lbnRyaWVzKCkpLCBsID0gZW50cmllcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGVudHJ5ID0gZW50cmllc1tpXTtcbiAgICAgIHJlcyA9IGZ1bihlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgaWYgKHJlc1swXSkgcmV0dXJuIHJlc1sxXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcyA/IHJlc1sxXSA6IGRyZXM7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgbmV3IHJhbmdlIGluc3RhbmNlIHdpdGggZmlyc3QgYW5kIGxhc3QgdmFsdWVzLCBhbmQgd2hldGhlciB0aGVcbiAgLy8gcmFuZ2UgZXhjbHVkZXMgdGhlIGxhc3QgdmFsdWUuXG4gIC8vXG4gIE9wYWwucmFuZ2UgPSBmdW5jdGlvbihmaXJzdCwgbGFzdCwgZXhjKSB7XG4gICAgdmFyIHJhbmdlICAgICAgICAgPSBuZXcgT3BhbC5SYW5nZSgpO1xuICAgICAgICByYW5nZS5iZWdpbiAgID0gZmlyc3Q7XG4gICAgICAgIHJhbmdlLmVuZCAgICAgPSBsYXN0O1xuICAgICAgICByYW5nZS5leGNsICAgID0gZXhjO1xuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIHZhciByZXNlcnZlZF9pdmFyX25hbWVzID0gW1xuICAgIC8vIHByb3BlcnRpZXNcbiAgICBcImNvbnN0cnVjdG9yXCIsIFwiZGlzcGxheU5hbWVcIiwgXCJfX2NvdW50X19cIiwgXCJfX25vU3VjaE1ldGhvZF9fXCIsXG4gICAgXCJfX3BhcmVudF9fXCIsIFwiX19wcm90b19fXCIsXG4gICAgLy8gbWV0aG9kc1xuICAgIFwiaGFzT3duUHJvcGVydHlcIiwgXCJ2YWx1ZU9mXCJcbiAgXTtcblxuICAvLyBHZXQgdGhlIGl2YXIgbmFtZSBmb3IgYSBnaXZlbiBuYW1lLlxuICAvLyBNb3N0bHkgYWRkcyBhIHRyYWlsaW5nICQgdG8gcmVzZXJ2ZWQgbmFtZXMuXG4gIC8vXG4gIE9wYWwuaXZhciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAocmVzZXJ2ZWRfaXZhcl9uYW1lcy5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgbmFtZSArPSBcIiRcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZTtcbiAgfTtcblxuICAvLyBTdXBwb3J0IGZvciAjZnJlZXplXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBoZWxwZXIgdGhhdCBjYW4gYmUgdXNlZCBmcm9tIG1ldGhvZHNcbiAgZnVuY3Rpb24gJGRlbnlfZnJvemVuX2FjY2VzcyhvYmopIHtcbiAgICBpZiAob2JqLiQkZnJvemVuKSB7XG4gICAgICAkcmFpc2UoT3BhbC5Gcm96ZW5FcnJvciwgXCJjYW4ndCBtb2RpZnkgZnJvemVuIFwiICsgKG9iai4kY2xhc3MoKSkgKyBcIjogXCIgKyAob2JqKSwgbmV3IE1hcChbW1wicmVjZWl2ZXJcIiwgb2JqXV0pKTtcbiAgICB9XG4gIH07XG4gIE9wYWwuZGVueV9mcm96ZW5fYWNjZXNzID0gJGRlbnlfZnJvemVuX2FjY2VzcztcblxuICAvLyBjb21tb24gI2ZyZWV6ZSBydW50aW1lIHN1cHBvcnRcbiAgT3BhbC5mcmVlemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICAkcHJvcChvYmosIFwiJCRmcm96ZW5cIiwgdHJ1ZSk7XG5cbiAgICAvLyBzZXQgJCRpZFxuICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KCckJGlkJykpIHsgJHByb3Aob2JqLCAnJCRpZCcsICR1aWQoKSk7IH1cblxuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoJyQkbWV0YScpKSB7XG4gICAgICAvLyBmcmVlemUgJCRtZXRhIGlmIGl0IGhhcyBhbHJlYWR5IGJlZW4gc2V0XG4gICAgICBvYmouJCRtZXRhLiRmcmVlemUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW5zdXJlICQkbWV0YSBjYW4gYmUgc2V0IGxhemlseSwgJCRtZXRhIGlzIGZyb3plbiB3aGVuIHNldCBpbiBydW50aW1lLmpzXG4gICAgICAkcHJvcChvYmosICckJG1ldGEnLCBudWxsKTtcbiAgICB9XG5cbiAgICAvLyAkJGNvbXBhcmFibGUgaXMgdXNlZCBpbnRlcm5hbGx5IGFuZCBzZXQgbXVsdGlwbGUgdGltZXNcbiAgICAvLyBkZWZpbmluZyBpdCBiZWZvcmUgc2VhbGluZyBlbnN1cmVzIGl0IGNhbiBiZSBtb2RpZmllZCBsYXRlciBvblxuICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KCckJGNvbXBhcmFibGUnKSkgeyAkcHJvcChvYmosICckJGNvbXBhcmFibGUnLCBudWxsKTsgfVxuXG4gICAgLy8gc2VhbCB0aGUgT2JqZWN0XG4gICAgT2JqZWN0LnNlYWwob2JqKTtcblxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gSXRlcmF0ZSBvdmVyIGV2ZXJ5IGluc3RhbmNlIHZhcmlhYmxlIGFuZCBjYWxsIGZ1bmMgZm9yIGVhY2ggb25lXG4gIC8vIGdpdmluZyBuYW1lIG9mIHRoZSBpdmFyIGFuZCBvcHRpb25hbGx5IHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yLlxuICBmdW5jdGlvbiAkZWFjaF9pdmFyKG9iaiwgZnVuYykge1xuICAgIHZhciBvd25fcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLCBvd25fcHJvcHNfbGVuZ3RoID0gb3duX3Byb3BzLmxlbmd0aCwgaSwgcHJvcCwgZGVzYztcblxuICAgIGZvcihpID0gMDsgaSA8IG93bl9wcm9wc19sZW5ndGg7IGkrKykge1xuICAgICAgcHJvcCA9IG93bl9wcm9wc1tpXTtcblxuICAgICAgaWYgKHByb3BbMF0gPT09ICckJykgY29udGludWU7XG5cbiAgICAgIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCk7XG5cbiAgICAgIGlmIChkZXNjICYmIGRlc2MuZW51bWVyYWJsZSkge1xuICAgICAgICBmdW5jKHByb3AsIGRlc2MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIE9wYWwuZWFjaF9pdmFyID0gJGVhY2hfaXZhcjtcblxuICAvLyBmcmV6ZSBwcm9wcywgbWFrZSBzZXR0ZXJzIG9mIGluc3RhbmNlIHZhcmlhYmxlcyB0aHJvdyBGcm96ZW5FcnJvclxuICBPcGFsLmZyZWV6ZV9wcm9wcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBkcF90ZW1wbGF0ZSA9IHtcbiAgICAgIGdldDogbnVsbCxcbiAgICAgIHNldDogZnVuY3Rpb24oX3ZhbCkgeyAkZGVueV9mcm96ZW5fYWNjZXNzKG9iaik7IH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfTtcblxuICAgICRlYWNoX2l2YXIob2JqLCBmdW5jdGlvbihwcm9wLCBkZXNjKSB7XG4gICAgICBpZiAoIWRlc2Mud3JpdGFibGUpIHJldHVybjtcblxuICAgICAgLy8gUmVkZWZpbmUgYSBwcm9wZXJ0eSB3aXRoIGEgc2V0dGVyIHRoYXQgcmFpc2VzIGFuIGVycm9yLlxuICAgICAgZHBfdGVtcGxhdGUuZ2V0ID0gJHJldHVybl92YWwoZGVzYy52YWx1ZSk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIGRwX3RlbXBsYXRlKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBSZWdleHBzXG4gIC8vIC0tLS0tLS1cblxuICAvLyBFc2NhcGUgUmVnZXhwIHNwZWNpYWwgY2hhcnMgbGV0dGluZyB0aGUgcmVzdWx0aW5nIHN0cmluZyBiZSB1c2VkIHRvIGJ1aWxkXG4gIC8vIGEgbmV3IFJlZ2V4cC5cbiAgLy9cbiAgT3BhbC5lc2NhcGVfcmVnZXhwID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oWy1bXFxdXFwve30oKSorPy5eJFxcXFx8IF0pL2csICdcXFxcJDEnKVxuICAgICAgICAgICAgICAucmVwbGFjZSgvW1xcbl0vZywgJ1xcXFxuJylcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHJdL2csICdcXFxccicpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFxmXS9nLCAnXFxcXGYnKVxuICAgICAgICAgICAgICAucmVwbGFjZSgvW1xcdF0vZywgJ1xcXFx0Jyk7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgZ2xvYmFsIFJlZ2V4cCBmcm9tIGEgUmVnRXhwIG9iamVjdCBhbmQgY2FjaGUgdGhlIHJlc3VsdFxuICAvLyBvbiB0aGUgb2JqZWN0IGl0c2VsZiAoJCRnIGF0dHJpYnV0ZSkuXG4gIC8vXG4gIE9wYWwuZ2xvYmFsX3JlZ2V4cCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgICBpZiAocGF0dGVybi5nbG9iYWwpIHtcbiAgICAgIHJldHVybiBwYXR0ZXJuOyAvLyBSZWdFeHAgYWxyZWFkeSBoYXMgdGhlIGdsb2JhbCBmbGFnXG4gICAgfVxuICAgIGlmIChwYXR0ZXJuLiQkZyA9PSBudWxsKSB7XG4gICAgICBwYXR0ZXJuLiQkZyA9IG5ldyBSZWdFeHAocGF0dGVybi5zb3VyY2UsIChwYXR0ZXJuLm11bHRpbGluZSA/ICdnbScgOiAnZycpICsgKHBhdHRlcm4uaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdHRlcm4uJCRnLmxhc3RJbmRleCA9IG51bGw7IC8vIHJlc2V0IGxhc3RJbmRleCBwcm9wZXJ0eVxuICAgIH1cbiAgICByZXR1cm4gcGF0dGVybi4kJGc7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgZ2xvYmFsIG11bHRpbGluZSBSZWdleHAgZnJvbSBhIFJlZ0V4cCBvYmplY3QgYW5kIGNhY2hlIHRoZSByZXN1bHRcbiAgLy8gb24gdGhlIG9iamVjdCBpdHNlbGYgKCQkZ20gb3IgJCRnIGF0dHJpYnV0ZSkuXG4gIC8vXG4gIE9wYWwuZ2xvYmFsX211bHRpbGluZV9yZWdleHAgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gICAgdmFyIHJlc3VsdCwgZmxhZ3M7XG5cbiAgICAvLyBSZWdFeHAgYWxyZWFkeSBoYXMgdGhlIGdsb2JhbCBhbmQgbXVsdGlsaW5lIGZsYWdcbiAgICBpZiAocGF0dGVybi5nbG9iYWwgJiYgcGF0dGVybi5tdWx0aWxpbmUpIHJldHVybiBwYXR0ZXJuO1xuXG4gICAgZmxhZ3MgPSAnZ20nICsgKHBhdHRlcm4uaWdub3JlQ2FzZSA/ICdpJyA6ICcnKTtcbiAgICBpZiAocGF0dGVybi5tdWx0aWxpbmUpIHtcbiAgICAgIC8vIHdlIGFyZSB1c2luZyB0aGUgJCRnIGF0dHJpYnV0ZSBiZWNhdXNlIHRoZSBSZWdleHAgaXMgYWxyZWFkeSBtdWx0aWxpbmVcbiAgICAgIGlmIChwYXR0ZXJuLiQkZyA9PSBudWxsKSB7XG4gICAgICAgIHBhdHRlcm4uJCRnID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnNvdXJjZSwgZmxhZ3MpO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gcGF0dGVybi4kJGc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwYXR0ZXJuLiQkZ20gPT0gbnVsbCkge1xuICAgICAgICBwYXR0ZXJuLiQkZ20gPSBuZXcgUmVnRXhwKHBhdHRlcm4uc291cmNlLCBmbGFncyk7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBwYXR0ZXJuLiQkZ207XG4gICAgfVxuICAgIHJlc3VsdC5sYXN0SW5kZXggPSBudWxsOyAvLyByZXNldCBsYXN0SW5kZXggcHJvcGVydHlcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENvbWJpbmUgbXVsdGlwbGUgcmVnZXhwIHBhcnRzIHRvZ2V0aGVyXG4gIE9wYWwucmVnZXhwID0gZnVuY3Rpb24ocGFydHMsIGZsYWdzKSB7XG4gICAgdmFyIHBhcnQ7XG4gICAgdmFyIGlnbm9yZUNhc2UgPSB0eXBlb2YgZmxhZ3MgIT09ICd1bmRlZmluZWQnICYmIGZsYWdzICYmIGZsYWdzLmluZGV4T2YoJ2knKSA+PSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGFydHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgaWYgKHBhcnQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgaWYgKHBhcnQuaWdub3JlQ2FzZSAhPT0gaWdub3JlQ2FzZSlcbiAgICAgICAgICBPcGFsLktlcm5lbC4kd2FybihcbiAgICAgICAgICAgIFwiaWdub3JlIGNhc2UgZG9lc24ndCBtYXRjaCBmb3IgXCIgKyBwYXJ0LnNvdXJjZS4kaW5zcGVjdCgpLFxuICAgICAgICAgICAgbmV3IE1hcChbWyd1cGxldmVsJywgIDFdXSlcbiAgICAgICAgICApXG5cbiAgICAgICAgcGFydCA9IHBhcnQuc291cmNlO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnQgPT09ICcnKSBwYXJ0ID0gJyg/OicgKyBwYXJ0ICsgJyknO1xuICAgICAgcGFydHNbaV0gPSBwYXJ0O1xuICAgIH1cblxuICAgIGlmIChmbGFncykge1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGFydHMuam9pbignJyksIGZsYWdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGFydHMuam9pbignJykpO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXF1aXJlIHN5c3RlbVxuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIE9wYWwubW9kdWxlcyAgICAgICAgID0ge307XG4gIE9wYWwubG9hZGVkX2ZlYXR1cmVzID0gWydjb3JlbGliL3J1bnRpbWUnXTtcbiAgT3BhbC5jdXJyZW50X2RpciAgICAgPSAnLic7XG4gIE9wYWwucmVxdWlyZV90YWJsZSAgID0geydjb3JlbGliL3J1bnRpbWUnOiB0cnVlfTtcblxuICBPcGFsLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICB2YXIgcGFydHMsIHBhcnQsIG5ld19wYXJ0cyA9IFtdLCBTRVBBUkFUT1IgPSAnLyc7XG5cbiAgICBpZiAoT3BhbC5jdXJyZW50X2RpciAhPT0gJy4nKSB7XG4gICAgICBwYXRoID0gT3BhbC5jdXJyZW50X2Rpci5yZXBsYWNlKC9cXC8qJC8sICcvJykgKyBwYXRoO1xuICAgIH1cblxuICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL15cXC5cXC8vLCAnJyk7XG4gICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFwuKHJifG9wYWx8anMpJC8sICcnKTtcbiAgICBwYXJ0cyA9IHBhdGguc3BsaXQoU0VQQVJBVE9SKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBhcnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgIGlmIChwYXJ0ID09PSAnJykgY29udGludWU7XG4gICAgICAocGFydCA9PT0gJy4uJykgPyBuZXdfcGFydHMucG9wKCkgOiBuZXdfcGFydHMucHVzaChwYXJ0KVxuICAgIH1cblxuICAgIHJldHVybiBuZXdfcGFydHMuam9pbihTRVBBUkFUT1IpO1xuICB9O1xuXG4gIE9wYWwubG9hZGVkID0gZnVuY3Rpb24ocGF0aHMpIHtcbiAgICB2YXIgaSwgbCwgcGF0aDtcblxuICAgIGZvciAoaSA9IDAsIGwgPSBwYXRocy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHBhdGggPSBPcGFsLm5vcm1hbGl6ZShwYXRoc1tpXSk7XG5cbiAgICAgIGlmIChPcGFsLnJlcXVpcmVfdGFibGVbcGF0aF0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIE9wYWwubG9hZGVkX2ZlYXR1cmVzLnB1c2gocGF0aCk7XG4gICAgICBPcGFsLnJlcXVpcmVfdGFibGVbcGF0aF0gPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICBPcGFsLmxvYWRfbm9ybWFsaXplZCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICBPcGFsLmxvYWRlZChbcGF0aF0pO1xuXG4gICAgdmFyIG1vZHVsZSA9IE9wYWwubW9kdWxlc1twYXRoXTtcblxuICAgIGlmIChtb2R1bGUpIHtcbiAgICAgIHZhciByZXR2YWwgPSBtb2R1bGUoT3BhbCk7XG4gICAgICBpZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIHJldHZhbCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgLy8gQSBzcGVjaWFsIGNhc2Ugb2YgcmVxdWlyZSBoYXZpbmcgYW4gYXN5bmMgdG9wOlxuICAgICAgICAvLyBXZSB3aWxsIG5lZWQgdG8gYXdhaXQgaXQuXG4gICAgICAgIHJldHVybiByZXR2YWwudGhlbigkcmV0dXJuX3ZhbCh0cnVlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHNldmVyaXR5ID0gT3BhbC5jb25maWcubWlzc2luZ19yZXF1aXJlX3NldmVyaXR5O1xuICAgICAgdmFyIG1lc3NhZ2UgID0gJ2Nhbm5vdCBsb2FkIHN1Y2ggZmlsZSAtLSAnICsgcGF0aDtcblxuICAgICAgaWYgKHNldmVyaXR5ID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgJHJhaXNlKE9wYWwuTG9hZEVycm9yLCBtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNldmVyaXR5ID09PSBcIndhcm5pbmdcIikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IExvYWRFcnJvcjogJyArIG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIE9wYWwubG9hZCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICBwYXRoID0gT3BhbC5ub3JtYWxpemUocGF0aCk7XG5cbiAgICByZXR1cm4gT3BhbC5sb2FkX25vcm1hbGl6ZWQocGF0aCk7XG4gIH07XG5cbiAgT3BhbC5yZXF1aXJlID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIHBhdGggPSBPcGFsLm5vcm1hbGl6ZShwYXRoKTtcblxuICAgIGlmIChPcGFsLnJlcXVpcmVfdGFibGVbcGF0aF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gT3BhbC5sb2FkX25vcm1hbGl6ZWQocGF0aCk7XG4gIH07XG5cblxuICAvLyBTdHJpbmdzXG4gIC8vIC0tLS0tLS1cblxuICBPcGFsLmVuY29kaW5ncyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy8gU2V0cyB0aGUgZW5jb2Rpbmcgb24gYSBzdHJpbmcsIHdpbGwgdHJlYXQgc3RyaW5nIGxpdGVyYWxzIGFzIGZyb3plbiBzdHJpbmdzXG4gIC8vIHJhaXNpbmcgYSBGcm96ZW5FcnJvci5cbiAgLy9cbiAgLy8gQHBhcmFtIHN0ciBbU3RyaW5nXSB0aGUgc3RyaW5nIG9uIHdoaWNoIHRoZSBlbmNvZGluZyBzaG91bGQgYmUgc2V0XG4gIC8vIEBwYXJhbSBuYW1lIFtTdHJpbmddIHRoZSBjYW5vbmljYWwgbmFtZSBvZiB0aGUgZW5jb2RpbmdcbiAgLy8gQHBhcmFtIHR5cGUgW1N0cmluZ10gcG9zc2libGUgdmFsdWVzIGFyZSBlaXRoZXIgYFwiZW5jb2RpbmdcImAsIGBcImludGVybmFsX2VuY29kaW5nXCJgLCBvciBgdW5kZWZpbmVkXG4gIE9wYWwuc2V0X2VuY29kaW5nID0gZnVuY3Rpb24oc3RyLCBuYW1lLCB0eXBlKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSBcInVuZGVmaW5lZFwiKSB0eXBlID0gXCJlbmNvZGluZ1wiO1xuICAgIGlmICh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyB8fCBzdHIuJCRmcm96ZW4gPT09IHRydWUpXG4gICAgICAkcmFpc2UoT3BhbC5Gcm96ZW5FcnJvciwgXCJjYW4ndCBtb2RpZnkgZnJvemVuIFN0cmluZ1wiKTtcblxuICAgIHZhciBlbmNvZGluZyA9IE9wYWwuZmluZF9lbmNvZGluZyhuYW1lKTtcblxuICAgIGlmIChlbmNvZGluZyA9PT0gc3RyW3R5cGVdKSB7IHJldHVybiBzdHI7IH1cblxuICAgIHN0clt0eXBlXSA9IGVuY29kaW5nO1xuXG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICAvLyBGZXRjaGVzIHRoZSBlbmNvZGluZyBmb3IgdGhlIGdpdmVuIG5hbWUgb3IgcmFpc2VzIEFyZ3VtZW50RXJyb3IuXG4gIE9wYWwuZmluZF9lbmNvZGluZyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgcmVnaXN0ZXIgPSBPcGFsLmVuY29kaW5ncztcbiAgICB2YXIgZW5jb2RpbmcgPSByZWdpc3RlcltuYW1lXSB8fCByZWdpc3RlcltuYW1lLnRvVXBwZXJDYXNlKCldO1xuICAgIGlmICghZW5jb2RpbmcpICRyYWlzZShPcGFsLkFyZ3VtZW50RXJyb3IsIFwidW5rbm93biBlbmNvZGluZyBuYW1lIC0gXCIgKyBuYW1lKTtcbiAgICByZXR1cm4gZW5jb2Rpbmc7XG4gIH1cblxuICAvLyBAcmV0dXJucyBhIFN0cmluZyBvYmplY3Qgd2l0aCB0aGUgZW5jb2Rpbmcgc2V0IGZyb20gYSBzdHJpbmcgbGl0ZXJhbFxuICBPcGFsLmVuYyA9IGZ1bmN0aW9uKHN0ciwgbmFtZSkge1xuICAgIHZhciBkdXAgPSBuZXcgU3RyaW5nKHN0cik7XG4gICAgZHVwID0gT3BhbC5zZXRfZW5jb2RpbmcoZHVwLCBuYW1lKTtcbiAgICBkdXAuaW50ZXJuYWxfZW5jb2RpbmcgPSBkdXAuZW5jb2Rpbmc7XG4gICAgcmV0dXJuIGR1cFxuICB9XG5cbiAgLy8gQHJldHVybnMgYSBTdHJpbmcgb2JqZWN0IHdpdGggdGhlIGludGVybmFsIGVuY29kaW5nIHNldCB0byBCaW5hcnlcbiAgT3BhbC5iaW5hcnkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICB2YXIgZHVwID0gbmV3IFN0cmluZyhzdHIpO1xuICAgIHJldHVybiBPcGFsLnNldF9lbmNvZGluZyhkdXAsIFwiYmluYXJ5XCIsIFwiaW50ZXJuYWxfZW5jb2RpbmdcIik7XG4gIH1cblxuICBPcGFsLmxhc3RfcHJvbWlzZSA9IG51bGw7XG4gIE9wYWwucHJvbWlzZV91bmhhbmRsZWRfZXhjZXB0aW9uID0gZmFsc2U7XG5cbiAgLy8gUnVuIGEgYmxvY2sgb2YgY29kZSwgYnV0IGlmIGl0IHJldHVybnMgYSBQcm9taXNlLCBkb24ndCBydW4gdGhlIG5leHRcbiAgLy8gb25lLCBidXQgcXVldWUgaXQuXG4gIE9wYWwucXVldWUgPSBmdW5jdGlvbihwcm9jKSB7XG4gICAgaWYgKE9wYWwubGFzdF9wcm9taXNlKSB7XG4gICAgICAvLyBUaGUgYXN5bmMgcGF0aCBpcyB0YWtlbiBvbmx5IGlmIGFueXRoaW5nIGJlZm9yZSByZXR1cm5lZCBhXG4gICAgICAvLyBQcm9taXNlKFYyKS5cbiAgICAgIE9wYWwubGFzdF9wcm9taXNlID0gT3BhbC5sYXN0X3Byb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFPcGFsLnByb21pc2VfdW5oYW5kbGVkX2V4Y2VwdGlvbikgcmV0dXJuIHByb2MoT3BhbCk7XG4gICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbihlcnJvcikge1xuICAgICAgICBpZiAoT3BhbC5yZXNwb25kX3RvKGVycm9yLCAnJGZ1bGxfbWVzc2FnZScpKSB7XG4gICAgICAgICAgZXJyb3IgPSBlcnJvci4kZnVsbF9tZXNzYWdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIC8vIEFib3J0IGZ1cnRoZXIgZXhlY3V0aW9uXG4gICAgICAgIE9wYWwucHJvbWlzZV91bmhhbmRsZWRfZXhjZXB0aW9uID0gdHJ1ZTtcbiAgICAgICAgT3BhbC5leGl0KDEpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gT3BhbC5sYXN0X3Byb21pc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHJldCA9IHByb2MoT3BhbCk7XG4gICAgICBpZiAodHlwZW9mIFByb21pc2UgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHJldCA9PT0gJ29iamVjdCcgJiYgcmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBPcGFsLmxhc3RfcHJvbWlzZSA9IHJldDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9XG5cbiAgLy8gT3BlcmF0b3IgaGVscGVyc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tXG5cbiAgZnVuY3Rpb24gYXJlX2JvdGhfbnVtYmVycyhsLHIpIHsgcmV0dXJuIHR5cGVvZihsKSA9PT0gJ251bWJlcicgJiYgdHlwZW9mKHIpID09PSAnbnVtYmVyJyB9XG5cbiAgT3BhbC5yYl9wbHVzICAgPSBmdW5jdGlvbihsLHIpIHsgcmV0dXJuIGFyZV9ib3RoX251bWJlcnMobCxyKSA/IGwgKyByIDogbFsnJCsnXShyKTsgfVxuICBPcGFsLnJiX21pbnVzICA9IGZ1bmN0aW9uKGwscikgeyByZXR1cm4gYXJlX2JvdGhfbnVtYmVycyhsLHIpID8gbCAtIHIgOiBsWyckLSddKHIpOyB9XG4gIE9wYWwucmJfdGltZXMgID0gZnVuY3Rpb24obCxyKSB7IHJldHVybiBhcmVfYm90aF9udW1iZXJzKGwscikgPyBsICogciA6IGxbJyQqJ10ocik7IH1cbiAgT3BhbC5yYl9kaXZpZGUgPSBmdW5jdGlvbihsLHIpIHsgcmV0dXJuIGFyZV9ib3RoX251bWJlcnMobCxyKSA/IGwgLyByIDogbFsnJC8nXShyKTsgfVxuICBPcGFsLnJiX2x0ICAgICA9IGZ1bmN0aW9uKGwscikgeyByZXR1cm4gYXJlX2JvdGhfbnVtYmVycyhsLHIpID8gbCA8IHIgOiBsWyckPCddKHIpOyB9XG4gIE9wYWwucmJfZ3QgICAgID0gZnVuY3Rpb24obCxyKSB7IHJldHVybiBhcmVfYm90aF9udW1iZXJzKGwscikgPyBsID4gciA6IGxbJyQ+J10ocik7IH1cbiAgT3BhbC5yYl9sZSAgICAgPSBmdW5jdGlvbihsLHIpIHsgcmV0dXJuIGFyZV9ib3RoX251bWJlcnMobCxyKSA/IGwgPD0gciA6IGxbJyQ8PSddKHIpOyB9XG4gIE9wYWwucmJfZ2UgICAgID0gZnVuY3Rpb24obCxyKSB7IHJldHVybiBhcmVfYm90aF9udW1iZXJzKGwscikgPyBsID49IHIgOiBsWyckPj0nXShyKTsgfVxuXG4gIC8vIE9wdGltaXplZCBoZWxwZXJzIGZvciBjYWxscyBsaWtlICR0cnV0aHkoKGEpWyckPT09J10oYikpIC0+ICRlcWVxZXEoYSwgYilcbiAgZnVuY3Rpb24gYXJlX2JvdGhfbnVtYmVyc19vcl9zdHJpbmdzKGxocywgcmhzKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgbGhzID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgcmhzID09PSAnbnVtYmVyJykgfHxcbiAgICAgICAgICAgKHR5cGVvZiBsaHMgPT09ICdzdHJpbmcnICYmIHR5cGVvZiByaHMgPT09ICdzdHJpbmcnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uICRlcWVxKGxocywgcmhzKSB7XG4gICAgcmV0dXJuIGFyZV9ib3RoX251bWJlcnNfb3Jfc3RyaW5ncyhsaHMscmhzKSA/IGxocyA9PT0gcmhzIDogJHRydXRoeSgobGhzKVsnJD09J10ocmhzKSk7XG4gIH07XG4gIE9wYWwuZXFlcSA9ICRlcWVxO1xuICBPcGFsLmVxZXFlcSA9IGZ1bmN0aW9uKGxocywgcmhzKSB7XG4gICAgcmV0dXJuIGFyZV9ib3RoX251bWJlcnNfb3Jfc3RyaW5ncyhsaHMscmhzKSA/IGxocyA9PT0gcmhzIDogJHRydXRoeSgobGhzKVsnJD09PSddKHJocykpO1xuICB9O1xuICBPcGFsLm5lcWVxID0gZnVuY3Rpb24obGhzLCByaHMpIHtcbiAgICByZXR1cm4gYXJlX2JvdGhfbnVtYmVyc19vcl9zdHJpbmdzKGxocyxyaHMpID8gbGhzICE9PSByaHMgOiAkdHJ1dGh5KChsaHMpWyckIT0nXShyaHMpKTtcbiAgfTtcbiAgT3BhbC5ub3QgPSBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBhcmcgfHwgbnVsbCA9PT0gYXJnIHx8IGZhbHNlID09PSBhcmcgfHwgbmlsID09PSBhcmcpIHJldHVybiB0cnVlO1xuICAgIGlmICh0cnVlID09PSBhcmcgfHwgYXJnWyckISddLiQkcHJpc3RpbmUpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gJHRydXRoeShhcmdbJyQhJ10oKSk7XG4gIH1cblxuICAvLyBTaG9ydGN1dHMgLSBvcHRpbWl6ZWQgZnVuY3Rpb24gZ2VuZXJhdG9ycyBmb3Igc2ltcGxlIGtpbmRzIG9mIGZ1bmN0aW9uc1xuICBmdW5jdGlvbiAkcmV0dXJuX3ZhbChhcmcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH1cbiAgfVxuICBPcGFsLnJldHVybl92YWwgPSAkcmV0dXJuX3ZhbDtcblxuICBPcGFsLnJldHVybl9zZWxmID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgT3BhbC5yZXR1cm5faXZhciA9IGZ1bmN0aW9uKGl2YXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpc1tpdmFyXSA9PSBudWxsKSB7IHJldHVybiBuaWw7IH1cbiAgICAgIHJldHVybiB0aGlzW2l2YXJdO1xuICAgIH1cbiAgfVxuICBPcGFsLmFzc2lnbl9pdmFyID0gZnVuY3Rpb24oaXZhcikge1xuICAgIHJldHVybiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3ModGhpcyk7XG4gICAgICByZXR1cm4gdGhpc1tpdmFyXSA9IHZhbDtcbiAgICB9XG4gIH1cbiAgT3BhbC5hc3NpZ25faXZhcl92YWwgPSBmdW5jdGlvbihpdmFyLCBzdGF0aWNfdmFsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2Vzcyh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzW2l2YXJdID0gc3RhdGljX3ZhbDtcbiAgICB9XG4gIH1cblxuICAvLyBQcmltaXRpdmVzIGZvciBoYW5kbGluZyBwYXJhbWV0ZXJzXG4gIE9wYWwuZW5zdXJlX2t3YXJncyA9IGZ1bmN0aW9uKGt3YXJncykge1xuICAgIGlmIChrd2FyZ3MgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICB9IGVsc2UgaWYgKGt3YXJncy4kJGlzX2hhc2gpIHtcbiAgICAgIHJldHVybiBrd2FyZ3M7XG4gICAgfSBlbHNlIHtcbiAgICAgICRyYWlzZShPcGFsLkFyZ3VtZW50RXJyb3IsICdleHBlY3RlZCBrd2FyZ3MnKTtcbiAgICB9XG4gIH1cblxuICBPcGFsLmdldF9rd2FyZyA9IGZ1bmN0aW9uKGt3YXJncywga2V5KSB7XG4gICAgdmFyIGt3YXJnID0gT3BhbC5oYXNoX2dldChrd2FyZ3MsIGtleSk7XG4gICAgaWYgKGt3YXJnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICRyYWlzZShPcGFsLkFyZ3VtZW50RXJyb3IsICdtaXNzaW5nIGtleXdvcmQ6ICcra2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIGt3YXJnO1xuICB9XG5cbiAgLy8gQXJyYXlzIG9mIHNpemUgPiAzMiBlbGVtZW50cyB0aGF0IGNvbnRhaW4gb25seSBzdHJpbmdzLFxuICAvLyBzeW1ib2xzLCBpbnRlZ2VycyBhbmQgbmlscyBhcmUgY29tcGlsZWQgYXMgYSBzZWxmLWV4dHJhY3RpbmdcbiAgLy8gc3RyaW5nLlxuICBPcGFsLmxhcmdlX2FycmF5X3VucGFjayA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHZhciBhcnJheSA9IHN0ci5zcGxpdChcIixcIiksIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCwgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHN3aXRjaChhcnJheVtpXVswXSkge1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICBhcnJheVtpXSA9IG5pbFxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICctJzpcbiAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgIGNhc2UgJzEnOlxuICAgICAgICBjYXNlICcyJzpcbiAgICAgICAgY2FzZSAnMyc6XG4gICAgICAgIGNhc2UgJzQnOlxuICAgICAgICBjYXNlICc1JzpcbiAgICAgICAgY2FzZSAnNic6XG4gICAgICAgIGNhc2UgJzcnOlxuICAgICAgICBjYXNlICc4JzpcbiAgICAgICAgY2FzZSAnOSc6XG4gICAgICAgICAgYXJyYXlbaV0gPSArYXJyYXlbaV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8vIE9wYWwzMi1jaGVja3N1bSBhbGdvcml0aG0gZm9yICNoYXNoXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIE9wYWwub3BhbDMyX2luaXQgPSAkcmV0dXJuX3ZhbCgweDRmNzA2MTZjKTtcblxuICBmdW5jdGlvbiAkb3BhbDMyX3JvcihuLCBkKSB7XG4gICAgcmV0dXJuIChuIDw8IGQpfChuID4+PiAoMzIgLSBkKSk7XG4gIH07XG5cbiAgT3BhbC5vcGFsMzJfYWRkID0gZnVuY3Rpb24oaGFzaCwgbmV4dCkge1xuICAgIGhhc2ggXj0gbmV4dDtcbiAgICBoYXNoID0gJG9wYWwzMl9yb3IoaGFzaCwgMSk7XG4gICAgcmV0dXJuIGhhc2g7XG4gIH07XG5cbiAgLy8gSW5pdGlhbGl6YXRpb25cbiAgLy8gLS0tLS0tLS0tLS0tLS1cbiAgT3BhbC5CYXNpY09iamVjdCA9IEJhc2ljT2JqZWN0ID0gJGFsbG9jYXRlX2NsYXNzKCdCYXNpY09iamVjdCcsIG51bGwpO1xuICBPcGFsLk9iamVjdCAgICAgID0gX09iamVjdCAgICAgPSAkYWxsb2NhdGVfY2xhc3MoJ09iamVjdCcsIE9wYWwuQmFzaWNPYmplY3QpO1xuICBPcGFsLk1vZHVsZSAgICAgID0gTW9kdWxlICAgICAgPSAkYWxsb2NhdGVfY2xhc3MoJ01vZHVsZScsIE9wYWwuT2JqZWN0KTtcbiAgT3BhbC5DbGFzcyAgICAgICA9IENsYXNzICAgICAgID0gJGFsbG9jYXRlX2NsYXNzKCdDbGFzcycsIE9wYWwuTW9kdWxlKTtcbiAgT3BhbC5PcGFsICAgICAgICA9IF9PcGFsICAgICAgID0gJGFsbG9jYXRlX21vZHVsZSgnT3BhbCcpO1xuICBPcGFsLktlcm5lbCAgICAgID0gS2VybmVsICAgICAgPSAkYWxsb2NhdGVfbW9kdWxlKCdLZXJuZWwnKTtcblxuICAkc2V0X3Byb3RvKE9wYWwuQmFzaWNPYmplY3QsIE9wYWwuQ2xhc3MuJCRwcm90b3R5cGUpO1xuICAkc2V0X3Byb3RvKE9wYWwuT2JqZWN0LCBPcGFsLkNsYXNzLiQkcHJvdG90eXBlKTtcbiAgJHNldF9wcm90byhPcGFsLk1vZHVsZSwgT3BhbC5DbGFzcy4kJHByb3RvdHlwZSk7XG4gICRzZXRfcHJvdG8oT3BhbC5DbGFzcywgT3BhbC5DbGFzcy4kJHByb3RvdHlwZSk7XG5cbiAgLy8gQmFzaWNPYmplY3QgY2FuIHJlYWNoIGl0c2VsZiwgYXZvaWQgY29uc3Rfc2V0IHRvIHNraXAgdGhlICQkYmFzZV9tb2R1bGUgbG9naWNcbiAgQmFzaWNPYmplY3QuJCRjb25zdC5CYXNpY09iamVjdCA9IEJhc2ljT2JqZWN0O1xuXG4gIC8vIEFzc2lnbiBiYXNpYyBjb25zdGFudHNcbiAgJGNvbnN0X3NldChfT2JqZWN0LCBcIkJhc2ljT2JqZWN0XCIsICBCYXNpY09iamVjdCk7XG4gICRjb25zdF9zZXQoX09iamVjdCwgXCJPYmplY3RcIiwgICAgICAgX09iamVjdCk7XG4gICRjb25zdF9zZXQoX09iamVjdCwgXCJNb2R1bGVcIiwgICAgICAgTW9kdWxlKTtcbiAgJGNvbnN0X3NldChfT2JqZWN0LCBcIkNsYXNzXCIsICAgICAgICBDbGFzcyk7XG4gICRjb25zdF9zZXQoX09iamVjdCwgXCJPcGFsXCIsICAgICAgICAgX09wYWwpO1xuICAkY29uc3Rfc2V0KF9PYmplY3QsIFwiS2VybmVsXCIsICAgICAgIEtlcm5lbCk7XG5cbiAgLy8gRml4IGJvb3RlZCBjbGFzc2VzIHRvIGhhdmUgY29ycmVjdCAuY2xhc3MgdmFsdWVcbiAgQmFzaWNPYmplY3QuJCRjbGFzcyA9IENsYXNzO1xuICBfT2JqZWN0LiQkY2xhc3MgICAgID0gQ2xhc3M7XG4gIE1vZHVsZS4kJGNsYXNzICAgICAgPSBDbGFzcztcbiAgQ2xhc3MuJCRjbGFzcyAgICAgICA9IENsYXNzO1xuICBfT3BhbC4kJGNsYXNzICAgICAgID0gTW9kdWxlO1xuICBLZXJuZWwuJCRjbGFzcyAgICAgID0gTW9kdWxlO1xuXG4gIC8vIEZvcndhcmQgLnRvU3RyaW5nKCkgdG8gI3RvX3NcbiAgJHByb3AoX09iamVjdC4kJHByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRvX3MgPSB0aGlzLiR0b19zKCk7XG4gICAgaWYgKHRvX3MuJCRpc19zdHJpbmcgJiYgdHlwZW9mKHRvX3MpID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gYSBzdHJpbmcgY3JlYXRlZCB1c2luZyBuZXcgU3RyaW5nKCdzdHJpbmcnKVxuICAgICAgcmV0dXJuIHRvX3MudmFsdWVPZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdG9fcztcbiAgICB9XG4gIH0pO1xuXG4gIC8vIE1ha2UgS2VybmVsI3JlcXVpcmUgaW1tZWRpYXRlbHkgYXZhaWxhYmxlIGFzIGl0J3MgbmVlZGVkIHRvIHJlcXVpcmUgYWxsIHRoZVxuICAvLyBvdGhlciBjb3JlbGliIGZpbGVzLlxuICAkcHJvcChfT2JqZWN0LiQkcHJvdG90eXBlLCAnJHJlcXVpcmUnLCBPcGFsLnJlcXVpcmUpO1xuXG4gIC8vIEluc3RhbnRpYXRlIHRoZSBtYWluIG9iamVjdFxuICBPcGFsLnRvcCA9IG5ldyBfT2JqZWN0KCk7XG4gIE9wYWwudG9wLiR0b19zID0gT3BhbC50b3AuJGluc3BlY3QgPSAkcmV0dXJuX3ZhbCgnbWFpbicpO1xuICBPcGFsLnRvcC4kZGVmaW5lX21ldGhvZCA9IHRvcF9kZWZpbmVfbWV0aG9kO1xuXG4gIC8vIEZvd2FyZCBjYWxscyB0byBkZWZpbmVfbWV0aG9kIG9uIHRoZSB0b3Agb2JqZWN0IHRvIE9iamVjdFxuICBmdW5jdGlvbiB0b3BfZGVmaW5lX21ldGhvZCgpIHtcbiAgICB2YXIgYmxvY2sgPSB0b3BfZGVmaW5lX21ldGhvZC4kJHA7XG4gICAgdG9wX2RlZmluZV9tZXRob2QuJCRwID0gbnVsbDtcbiAgICByZXR1cm4gT3BhbC5zZW5kKF9PYmplY3QsICdkZWZpbmVfbWV0aG9kJywgYXJndW1lbnRzLCBibG9jaylcbiAgfTtcblxuICAvLyBOaWxcbiAgT3BhbC5OaWxDbGFzcyA9ICRhbGxvY2F0ZV9jbGFzcygnTmlsQ2xhc3MnLCBPcGFsLk9iamVjdCk7XG4gICRjb25zdF9zZXQoX09iamVjdCwgJ05pbENsYXNzJywgT3BhbC5OaWxDbGFzcyk7XG4gIG5pbCA9IE9wYWwubmlsID0gbmV3IE9wYWwuTmlsQ2xhc3MoKTtcbiAgbmlsLiQkaWQgPSBuaWxfaWQ7XG4gIG5pbC5jYWxsID0gbmlsLmFwcGx5ID0gZnVuY3Rpb24oKSB7ICRyYWlzZShPcGFsLkxvY2FsSnVtcEVycm9yLCAnbm8gYmxvY2sgZ2l2ZW4nKTsgfTtcbiAgbmlsLiQkZnJvemVuID0gdHJ1ZTtcbiAgbmlsLiQkY29tcGFyYWJsZSA9IGZhbHNlO1xuICBPYmplY3Quc2VhbChuaWwpO1xuXG4gIE9wYWwudGhyb3dlciA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICB2YXIgdGhyb3dlciA9IHtcbiAgICAgICR0aHJvd2VyX3R5cGU6IHR5cGUsXG4gICAgICAkdGhyb3c6IGZ1bmN0aW9uKHZhbHVlLCBjYWxsZWRfZnJvbV9sYW1iZGEpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHZhbHVlID0gbmlsO1xuICAgICAgICBpZiAodGhpcy5pc19vcnBoYW4gJiYgIWNhbGxlZF9mcm9tX2xhbWJkYSkge1xuICAgICAgICAgICRyYWlzZShPcGFsLkxvY2FsSnVtcEVycm9yLCAndW5leHBlY3RlZCAnICsgdHlwZSwgdmFsdWUsIHR5cGUuJHRvX3N5bSgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiR2ID0gdmFsdWU7XG4gICAgICAgIHRocm93IHRoaXM7XG4gICAgICB9LFxuICAgICAgaXNfb3JwaGFuOiBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gdGhyb3dlcjtcbiAgfTtcblxuICAvLyBEZWZpbmUgYSBcIiRAXCIgZ2xvYmFsIHZhcmlhYmxlLCB3aGljaCB3b3VsZCBjb21wdXRlIGFuZCByZXR1cm4gYSBiYWNrdHJhY2Ugb24gZGVtYW5kLlxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoJGd2YXJzLCBcIkBcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoJHRydXRoeSgkZ3ZhcnNbXCIhXCJdKSkgcmV0dXJuICRndmFyc1tcIiFcIl0uJGJhY2t0cmFjZSgpO1xuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24oYnQpIHtcbiAgICAgIGlmICgkdHJ1dGh5KCRndmFyc1tcIiFcIl0pKVxuICAgICAgICAkZ3ZhcnNbXCIhXCJdLiRzZXRfYmFja3RyYWNlKGJ0KTtcbiAgICAgIGVsc2VcbiAgICAgICAgJHJhaXNlKE9wYWwuQXJndW1lbnRFcnJvciwgXCIkISBub3Qgc2V0XCIpO1xuICAgIH1cbiAgfSk7XG5cbiAgT3BhbC50X2V2YWxfcmV0dXJuID0gT3BhbC50aHJvd2VyKFwicmV0dXJuXCIpO1xuXG4gIFR5cGVFcnJvci4kJHN1cGVyID0gRXJyb3I7XG5cbiAgLy8gSWYgZW5hYmxlLWZpbGUtc291cmNlLWVtYmVkIGNvbXBpbGVyIG9wdGlvbiBpcyBlbmFibGVkLCBlYWNoIG1vZHVsZSBsb2FkZWQgd2lsbCBhZGQgaXRzXG4gIC8vIHNvdXJjZXMgdG8gdGhpcyBvYmplY3RcbiAgT3BhbC5maWxlX3NvdXJjZXMgPSB7fTtcbn0pLmNhbGwodGhpcyk7XG5PcGFsLmxvYWRlZChbXCJjb3JlbGliL3J1bnRpbWUuanNcIl0pOyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRjtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTs7QUFFRjtBQUNFOztBQUVGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNGOztBQUVBOztBQUVBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNFOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0E7QUFDQTtBQUNGO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7QUFDQTs7O0FBR0E7QUFDRTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNGOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDRjtBQUNBOztBQUVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNFO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTtBQUNBOztBQUVKO0FBQ0U7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0k7O0FBRUo7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7O0FBRUY7QUFDRTs7QUFFRjtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUY7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDQTtBQUNJO0FBQ0E7QUFDQTs7QUFFSjtBQUNFOztBQUVBO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFSjtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0k7O0FBRUo7QUFDRTtBQUNGOztBQUVBO0FBQ0k7O0FBRUo7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7OztBQUdBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNGO0FBQ0E7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNGOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0k7QUFDQTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0o7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0o7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0U7QUFDSjtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7QUFDRjtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNFO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0E7QUFDRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDRjtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGOztBQUVBOztBQUVBOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0k7QUFDQTtBQUNBOztBQUVKO0FBQ0E7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRTs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRTtBQUNFOztBQUVGO0FBQ0k7O0FBRUo7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNJOztBQUVKO0FBQ0U7QUFDQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDRTtBQUNJO0FBQ0E7O0FBRUo7QUFDRTtBQUNFO0FBQ0E7QUFDRTtBQUNKO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNFO0FBQ0k7QUFDQTs7QUFFSjtBQUNFO0FBQ0U7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7QUFDRjtBQUNGO0FBQ0U7QUFDRjtBQUNGO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTs7QUFFRjtBQUNFO0FBQ0E7QUFDRTs7QUFFRjs7QUFFQTtBQUNFOztBQUVGO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0k7QUFDQTs7QUFFSjtBQUNFO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNGOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVGO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0Y7QUFDRTtBQUNBO0FBQ0U7QUFDRTs7QUFFQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0k7QUFDQTtBQUNBOztBQUVKO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDQTs7QUFFQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ1U7QUFDQTtBQUNBO0FBQ0E7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNGO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDRTtBQUNFO0FBQ0U7QUFDQTtBQUNGOztBQUVGO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNGOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7QUFDQTtBQUNGO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ087QUFDVDs7QUFFQTtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7O0FBRUE7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0o7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0E7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNGO0FBQ0E7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0U7QUFDSjtBQUNGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNGO0FBQ0EifX0seyJvZmZzZXQiOnsibGluZSI6MzEwNSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvaGVscGVycy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHR5cGVfZXJyb3IsIGNvZXJjZV90b1xuIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXG5cbm1vZHVsZSA6Ok9wYWxcbiAgZGVmIHNlbGYuYnJpZGdlKGNvbnN0cnVjdG9yLCBrbGFzcylcbiAgICBgT3BhbC5icmlkZ2UoY29uc3RydWN0b3IsIGtsYXNzKWBcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY29lcmNlX3RvIShvYmplY3QsIHR5cGUsIG1ldGhvZCwgKmFyZ3MpXG4gICAgY29lcmNlZCA9IGAkY29lcmNlX3RvKG9iamVjdCwgdHlwZSwgbWV0aG9kLCBhcmdzKWBcblxuICAgIHVubGVzcyB0eXBlID09PSBjb2VyY2VkXG4gICAgICA6Oktlcm5lbC5yYWlzZSBgJHR5cGVfZXJyb3Iob2JqZWN0LCB0eXBlLCBtZXRob2QsIGNvZXJjZWQpYFxuICAgIGVuZFxuXG4gICAgY29lcmNlZFxuICBlbmRcblxuICBkZWYgc2VsZi5jb2VyY2VfdG8/KG9iamVjdCwgdHlwZSwgbWV0aG9kLCAqYXJncylcbiAgICByZXR1cm4gdW5sZXNzIG9iamVjdC5yZXNwb25kX3RvPyBtZXRob2RcblxuICAgIGNvZXJjZWQgPSBgJGNvZXJjZV90byhvYmplY3QsIHR5cGUsIG1ldGhvZCwgYXJncylgXG5cbiAgICByZXR1cm4gaWYgY29lcmNlZC5uaWw/XG5cbiAgICB1bmxlc3MgdHlwZSA9PT0gY29lcmNlZFxuICAgICAgOjpLZXJuZWwucmFpc2UgYCR0eXBlX2Vycm9yKG9iamVjdCwgdHlwZSwgbWV0aG9kLCBjb2VyY2VkKWBcbiAgICBlbmRcblxuICAgIGNvZXJjZWRcbiAgZW5kXG5cbiAgZGVmIHNlbGYudHJ5X2NvbnZlcnQob2JqZWN0LCB0eXBlLCBtZXRob2QpXG4gICAgcmV0dXJuIG9iamVjdCBpZiB0eXBlID09PSBvYmplY3RcblxuICAgIGlmIG9iamVjdC5yZXNwb25kX3RvPyBtZXRob2RcbiAgICAgIG9iamVjdC5fX3NlbmRfXyBtZXRob2RcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY29tcGFyZShhLCBiKVxuICAgIGNvbXBhcmUgPSBhIDw9PiBiXG5cbiAgICBpZiBgY29tcGFyZSA9PT0gbmlsYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3thLmNsYXNzfSB3aXRoICN7Yi5jbGFzc30gZmFpbGVkXCJcbiAgICBlbmRcblxuICAgIGNvbXBhcmVcbiAgZW5kXG5cbiAgZGVmIHNlbGYuZGVzdHJ1Y3R1cmUoYXJncylcbiAgICAleHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYXJncy4kJGlzX2FycmF5KSB7XG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBhcmdzX2FyeSA9IG5ldyBBcnJheShhcmdzLmxlbmd0aCk7XG4gICAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBhcmdzX2FyeS5sZW5ndGg7IGkgPCBsOyBpKyspIHsgYXJnc19hcnlbaV0gPSBhcmdzW2ldOyB9XG5cbiAgICAgICAgcmV0dXJuIGFyZ3NfYXJ5O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYucmVzcG9uZF90bz8ob2JqLCBtZXRob2QsIGluY2x1ZGVfYWxsID0gZmFsc2UpXG4gICAgJXh7XG4gICAgICBpZiAob2JqID09IG51bGwgfHwgIW9iai4kJGNsYXNzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvYmoucmVzcG9uZF90bz8obWV0aG9kLCBpbmNsdWRlX2FsbClcbiAgZW5kXG5cbiAgZGVmIHNlbGYuaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEobmFtZSlcbiAgICBuYW1lID0gOjpPcGFsLmNvZXJjZV90byEobmFtZSwgOjpTdHJpbmcsIDp0b19zdHIpXG5cbiAgICB1bmxlc3MgYC9eQFthLXpBLVpfXVthLXpBLVowLTlfXSo/JC8udGVzdChuYW1lKWBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLm5ldyhcIicje25hbWV9JyBpcyBub3QgYWxsb3dlZCBhcyBhbiBpbnN0YW5jZSB2YXJpYWJsZSBuYW1lXCIsIG5hbWUpXG4gICAgZW5kXG5cbiAgICBuYW1lXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNsYXNzX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG4gICAgbmFtZSA9IDo6T3BhbC5jb2VyY2VfdG8hKG5hbWUsIDo6U3RyaW5nLCA6dG9fc3RyKVxuXG4gICAgaWYgYG5hbWUubGVuZ3RoIDwgMyB8fCBuYW1lLnNsaWNlKDAsMikgIT09ICdAQCdgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvci5uZXcoXCJgI3tuYW1lfScgaXMgbm90IGFsbG93ZWQgYXMgYSBjbGFzcyB2YXJpYWJsZSBuYW1lXCIsIG5hbWUpXG4gICAgZW5kXG5cbiAgICBuYW1lXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvbnN0X25hbWU/KGNvbnN0X25hbWUpXG4gICAgJXh7XG4gICAgICBpZiAodHlwZW9mIGNvbnN0X25hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICN7Y29uc3RfbmFtZSA9IDo6T3BhbC5jb2VyY2VfdG8hKGNvbnN0X25hbWUsIDo6U3RyaW5nLCA6dG9fc3RyKX1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7Y29uc3RfbmFtZX1bMF0gPT09ICN7Y29uc3RfbmFtZX1bMF0udG9VcHBlckNhc2UoKVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYuY29uc3RfbmFtZSEoY29uc3RfbmFtZSlcbiAgICBjb25zdF9uYW1lID0gOjpPcGFsLmNvZXJjZV90byEoY29uc3RfbmFtZSwgOjpTdHJpbmcsIDp0b19zdHIpIGlmIGRlZmluZWQ/IDo6U3RyaW5nXG5cbiAgICAleHtcbiAgICAgIGlmICghY29uc3RfbmFtZSB8fCBjb25zdF9uYW1lWzBdICE9IGNvbnN0X25hbWVbMF0udG9VcHBlckNhc2UoKSkge1xuICAgICAgICAje3JhaXNlIDo6TmFtZUVycm9yLCBcIndyb25nIGNvbnN0YW50IG5hbWUgI3tjb25zdF9uYW1lfVwifVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0X25hbWVcbiAgZW5kXG5cbiAgIyBAcHJpdmF0ZVxuICAjIE1hcmsgc29tZSBtZXRob2RzIGFzIHByaXN0aW5lIGluIG9yZGVyIHRvIGFwcGx5IG9wdGltaXphdGlvbnMgd2hlbiB0aGV5XG4gICMgYXJlIHN0aWxsIGluIHRoZWlyIG9yaWdpbmFsIGZvcm0uIFRoaXMgY291bGQgcHJvYmFibHkgYmUgbW92ZWQgdG9cbiAgIyB0aGUgYE9wYWwuZGVmKClgIEpTIEFQSSwgYnV0IGZvciBub3cgaXQgd2lsbCBzdGF5IG1hbnVhbC5cbiAgI1xuICAjIEBleGFtcGxlXG4gICNcbiAgIyAgIE9wYWwucHJpc3RpbmUgQXJyYXksIDphbGxvY2F0ZSwgOmNvcHlfaW5zdGFuY2VfdmFyaWFibGVzLCA6aW5pdGlhbGl6ZV9kdXBcbiAgI1xuICAjICAgY2xhc3MgQXJyYXlcbiAgIyAgICAgZGVmIGR1cFxuICAjICAgICAgICV4e1xuICAjICAgICAgICAgaWYgKFxuICAjICAgICAgICAgICBzZWxmLiRhbGxvY2F0ZS4kJHByaXN0aW5lICYmXG4gICMgICAgICAgICAgIHNlbGYuJGNvcHlfaW5zdGFuY2VfdmFyaWFibGVzLiQkcHJpc3RpbmUgJiZcbiAgIyAgICAgICAgICAgc2VsZi4kaW5pdGlhbGl6ZV9kdXAuJCRwcmlzdGluZVxuICAjICAgICAgICAgKSByZXR1cm4gc2VsZi5zbGljZSgwKTtcbiAgIyAgICAgICB9XG4gICNcbiAgIyAgICAgICBzdXBlclxuICAjICAgICBlbmRcbiAgIyAgIGVuZFxuICAjXG4gICMgQHBhcmFtIG93bmVyX2NsYXNzIFtDbGFzc10gdGhlIGNsYXNzIG93bmluZyB0aGUgbWV0aG9kc1xuICAjIEBwYXJhbSBtZXRob2RfbmFtZXMgW0FycmF5PFN5bWJvbD5dIHRoZSBsaXN0IG9mIG1ldGhvZHMgbmFtZXMgdG8gbWFya1xuICAjIEByZXR1cm4gW25pbF1cbiAgZGVmIHNlbGYucHJpc3RpbmUob3duZXJfY2xhc3MsICptZXRob2RfbmFtZXMpXG4gICAgJXh7XG4gICAgICB2YXIgbWV0aG9kX25hbWUsIG1ldGhvZDtcbiAgICAgIGZvciAodmFyIGkgPSBtZXRob2RfbmFtZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbWV0aG9kX25hbWUgPSBtZXRob2RfbmFtZXNbaV07XG4gICAgICAgIG1ldGhvZCA9IG93bmVyX2NsYXNzLiQkcHJvdG90eXBlW09wYWwuanNpZChtZXRob2RfbmFtZSldO1xuXG4gICAgICAgIGlmIChtZXRob2QgJiYgIW1ldGhvZC4kJHN0dWIpIHtcbiAgICAgICAgICBtZXRob2QuJCRwcmlzdGluZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbmlsXG4gIGVuZFxuXG4gIGB2YXIgaW5zcGVjdF9zdGFjayA9IFtdYFxuXG4gICMgUGVyZm9ybXMgYSBzYWZlIGNhbGwgdG8gaW5zcGVjdCBmb3IgYW55IHZhbHVlLCB3aGV0aGVyXG4gICMgbmF0aXZlIG9yIE9wYWwtd3JhcHBlZC5cbiAgI1xuICAjIEBwYXJhbSB2YWx1ZSBbT2JqZWN0XVxuICAjIEByZXR1cm4gW1N0cmluZ11cbiAgZGVmIHNlbGYuaW5zcGVjdCh2YWx1ZSA9IHVuZGVmaW5lZClcbiAgICBgdmFyIHB1c2hlZCA9IGZhbHNlYFxuICAgIGJlZ2luXG4gICAgICAleHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gSlMgbnVsbCB2YWx1ZVxuICAgICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIEpTIHVuZGVmaW5lZCB2YWx1ZVxuICAgICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUuJCRjbGFzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBKUyBvYmplY3QgLyBvdGhlciB2YWx1ZSB0aGF0IGlzIG5vdCBicmlkZ2VkXG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS4kaW5zcGVjdCAhPT0gJ2Z1bmN0aW9uJyB8fCB2YWx1ZS4kaW5zcGVjdC4kJHN0dWIpIHtcbiAgICAgICAgICAvLyBCYXNpY09iamVjdCBhbmQgZnJpZW5kc1xuICAgICAgICAgIHJldHVybiAje1wiIzwje2B2YWx1ZS4kJGNsYXNzYH06MHgje3ZhbHVlLl9faWRfXy50b19zKDE2KX0+XCJ9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5zcGVjdF9zdGFjay5pbmRleE9mKCN7dmFsdWUuX19pZF9ffSkgIT09IC0xKSB7XG4gICAgICAgICAgLy8gaW5zcGVjdCByZWN1cnNpbmcgaW5zaWRlIGluc3BlY3QgdG8gZmluZCBvdXQgYWJvdXQgdGhlXG4gICAgICAgICAgLy8gc2FtZSBvYmplY3RcbiAgICAgICAgICByZXR1cm4gI3tcIiM8I3tgdmFsdWUuJCRjbGFzc2B9OjB4I3t2YWx1ZS5fX2lkX18udG9fcygxNil9PlwifVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIGFueXRoaW5nIHN1cHBvcnRpbmcgT3BhbFxuICAgICAgICAgIGluc3BlY3Rfc3RhY2sucHVzaCgje3ZhbHVlLl9faWRfX30pO1xuICAgICAgICAgIHB1c2hlZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlLiRpbnNwZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5pbFxuICAgIHJlc2N1ZSA6OkV4Y2VwdGlvbiA9PiBlICMgcnVib2NvcDpkaXNhYmxlIExpbnQvUmVzY3VlRXhjZXB0aW9uXG4gICAgICBcIiM8I3tgdmFsdWUuJCRjbGFzc2B9OjB4I3t2YWx1ZS5fX2lkX18udG9fcygxNil9PlwiXG4gICAgZW5zdXJlXG4gICAgICBgaWYgKHB1c2hlZCkgaW5zcGVjdF9zdGFjay5wb3AoKWBcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpPcGFsPiIsImJyaWRnZSIsInNlbGYiLCJjb25zdHJ1Y3RvciIsImtsYXNzIiwiY29lcmNlX3RvISIsIm9iamVjdCIsInR5cGUiLCJtZXRob2QiLCJjb2VyY2VkIiwiS2VybmVsIiwicmFpc2UiLCJjb2VyY2VfdG8/IiwicmVzcG9uZF90bz8iLCJuaWw/IiwidHJ5X2NvbnZlcnQiLCJfX3NlbmRfXyIsImNvbXBhcmUiLCJhIiwiYiIsIjw9PiIsIkFyZ3VtZW50RXJyb3IiLCJjbGFzcyIsImRlc3RydWN0dXJlIiwiYXJncyIsIm9iaiIsImluY2x1ZGVfYWxsIiwiaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEiLCJuYW1lIiwiT3BhbCIsIlN0cmluZyIsIk5hbWVFcnJvciIsIm5ldyIsImNsYXNzX3ZhcmlhYmxlX25hbWUhIiwiY29uc3RfbmFtZT8iLCJjb25zdF9uYW1lIiwiY29uc3RfbmFtZSEiLCJwcmlzdGluZSIsIm93bmVyX2NsYXNzIiwiaW5zcGVjdCIsInZhbHVlIiwiX19pZF9fIiwidG9fcyIsIjE2IiwiRXhjZXB0aW9uIiwiZSJdLCJtYXBwaW5ncyI6IkFBQUFBLGtDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBR0FBLE9BQUFDO0VBQUFBOzs7O0lBQ0VDLE1BQUlDLElBQUpELGFBQUFBLGtCQUFnQkUsV0FBRCxFQUFjQyxLQUE3Qkg7QUFBQUE7TUFDRUEsT0FBQ0EsK0JBQURBO0lBREZBLENBQUFBO0lBSUFJLE1BQUlILElBQUpHLGlCQUFBQSxnQ0FBb0JDLE1BQUQsRUFBU0MsSUFBVCxFQUFlQyxNQUFmLEVBUnJCLEVBUUVIO0FBQUFBLE1BQUFBOzs7TUFS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QTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSxpQkFBb0JBLElBQUQsR0FBQSxDQUFNQSxhQUFOLENBQUEsR0FBcUJBLEtBQXJCLEdBQUEsQ0FBMEJDLEtBQUtDLFFBQUFBLENBQUFBLENBQU9DLE1BQUFBLENBQU1DLEVBQU5ELENBQXRDLENBQUEsR0FBZ0RIO0FBQ25FQTtBQUNBQSx1Q0FBeUNDLEtBQUtDLFFBQUFBLENBQUFBLENBQVFGO0FBQ3REQTtBQUNBQTtBQUNBQSxpQkFBb0JBLElBQUQsR0FBQSxDQUFNQSxhQUFOLENBQUEsR0FBcUJBLEtBQXJCLEdBQUEsQ0FBMEJDLEtBQUtDLFFBQUFBLENBQUFBLENBQU9DLE1BQUFBLENBQU1DLEVBQU5ELENBQXRDLENBQUEsR0FBZ0RIO0FBQ25FQTtBQUNBQTtBQUNBQTtBQUNBQSw2QkFBK0JDLEtBQUtDLFFBQUFBLENBQUFBLENBQVFGO0FBQzVDQTtBQUNBQTtBQUNBQTtBQUNBQTtRQUNNQSxPQUFBO01BN0JBO1FBOEJGLHNCQUFPLENBQUFLLGdCQUFBLENBQVAsSUFBc0JDLENBQUFBLElBQXRCLElBQXNCQTtVQUF0QjtZQUNFTixPQUFDQSxJQUFELEdBQUEsQ0FBTUEsYUFBTixDQUFBLEdBQXFCQSxLQUFyQixHQUFBLENBQTBCQyxLQUFLQyxRQUFBQSxDQUFBQSxDQUFPQyxNQUFBQSxDQUFNQyxFQUFORCxDQUF0QyxDQUFBLEdBQWdESDtVQURsRDtRQUFBLENBOUJFO01BQUE7TUFBQTtRQWlDQ0E7TUFqQ0QsQ0FBQTtJQUhKQSxDQUFBQSxJQUFBQTtFQXBLRnZDLEdBQU8sSUFBUEE7QUFIQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMzMTQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL21vZHVsZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHRydXRoeSwgY29lcmNlX3RvLCBjb25zdF9zZXQsIE9iamVjdCwgcmV0dXJuX2l2YXIsIGFzc2lnbl9pdmFyLCBpdmFyLCBkZW55X2Zyb3plbl9hY2Nlc3MsIGZyZWV6ZSwgcHJvcCwganNpZCwgZWFjaF9pdmFyXG4jIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcblxuY2xhc3MgOjpNb2R1bGVcbiAgJXh7XG4gICAgZnVuY3Rpb24gZW5zdXJlX3N5bWJvbF9vcl9zdHJpbmcobmFtZSkge1xuICAgICAgaWYgKG5hbWUuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9O1xuICAgICAgdmFyIGNvbnZlcnRlZF9uYW1lID0gI3s6Ok9wYWwudHJ5X2NvbnZlcnQoYG5hbWVgLCA6OlN0cmluZywgOnRvX3N0cil9O1xuICAgICAgaWYgKGNvbnZlcnRlZF9uYW1lLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0ZWRfbmFtZTtcbiAgICAgIH0gZWxzZSBpZiAoY29udmVydGVkX25hbWUgPT09IG5pbCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIiN7YG5hbWVgfSBpcyBub3QgYSBzeW1ib2wgbm9yIGEgc3RyaW5nXCJ9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3tgbmFtZWAuY2xhc3N9IHRvIFN0cmluZyAoI3tgbmFtZWAuY2xhc3N9I3RvX3N0ciBnaXZlcyAje2Bjb252ZXJ0ZWRfbmFtZWAuY2xhc3N9XCJ9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGVmIHNlbGYuYWxsb2NhdGVcbiAgICAleHtcbiAgICAgIHZhciBtb2R1bGUgPSBPcGFsLmFsbG9jYXRlX21vZHVsZShuaWwsIGZ1bmN0aW9uKCl7fSk7XG4gICAgICAvLyBMaW5rIHRoZSBwcm90b3R5cGUgb2YgTW9kdWxlIHN1YmNsYXNzZXNcbiAgICAgIGlmIChzZWxmICE9PSBPcGFsLk1vZHVsZSkgT2JqZWN0LnNldFByb3RvdHlwZU9mKG1vZHVsZSwgc2VsZi4kJHByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gbW9kdWxlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoJmJsb2NrKVxuICAgIG1vZHVsZV9ldmFsKCZibG9jaykgaWYgYmxvY2tfZ2l2ZW4/XG4gIGVuZFxuXG4gIGRlZiA9PT0ob2JqZWN0KVxuICAgIHJldHVybiBmYWxzZSBpZiBgb2JqZWN0ID09IG51bGxgXG5cbiAgICBgT3BhbC5pc19hKG9iamVjdCwgc2VsZilgXG4gIGVuZFxuXG4gIGRlZiA8KG90aGVyKVxuICAgIHVubGVzcyA6Ok1vZHVsZSA9PT0gb3RoZXJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnY29tcGFyZWQgd2l0aCBub24gY2xhc3MvbW9kdWxlJ1xuICAgIGVuZFxuXG4gICAgIyBjbGFzcyBjYW5ub3QgYmUgYSBkZXNjZW5kYW50IG9mIGl0c2VsZlxuICAgICV4e1xuICAgICAgdmFyIHdvcmtpbmcgPSBzZWxmLFxuICAgICAgICAgIGFuY2VzdG9ycyxcbiAgICAgICAgICBpLCBsZW5ndGg7XG5cbiAgICAgIGlmICh3b3JraW5nID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKHNlbGYpLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFuY2VzdG9yc1tpXSA9PT0gb3RoZXIpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhvdGhlciksIGxlbmd0aCA9IGFuY2VzdG9ycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYW5jZXN0b3JzW2ldID09PSBzZWxmKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgPD0ob3RoZXIpXG4gICAgZXF1YWw/KG90aGVyKSB8fCBzZWxmIDwgb3RoZXJcbiAgZW5kXG5cbiAgZGVmID4ob3RoZXIpXG4gICAgdW5sZXNzIDo6TW9kdWxlID09PSBvdGhlclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdjb21wYXJlZCB3aXRoIG5vbiBjbGFzcy9tb2R1bGUnXG4gICAgZW5kXG5cbiAgICBvdGhlciA8IHNlbGZcbiAgZW5kXG5cbiAgZGVmID49KG90aGVyKVxuICAgIGVxdWFsPyhvdGhlcikgfHwgc2VsZiA+IG90aGVyXG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdW5sZXNzIDo6TW9kdWxlID09PSBvdGhlclxuICAgICAgcmV0dXJuIG5pbFxuICAgIGVuZFxuXG4gICAgbHQgPSBzZWxmIDwgb3RoZXJcbiAgICByZXR1cm4gbmlsIGlmIGx0Lm5pbD9cbiAgICBsdCA/IC0xIDogMVxuICBlbmRcblxuICBkZWYgYWxpYXNfbWV0aG9kKG5ld25hbWUsIG9sZG5hbWUpXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXG5cbiAgICBuZXduYW1lID0gYCRjb2VyY2VfdG8obmV3bmFtZSwgI3s6OlN0cmluZ30sICd0b19zdHInKWBcbiAgICBvbGRuYW1lID0gYCRjb2VyY2VfdG8ob2xkbmFtZSwgI3s6OlN0cmluZ30sICd0b19zdHInKWBcbiAgICBgT3BhbC5hbGlhcyhzZWxmLCBuZXduYW1lLCBvbGRuYW1lKWBcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGFsaWFzX25hdGl2ZShtaWQsIGpzaWQgPSBtaWQpXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXG5cbiAgICBgT3BhbC5hbGlhc19uYXRpdmUoc2VsZiwgbWlkLCBqc2lkKWBcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGFuY2VzdG9yc1xuICAgIGBPcGFsLmFuY2VzdG9ycyhzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIGFwcGVuZF9mZWF0dXJlcyhpbmNsdWRlcilcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhpbmNsdWRlcilgXG5cbiAgICBgT3BhbC5hcHBlbmRfZmVhdHVyZXMoc2VsZiwgaW5jbHVkZXIpYFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGF0dHJfYWNjZXNzb3IoKm5hbWVzKVxuICAgIGF0dHJfcmVhZGVyKCpuYW1lcylcbiAgICBhdHRyX3dyaXRlcigqbmFtZXMpXG4gIGVuZFxuXG4gIGRlZiBhdHRyKCphcmdzKVxuICAgICV4e1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09IDIgJiYgKGFyZ3NbMV0gPT09IHRydWUgfHwgYXJnc1sxXSA9PT0gZmFsc2UpKSB7XG4gICAgICAgICN7d2FybiAnb3B0aW9uYWwgYm9vbGVhbiBhcmd1bWVudCBpcyBvYnNvbGV0ZWQnLCB1cGxldmVsOiAxfVxuXG4gICAgICAgIGFyZ3NbMV0gPyAje2F0dHJfYWNjZXNzb3IoYGFyZ3NbMF1gKX0gOiAje2F0dHJfcmVhZGVyKGBhcmdzWzBdYCl9O1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGF0dHJfcmVhZGVyKCphcmdzKVxuICBlbmRcblxuICBkZWYgYXR0cl9yZWFkZXIoKm5hbWVzKVxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgdmFyIHByb3RvID0gc2VsZi4kJHByb3RvdHlwZTtcblxuICAgICAgZm9yICh2YXIgaSA9IG5hbWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBuYW1lID0gbmFtZXNbaV0sXG4gICAgICAgICAgICBpZCAgID0gJGpzaWQobmFtZSksXG4gICAgICAgICAgICBpdmFyID0gJGl2YXIobmFtZSk7XG5cbiAgICAgICAgdmFyIGJvZHkgPSAkcmV0dXJuX2l2YXIoaXZhcik7XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgaW5zdGFuY2UgdmFyaWFibGUgYXMgbmlsXG4gICAgICAgIE9wYWwucHJvcChwcm90bywgaXZhciwgbmlsKTtcblxuICAgICAgICBib2R5LiQkcGFyYW1ldGVycyA9IFtdO1xuICAgICAgICBib2R5LiQkYXJpdHkgPSAwO1xuXG4gICAgICAgIE9wYWwuZGVmbihzZWxmLCBpZCwgYm9keSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBhdHRyX3dyaXRlcigqbmFtZXMpXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICB2YXIgcHJvdG8gPSBzZWxmLiQkcHJvdG90eXBlO1xuXG4gICAgICBmb3IgKHZhciBpID0gbmFtZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXSxcbiAgICAgICAgICAgIGlkICAgPSAkanNpZChuYW1lICsgJz0nKSxcbiAgICAgICAgICAgIGl2YXIgPSAkaXZhcihuYW1lKTtcblxuICAgICAgICB2YXIgYm9keSA9ICRhc3NpZ25faXZhcihpdmFyKVxuXG4gICAgICAgIGJvZHkuJCRwYXJhbWV0ZXJzID0gW1sncmVxJ11dO1xuICAgICAgICBib2R5LiQkYXJpdHkgPSAxO1xuXG4gICAgICAgIC8vIGluaXRpYWxpemUgdGhlIGluc3RhbmNlIHZhcmlhYmxlIGFzIG5pbFxuICAgICAgICBPcGFsLnByb3AocHJvdG8sIGl2YXIsIG5pbCk7XG5cbiAgICAgICAgT3BhbC5kZWZuKHNlbGYsIGlkLCBib2R5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGF1dG9sb2FkKGNvbnN0LCBwYXRoKVxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgaWYgKCEje09wYWwuY29uc3RfbmFtZT8oY29uc3QpfSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLCBcImF1dG9sb2FkIG11c3QgYmUgY29uc3RhbnQgbmFtZTogI3tjb25zdH1cIn1cbiAgICAgIH1cblxuICAgICAgaWYgKHBhdGggPT0gXCJcIikge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2VtcHR5IGZpbGUgbmFtZSd9XG4gICAgICB9XG5cbiAgICAgIGlmICghc2VsZi4kJGNvbnN0Lmhhc093blByb3BlcnR5KCN7Y29uc3R9KSkge1xuICAgICAgICBpZiAoIXNlbGYuJCRhdXRvbG9hZCkge1xuICAgICAgICAgIHNlbGYuJCRhdXRvbG9hZCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbisrO1xuICAgICAgICBzZWxmLiQkYXV0b2xvYWRbI3tjb25zdH1dID0geyBwYXRoOiAje3BhdGh9LCBsb2FkZWQ6IGZhbHNlLCByZXF1aXJlZDogZmFsc2UsIHN1Y2Nlc3M6IGZhbHNlLCBleGNlcHRpb246IGZhbHNlIH07XG5cbiAgICAgICAgaWYgKHNlbGYuJGNvbnN0X2FkZGVkICYmICFzZWxmLiRjb25zdF9hZGRlZC4kJHByaXN0aW5lKSB7XG4gICAgICAgICAgc2VsZi4kY29uc3RfYWRkZWQoI3tjb25zdH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGF1dG9sb2FkPyhjb25zdClcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkYXV0b2xvYWQgJiYgc2VsZi4kJGF1dG9sb2FkWyN7Y29uc3R9XSAmJiAhc2VsZi4kJGF1dG9sb2FkWyN7Y29uc3R9XS5yZXF1aXJlZCAmJiAhc2VsZi4kJGF1dG9sb2FkWyN7Y29uc3R9XS5zdWNjZXNzKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkYXV0b2xvYWRbI3tjb25zdH1dLnBhdGg7XG4gICAgICB9XG5cbiAgICAgIHZhciBhbmNlc3RvcnMgPSBzZWxmLiRhbmNlc3RvcnMoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFuY2VzdG9ycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYW5jZXN0b3JzW2ldLiQkYXV0b2xvYWQgJiYgYW5jZXN0b3JzW2ldLiQkYXV0b2xvYWRbI3tjb25zdH1dICYmICFhbmNlc3RvcnNbaV0uJCRhdXRvbG9hZFsje2NvbnN0fV0ucmVxdWlyZWQgJiYgIWFuY2VzdG9yc1tpXS4kJGF1dG9sb2FkWyN7Y29uc3R9XS5zdWNjZXNzKSB7XG4gICAgICAgICAgcmV0dXJuIGFuY2VzdG9yc1tpXS4kJGF1dG9sb2FkWyN7Y29uc3R9XS5wYXRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNsYXNzX3ZhcmlhYmxlc1xuICAgIGBPYmplY3Qua2V5cyhPcGFsLmNsYXNzX3ZhcmlhYmxlcyhzZWxmKSlgXG4gIGVuZFxuXG4gIGRlZiBjbGFzc192YXJpYWJsZV9nZXQobmFtZSlcbiAgICBuYW1lID0gOjpPcGFsLmNsYXNzX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICBgT3BhbC5jbGFzc192YXJpYWJsZV9nZXQoc2VsZiwgbmFtZSwgZmFsc2UpYFxuICBlbmRcblxuICBkZWYgY2xhc3NfdmFyaWFibGVfc2V0KG5hbWUsIHZhbHVlKVxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxuXG4gICAgbmFtZSA9IDo6T3BhbC5jbGFzc192YXJpYWJsZV9uYW1lIShuYW1lKVxuXG4gICAgYE9wYWwuY2xhc3NfdmFyaWFibGVfc2V0KHNlbGYsIG5hbWUsIHZhbHVlKWBcbiAgZW5kXG5cbiAgZGVmIGNsYXNzX3ZhcmlhYmxlX2RlZmluZWQ/KG5hbWUpXG4gICAgbmFtZSA9IDo6T3BhbC5jbGFzc192YXJpYWJsZV9uYW1lIShuYW1lKVxuXG4gICAgYE9wYWwuY2xhc3NfdmFyaWFibGVzKHNlbGYpLmhhc093blByb3BlcnR5KG5hbWUpYFxuICBlbmRcblxuICBkZWYgY29uc3RfYWRkZWQobmFtZSlcbiAgZW5kXG4gIDo6T3BhbC5wcmlzdGluZSBzZWxmLCA6Y29uc3RfYWRkZWRcblxuICBkZWYgcmVtb3ZlX2NsYXNzX3ZhcmlhYmxlKG5hbWUpXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXG5cbiAgICBuYW1lID0gOjpPcGFsLmNsYXNzX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICAleHtcbiAgICAgIGlmIChPcGFsLmhhc093blByb3BlcnR5LmNhbGwoc2VsZi4kJGN2YXJzLCBuYW1lKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBzZWxmLiQkY3ZhcnNbbmFtZV07XG4gICAgICAgIGRlbGV0ZSBzZWxmLiQkY3ZhcnNbbmFtZV07XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpOYW1lRXJyb3IsIFwiY2Fubm90IHJlbW92ZSAje25hbWV9IGZvciAje3NlbGZ9XCJ9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29uc3RhbnRzKGluaGVyaXQgPSB0cnVlKVxuICAgIGBPcGFsLmNvbnN0YW50cyhzZWxmLCBpbmhlcml0KWBcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY29uc3RhbnRzKGluaGVyaXQgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoaW5oZXJpdCA9PSBudWxsKSB7XG4gICAgICAgIHZhciBuZXN0aW5nID0gKHNlbGYuJCRuZXN0aW5nIHx8IFtdKS5jb25jYXQoJE9iamVjdCksXG4gICAgICAgICAgICBjb25zdGFudCwgY29uc3RhbnRzID0ge30sXG4gICAgICAgICAgICBpLCBpaTtcblxuICAgICAgICBmb3IoaSA9IDAsIGlpID0gbmVzdGluZy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgZm9yIChjb25zdGFudCBpbiBuZXN0aW5nW2ldLiQkY29uc3QpIHtcbiAgICAgICAgICAgIGNvbnN0YW50c1tjb25zdGFudF0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoY29uc3RhbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcGFsLmNvbnN0YW50cyhzZWxmLCBpbmhlcml0KVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYubmVzdGluZ1xuICAgIGBzZWxmLiQkbmVzdGluZyB8fCBbXWBcbiAgZW5kXG5cbiAgIyBjaGVjayBmb3IgY29uc3RhbnQgd2l0aGluIGN1cnJlbnQgc2NvcGVcbiAgIyBpZiBpbmhlcml0IGlzIHRydWUgb3Igc2VsZiBpcyBPYmplY3QsIHdpbGwgYWxzbyBjaGVjayBhbmNlc3RvcnNcbiAgZGVmIGNvbnN0X2RlZmluZWQ/KG5hbWUsIGluaGVyaXQgPSB0cnVlKVxuICAgIG5hbWUgPSBPcGFsLmNvbnN0X25hbWUhKG5hbWUpXG5cbiAgICA6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvci5uZXcoXCJ3cm9uZyBjb25zdGFudCBuYW1lICN7bmFtZX1cIiwgbmFtZSkgdW5sZXNzIG5hbWUgPX4gOjpPcGFsOjpDT05TVF9OQU1FX1JFR0VYUFxuXG4gICAgJXh7XG4gICAgICB2YXIgbW9kdWxlLCBtb2R1bGVzID0gW3NlbGZdLCBtb2R1bGVfY29uc3RhbnRzLCBpLCBpaTtcblxuICAgICAgLy8gQWRkIHVwIGFuY2VzdG9ycyBpZiBpbmhlcml0IGlzIHRydWVcbiAgICAgIGlmIChpbmhlcml0KSB7XG4gICAgICAgIG1vZHVsZXMgPSBtb2R1bGVzLmNvbmNhdChPcGFsLmFuY2VzdG9ycyhzZWxmKSk7XG5cbiAgICAgICAgLy8gQWRkIE9iamVjdCdzIGFuY2VzdG9ycyBpZiBpdCdzIGEgbW9kdWxlIOKAkyBtb2R1bGVzIGhhdmUgbm8gYW5jZXN0b3JzIG90aGVyd2lzZVxuICAgICAgICBpZiAoc2VsZi4kJGlzX21vZHVsZSkge1xuICAgICAgICAgIG1vZHVsZXMgPSBtb2R1bGVzLmNvbmNhdChbJE9iamVjdF0pLmNvbmNhdChPcGFsLmFuY2VzdG9ycygkT2JqZWN0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgaWkgPSBtb2R1bGVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgbW9kdWxlID0gbW9kdWxlc1tpXTtcbiAgICAgICAgaWYgKG1vZHVsZS4kJGNvbnN0WyN7bmFtZX1dICE9IG51bGwpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIG1vZHVsZS4kJGF1dG9sb2FkICYmXG4gICAgICAgICAgbW9kdWxlLiQkYXV0b2xvYWRbI3tuYW1lfV0gJiZcbiAgICAgICAgICAhbW9kdWxlLiQkYXV0b2xvYWRbI3tuYW1lfV0ucmVxdWlyZWQgJiZcbiAgICAgICAgICAhbW9kdWxlLiQkYXV0b2xvYWRbI3tuYW1lfV0uc3VjY2Vzc1xuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29uc3RfZ2V0KG5hbWUsIGluaGVyaXQgPSB0cnVlKVxuICAgIG5hbWUgPSBPcGFsLmNvbnN0X25hbWUhKG5hbWUpXG5cbiAgICAleHtcbiAgICAgIGlmIChuYW1lLmluZGV4T2YoJzo6JykgPT09IDAgJiYgbmFtZSAhPT0gJzo6Jyl7XG4gICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIGBuYW1lLmluZGV4T2YoJzo6JykgIT0gLTEgJiYgbmFtZSAhPSAnOjonYFxuICAgICAgcmV0dXJuIG5hbWUuc3BsaXQoJzo6JykuaW5qZWN0KHNlbGYpIHsgfG8sIGN8IG8uY29uc3RfZ2V0KGMpIH1cbiAgICBlbmRcblxuICAgIDo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLm5ldyhcIndyb25nIGNvbnN0YW50IG5hbWUgI3tuYW1lfVwiLCBuYW1lKSB1bmxlc3MgbmFtZSA9fiA6Ok9wYWw6OkNPTlNUX05BTUVfUkVHRVhQXG5cbiAgICAleHtcbiAgICAgIGlmIChpbmhlcml0KSB7XG4gICAgICAgIHJldHVybiBPcGFsLiQkKFtzZWxmXSwgbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3BhbC5jb25zdF9nZXRfbG9jYWwoc2VsZiwgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29uc3RfbWlzc2luZyhuYW1lKVxuICAgIGZ1bGxfY29uc3RfbmFtZSA9IHNlbGYgPT0gOjpPYmplY3QgPyBuYW1lIDogXCIje3NlbGZ9Ojoje25hbWV9XCJcblxuICAgIDo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLm5ldyhcInVuaW5pdGlhbGl6ZWQgY29uc3RhbnQgI3tmdWxsX2NvbnN0X25hbWV9XCIsIG5hbWUpXG4gIGVuZFxuXG4gIGRlZiBjb25zdF9zZXQobmFtZSwgdmFsdWUpXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXG5cbiAgICBuYW1lID0gOjpPcGFsLmNvbnN0X25hbWUhKG5hbWUpXG5cbiAgICBpZiBuYW1lICF+IDo6T3BhbDo6Q09OU1RfTkFNRV9SRUdFWFAgfHwgbmFtZS5zdGFydF93aXRoPygnOjonKVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpOYW1lRXJyb3IubmV3KFwid3JvbmcgY29uc3RhbnQgbmFtZSAje25hbWV9XCIsIG5hbWUpXG4gICAgZW5kXG5cbiAgICBgJGNvbnN0X3NldChzZWxmLCBuYW1lLCB2YWx1ZSlgXG5cbiAgICB2YWx1ZVxuICBlbmRcblxuICBkZWYgcHVibGljX2NvbnN0YW50KGNvbnN0X25hbWUpXG4gIGVuZFxuXG4gIGRlZiBkZWZpbmVfbWV0aG9kKG5hbWUsIG1ldGhvZCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkICYmIGJsb2NrID09PSBuaWwpXG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY3JlYXRlIGEgUHJvYyBvYmplY3Qgd2l0aG91dCBhIGJsb2NrJ31cblxuICAgICAgbmFtZSA9IGVuc3VyZV9zeW1ib2xfb3Jfc3RyaW5nKG5hbWUpO1xuICAgIH1cblxuICAgIGlmIGBtZXRob2QgIT09IHVuZGVmaW5lZGBcbiAgICAgIGJsb2NrID0gY2FzZSBtZXRob2RcbiAgICAgICAgICAgICAgd2hlbiA6OlByb2NcbiAgICAgICAgICAgICAgICBtZXRob2RcblxuICAgICAgICAgICAgICB3aGVuIDo6TWV0aG9kXG4gICAgICAgICAgICAgICAgYCN7bWV0aG9kLnRvX3Byb2N9LiQkdW5ib3VuZGBcblxuICAgICAgICAgICAgICB3aGVuIDo6VW5ib3VuZE1ldGhvZFxuICAgICAgICAgICAgICAgIGBPcGFsLndyYXBfbWV0aG9kX2JvZHkobWV0aG9kLiQkbWV0aG9kKWBcblxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje21ldGhvZC5jbGFzc30gKGV4cGVjdGVkIFByb2MvTWV0aG9kL1VuYm91bmRNZXRob2QpXCJcbiAgICAgICAgICAgICAgZW5kXG5cbiAgICAgIGlmIGAhbWV0aG9kLiQkaXNfcHJvY2BcbiAgICAgICAgb3duZXIgPSBtZXRob2Qub3duZXJcbiAgICAgICAgaWYgYG93bmVyLiQkaXNfY2xhc3NgICYmICEoc2VsZiA8PSBvd25lcikgIyBydWJvY29wOmRpc2FibGUgU3R5bGUvSW52ZXJzZU1ldGhvZHNcbiAgICAgICAgICBtZXNzYWdlID0gYG93bmVyLiQkaXNfc2luZ2xldG9uYCA/IFwiY2FuJ3QgYmluZCBzaW5nbGV0b24gbWV0aG9kIHRvIGEgZGlmZmVyZW50IGNsYXNzXCIgOiBcImJpbmQgYXJndW1lbnQgbXVzdCBiZSBhIHN1YmNsYXNzIG9mICN7b3duZXJ9XCJcbiAgICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgbWVzc2FnZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAodHlwZW9mKFByb3h5KSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIG1ldGEgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgICAgICAgYmxvY2suJCRwcm94eV90YXJnZXQgPSBibG9ja1xuICAgICAgICBibG9jayA9IG5ldyBQcm94eShibG9jaywge1xuICAgICAgICAgIGFwcGx5OiBmdW5jdGlvbih0YXJnZXQsIHNlbGYsIGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBvbGRfbmFtZSA9IHRhcmdldC4kJGpzaWQsIG9sZF9sYW1iZGEgPSB0YXJnZXQuJCRpc19sYW1iZGE7XG4gICAgICAgICAgICB0YXJnZXQuJCRqc2lkID0gbmFtZTtcbiAgICAgICAgICAgIHRhcmdldC4kJGlzX2xhbWJkYSA9IHRydWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgIGlmIChlID09PSB0YXJnZXQuJCRicmsgfHwgZSA9PT0gdGFyZ2V0LiQkcmV0KSByZXR1cm4gZS4kdjtcbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHRhcmdldC4kJGpzaWQgPSBvbGRfbmFtZTtcbiAgICAgICAgICAgICAgdGFyZ2V0LiQkaXNfbGFtYmRhID0gb2xkX2xhbWJkYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGJsb2NrLiQkanNpZCAgICAgICAgPSBuYW1lO1xuICAgICAgYmxvY2suJCRzICAgICAgICAgICA9IG51bGw7XG4gICAgICBibG9jay4kJGRlZiAgICAgICAgID0gYmxvY2s7XG4gICAgICBibG9jay4kJGRlZmluZV9tZXRoID0gdHJ1ZTtcblxuICAgICAgcmV0dXJuIE9wYWwuZGVmbihzZWxmLCAkanNpZChuYW1lKSwgYmxvY2spO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZyZWV6ZVxuICAgICMgU3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBmcmVlemUsIGJlY2F1c2UgdGhlICQkYmFzZV9tb2R1bGUgcHJvcGVydHkgbmVlZHMgdG8gYmVcbiAgICAjIGFjY2Vzc2libGUgZGVzcGl0ZSB0aGUgZnJvemVuIHN0YXR1c1xuXG4gICAgcmV0dXJuIHNlbGYgaWYgZnJvemVuP1xuXG4gICAgJXh7XG4gICAgICBpZiAoIXNlbGYuaGFzT3duUHJvcGVydHkoJyQkYmFzZV9tb2R1bGUnKSkgeyAkcHJvcChzZWxmLCAnJCRiYXNlX21vZHVsZScsIG51bGwpOyB9XG5cbiAgICAgIHJldHVybiAkZnJlZXplKHNlbGYpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlbW92ZV9tZXRob2QoKm5hbWVzKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmFtZSA9IGVuc3VyZV9zeW1ib2xfb3Jfc3RyaW5nKG5hbWVzW2ldKTtcbiAgICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgICBPcGFsLnJkZWYoc2VsZiwgXCIkXCIgKyBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBzaW5nbGV0b25fY2xhc3M/XG4gICAgYCEhc2VsZi4kJGlzX3NpbmdsZXRvbmBcbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGUoKm1vZHMpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gbW9kcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbW9kID0gbW9kc1tpXTtcblxuICAgICAgICBpZiAoIW1vZC4kJGlzX21vZHVsZSkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje2Btb2RgLmNsYXNzfSAoZXhwZWN0ZWQgTW9kdWxlKVwifTtcbiAgICAgICAgfVxuXG4gICAgICAgICN7YG1vZGAuYXBwZW5kX2ZlYXR1cmVzIHNlbGZ9O1xuICAgICAgICAje2Btb2RgLmluY2x1ZGVkIHNlbGZ9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGVkX21vZHVsZXNcbiAgICBgT3BhbC5pbmNsdWRlZF9tb2R1bGVzKHNlbGYpYFxuICBlbmRcblxuICBkZWYgaW5jbHVkZT8obW9kKVxuICAgICV4e1xuICAgICAgaWYgKCFtb2QuJCRpc19tb2R1bGUpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7YG1vZGAuY2xhc3N9IChleHBlY3RlZCBNb2R1bGUpXCJ9O1xuICAgICAgfVxuXG4gICAgICB2YXIgaSwgaWksIG1vZDIsIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKHNlbGYpO1xuXG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGFuY2VzdG9ycy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIG1vZDIgPSBhbmNlc3RvcnNbaV07XG4gICAgICAgIGlmIChtb2QyID09PSBtb2QgJiYgbW9kMiAhPT0gc2VsZikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV9tZXRob2QobmFtZSlcbiAgICAleHtcbiAgICAgIHZhciBtZXRoID0gc2VsZi4kJHByb3RvdHlwZVskanNpZChuYW1lKV07XG5cbiAgICAgIGlmICghbWV0aCB8fCBtZXRoLiQkc3R1Yikge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLm5ldyhcInVuZGVmaW5lZCBtZXRob2QgYCN7bmFtZX0nIGZvciBjbGFzcyBgI3tzZWxmLm5hbWV9J1wiLCBuYW1lKX07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAjezo6VW5ib3VuZE1ldGhvZC5uZXcoc2VsZiwgYG1ldGguJCRvd25lciB8fCAje3NlbGZ9YCwgYG1ldGhgLCBuYW1lKX07XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfbWV0aG9kcyhpbmNsdWRlX3N1cGVyID0gdHJ1ZSlcbiAgICAleHtcbiAgICAgIGlmICgkdHJ1dGh5KCN7aW5jbHVkZV9zdXBlcn0pKSB7XG4gICAgICAgIHJldHVybiBPcGFsLmluc3RhbmNlX21ldGhvZHMoc2VsZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3BhbC5vd25faW5zdGFuY2VfbWV0aG9kcyhzZWxmKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlZChtb2QpXG4gIGVuZFxuXG4gIGRlZiBleHRlbmRlZChtb2QpXG4gIGVuZFxuXG4gIGRlZiBleHRlbmRfb2JqZWN0KG9iamVjdClcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhvYmplY3QpYFxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgbWV0aG9kX2FkZGVkKCopXG4gIGVuZFxuXG4gIGRlZiBtZXRob2RfcmVtb3ZlZCgqKVxuICBlbmRcblxuICBkZWYgbWV0aG9kX3VuZGVmaW5lZCgqKVxuICBlbmRcblxuICBkZWYgbW9kdWxlX2V2YWwoKmFyZ3MsICZibG9jaylcbiAgICBpZiBibG9jay5uaWw/ICYmIGAhIU9wYWwuY29tcGlsZWBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKDAgZm9yIDEuLjMpJyB1bmxlc3MgKDEuLjMpLmNvdmVyPyBhcmdzLnNpemVcblxuICAgICAgc3RyaW5nLCBmaWxlLCBfbGluZW5vID0gKmFyZ3NcbiAgICAgIGRlZmF1bHRfZXZhbF9vcHRpb25zID0geyBmaWxlOiAoZmlsZSB8fCAnKGV2YWwpJyksIGV2YWw6IHRydWUgfVxuICAgICAgY29tcGlsaW5nX29wdGlvbnMgPSBfX09QQUxfQ09NUElMRVJfQ09ORklHX18ubWVyZ2UoZGVmYXVsdF9ldmFsX29wdGlvbnMpXG4gICAgICBjb21waWxlZCA9IDo6T3BhbC5jb21waWxlIHN0cmluZywgY29tcGlsaW5nX29wdGlvbnNcbiAgICAgIGJsb2NrID0gOjpLZXJuZWwucHJvYyBkb1xuICAgICAgICAleHtuZXcgRnVuY3Rpb24oXCJPcGFsLHNlbGZcIiwgXCJyZXR1cm4gXCIgKyBjb21waWxlZCkoT3BhbCwgc2VsZil9XG4gICAgICBlbmRcbiAgICBlbHNpZiBhcmdzLmFueT9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2FyZ3Muc2l6ZX0gZm9yIDApXCIgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG5cXG4gIE5PVEU6SWYgeW91IHdhbnQgdG8gZW5hYmxlIHBhc3NpbmcgYSBTdHJpbmcgYXJndW1lbnQgcGxlYXNlIGFkZCBcXFwicmVxdWlyZSAnb3BhbC1wYXJzZXInXFxcIiB0byB5b3VyIHNjcmlwdFxcblwiXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBvbGQgPSBibG9jay4kJHMsXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICBibG9jay4kJHMgPSBudWxsO1xuICAgICAgcmVzdWx0ID0gYmxvY2suYXBwbHkoc2VsZiwgW3NlbGZdKTtcbiAgICAgIGJsb2NrLiQkcyA9IG9sZDtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtb2R1bGVfZXhlYygqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKGJsb2NrID09PSBuaWwpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkxvY2FsSnVtcEVycm9yLCAnbm8gYmxvY2sgZ2l2ZW4nfVxuICAgICAgfVxuXG4gICAgICB2YXIgYmxvY2tfc2VsZiA9IGJsb2NrLiQkcywgcmVzdWx0O1xuXG4gICAgICBibG9jay4kJHMgPSBudWxsO1xuICAgICAgcmVzdWx0ID0gYmxvY2suYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICBibG9jay4kJHMgPSBibG9ja19zZWxmO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF9kZWZpbmVkPyhtZXRob2QpXG4gICAgJXh7XG4gICAgICB2YXIgYm9keSA9IHNlbGYuJCRwcm90b3R5cGVbJGpzaWQobWV0aG9kKV07XG4gICAgICByZXR1cm4gKCEhYm9keSkgJiYgIWJvZHkuJCRzdHViO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1vZHVsZV9mdW5jdGlvbigqbWV0aG9kcylcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIGlmIChtZXRob2RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzZWxmLiQkbW9kdWxlX2Z1bmN0aW9uID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbWV0aG9kcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBtZXRoID0gbWV0aG9kc1tpXSxcbiAgICAgICAgICAgICAgaWQgICA9ICRqc2lkKG1ldGgpLFxuICAgICAgICAgICAgICBmdW5jID0gc2VsZi4kJHByb3RvdHlwZVtpZF07XG5cbiAgICAgICAgICBPcGFsLmRlZnMoc2VsZiwgaWQsIGZ1bmMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRob2RzLmxlbmd0aCA9PT0gMSA/IG1ldGhvZHNbMF0gOiBtZXRob2RzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBuYW1lXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi4kJGZ1bGxfbmFtZSkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGZ1bGxfbmFtZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IFtdLCBiYXNlID0gc2VsZjtcblxuICAgICAgd2hpbGUgKGJhc2UpIHtcbiAgICAgICAgLy8gR2l2ZSB1cCBpZiBhbnkgb2YgdGhlIGFuY2VzdG9ycyBpcyB1bm5hbWVkXG4gICAgICAgIGlmIChiYXNlLiQkbmFtZSA9PT0gbmlsIHx8IGJhc2UuJCRuYW1lID09IG51bGwpIHJldHVybiBuaWw7XG5cbiAgICAgICAgcmVzdWx0LnVuc2hpZnQoYmFzZS4kJG5hbWUpO1xuXG4gICAgICAgIGJhc2UgPSBiYXNlLiQkYmFzZV9tb2R1bGU7XG5cbiAgICAgICAgaWYgKGJhc2UgPT09ICRPYmplY3QpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kJGZ1bGxfbmFtZSA9IHJlc3VsdC5qb2luKCc6OicpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHByZXBlbmQoKm1vZHMpXG4gICAgJXh7XG4gICAgICBpZiAobW9kcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIChnaXZlbiAwLCBleHBlY3RlZCAxKyknfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gbW9kcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbW9kID0gbW9kc1tpXTtcblxuICAgICAgICBpZiAoIW1vZC4kJGlzX21vZHVsZSkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje2Btb2RgLmNsYXNzfSAoZXhwZWN0ZWQgTW9kdWxlKVwifTtcbiAgICAgICAgfVxuXG4gICAgICAgICN7YG1vZGAucHJlcGVuZF9mZWF0dXJlcyBzZWxmfTtcbiAgICAgICAgI3tgbW9kYC5wcmVwZW5kZWQgc2VsZn07XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcHJlcGVuZF9mZWF0dXJlcyhwcmVwZW5kZXIpXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHByZXBlbmRlcik7XG5cbiAgICAgIGlmICghc2VsZi4kJGlzX21vZHVsZSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3tzZWxmLmNsYXNzfSAoZXhwZWN0ZWQgTW9kdWxlKVwifTtcbiAgICAgIH1cblxuICAgICAgT3BhbC5wcmVwZW5kX2ZlYXR1cmVzKHNlbGYsIHByZXBlbmRlcilcbiAgICB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcHJlcGVuZGVkKG1vZClcbiAgZW5kXG5cbiAgZGVmIHJlbW92ZV9jb25zdChuYW1lKVxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxuXG4gICAgYE9wYWwuY29uc3RfcmVtb3ZlKHNlbGYsIG5hbWUpYFxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIGBPcGFsLk1vZHVsZS4kbmFtZS5jYWxsKHNlbGYpYCB8fCBcIiM8I3tgc2VsZi4kJGlzX21vZHVsZSA/ICdNb2R1bGUnIDogJ0NsYXNzJ2B9OjB4I3tfX2lkX18udG9fcygxNil9PlwiXG4gIGVuZFxuXG4gIGRlZiB1bmRlZl9tZXRob2QoKm5hbWVzKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmFtZSA9IGVuc3VyZV9zeW1ib2xfb3Jfc3RyaW5nKG5hbWVzW2ldKTtcbiAgICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgICBPcGFsLnVkZWYoc2VsZiwgXCIkXCIgKyBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZXNcbiAgICBjb25zdHMgPSBjb25zdGFudHNcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgJGVhY2hfaXZhcihzZWxmLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lICE9PSAnY29uc3RydWN0b3InICYmICEje2NvbnN0cy5pbmNsdWRlPyhgbmFtZWApfSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKCdAJyArIG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gICV4e1xuICAgIGZ1bmN0aW9uIGNvcHlJbnN0YW5jZU1ldGhvZHMoZnJvbSwgdG8pIHtcbiAgICAgIHZhciBpLCBtZXRob2RfbmFtZXMgPSBPcGFsLm93bl9pbnN0YW5jZV9tZXRob2RzKGZyb20pO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG1ldGhvZF9uYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmFtZSA9IG1ldGhvZF9uYW1lc1tpXSxcbiAgICAgICAgICAgIGpzaWQgPSAkanNpZChuYW1lKSxcbiAgICAgICAgICAgIGJvZHkgPSBmcm9tLiQkcHJvdG90eXBlW2pzaWRdLFxuICAgICAgICAgICAgd3JhcHBlZCA9IE9wYWwud3JhcF9tZXRob2RfYm9keShib2R5KTtcblxuICAgICAgICB3cmFwcGVkLiQkanNpZCA9IG5hbWU7XG4gICAgICAgIE9wYWwuZGVmbih0bywganNpZCwgd3JhcHBlZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29weUluY2x1ZGVkTW9kdWxlcyhmcm9tLCB0bykge1xuICAgICAgdmFyIG1vZHVsZXMgPSBmcm9tLiQkb3duX2luY2x1ZGVkX21vZHVsZXM7XG4gICAgICBmb3IgKHZhciBpID0gbW9kdWxlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBPcGFsLmFwcGVuZF9mZWF0dXJlcyhtb2R1bGVzW2ldLCB0byk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29weVByZXBlbmRlZE1vZHVsZXMoZnJvbSwgdG8pIHtcbiAgICAgIHZhciBtb2R1bGVzID0gZnJvbS4kJG93bl9wcmVwZW5kZWRfbW9kdWxlcztcbiAgICAgIGZvciAodmFyIGkgPSBtb2R1bGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIE9wYWwucHJlcGVuZF9mZWF0dXJlcyhtb2R1bGVzW2ldLCB0byk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGVmIGluaXRpYWxpemVfY29weShvdGhlcilcbiAgICAleHtcbiAgICAgIGNvcHlJbnN0YW5jZU1ldGhvZHMob3RoZXIsIHNlbGYpO1xuICAgICAgY29weUluY2x1ZGVkTW9kdWxlcyhvdGhlciwgc2VsZik7XG4gICAgICBjb3B5UHJlcGVuZGVkTW9kdWxlcyhvdGhlciwgc2VsZik7XG4gICAgICBzZWxmLiQkY2xvbmVkX2Zyb20gPSBvdGhlci4kJGNsb25lZF9mcm9tLmNvbmNhdChvdGhlcik7XG4gICAgfVxuICAgIGNvcHlfY2xhc3NfdmFyaWFibGVzKG90aGVyKVxuICAgIGNvcHlfY29uc3RhbnRzKG90aGVyKVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZV9kdXAob3RoZXIpXG4gICAgc3VwZXJcbiAgICAjIFVubGlrZSBvdGhlciBjbGFzc2VzLCBNb2R1bGUncyBzaW5nbGV0b24gbWV0aG9kcyBhcmUgY29waWVkIG9uIE9iamVjdCNkdXAuXG4gICAgY29weV9zaW5nbGV0b25fbWV0aG9kcyhvdGhlcilcbiAgZW5kXG5cbiAgZGVmIGNvcHlfY2xhc3NfdmFyaWFibGVzKG90aGVyKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBvdGhlci4kJGN2YXJzKSB7XG4gICAgICAgIHNlbGYuJCRjdmFyc1tuYW1lXSA9IG90aGVyLiQkY3ZhcnNbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29weV9jb25zdGFudHMob3RoZXIpXG4gICAgJXh7XG4gICAgICB2YXIgbmFtZSwgb3RoZXJfY29uc3RhbnRzID0gb3RoZXIuJCRjb25zdDtcblxuICAgICAgZm9yIChuYW1lIGluIG90aGVyX2NvbnN0YW50cykge1xuICAgICAgICAkY29uc3Rfc2V0KHNlbGYsIG5hbWUsIG90aGVyX2NvbnN0YW50c1tuYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVmaW5lKGtsYXNzLCAmYmxvY2spXG4gICAgcmVmaW5lbWVudF9tb2R1bGUsIG0sIGtsYXNzX2lkID0gc2VsZiwgbmlsLCBuaWxcbiAgICAleHtcbiAgICAgIGtsYXNzX2lkID0gT3BhbC5pZChrbGFzcyk7XG4gICAgICBpZiAodHlwZW9mIHNlbGYuJCRyZWZpbmVfbW9kdWxlcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBzZWxmLiQkcmVmaW5lX21vZHVsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBzZWxmLiQkcmVmaW5lX21vZHVsZXNba2xhc3NfaWRdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG0gPSBzZWxmLiQkcmVmaW5lX21vZHVsZXNba2xhc3NfaWRdID0gI3s6OlJlZmluZW1lbnQubmV3fTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBtID0gc2VsZi4kJHJlZmluZV9tb2R1bGVzW2tsYXNzX2lkXTtcbiAgICAgIH1cbiAgICAgIG0ucmVmaW5lbWVudF9tb2R1bGUgPSByZWZpbmVtZW50X21vZHVsZVxuICAgICAgbS5yZWZpbmVkX2NsYXNzID0ga2xhc3NcbiAgICB9XG4gICAgbS5jbGFzc19leGVjKCZibG9jaylcbiAgICBtXG4gIGVuZFxuXG4gIGRlZiByZWZpbmVtZW50c1xuICAgICV4e1xuICAgICAgdmFyIHJlZmluZV9tb2R1bGVzID0gc2VsZi4kJHJlZmluZV9tb2R1bGVzLCBoYXNoID0gI3t7fX07O1xuICAgICAgaWYgKHR5cGVvZiByZWZpbmVfbW9kdWxlcyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGhhc2g7XG4gICAgICBmb3IgKHZhciBpZCBpbiByZWZpbmVfbW9kdWxlcykge1xuICAgICAgICBoYXNoWyckW109J10ocmVmaW5lX21vZHVsZXNbaWRdLnJlZmluZWRfY2xhc3MsIHJlZmluZV9tb2R1bGVzW2lkXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gICMgQ29tcGlsZXIgb3ZlcnJpZGVzIHRoaXMgbWV0aG9kXG4gIGRlZiB1c2luZyhtb2QpXG4gICAgOjpLZXJuZWwucmFpc2UgJ01vZHVsZSN1c2luZyBpcyBub3QgcGVybWl0dGVkIGluIG1ldGhvZHMnXG4gIGVuZFxuXG4gIGFsaWFzIGNsYXNzX2V2YWwgbW9kdWxlX2V2YWxcbiAgYWxpYXMgY2xhc3NfZXhlYyBtb2R1bGVfZXhlY1xuICBhbGlhcyBpbnNwZWN0IHRvX3NcbmVuZFxuXG5jbGFzcyA6OlJlZmluZW1lbnQgPCA6Ok1vZHVsZVxuICBhdHRyX3JlYWRlciA6cmVmaW5lZF9jbGFzc1xuXG4gIGRlZiBpbnNwZWN0XG4gICAgaWYgQHJlZmluZW1lbnRfbW9kdWxlXG4gICAgICBcIiM8cmVmaW5lbWVudDoje0ByZWZpbmVkX2NsYXNzLmluc3BlY3R9QCN7QHJlZmluZW1lbnRfbW9kdWxlLmluc3BlY3R9PlwiXG4gICAgZWxzZVxuICAgICAgc3VwZXJcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOk1vZHVsZT4iLCJPcGFsIiwidHJ5X2NvbnZlcnQiLCJTdHJpbmciLCJLZXJuZWwiLCJyYWlzZSIsIlR5cGVFcnJvciIsImNsYXNzIiwiYWxsb2NhdGUiLCJzZWxmIiwiaW5pdGlhbGl6ZSIsImJsb2NrX2dpdmVuPyIsIm1vZHVsZV9ldmFsIiwiYmxvY2siLCJ0b19wcm9jIiwiPT09Iiwib2JqZWN0IiwiPCIsIm90aGVyIiwiTW9kdWxlIiwiPD0iLCIkcmV0X29yXzEiLCJlcXVhbD8iLCI+IiwiPj0iLCI8PT4iLCJsdCIsIm5pbD8iLCItMSIsIjEiLCJhbGlhc19tZXRob2QiLCJuZXduYW1lIiwib2xkbmFtZSIsImFsaWFzX25hdGl2ZSIsIm1pZCIsImpzaWQiLCJhbmNlc3RvcnMiLCJhcHBlbmRfZmVhdHVyZXMiLCJpbmNsdWRlciIsImF0dHJfYWNjZXNzb3IiLCJhdHRyX3JlYWRlciIsIm5hbWVzIiwiYXR0cl93cml0ZXIiLCJhdHRyIiwid2FybiIsImFyZ3MiLCJhdXRvbG9hZCIsImNvbnN0JCIsInBhdGgiLCJjb25zdF9uYW1lPyIsIk5hbWVFcnJvciIsIkFyZ3VtZW50RXJyb3IiLCJhdXRvbG9hZD8iLCJjbGFzc192YXJpYWJsZXMiLCJjbGFzc192YXJpYWJsZV9nZXQiLCJuYW1lIiwiY2xhc3NfdmFyaWFibGVfbmFtZSEiLCJjbGFzc192YXJpYWJsZV9zZXQiLCJ2YWx1ZSIsImNsYXNzX3ZhcmlhYmxlX2RlZmluZWQ/IiwiY29uc3RfYWRkZWQiLCJwcmlzdGluZSIsInJlbW92ZV9jbGFzc192YXJpYWJsZSIsImNvbnN0YW50cyIsImluaGVyaXQiLCJuZXN0aW5nIiwiY29uc3RfZGVmaW5lZD8iLCJjb25zdF9uYW1lISIsIj1+IiwiT3BhbDo6Q09OU1RfTkFNRV9SRUdFWFAiLCJuZXciLCJjb25zdF9nZXQiLCJpbmplY3QiLCJzcGxpdCIsImJsb2NrIGluIGNvbnN0X2dldCIsIm8iLCJjIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb25zdF9nZXQiLCJjb25zdF9taXNzaW5nIiwiZnVsbF9jb25zdF9uYW1lIiwiT2JqZWN0IiwiY29uc3Rfc2V0IiwiIX4iLCJzdGFydF93aXRoPyIsInB1YmxpY19jb25zdGFudCIsImRlZmluZV9tZXRob2QiLCJtZXRob2QiLCJQcm9jIiwiTWV0aG9kIiwiVW5ib3VuZE1ldGhvZCIsIm93bmVyIiwibWVzc2FnZSIsImZyZWV6ZSIsImZyb3plbj8iLCJyZW1vdmVfbWV0aG9kIiwic2luZ2xldG9uX2NsYXNzPyIsImluY2x1ZGUiLCJpbmNsdWRlZCIsImluY2x1ZGVkX21vZHVsZXMiLCJpbmNsdWRlPyIsIm1vZCIsImluc3RhbmNlX21ldGhvZCIsImluc3RhbmNlX21ldGhvZHMiLCJpbmNsdWRlX3N1cGVyIiwiZXh0ZW5kZWQiLCJleHRlbmRfb2JqZWN0IiwibWV0aG9kX2FkZGVkIiwibWV0aG9kX3JlbW92ZWQiLCJtZXRob2RfdW5kZWZpbmVkIiwiMyIsImNvdmVyPyIsInNpemUiLCJzdHJpbmciLCJmaWxlIiwiX2xpbmVubyIsImRlZmF1bHRfZXZhbF9vcHRpb25zIiwiY29tcGlsaW5nX29wdGlvbnMiLCJfX09QQUxfQ09NUElMRVJfQ09ORklHX18iLCJtZXJnZSIsImNvbXBpbGVkIiwiY29tcGlsZSIsInByb2MiLCJibG9jayBpbiBtb2R1bGVfZXZhbCIsImJsb2NrICgyIGxldmVscykgaW4gbW9kdWxlX2V2YWwiLCJhbnk/IiwibW9kdWxlX2V4ZWMiLCJMb2NhbEp1bXBFcnJvciIsIm1ldGhvZF9kZWZpbmVkPyIsIm1vZHVsZV9mdW5jdGlvbiIsInByZXBlbmQiLCJwcmVwZW5kX2ZlYXR1cmVzIiwicHJlcGVuZGVkIiwicHJlcGVuZGVyIiwicmVtb3ZlX2NvbnN0IiwidG9fcyIsIl9faWRfXyIsIjE2IiwidW5kZWZfbWV0aG9kIiwiaW5zdGFuY2VfdmFyaWFibGVzIiwiY29uc3RzIiwiaW5pdGlhbGl6ZV9jb3B5IiwiY29weV9jbGFzc192YXJpYWJsZXMiLCJjb3B5X2NvbnN0YW50cyIsImluaXRpYWxpemVfZHVwIiwiY29weV9zaW5nbGV0b25fbWV0aG9kcyIsInJlZmluZSIsImtsYXNzIiwicmVmaW5lbWVudF9tb2R1bGUiLCJtIiwia2xhc3NfaWQiLCJSZWZpbmVtZW50IiwiY2xhc3NfZXhlYyIsInJlZmluZW1lbnRzIiwidXNpbmciLCI8Y2xhc3M6UmVmaW5lbWVudD4iLCJpbnNwZWN0IiwiQHJlZmluZW1lbnRfbW9kdWxlIiwiQHJlZmluZWRfY2xhc3MiXSwibWFwcGluZ3MiOiJBQUFBQSxpQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFHQUM7RUFBQUE7O0lBQUFBOzs7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLDJCQUE2QkMsS0FBTUMsYUFBQUEsQ0FBY0YsSUFBcEIsRUFBMkJHLGFBQTNCLEVBQXFDLFFBQS9CRCxDQUF3Q0Y7QUFDM0VBO0FBQ0FBO0FBQ0FBO0FBQ0FBLFFBQVVJLE9BQVFDLE9BQUFBLENBQU9DLGdCQUFmLEVBQTRCLEVBQUEsR0FBQSxDQUFJTixJQUFKLENBQUEsR0FBVUEsK0JBQTlCSztBQUNsQkw7QUFDQUEsUUFBVUksT0FBUUMsT0FBQUEsQ0FBT0MsZ0JBQWYsRUFBNkJOLGdCQUFELEdBQUEsQ0FBaUJBLENBQUNBLElBQURBLENBQU1PLE9BQUFBLENBQUFBLENBQXZCLENBQUEsR0FBOEJQLGNBQTlCLEdBQUEsQ0FBNENBLENBQUNBLElBQURBLENBQU1PLE9BQUFBLENBQUFBLENBQWxELENBQUEsR0FBeURQLGdCQUF6RCxHQUFBLENBQXlFQSxDQUFDQSxjQUFEQSxDQUFnQk8sT0FBQUEsQ0FBQUEsQ0FBekYsQ0FBcEJGO0FBQ2xCTDtBQUNBQTtBQUNBQTtJQUVFUSxNQUFJQyxJQUFKRCxlQUFBQSxvQkFBQUE7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtJQU5FQSxDQUFBQTs7QUFTQUUsSUFBQUEsMEJBQUFBLHNCQUFBQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUNFLElBQXVCQyxlQUF2QjtRQUFBRCxPQUFBRSxNQUFBSCxJQUFBRyxlQUFBQSxFQUFBQSxFQUFBQSxFQUFhQyxLQUFEQyxTQUFBQSxDQUFBQSxDQUFaRjtNQUFBO1FBOUJKRixPQUFBO01BOEJJO0lBREZBLENBQUFBOztBQUlB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VXJELEdBQVZxRDtBQUFBQTtNQUNFQSxPQUFBckosT0FBUUMsT0FBQUEsQ0FBT29KLDBDQUFQcEo7SUFEVm9KLENBQUFBO0lBSUEsYUFBTSxZQUFOLEVBQWlCLGFBQWpCO0lBQ0EsYUFBTSxZQUFOLEVBQWlCLGFBQWpCO0lBQ0F6SixPQUFBLGFBQU0sU0FBTixFQUFjLE1BQWQ7RUF2MUJGQSxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0VBMDFCQUQsT0FBQTJKO0VBQUFBOztJQUFBQTs7QUFBQUE7O0lBQ0VqSixJQUFBK0IsYUFBQUEsQ0FBWSxlQUFaQTtJQUVBa0gsT0FBQUMsdUJBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7TUFBQUE7TUFDRSxJQUFBLFFBQUdDLHNCQUFILENBQUE7UUFDRUQsT0FBQ0EsZUFBRCxHQUFBLENBQWdCRSxrQkFBY0YsU0FBQUEsQ0FBQUEsQ0FBOUIsQ0FBQSxHQUF1Q0EsR0FBdkMsR0FBQSxDQUEwQ0Msc0JBQWtCRCxTQUFBQSxDQUFBQSxDQUE1RCxDQUFBLEdBQXFFQTtNQUR2RTtRQUdFQSxPQUFBLE9BQUFsSixJQUFBLEVBQUEsb0RBQUEsV0FBQSxFQUFBLEVBQUEsRUFBQSxNQUFBO01BSEY7SUFERmtKLENBQUFBO0VBSEZELEdBQU0sSUFBTkEsRUFBcUJ2SSxPQUFyQnVJO0FBNzFCQTNKOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo0MzgxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9jbGFzcy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcblxucmVxdWlyZSAnY29yZWxpYi9tb2R1bGUnXG5cbmNsYXNzIDo6Q2xhc3NcbiAgZGVmIHNlbGYubmV3KHN1cGVyY2xhc3MgPSBPYmplY3QsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmICghc3VwZXJjbGFzcy4kJGlzX2NsYXNzKSB7XG4gICAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJzdXBlcmNsYXNzIG11c3QgYmUgYSBDbGFzc1wiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGtsYXNzID0gT3BhbC5hbGxvY2F0ZV9jbGFzcyhuaWwsIHN1cGVyY2xhc3MpO1xuICAgICAgc3VwZXJjbGFzcy4kaW5oZXJpdGVkKGtsYXNzKTtcbiAgICAgICN7YGtsYXNzYC5jbGFzc19ldmFsKCZibG9jaykgaWYgYmxvY2tfZ2l2ZW4/fVxuICAgICAgcmV0dXJuIGtsYXNzO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGFsbG9jYXRlXG4gICAgJXh7XG4gICAgICB2YXIgb2JqID0gbmV3IHNlbGYuJCRjb25zdHJ1Y3RvcigpO1xuICAgICAgb2JqLiQkaWQgPSBPcGFsLnVpZCgpO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjbG9uZShmcmVlemU6IG5pbClcbiAgICB1bmxlc3MgZnJlZXplLm5pbD8gfHwgZnJlZXplID09IHRydWUgfHwgZnJlZXplID09IGZhbHNlXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcInVuZXhwZWN0ZWQgdmFsdWUgZm9yIGZyZWV6ZTogI3tmcmVlemUuY2xhc3N9XCJcbiAgICBlbmRcblxuICAgIGNvcHkgPSBgT3BhbC5hbGxvY2F0ZV9jbGFzcyhuaWwsIHNlbGYuJCRzdXBlcilgXG4gICAgY29weS5jb3B5X2luc3RhbmNlX3ZhcmlhYmxlcyhzZWxmKVxuICAgIGNvcHkuY29weV9zaW5nbGV0b25fbWV0aG9kcyhzZWxmKVxuICAgIGNvcHkuaW5pdGlhbGl6ZV9jbG9uZShzZWxmLCBmcmVlemU6IGZyZWV6ZSlcblxuICAgIGlmIGZyZWV6ZSA9PSB0cnVlIHx8IChmcmVlemUubmlsPyAmJiBmcm96ZW4/KVxuICAgICAgY29weS5mcmVlemVcbiAgICBlbmRcblxuICAgIGNvcHlcbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgIGNvcHkgPSBgT3BhbC5hbGxvY2F0ZV9jbGFzcyhuaWwsIHNlbGYuJCRzdXBlcilgXG5cbiAgICBjb3B5LmNvcHlfaW5zdGFuY2VfdmFyaWFibGVzKHNlbGYpXG4gICAgY29weS5pbml0aWFsaXplX2R1cChzZWxmKVxuXG4gICAgY29weVxuICBlbmRcblxuICBkZWYgZGVzY2VuZGFudHNcbiAgICBzdWJjbGFzc2VzICsgc3ViY2xhc3Nlcy5tYXAoJjpkZXNjZW5kYW50cykuZmxhdHRlblxuICBlbmRcblxuICBkZWYgaW5oZXJpdGVkKGNscylcbiAgZW5kXG5cbiAgZGVmIG5ldygqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIG9iamVjdCA9ICN7YWxsb2NhdGV9O1xuICAgICAgT3BhbC5zZW5kKG9iamVjdCwgb2JqZWN0LiRpbml0aWFsaXplLCBhcmdzLCBibG9jayk7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHN1YmNsYXNzZXNcbiAgICAleHtcbiAgICAgIGlmICh0eXBlb2YgV2Vha1JlZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIGksIHN1YmNsYXNzLCBvdXQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlbGYuJCRzdWJjbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3ViY2xhc3MgPSBzZWxmLiQkc3ViY2xhc3Nlc1tpXS5kZXJlZigpO1xuICAgICAgICAgIGlmIChzdWJjbGFzcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvdXQucHVzaChzdWJjbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuJCRzdWJjbGFzc2VzO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHN1cGVyY2xhc3NcbiAgICBgc2VsZi4kJHN1cGVyIHx8IG5pbGBcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICAleHtcbiAgICAgIHZhciBzaW5nbGV0b25fb2YgPSBzZWxmLiQkc2luZ2xldG9uX29mO1xuXG4gICAgICBpZiAoc2luZ2xldG9uX29mICYmIHNpbmdsZXRvbl9vZi4kJGlzX2FfbW9kdWxlKSB7XG4gICAgICAgIHJldHVybiAje1wiIzxDbGFzczoje2BzaW5nbGV0b25fb2ZgLm5hbWV9PlwifTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNpbmdsZXRvbl9vZikge1xuICAgICAgICAvLyBhIHNpbmdsZXRvbiBjbGFzcyBjcmVhdGVkIGZyb20gYW4gb2JqZWN0XG4gICAgICAgIHJldHVybiAje1wiIzxDbGFzczojPCN7YHNpbmdsZXRvbl9vZi4kJGNsYXNzYC5uYW1lfToweCN7YE9wYWwuaWQoc2luZ2xldG9uX29mKWAudG9fcygxNil9Pj5cIn07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje3N1cGVyKCl9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGF0dGFjaGVkX29iamVjdFxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRzaW5nbGV0b25fb2YgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJHNpbmdsZXRvbl9vZjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImAje3NlbGZ9JyBpcyBub3QgYSBzaW5nbGV0b24gY2xhc3NcIn1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGluc3BlY3QgdG9fc1xuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOkNsYXNzPiIsIm5ldyIsInN1cGVyY2xhc3MiLCJPYmplY3QiLCJibG9ja19naXZlbj8iLCJjbGFzc19ldmFsIiwiYmxvY2siLCJ0b19wcm9jIiwiYWxsb2NhdGUiLCJjbG9uZSIsIiRrd2FyZ3MiLCJmcmVlemUiLCJuaWw/IiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwiY2xhc3MiLCJjb3B5IiwiY29weV9pbnN0YW5jZV92YXJpYWJsZXMiLCJjb3B5X3NpbmdsZXRvbl9tZXRob2RzIiwiaW5pdGlhbGl6ZV9jbG9uZSIsImZyb3plbj8iLCJkdXAiLCJpbml0aWFsaXplX2R1cCIsImRlc2NlbmRhbnRzIiwiKyIsInN1YmNsYXNzZXMiLCJtYXAiLCJmbGF0dGVuIiwiaW5oZXJpdGVkIiwidG9fcyIsIm5hbWUiLCIxNiIsImF0dGFjaGVkX29iamVjdCIsIktlcm5lbCIsIlR5cGVFcnJvciJdLCJtYXBwaW5ncyI6IkFBQUFBLGdDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQyxJQUFBQyxTQUFBQSxDQUFRRixnQkFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOzs7SUFDRUMsTUFBSUgsSUFBSkcsVUFBQUEsc0JBQWFDLFVBQWJEO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQWEscUNBQWFFOztBQUU1QkY7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBLE1BQVEsQ0FBOEJHLGVBQTlCLEdBQUEsQ0FBT0MsTUFBUEosQ0FBQ0EsS0FBREEsQ0FBT0ksY0FBQUEsRUFBQUEsRUFBQUEsRUFBYUMsS0FBREMsU0FBQUEsQ0FBQUEsQ0FBWkYsQ0FBUCxJQUFBLEdBQUE7QUFDUko7QUFDQUE7SUFWRUEsQ0FBQUEsSUFBQUE7O0FBYUFPLElBQUFBLHdCQUFBQSxvQkFBQUE7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQTtBQUNBQTtBQUNBQTtJQUxFQSxDQUFBQTs7QUFRQUMsSUFBQUEscUJBQUFBLGlCQTFCRkMsT0EwQkVEO0FBQUFBLE1BQUFBOzs7TUExQkY7O01BMEJZLHNDQUFBLDZCQUFRO01BQ2hCLEtBQU8sQ0FBQSxDQUFBLFFBQUFFLE1BQU1DLFNBQUFBLENBQUFBLENBQU4sQ0FBQSxJQUFBLENBQUEsTUFBZUQsTUFBZixFQUF5QixJQUF6QixDQUFBLENBQUEsQ0FBQSxJQUFBLENBQUEsTUFBaUNBLE1BQWpDLEVBQTJDLEtBQTNDLENBQUEsQ0FBQSxDQUFQO1FBQ0ViLElBQUFlLE9BQUFBLENBQU1DLG1CQUFOLEVBQXNCTCwrQkFBRCxHQUFBLENBQWdDRSxNQUFNSSxPQUFB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QUE7QUFKQUg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjQ1MzYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2Jhc2ljX29iamVjdC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIHVzZV9zdHJpY3Q6IHRydWVcbiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxuXG5jbGFzcyA6OkJhc2ljT2JqZWN0XG4gIGRlZiBpbml0aWFsaXplKCopXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBgc2VsZiA9PT0gb3RoZXJgXG4gIGVuZFxuXG4gIGRlZiBlcWw/KG90aGVyKVxuICAgIHNlbGYgPT0gb3RoZXJcbiAgZW5kXG5cbiAgYWxpYXMgZXF1YWw/ID09XG5cbiAgZGVmIF9faWRfX1xuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRpZCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkaWQ7XG4gICAgICB9XG4gICAgICBPcGFsLnByb3Aoc2VsZiwgJyQkaWQnLCBPcGFsLnVpZCgpKTtcbiAgICAgIHJldHVybiBzZWxmLiQkaWQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgX19zZW5kX18oc3ltYm9sLCAqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKCFzeW1ib2wuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgI3tyYWlzZSA6OlR5cGVFcnJvciwgXCIje2luc3BlY3R9IGlzIG5vdCBhIHN5bWJvbCBub3IgYSBzdHJpbmdcIn1cbiAgICAgIH1cblxuICAgICAgdmFyIGZ1bmMgPSBzZWxmW09wYWwuanNpZChzeW1ib2wpXTtcblxuICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgICBmdW5jLiQkcCA9IGJsb2NrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIHNlbGYuJG1ldGhvZF9taXNzaW5nLiQkcCA9IGJsb2NrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kbWV0aG9kX21pc3NpbmcuYXBwbHkoc2VsZiwgW3N5bWJvbF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiAhXG4gICAgZmFsc2VcbiAgZW5kXG4gIDo6T3BhbC5wcmlzdGluZSA6IVxuXG4gIGRlZiAhPShvdGhlcilcbiAgICAhKHNlbGYgPT0gb3RoZXIpXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV9ldmFsKCphcmdzLCAmYmxvY2spXG4gICAgaWYgYmxvY2submlsPyAmJiBgISFPcGFsLmNvbXBpbGVgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxLi4zKScgdW5sZXNzICgxLi4zKS5jb3Zlcj8gYXJncy5zaXplXG5cbiAgICAgIHN0cmluZywgZmlsZSwgX2xpbmVubyA9ICphcmdzXG4gICAgICBkZWZhdWx0X2V2YWxfb3B0aW9ucyA9IHsgZmlsZTogKGZpbGUgfHwgJyhldmFsKScpLCBldmFsOiB0cnVlIH1cbiAgICAgIGNvbXBpbGluZ19vcHRpb25zID0gX19PUEFMX0NPTVBJTEVSX0NPTkZJR19fLm1lcmdlKGRlZmF1bHRfZXZhbF9vcHRpb25zKVxuICAgICAgY29tcGlsZWQgPSA6Ok9wYWwuY29tcGlsZSBzdHJpbmcsIGNvbXBpbGluZ19vcHRpb25zXG4gICAgICBibG9jayA9IDo6S2VybmVsLnByb2MgZG9cbiAgICAgICAgJXh7bmV3IEZ1bmN0aW9uKFwiT3BhbCxzZWxmXCIsIFwicmV0dXJuIFwiICsgY29tcGlsZWQpKE9wYWwsIHNlbGYpfVxuICAgICAgZW5kXG4gICAgZWxzaWYgYmxvY2submlsPyAmJiBhcmdzLmxlbmd0aCA+PSAxICYmIGFyZ3MuZmlyc3RbMF0gPT0gJ0AnXG4gICAgICAjIGdldCBpbnN0YW5jZSB2YXJpYWJsZVxuICAgICAgcmV0dXJuIGluc3RhbmNlX3ZhcmlhYmxlX2dldChhcmdzLmZpcnN0KVxuICAgIGVsc2lmIGFyZ3MuYW55P1xuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YXJncy5zaXplfSBmb3IgMClcIlxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgb2xkID0gYmxvY2suJCRzLFxuICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgYmxvY2suJCRzID0gbnVsbDtcblxuICAgICAgLy8gTmVlZCB0byBwYXNzICQkZXZhbCBzbyB0aGF0IG1ldGhvZCBkZWZpbml0aW9ucyBrbm93IGlmIHRoaXMgaXNcbiAgICAgIC8vIGJlaW5nIGRvbmUgb24gYSBjbGFzcy9tb2R1bGUuIENhbm5vdCBiZSBjb21waWxlciBkcml2ZW4gc2luY2VcbiAgICAgIC8vIHNlbmQoOmluc3RhbmNlX2V2YWwpIG5lZWRzIHRvIHdvcmsuXG4gICAgICBpZiAoc2VsZi4kJGlzX2FfbW9kdWxlKSB7XG4gICAgICAgIHNlbGYuJCRldmFsID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSBibG9jay5jYWxsKHNlbGYsIHNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgIHNlbGYuJCRldmFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBibG9jay5jYWxsKHNlbGYsIHNlbGYpO1xuICAgICAgfVxuXG4gICAgICBibG9jay4kJHMgPSBvbGQ7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfZXhlYygqYXJncywgJmJsb2NrKVxuICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ25vIGJsb2NrIGdpdmVuJyB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIGJsb2NrX3NlbGYgPSBibG9jay4kJHMsXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICBibG9jay4kJHMgPSBudWxsO1xuXG4gICAgICBpZiAoc2VsZi4kJGlzX2FfbW9kdWxlKSB7XG4gICAgICAgIHNlbGYuJCRldmFsID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSBibG9jay5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICBzZWxmLiQkZXZhbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gYmxvY2suYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICB9XG5cbiAgICAgIGJsb2NrLiQkcyA9IGJsb2NrX3NlbGY7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2luZ2xldG9uX21ldGhvZF9hZGRlZCgqKVxuICBlbmRcblxuICBkZWYgc2luZ2xldG9uX21ldGhvZF9yZW1vdmVkKCopXG4gIGVuZFxuXG4gIGRlZiBzaW5nbGV0b25fbWV0aG9kX3VuZGVmaW5lZCgqKVxuICBlbmRcblxuICBkZWYgbWV0aG9kX21pc3Npbmcoc3ltYm9sLCAqYXJncywgJmJsb2NrKVxuICAgIGluc3BlY3RfcmVzdWx0ID0gOjpPcGFsLmluc3BlY3Qoc2VsZilcbiAgICA6Oktlcm5lbC5yYWlzZSA6Ok5vTWV0aG9kRXJyb3IubmV3KFxuICAgICAgXCJ1bmRlZmluZWQgbWV0aG9kIGAje3N5bWJvbH0nIGZvciAje2luc3BlY3RfcmVzdWx0fVwiLCBzeW1ib2wsIGFyZ3NcbiAgICApLCBuaWwsIDo6S2VybmVsLmNhbGxlcigxKVxuICBlbmRcblxuICA6Ok9wYWwucHJpc3RpbmUoc2VsZiwgOm1ldGhvZF9taXNzaW5nKVxuXG4gIGRlZiByZXNwb25kX3RvX21pc3Npbmc/KG1ldGhvZF9uYW1lLCBpbmNsdWRlX2FsbCA9IGZhbHNlKVxuICAgIGZhbHNlXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpCYXNpY09iamVjdD4iLCJpbml0aWFsaXplIiwiPT0iLCJvdGhlciIsImVxbD8iLCJzZWxmIiwiX19pZF9fIiwiX19zZW5kX18iLCJzeW1ib2wiLCJyYWlzZSIsIlR5cGVFcnJvciIsImluc3BlY3QiLCIhIiwiT3BhbCIsInByaXN0aW5lIiwiIT0iLCJpbnN0YW5jZV9ldmFsIiwiYmxvY2siLCJuaWw/IiwiMSIsIjMiLCJjb3Zlcj8iLCJhcmdzIiwic2l6ZSIsIktlcm5lbCIsIkFyZ3VtZW50RXJyb3IiLCJzdHJpbmciLCJmaWxlIiwiX2xpbmVubyIsImRlZmF1bHRfZXZhbF9vcHRpb25zIiwiJHJldF9vcl8xIiwiY29tcGlsaW5nX29wdGlvbnMiLCJfX09QQUxfQ09NUElMRVJfQ09ORklHX18iLCJtZXJnZSIsImNvbXBpbGVkIiwiY29tcGlsZSIsInByb2MiLCJibG9jayBpbiBpbnN0YW5jZV9ldmFsIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbnN0YW5jZV9ldmFsIiwiPj0iLCJsZW5ndGgiLCJmaXJzdCIsIltdIiwiMCIsImluc3RhbmNlX3ZhcmlhYmxlX2dldCIsImFueT8iLCJpbnN0YW5jZV9leGVjIiwic2luZ2xldG9uX21ldGhvZF9hZGRlZCIsInNpbmdsZXRvbl9tZXRob2RfcmVtb3ZlZCIsInNpbmdsZXRvbl9tZXRob2RfdW5kZWZpbmVkIiwibWV0aG9kX21pc3NpbmciLCJpbnNwZWN0X3Jlc3VsdCIsIk5vTWV0aG9kRXJyb3IiLCJuZXciLCJjYWxsZXIiLCJyZXNwb25kX3RvX21pc3Npbmc/IiwibWV0aG9kX25hbWUiLCJpbmNsdWRlX2FsbCJdLCJtYXBwaW5ncyI6IkFBQUFBLHVDQUFBQSxnQkFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBO0VBR0FBLE9BQUFDO0VBQUFBOzs7OztBQUNFQyxJQUFBQSwwQkFBQUEsc0JBSkYsRUFJRUE7QUFBQUEsTUFBQUE7OztN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SWlDO01BNUlqQ0EsT0FBQTtJQTRJRUEsQ0FBQUEsSUFBQUE7O0FBR0FDLElBQUFBLDhCQUFBQSwwQkFBbUIxQyxNQUFELEVBL0lwQixFQStJRTBDO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BL0lGO01BK0k2QjtNQUN6QkMsaUJBQWlCdEMsS0FBTUYsU0FBQUEsQ0FBU04sSUFBVE07TUFDdkJ1QyxPQUFBMUIsT0FBUWYsT0FBQUEsQ0FBTzJDLG9CQUFlQyxLQUFBQSxDQUMzQkgsb0JBQUQsR0FBQSxDQUFxQjFDLE1BQXJCLENBQUEsR0FBNEIwQyxRQUE1QixHQUFBLENBQW9DQyxjQUFwQyxDQURhLEVBQ3lDM0MsTUFEekMsRUFDaURjLElBRGxDK0IsQ0FBOUIsRUFFRyxHQUZILEVBRVE3QixPQUFROEIsUUFBQUEsQ0FBUW5DLENBQVJtQyxDQUZSN0M7SUFGVnlDLENBQUFBLElBQUFBO0lBT0FyQyxLQUFNQyxVQUFBQSxDQUFVVCxJQUFoQixFQUFzQixnQkFBaEJTO0lBRU5kLE9BQUF1RCxtQ0FBQUEsZ0RBQXdCQyxXQUFELEVBQWNDLFdBQXJDRjtBQUFBQTs7TUFBcUMsdUNBQWM7TUFDakRBLE9BQUE7SUFERkEsQ0FBQUEsSUFBQUE7RUFySkZ2RCxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBSEFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo0NzU4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9rZXJuZWwucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiB0cnV0aHksIGNvZXJjZV90bywgcmVzcG9uZF90bywgT3BhbCwgZGVueV9mcm96ZW5fYWNjZXNzLCBmcmVlemUsIGZyZWV6ZV9wcm9wcywganNpZCwgZWFjaF9pdmFyXG4jIHVzZV9zdHJpY3Q6IHRydWVcbiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxuXG5tb2R1bGUgOjpLZXJuZWxcbiAgZGVmID1+KG9iailcbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgIX4ob2JqKVxuICAgICEoc2VsZiA9fiBvYmopXG4gIGVuZFxuXG4gIGRlZiA9PT0ob3RoZXIpXG4gICAgb2JqZWN0X2lkID09IG90aGVyLm9iamVjdF9pZCB8fCBzZWxmID09IG90aGVyXG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgJXh7XG4gICAgICAvLyBzZXQgZ3VhcmQgZm9yIGluZmluaXRlIHJlY3Vyc2lvblxuICAgICAgc2VsZi4kJGNvbXBhcmFibGUgPSB0cnVlO1xuXG4gICAgICB2YXIgeCA9ICN7c2VsZiA9PSBvdGhlcn07XG5cbiAgICAgIGlmICh4ICYmIHggIT09IG5pbCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtZXRob2QobmFtZSlcbiAgICAleHtcbiAgICAgIHZhciBtZXRoID0gc2VsZlskanNpZChuYW1lKV07XG5cbiAgICAgIGlmICghbWV0aCB8fCBtZXRoLiQkc3R1Yikge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLm5ldyhcInVuZGVmaW5lZCBtZXRob2QgYCN7bmFtZX0nIGZvciBjbGFzcyBgI3tzZWxmLmNsYXNzfSdcIiwgbmFtZSl9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3s6Ok1ldGhvZC5uZXcoc2VsZiwgYG1ldGguJCRvd25lciB8fCAje3NlbGYuY2xhc3N9YCwgYG1ldGhgLCBuYW1lKX07XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWV0aG9kcyhhbGwgPSB0cnVlKVxuICAgICV4e1xuICAgICAgaWYgKCR0cnV0aHkoI3thbGx9KSkge1xuICAgICAgICByZXR1cm4gT3BhbC5tZXRob2RzKHNlbGYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wYWwub3duX21ldGhvZHMoc2VsZik7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgcHVibGljX21ldGhvZHMoYWxsID0gdHJ1ZSlcbiAgICAleHtcbiAgICAgIGlmICgkdHJ1dGh5KCN7YWxsfSkpIHtcbiAgICAgICAgcmV0dXJuIE9wYWwubWV0aG9kcyhzZWxmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcGFsLnJlY2VpdmVyX21ldGhvZHMoc2VsZik7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgQXJyYXkob2JqZWN0KVxuICAgICV4e1xuICAgICAgdmFyIGNvZXJjZWQ7XG5cbiAgICAgIGlmIChvYmplY3QgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmplY3QuJCRpc19hcnJheSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuXG4gICAgICBjb2VyY2VkID0gI3s6Ok9wYWwuY29lcmNlX3RvPyhvYmplY3QsIDo6QXJyYXksIDp0b19hcnkpfTtcbiAgICAgIGlmIChjb2VyY2VkICE9PSBuaWwpIHsgcmV0dXJuIGNvZXJjZWQ7IH1cblxuICAgICAgY29lcmNlZCA9ICN7OjpPcGFsLmNvZXJjZV90bz8ob2JqZWN0LCA6OkFycmF5LCA6dG9fYSl9O1xuICAgICAgaWYgKGNvZXJjZWQgIT09IG5pbCkgeyByZXR1cm4gY29lcmNlZDsgfVxuXG4gICAgICByZXR1cm4gW29iamVjdF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgYXRfZXhpdCgmYmxvY2spXG4gICAgJF9fYXRfZXhpdF9fIHx8PSBbXVxuICAgICRfX2F0X2V4aXRfXyA8PCBibG9ja1xuICAgIGJsb2NrXG4gIGVuZFxuXG4gIGRlZiBjYWxsZXIoc3RhcnQgPSAxLCBsZW5ndGggPSBuaWwpXG4gICAgJXh7XG4gICAgICB2YXIgc3RhY2ssIHJlc3VsdDtcblxuICAgICAgc3RhY2sgPSBuZXcgRXJyb3IoKS4kYmFja3RyYWNlKCk7XG4gICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9ICN7c3RhcnR9ICsgMSwgaWkgPSBzdGFjay5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGlmICghc3RhY2tbaV0ubWF0Y2goL3J1bnRpbWVcXC5qcy8pKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goc3RhY2tbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoICE9IG5pbCkgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNhbGxlcl9sb2NhdGlvbnMoKmFyZ3MpXG4gICAgY2FsbGVyKCphcmdzKS5tYXAgZG8gfGxvY3xcbiAgICAgIDo6VGhyZWFkOjpCYWNrdHJhY2U6OkxvY2F0aW9uLm5ldyhsb2MpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBjbGFzc1xuICAgIGBzZWxmLiQkY2xhc3NgXG4gIGVuZFxuXG4gIGRlZiBjb3B5X2luc3RhbmNlX3ZhcmlhYmxlcyhvdGhlcilcbiAgICAleHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob3RoZXIpLCBpLCBpaSwgbmFtZTtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0ga2V5cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIG5hbWUgPSBrZXlzW2ldO1xuICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgIT09ICckJyAmJiBvdGhlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHNlbGZbbmFtZV0gPSBvdGhlcltuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvcHlfc2luZ2xldG9uX21ldGhvZHMob3RoZXIpXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbmFtZSwgbmFtZXMsIGxlbmd0aDtcblxuICAgICAgaWYgKG90aGVyLmhhc093blByb3BlcnR5KCckJG1ldGEnKSAmJiBvdGhlci4kJG1ldGEgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIG90aGVyX3NpbmdsZXRvbl9jbGFzcyA9IE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhvdGhlcik7XG4gICAgICAgIHZhciBzZWxmX3NpbmdsZXRvbl9jbGFzcyA9IE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhzZWxmKTtcbiAgICAgICAgbmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvdGhlcl9zaW5nbGV0b25fY2xhc3MuJCRwcm90b3R5cGUpO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG5hbWVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICAgIGlmIChPcGFsLmlzX21ldGhvZChuYW1lKSkge1xuICAgICAgICAgICAgc2VsZl9zaW5nbGV0b25fY2xhc3MuJCRwcm90b3R5cGVbbmFtZV0gPSBvdGhlcl9zaW5nbGV0b25fY2xhc3MuJCRwcm90b3R5cGVbbmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZl9zaW5nbGV0b25fY2xhc3MuJCRjb25zdCA9IE9iamVjdC5hc3NpZ24oe30sIG90aGVyX3NpbmdsZXRvbl9jbGFzcy4kJGNvbnN0KTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKFxuICAgICAgICAgIHNlbGZfc2luZ2xldG9uX2NsYXNzLiQkcHJvdG90eXBlLFxuICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihvdGhlcl9zaW5nbGV0b25fY2xhc3MuJCRwcm90b3R5cGUpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob3RoZXIpLCBsZW5ndGggPSBuYW1lcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gJyQnICYmIG5hbWUuY2hhckF0KDEpICE9PSAnJCcgJiYgb3RoZXIuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICBzZWxmW25hbWVdID0gb3RoZXJbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjbG9uZShmcmVlemU6IG5pbClcbiAgICB1bmxlc3MgZnJlZXplLm5pbD8gfHwgZnJlZXplID09IHRydWUgfHwgZnJlZXplID09IGZhbHNlXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcInVuZXhwZWN0ZWQgdmFsdWUgZm9yIGZyZWV6ZTogI3tmcmVlemUuY2xhc3N9XCJcbiAgICBlbmRcblxuICAgIGNvcHkgPSBzZWxmLmNsYXNzLmFsbG9jYXRlXG5cbiAgICBjb3B5LmNvcHlfaW5zdGFuY2VfdmFyaWFibGVzKHNlbGYpXG4gICAgY29weS5jb3B5X3NpbmdsZXRvbl9tZXRob2RzKHNlbGYpXG4gICAgY29weS5pbml0aWFsaXplX2Nsb25lKHNlbGYsIGZyZWV6ZTogZnJlZXplKVxuXG4gICAgaWYgZnJlZXplID09IHRydWUgfHwgKGZyZWV6ZS5uaWw/ICYmIGZyb3plbj8pXG4gICAgICBjb3B5LmZyZWV6ZVxuICAgIGVuZFxuXG4gICAgY29weVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZV9jbG9uZShvdGhlciwgZnJlZXplOiBuaWwpXG4gICAgaW5pdGlhbGl6ZV9jb3B5KG90aGVyKVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGRlZmluZV9zaW5nbGV0b25fbWV0aG9kKG5hbWUsIG1ldGhvZCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIHNpbmdsZXRvbl9jbGFzcy5kZWZpbmVfbWV0aG9kKG5hbWUsIG1ldGhvZCwgJmJsb2NrKVxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgY29weSA9IHNlbGYuY2xhc3MuYWxsb2NhdGVcblxuICAgIGNvcHkuY29weV9pbnN0YW5jZV92YXJpYWJsZXMoc2VsZilcbiAgICBjb3B5LmluaXRpYWxpemVfZHVwKHNlbGYpXG5cbiAgICBjb3B5XG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2R1cChvdGhlcilcbiAgICBpbml0aWFsaXplX2NvcHkob3RoZXIpXG4gIGVuZFxuXG4gIGRlZiBlbnVtX2ZvcihtZXRob2QgPSA6ZWFjaCwgKmFyZ3MsICZibG9jaylcbiAgICA6OkVudW1lcmF0b3IuZm9yKHNlbGYsIG1ldGhvZCwgKmFyZ3MsICZibG9jaylcbiAgZW5kXG5cbiAgZGVmIGVxdWFsPyhvdGhlcilcbiAgICBgc2VsZiA9PT0gb3RoZXJgXG4gIGVuZFxuXG4gIGRlZiBleGl0KHN0YXR1cyA9IHRydWUpXG4gICAgJF9fYXRfZXhpdF9fIHx8PSBbXVxuXG4gICAgdW50aWwgJF9fYXRfZXhpdF9fLmVtcHR5P1xuICAgICAgYmxvY2sgPSAkX19hdF9leGl0X18ucG9wXG4gICAgICBibG9jay5jYWxsXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmIChzdGF0dXMuJCRpc19ib29sZWFuKSB7XG4gICAgICAgIHN0YXR1cyA9IHN0YXR1cyA/IDAgOiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdHVzID0gJGNvZXJjZV90byhzdGF0dXMsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpXG4gICAgICB9XG5cbiAgICAgIE9wYWwuZXhpdChzdGF0dXMpO1xuICAgIH1cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGV4dGVuZCgqbW9kcylcbiAgICAleHtcbiAgICAgIGlmIChtb2RzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICN7cmFpc2UgOjpBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoZ2l2ZW4gMCwgZXhwZWN0ZWQgMSspJ31cbiAgICAgIH1cblxuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgdmFyIHNpbmdsZXRvbiA9ICN7c2luZ2xldG9uX2NsYXNzfTtcblxuICAgICAgZm9yICh2YXIgaSA9IG1vZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIG1vZCA9IG1vZHNbaV07XG5cbiAgICAgICAgaWYgKCFtb2QuJCRpc19tb2R1bGUpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3tgbW9kYC5jbGFzc30gKGV4cGVjdGVkIE1vZHVsZSlcIn07XG4gICAgICAgIH1cblxuICAgICAgICAje2Btb2RgLmFwcGVuZF9mZWF0dXJlcyBgc2luZ2xldG9uYH07XG4gICAgICAgICN7YG1vZGAuZXh0ZW5kX29iamVjdCBzZWxmfTtcbiAgICAgICAgI3tgbW9kYC5leHRlbmRlZCBzZWxmfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBmcmVlemVcbiAgICByZXR1cm4gc2VsZiBpZiBmcm96ZW4/XG5cbiAgICAleHtcbiAgICAgIGlmICh0eXBlb2Yoc2VsZikgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgJGZyZWV6ZV9wcm9wcyhzZWxmKTtcbiAgICAgICAgcmV0dXJuICRmcmVlemUoc2VsZik7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBmcm96ZW4/XG4gICAgJXh7XG4gICAgICBzd2l0Y2ggKHR5cGVvZihzZWxmKSkge1xuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgIHJldHVybiAoc2VsZi4kJGZyb3plbiB8fCBmYWxzZSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgZ2V0cygqYXJncylcbiAgICAkc3RkaW4uZ2V0cygqYXJncylcbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICBfX2lkX19cbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemVfY29weShvdGhlcilcbiAgZW5kXG5cbiAgYHZhciBpbnNwZWN0X3N0YWNrID0gW11gXG5cbiAgZGVmIGluc3BlY3RcbiAgICBpdnMgPSAnJ1xuICAgIGlkID0gX19pZF9fXG4gICAgaWYgYGluc3BlY3Rfc3RhY2tgLmluY2x1ZGU/IGlkXG4gICAgICBpdnMgPSAnIC4uLidcbiAgICBlbHNlXG4gICAgICBgaW5zcGVjdF9zdGFja2AgPDwgaWRcbiAgICAgIHB1c2hlZCA9IHRydWVcbiAgICAgIGluc3RhbmNlX3ZhcmlhYmxlcy5lYWNoIGRvIHxpfFxuICAgICAgICBpdmFyID0gaW5zdGFuY2VfdmFyaWFibGVfZ2V0KGkpXG4gICAgICAgIGluc3BlY3QgPSBPcGFsLmluc3BlY3QoaXZhcilcbiAgICAgICAgaXZzICs9IFwiICN7aX09I3tpbnNwZWN0fVwiXG4gICAgICBlbmRcbiAgICBlbmRcbiAgICBcIiM8I3tzZWxmLmNsYXNzfToweCN7aWQudG9fcygxNil9I3tpdnN9PlwiXG4gIHJlc2N1ZSA9PiBlXG4gICAgXCIjPCN7c2VsZi5jbGFzc306MHgje2lkLnRvX3MoMTYpfT5cIlxuICBlbnN1cmVcbiAgICBgaW5zcGVjdF9zdGFja2AucG9wIGlmIHB1c2hlZFxuICBlbmRcblxuICBkZWYgaW5zdGFuY2Vfb2Y/KGtsYXNzKVxuICAgICV4e1xuICAgICAgaWYgKCFrbGFzcy4kJGlzX2NsYXNzICYmICFrbGFzcy4kJGlzX21vZHVsZSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnY2xhc3Mgb3IgbW9kdWxlIHJlcXVpcmVkJ307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiQkY2xhc3MgPT09IGtsYXNzO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX3ZhcmlhYmxlX2RlZmluZWQ/KG5hbWUpXG4gICAgbmFtZSA9IDo6T3BhbC5pbnN0YW5jZV92YXJpYWJsZV9uYW1lIShuYW1lKVxuXG4gICAgYE9wYWwuaGFzT3duUHJvcGVydHkuY2FsbChzZWxmLCBuYW1lLnN1YnN0cigxKSlgXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZV9nZXQobmFtZSlcbiAgICBuYW1lID0gOjpPcGFsLmluc3RhbmNlX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICAleHtcbiAgICAgIHZhciBpdmFyID0gc2VsZltPcGFsLml2YXIobmFtZS5zdWJzdHIoMSkpXTtcblxuICAgICAgcmV0dXJuIGl2YXIgPT0gbnVsbCA/IG5pbCA6IGl2YXI7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVfc2V0KG5hbWUsIHZhbHVlKVxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxuXG4gICAgbmFtZSA9IDo6T3BhbC5pbnN0YW5jZV92YXJpYWJsZV9uYW1lIShuYW1lKVxuXG4gICAgYHNlbGZbT3BhbC5pdmFyKG5hbWUuc3Vic3RyKDEpKV0gPSB2YWx1ZWBcbiAgZW5kXG5cbiAgZGVmIHJlbW92ZV9pbnN0YW5jZV92YXJpYWJsZShuYW1lKVxuICAgIG5hbWUgPSA6Ok9wYWwuaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgICV4e1xuICAgICAgdmFyIGtleSA9IE9wYWwuaXZhcihuYW1lLnN1YnN0cigxKSksXG4gICAgICAgICAgdmFsO1xuICAgICAgaWYgKHNlbGYuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB2YWwgPSBzZWxmW2tleV07XG4gICAgICAgIGRlbGV0ZSBzZWxmW2tleV07XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgOjpLZXJuZWwucmFpc2UgOjpOYW1lRXJyb3IsIFwiaW5zdGFuY2UgdmFyaWFibGUgI3tuYW1lfSBub3QgZGVmaW5lZFwiXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZXNcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSwgbmFtZTtcblxuICAgICAgJGVhY2hfaXZhcihzZWxmLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lLnN1YnN0cigtMSkgPT09ICckJykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIG5hbWUubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goJ0AnICsgbmFtZSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBJbnRlZ2VyKHZhbHVlLCBiYXNlID0gdW5kZWZpbmVkLCBleGNlcHRpb246IHRydWUpXG4gICAgJXh7XG4gICAgICB2YXIgaSwgc3RyLCBiYXNlX2RpZ2l0cztcblxuICAgICAgZXhjZXB0aW9uID0gJHRydXRoeSgje2V4Y2VwdGlvbn0pO1xuXG4gICAgICBpZiAoIXZhbHVlLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIGlmIChiYXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2Jhc2Ugc3BlY2lmaWVkIGZvciBub24gc3RyaW5nIHZhbHVlJ31cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSBuaWwpIHtcbiAgICAgICAgICBpZiAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgbmlsIGludG8gSW50ZWdlclwifVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUuJCRpc19udW1iZXIpIHtcbiAgICAgICAgICBpZiAodmFsdWUgPT09IEluZmluaXR5IHx8IHZhbHVlID09PSAtSW5maW5pdHkgfHwgaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpGbG9hdERvbWFpbkVycm9yLCB2YWx1ZX1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoI3t2YWx1ZS5yZXNwb25kX3RvPyg6dG9faW50KX0pIHtcbiAgICAgICAgICBpID0gI3t2YWx1ZS50b19pbnR9O1xuICAgICAgICAgIGlmIChPcGFsLmlzX2EoaSwgI3s6OkludGVnZXJ9KSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgje3ZhbHVlLnJlc3BvbmRfdG8/KDp0b19pKX0pIHtcbiAgICAgICAgICBpID0gI3t2YWx1ZS50b19pfTtcbiAgICAgICAgICBpZiAoT3BhbC5pc19hKGksICN7OjpJbnRlZ2VyfSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleGNlcHRpb24pIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3t2YWx1ZS5jbGFzc30gaW50byBJbnRlZ2VyXCJ9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUgPT09IFwiMFwiKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmFzZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJhc2UgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZSA9ICRjb2VyY2VfdG8oYmFzZSwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgICAgIGlmIChiYXNlID09PSAxIHx8IGJhc2UgPCAwIHx8IGJhc2UgPiAzNikge1xuICAgICAgICAgIGlmIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFkaXggI3tiYXNlfVwifVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdHIgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBzdHIgPSBzdHIucmVwbGFjZSgvKFxcZClfKD89XFxkKS9nLCAnJDEnKTtcblxuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoL14oXFxzKlsrLV0/KSgwW2JvZHhdPykvLCBmdW5jdGlvbiAoXywgaGVhZCwgZmxhZykge1xuICAgICAgICBzd2l0Y2ggKGZsYWcpIHtcbiAgICAgICAgY2FzZSAnMGInOlxuICAgICAgICAgIGlmIChiYXNlID09PSAwIHx8IGJhc2UgPT09IDIpIHtcbiAgICAgICAgICAgIGJhc2UgPSAyO1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG5vLWJyZWFrXG4gICAgICAgIGNhc2UgJzAnOlxuICAgICAgICBjYXNlICcwbyc6XG4gICAgICAgICAgaWYgKGJhc2UgPT09IDAgfHwgYmFzZSA9PT0gOCkge1xuICAgICAgICAgICAgYmFzZSA9IDg7XG4gICAgICAgICAgICByZXR1cm4gaGVhZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gbm8tYnJlYWtcbiAgICAgICAgY2FzZSAnMGQnOlxuICAgICAgICAgIGlmIChiYXNlID09PSAwIHx8IGJhc2UgPT09IDEwKSB7XG4gICAgICAgICAgICBiYXNlID0gMTA7XG4gICAgICAgICAgICByZXR1cm4gaGVhZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gbm8tYnJlYWtcbiAgICAgICAgY2FzZSAnMHgnOlxuICAgICAgICAgIGlmIChiYXNlID09PSAwIHx8IGJhc2UgPT09IDE2KSB7XG4gICAgICAgICAgICBiYXNlID0gMTY7XG4gICAgICAgICAgICByZXR1cm4gaGVhZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gbm8tYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCB2YWx1ZSBmb3IgSW50ZWdlcigpOiBcXFwiI3t2YWx1ZX1cXFwiXCJ9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGJhc2UgPSAoYmFzZSA9PT0gMCA/IDEwIDogYmFzZSk7XG5cbiAgICAgIGJhc2VfZGlnaXRzID0gJzAtJyArIChiYXNlIDw9IDEwID8gYmFzZSAtIDEgOiAnOWEtJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoOTcgKyAoYmFzZSAtIDExKSkpO1xuXG4gICAgICBpZiAoIShuZXcgUmVnRXhwKCdeXFxcXHMqWystXT9bJyArIGJhc2VfZGlnaXRzICsgJ10rXFxcXHMqJCcpKS50ZXN0KHN0cikpIHtcbiAgICAgICAgaWYgKGV4Y2VwdGlvbikge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgdmFsdWUgZm9yIEludGVnZXIoKTogXFxcIiN7dmFsdWV9XFxcIlwifVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaSA9IHBhcnNlSW50KHN0ciwgYmFzZSk7XG5cbiAgICAgIGlmIChpc05hTihpKSkge1xuICAgICAgICBpZiAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCB2YWx1ZSBmb3IgSW50ZWdlcigpOiBcXFwiI3t2YWx1ZX1cXFwiXCJ9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBGbG9hdCh2YWx1ZSwgZXhjZXB0aW9uOiB0cnVlKVxuICAgICV4e1xuICAgICAgdmFyIHN0cjtcblxuICAgICAgZXhjZXB0aW9uID0gJHRydXRoeSgje2V4Y2VwdGlvbn0pO1xuXG4gICAgICBpZiAodmFsdWUgPT09IG5pbCkge1xuICAgICAgICBpZiAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0IG5pbCBpbnRvIEZsb2F0XCJ9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgc3RyID0gdmFsdWUudG9TdHJpbmcoKTtcblxuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvKFxcZClfKD89XFxkKS9nLCAnJDEnKTtcblxuICAgICAgICAvL1NwZWNpYWwgY2FzZSBmb3IgaGV4IHN0cmluZ3Mgb25seTpcbiAgICAgICAgaWYgKC9eXFxzKlstK10/MFt4WF1bMC05YS1mQS1GXStcXHMqJC8udGVzdChzdHIpKSB7XG4gICAgICAgICAgcmV0dXJuICN7OjpLZXJuZWwuSW50ZWdlcihgc3RyYCl9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEvXlxccypbLStdP1swLTldKlxcLj9bMC05XSsoW2VFXVstK10/WzAtOV0rKT9cXHMqJC8udGVzdChzdHIpKSB7XG4gICAgICAgICAgaWYgKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCB2YWx1ZSBmb3IgRmxvYXQoKTogXFxcIiN7dmFsdWV9XFxcIlwifVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHN0cik7XG4gICAgICB9XG5cbiAgICAgIGlmIChleGNlcHRpb24pIHtcbiAgICAgICAgcmV0dXJuICN7OjpPcGFsLmNvZXJjZV90byEodmFsdWUsIDo6RmxvYXQsIDp0b19mKX07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJGNvZXJjZV90byh2YWx1ZSwgI3s6OkZsb2F0fSwgJ3RvX2YnKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBIYXNoKGFyZylcbiAgICByZXR1cm4ge30gaWYgYXJnLm5pbD8gfHwgYXJnID09IFtdXG4gICAgcmV0dXJuIGFyZyBpZiA6Okhhc2ggPT09IGFyZ1xuICAgIDo6T3BhbC5jb2VyY2VfdG8hKGFyZywgOjpIYXNoLCA6dG9faGFzaClcbiAgZW5kXG5cbiAgZGVmIGlzX2E/KGtsYXNzKVxuICAgICV4e1xuICAgICAgaWYgKCFrbGFzcy4kJGlzX2NsYXNzICYmICFrbGFzcy4kJGlzX21vZHVsZSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnY2xhc3Mgb3IgbW9kdWxlIHJlcXVpcmVkJ307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBPcGFsLmlzX2Eoc2VsZiwga2xhc3MpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGl0c2VsZlxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGxhbWJkYSgmYmxvY2spXG4gICAgYE9wYWwubGFtYmRhKGJsb2NrKWBcbiAgZW5kXG5cbiAgZGVmIGxvYWQoZmlsZSlcbiAgICBmaWxlID0gOjpPcGFsLmNvZXJjZV90byEoZmlsZSwgOjpTdHJpbmcsIDp0b19zdHIpXG4gICAgYE9wYWwubG9hZCgje2ZpbGV9KWBcbiAgZW5kXG5cbiAgZGVmIGxvb3BcbiAgICByZXR1cm4gZW51bV9mb3IoOmxvb3ApIHsgOjpGbG9hdDo6SU5GSU5JVFkgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICB3aGlsZSB0cnVlXG4gICAgICBiZWdpblxuICAgICAgICB5aWVsZFxuICAgICAgcmVzY3VlIDo6U3RvcEl0ZXJhdGlvbiA9PiBlXG4gICAgICAgIHJldHVybiBlLnJlc3VsdFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBuaWw/XG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIHByaW50ZigqYXJncylcbiAgICByZXR1cm4gaWYgYXJncy5lbXB0eT9cblxuICAgIGlvID0gYGFyZ3NbMF0uJCRpc19zdHJpbmdgID8gJHN0ZG91dCA6IGFyZ3Muc2hpZnRcbiAgICBpby53cml0ZSBmb3JtYXQoKmFyZ3MpXG5cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIHByb2MoJmJsb2NrKVxuICAgIHVubGVzcyBibG9ja1xuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY3JlYXRlIFByb2Mgb2JqZWN0IHdpdGhvdXQgYSBibG9jaydcbiAgICBlbmRcblxuICAgIGBibG9jay4kJGlzX2xhbWJkYSA9IGZhbHNlYFxuICAgIGJsb2NrXG4gIGVuZFxuXG4gIGRlZiBwdXRzKCpzdHJzKVxuICAgICRzdGRvdXQucHV0cygqc3RycylcbiAgZW5kXG5cbiAgZGVmIHAoKmFyZ3MpXG4gICAgYXJncy5lYWNoIHsgfG9ianwgJHN0ZG91dC5wdXRzIG9iai5pbnNwZWN0IH1cblxuICAgIGFyZ3MubGVuZ3RoIDw9IDEgPyBhcmdzWzBdIDogYXJnc1xuICBlbmRcblxuICBkZWYgcHJpbnQoKnN0cnMpXG4gICAgJHN0ZG91dC5wcmludCgqc3RycylcbiAgZW5kXG5cbiAgZGVmIHJlYWRsaW5lKCphcmdzKVxuICAgICRzdGRpbi5yZWFkbGluZSgqYXJncylcbiAgZW5kXG5cbiAgZGVmIHdhcm4oKnN0cnMsIHVwbGV2ZWw6IG5pbClcbiAgICBpZiB1cGxldmVsXG4gICAgICB1cGxldmVsID0gOjpPcGFsLmNvZXJjZV90byEodXBsZXZlbCwgOjpJbnRlZ2VyLCA6dG9fc3RyKVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIm5lZ2F0aXZlIGxldmVsICgje3VwbGV2ZWx9KVwiIGlmIHVwbGV2ZWwgPCAwXG4gICAgICBsb2NhdGlvbiA9IGNhbGxlcih1cGxldmVsICsgMSwgMSkuZmlyc3QmLnNwbGl0KCc6aW4gYCcpJi5maXJzdFxuICAgICAgbG9jYXRpb24gPSBcIiN7bG9jYXRpb259OiBcIiBpZiBsb2NhdGlvblxuICAgICAgc3RycyA9IHN0cnMubWFwIHsgfHN8IFwiI3tsb2NhdGlvbn13YXJuaW5nOiAje3N9XCIgfVxuICAgIGVuZFxuXG4gICAgJHN0ZGVyci5wdXRzKCpzdHJzKSB1bmxlc3MgJFZFUkJPU0UubmlsPyB8fCBzdHJzLmVtcHR5P1xuICBlbmRcblxuICBkZWYgcmFpc2UoZXhjZXB0aW9uID0gdW5kZWZpbmVkLCBzdHJpbmcgPSBuaWwsIGJhY2t0cmFjZSA9IG5pbClcbiAgICAleHtcbiAgICAgIGlmIChleGNlcHRpb24gPT0gbnVsbCAmJiAjeyQhfSAhPT0gbmlsKSB7XG4gICAgICAgIHRocm93ICN7JCF9O1xuICAgICAgfVxuICAgICAgaWYgKGV4Y2VwdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIGV4Y2VwdGlvbiA9ICN7OjpSdW50aW1lRXJyb3IubmV3ICcnfTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCRyZXNwb25kX3RvKGV4Y2VwdGlvbiwgJyR0b19zdHInKSkge1xuICAgICAgICBleGNlcHRpb24gPSAjezo6UnVudGltZUVycm9yLm5ldyBleGNlcHRpb24udG9fc3RyfTtcbiAgICAgIH1cbiAgICAgIC8vIHVzaW5nIHJlc3BvbmRfdG8/IGFuZCBub3QgYW4gdW5kZWZpbmVkIGNoZWNrIHRvIGF2b2lkIG1ldGhvZF9taXNzaW5nIG1hdGNoaW5nIGFzIHRydWVcbiAgICAgIGVsc2UgaWYgKGV4Y2VwdGlvbi4kJGlzX2NsYXNzICYmICRyZXNwb25kX3RvKGV4Y2VwdGlvbiwgJyRleGNlcHRpb24nKSkge1xuICAgICAgICBleGNlcHRpb24gPSAje2V4Y2VwdGlvbi5leGNlcHRpb24gc3RyaW5nfTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGV4Y2VwdGlvbi4kJGlzX2V4Y2VwdGlvbikge1xuICAgICAgICAvLyBleGNlcHRpb24gaXMgZmluZVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGV4Y2VwdGlvbiA9ICN7OjpUeXBlRXJyb3IubmV3ICdleGNlcHRpb24gY2xhc3Mvb2JqZWN0IGV4cGVjdGVkJ307XG4gICAgICB9XG5cbiAgICAgIGlmIChiYWNrdHJhY2UgIT09IG5pbCkge1xuICAgICAgICBleGNlcHRpb24uJHNldF9iYWNrdHJhY2UoYmFja3RyYWNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCN7JCF9ICE9PSBuaWwpIHtcbiAgICAgICAgT3BhbC5leGNlcHRpb25zLnB1c2goI3skIX0pO1xuICAgICAgfVxuXG4gICAgICAjeyQhfSA9IGV4Y2VwdGlvbjtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJhbmQobWF4ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAjezo6UmFuZG9tOjpERUZBVUxULnJhbmR9O1xuICAgICAgfVxuXG4gICAgICBpZiAobWF4LiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIGlmIChtYXggPCAwKSB7XG4gICAgICAgICAgbWF4ID0gTWF0aC5hYnMobWF4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXggJSAxICE9PSAwKSB7XG4gICAgICAgICAgbWF4ID0gbWF4LiR0b19pKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF4ID09PSAwKSB7XG4gICAgICAgICAgbWF4ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIDo6UmFuZG9tOjpERUZBVUxULnJhbmQobWF4KVxuICBlbmRcblxuICBkZWYgcmVzcG9uZF90bz8obmFtZSwgaW5jbHVkZV9hbGwgPSBmYWxzZSlcbiAgICAleHtcbiAgICAgIHZhciBib2R5ID0gc2VsZlskanNpZChuYW1lKV07XG5cbiAgICAgIGlmICh0eXBlb2YoYm9keSkgPT09IFwiZnVuY3Rpb25cIiAmJiAhYm9keS4kJHN0dWIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmWyckcmVzcG9uZF90b19taXNzaW5nPyddLiQkcHJpc3RpbmUgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7cmVzcG9uZF90b19taXNzaW5nPyhuYW1lLCBpbmNsdWRlX2FsbCl9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlc3BvbmRfdG9fbWlzc2luZz8obWV0aG9kX25hbWUsIGluY2x1ZGVfYWxsID0gZmFsc2UpXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgOjpPcGFsLnByaXN0aW5lKHNlbGYsIDpyZXNwb25kX3RvPywgOnJlc3BvbmRfdG9fbWlzc2luZz8pXG5cbiAgZGVmIHJlcXVpcmUoZmlsZSlcbiAgICAleHtcbiAgICAgIC8vIEFzIE9iamVjdC5yZXF1aXJlIHJlZmVycyB0byBLZXJuZWwucmVxdWlyZSBvbmNlIEtlcm5lbCBoYXMgYmVlbiBsb2FkZWQgdGhlIFN0cmluZ1xuICAgICAgLy8gY2xhc3MgbWF5IG5vdCBiZSBhdmFpbGFibGUgeWV0LCB0aGUgY29lcmNpb24gcmVxdWlyZXMgYm90aCAgU3RyaW5nIGFuZCBBcnJheSB0byBiZSBsb2FkZWQuXG4gICAgICBpZiAodHlwZW9mICN7ZmlsZX0gIT09ICdzdHJpbmcnICYmIE9wYWwuU3RyaW5nICYmIE9wYWwuQXJyYXkpIHtcbiAgICAgICAgI3tmaWxlID0gOjpPcGFsLmNvZXJjZV90byEoZmlsZSwgOjpTdHJpbmcsIDp0b19zdHIpIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBPcGFsLnJlcXVpcmUoI3tmaWxlfSlcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZXF1aXJlX3JlbGF0aXZlKGZpbGUpXG4gICAgOjpPcGFsLnRyeV9jb252ZXJ0IShmaWxlLCA6OlN0cmluZywgOnRvX3N0cilcbiAgICBmaWxlID0gOjpGaWxlLmV4cGFuZF9wYXRoIDo6RmlsZS5qb2luKGBPcGFsLmN1cnJlbnRfZmlsZWAsICcuLicsIGZpbGUpXG5cbiAgICBgT3BhbC5yZXF1aXJlKCN7ZmlsZX0pYFxuICBlbmRcblxuICAjIGBwYXRoYCBzaG91bGQgYmUgdGhlIGZ1bGwgcGF0aCB0byBiZSBmb3VuZCBpbiByZWdpc3RlcmVkIG1vZHVsZXMgKGBPcGFsLm1vZHVsZXNgKVxuICBkZWYgcmVxdWlyZV90cmVlKHBhdGgsIGF1dG9sb2FkOiBmYWxzZSlcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgcGF0aCA9ICN7OjpGaWxlLmV4cGFuZF9wYXRoKHBhdGgpfVxuICAgICAgcGF0aCA9IE9wYWwubm9ybWFsaXplKHBhdGgpO1xuICAgICAgaWYgKHBhdGggPT09ICcuJykgcGF0aCA9ICcnO1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBPcGFsLm1vZHVsZXMpIHtcbiAgICAgICAgaWYgKCN7YG5hbWVgLnN0YXJ0X3dpdGg/KHBhdGgpfSkge1xuICAgICAgICAgIGlmKCEje2F1dG9sb2FkfSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goW25hbWUsIE9wYWwucmVxdWlyZShuYW1lKV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChbbmFtZSwgdHJ1ZV0pOyAvLyBkbyBub3RoaW5nLCBkZWxlZ2F0ZWQgdG8gYSBhdXRvbG9hZGluZ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNpbmdsZXRvbl9jbGFzc1xuICAgIGBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Moc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBzbGVlcChzZWNvbmRzID0gbmlsKVxuICAgICV4e1xuICAgICAgaWYgKHNlY29uZHMgPT09IG5pbCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgTmlsQ2xhc3MgaW50byB0aW1lIGludGVydmFsXCJ9XG4gICAgICB9XG4gICAgICBpZiAoIXNlY29uZHMuJCRpc19udW1iZXIpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7c2Vjb25kcy5jbGFzc30gaW50byB0aW1lIGludGVydmFsXCJ9XG4gICAgICB9XG4gICAgICBpZiAoc2Vjb25kcyA8IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0aW1lIGludGVydmFsIG11c3QgYmUgcG9zaXRpdmUnfVxuICAgICAgfVxuICAgICAgdmFyIGdldF90aW1lID0gT3BhbC5nbG9iYWwucGVyZm9ybWFuY2UgP1xuICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gcGVyZm9ybWFuY2Uubm93KCl9IDpcbiAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuIG5ldyBEYXRlKCl9XG5cbiAgICAgIHZhciB0ID0gZ2V0X3RpbWUoKTtcbiAgICAgIHdoaWxlIChnZXRfdGltZSgpIC0gdCA8PSBzZWNvbmRzICogMTAwMCk7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZChzZWNvbmRzKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzcmFuZChzZWVkID0gUmFuZG9tLm5ld19zZWVkKVxuICAgIDo6UmFuZG9tLnNyYW5kKHNlZWQpXG4gIGVuZFxuXG4gIGRlZiBTdHJpbmcoc3RyKVxuICAgIDo6T3BhbC5jb2VyY2VfdG8/KHN0ciwgOjpTdHJpbmcsIDp0b19zdHIpIHx8XG4gICAgICA6Ok9wYWwuY29lcmNlX3RvIShzdHIsIDo6U3RyaW5nLCA6dG9fcylcbiAgZW5kXG5cbiAgZGVmIHRhcCgmYmxvY2spXG4gICAgeWllbGQgc2VsZlxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRvX3Byb2NcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgXCIjPCN7c2VsZi5jbGFzc306MHgje19faWRfXy50b19zKDE2KX0+XCJcbiAgZW5kXG5cbiAgZGVmIGNhdGNoKHRhZyA9IG5pbClcbiAgICB0YWcgfHw9IDo6T2JqZWN0Lm5ld1xuICAgIHlpZWxkKHRhZylcbiAgcmVzY3VlIDo6VW5jYXVnaHRUaHJvd0Vycm9yID0+IGVcbiAgICByZXR1cm4gZS52YWx1ZSBpZiBlLnRhZyA9PSB0YWdcbiAgICA6Oktlcm5lbC5yYWlzZVxuICBlbmRcblxuICBkZWYgdGhyb3codGFnLCBvYmogPSBuaWwpXG4gICAgOjpLZXJuZWwucmFpc2UgOjpVbmNhdWdodFRocm93RXJyb3IubmV3KHRhZywgb2JqKVxuICBlbmRcblxuICAjIGJhc2ljIGltcGxlbWVudGF0aW9uIG9mIG9wZW4sIGRlbGVnYXRlIHRvIEZpbGUub3BlblxuICBkZWYgb3BlbigqYXJncywgJmJsb2NrKVxuICAgIDo6RmlsZS5vcGVuKCphcmdzLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiB5aWVsZF9zZWxmXG4gICAgcmV0dXJuIGVudW1fZm9yKDp5aWVsZF9zZWxmKSB7IDEgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgeWllbGQgc2VsZlxuICBlbmRcblxuICBhbGlhcyBmYWlsIHJhaXNlXG4gIGFsaWFzIGtpbmRfb2Y/IGlzX2E/XG4gIGFsaWFzIG9iamVjdF9pZCBfX2lkX19cbiAgYWxpYXMgcHVibGljX3NlbmQgX19zZW5kX19cbiAgYWxpYXMgc2VuZCBfX3NlbmRfX1xuICBhbGlhcyB0aGVuIHlpZWxkX3NlbGZcbiAgYWxpYXMgdG9fZW51bSBlbnVtX2ZvclxuZW5kXG5cbmNsYXNzIDo6T2JqZWN0XG4gICMgT2JqZWN0LnJlcXVpcmUgaGFzIGJlZW4gc2V0IHRvIHJ1bnRpbWUuanMgT3BhbC5yZXF1aXJlXG4gICMgTm93IHdlIGhhdmUgS2VybmVsIGxvYWRlZCwgbWFrZSBzdXJlIE9iamVjdC5yZXF1aXJlIHJlZmVycyB0byBLZXJuZWwucmVxdWlyZVxuICAjIHdoaWNoIGlzIHdoYXQgcnVieSBkb2VzIGFuZCBhbGxvd3MgZm9yIG92ZXJ3cml0aW5nIGJ5IGF1dG9sb2FkZXJzXG4gIGBkZWxldGUgJE9iamVjdC4kJHByb3RvdHlwZS4kcmVxdWlyZWBcbiAgaW5jbHVkZSA6Oktlcm5lbFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6S2VybmVsPiIsIj1+IiwiIX4iLCJvYmoiLCJzZWxmIiwiISIsIj09PSIsIm90aGVyIiwiJHJldF9vcl8xIiwib2JqZWN0X2lkIiwiPT0iLCI8PT4iLCJtZXRob2QiLCJuYW1lIiwiS2VybmVsIiwicmFpc2UiLCJOYW1lRXJyb3IiLCJuZXciLCJjbGFzcyIsIk1ldGhvZCIsIm1ldGhvZHMiLCJhbGwiLCJwdWJsaWNfbWV0aG9kcyIsIkFycmF5Iiwib2JqZWN0IiwiT3BhbCIsImNvZXJjZV90bz8iLCJhdF9leGl0IiwiJF9fYXRfZXhpdF9fIiwiPDwiLCJibG9jayIsImNhbGxlciIsInN0YXJ0IiwibGVuZ3RoIiwiMSIsImNhbGxlcl9sb2NhdGlvbnMiLCJtYXAiLCJhcmdzIiwiYmxvY2sgaW4gY2FsbGVyX2xvY2F0aW9ucyIsImxvYyIsImJsb2NrICgyIGxldmVscykgaW4gY2FsbGVyX2xvY2F0aW9ucyIsIlRocmVhZDo6QmFja3RyYWNlOjpMb2NhdGlvbiIsIlRocmVhZDo6QmFja3RyYWNlIiwiVGhyZWFkIiwiY29weV9pbnN0YW5jZV92YXJpYWJsZXMiLCJjb3B5X3NpbmdsZXRvbl9tZXRob2RzIiwiY2xvbmUiLCIka3dhcmdzIiwiZnJlZXplIiwibmlsPyIsIkFyZ3VtZW50RXJyb3IiLCJjb3B5IiwiYWxsb2NhdGUiLCJpbml0aWFsaXplX2Nsb25lIiwiZnJvemVuPyIsImluaXRpYWxpemVfY29weSIsImRlZmluZV9zaW5nbGV0b25fbWV0aG9kIiwiZGVmaW5lX21ldGhvZCIsInNpbmdsZXRvbl9jbGFzcyIsInRvX3Byb2MiLCJkdXAiLCJpbml0aWFsaXplX2R1cCIsImVudW1fZm9yIiwiZm9yIiwiRW51bWVyYXRvciIsImVxdWFsPyIsImV4aXQiLCJzdGF0dXMiLCJlbXB0eT8iLCJwb3AiLCJjYWxsIiwiSW50ZWdlciIsImV4dGVuZCIsIlR5cGVFcnJvciIsImFwcGVuZF9mZWF0dXJlcyIsImV4dGVuZF9vYmplY3QiLCJleHRlbmRlZCIsImdldHMiLCIkc3RkaW4iLCJoYXNoIiwiX19pZF9fIiwiaW5zcGVjdCIsIml2cyIsImlkIiwiaW5jbHVkZT8iLCJwdXNoZWQiLCJlYWNoIiwiaW5zdGFuY2VfdmFyaWFibGVzIiwiYmxvY2sgaW4gaW5zcGVjdCIsImkiLCJibG9jayAoMiBsZXZlbHMpIGluIGluc3BlY3QiLCJpdmFyIiwiaW5zdGFuY2VfdmFyaWFibGVfZ2V0IiwiKyIsInRvX3MiLCIxNiIsIlN0YW5kYXJkRXJyb3IiLCJlIiwiaW5zdGFuY2Vfb2Y/Iiwia2xhc3MiLCJpbnN0YW5jZV92YXJpYWJsZV9kZWZpbmVkPyIsImluc3RhbmNlX3ZhcmlhYmxlX25hbWUhIiwiaW5zdGFuY2VfdmFyaWFibGVfc2V0IiwidmFsdWUiLCJyZW1vdmVfaW5zdGFuY2VfdmFyaWFibGUiLCJleGNlcHRpb24iLCJGbG9hdERvbWFpbkVycm9yIiwicmVzcG9uZF90bz8iLCJ0b19pbnQiLCJ0b19pIiwiYmFzZSIsIkZsb2F0IiwiY29lcmNlX3RvISIsIkhhc2giLCJhcmciLCJpc19hPyIsIml0c2VsZiIsImxhbWJkYSIsImxvYWQiLCJmaWxlIiwiU3RyaW5nIiwibG9vcCIsImJsb2NrX2dpdmVuPyIsImJsb2NrIGluIGxvb3AiLCJibG9jayAoMiBsZXZlbHMpIGluIGxvb3AiLCJGbG9hdDo6SU5GSU5JVFkiLCJTdG9wSXRlcmF0aW9uIiwicmVzdWx0IiwicHJpbnRmIiwiaW8iLCIkc3Rkb3V0Iiwic2hpZnQiLCJ3cml0ZSIsImZvcm1hdCIsInByb2MiLCJwdXRzIiwic3RycyIsInAiLCJibG9jayBpbiBwIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwIiwiPD0iLCJbXSIsIjAiLCJwcmludCIsInJlYWRsaW5lIiwid2FybiIsInVwbGV2ZWwiLCI8IiwibG9jYXRpb24iLCJmaXJzdCIsImJsb2NrIGluIHdhcm4iLCJzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB3YXJuIiwiJFZFUkJPU0UiLCIkc3RkZXJyIiwic3RyaW5nIiwiYmFja3RyYWNlIiwiJCEiLCJSdW50aW1lRXJyb3IiLCJ0b19zdHIiLCJyYW5kIiwibWF4IiwiUmFuZG9tOjpERUZBVUxUIiwiUmFuZG9tIiwiaW5jbHVkZV9hbGwiLCJyZXNwb25kX3RvX21pc3Npbmc/IiwibWV0aG9kX25hbWUiLCJwcmlzdGluZSIsInJlcXVpcmUiLCJyZXF1aXJlX3JlbGF0aXZlIiwidHJ5X2NvbnZlcnQhIiwiRmlsZSIsImV4cGFuZF9wYXRoIiwiam9pbiIsInJlcXVpcmVfdHJlZSIsInBhdGgiLCJzdGFydF93aXRoPyIsImF1dG9sb2FkIiwic2xlZXAiLCJzZWNvbmRzIiwic3JhbmQiLCJzZWVkIiwibmV3X3NlZWQiLCJzdHIiLCJ0YXAiLCJjYXRjaCIsInRhZyIsIk9iamVjdCIsIlVuY2F1Z2h0VGhyb3dFcnJvciIsInRocm93Iiwib3BlbiIsInlpZWxkX3NlbGYiLCJibG9jayBpbiB5aWVsZF9zZWxmIiwiPGNsYXNzOk9iamVjdD4iLCJpbmNsdWRlIl0sIm1hcHBpbmdzIjoiQUFBQUEsaUNBQUFBLGdCQUFBQTtFQUFBQTtFQUFBQTs7RUFBQUE7O0VBSUFDO0VBQUFBOztJQUFBQTs7OztBQUNFQyxJQUFBQSxrQkFBQUEsWUFDRSxLQURGQSxDQUFBQTs7QUFJQUMsSUFBQUEsa0JBQUFBLCtCQUFPQyxHQUFQRDtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBRUUsSUFBS0gsT0FBQUEsQ0FBR0UsR0FBSEYsQ0FBUEksTUFBQUEsQ0FBQUE7SUFE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QWxJO01BQVA7TUFDQSxPQUFBLG9CQUFNMUQsSUFBTixDQUFBO0lBRkYyTCxDQUFBQTtJQUtBLGFBQU0sTUFBTixFQUFXLE9BQVg7SUFDQSxhQUFNLFVBQU4sRUFBZSxPQUFmO0lBQ0EsYUFBTSxXQUFOLEVBQWdCLFFBQWhCO0lBQ0EsYUFBTSxhQUFOLEVBQWtCLFVBQWxCO0lBQ0EsYUFBTSxNQUFOLEVBQVcsVUFBWDtJQUNBLGFBQU0sTUFBTixFQUFXLFlBQVg7SUFDQS9MLE9BQUEsYUFBTSxTQUFOLEVBQWMsVUFBZDtFQS8wQkZBLEdBQU8sSUFBUEE7RUFrMUJBRCxPQUFBa007RUFBQUE7Ozs7SUFJR0E7SUFDREEsT0FBQTdMLElBQUE4TCxTQUFBQSxDQUFRcEwsT0FBUm9MO0VBTEZELEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7QUF0MUJBbE07In19LHsib2Zmc2V0Ijp7ImxpbmUiOjU5MTAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL21haW4ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXG5cbmNsYXNzIDw8IHNlbGZcbiAgZGVmIHRvX3NcbiAgICAnbWFpbidcbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGUobW9kKVxuICAgIDo6T2JqZWN0LmluY2x1ZGUgbW9kXG4gIGVuZFxuXG4gIGRlZiBhdXRvbG9hZCgqYXJncylcbiAgICBgT3BhbC5PYmplY3QuJGF1dG9sb2FkLmFwcGx5KE9wYWwuT2JqZWN0LCBhcmdzKWBcbiAgZW5kXG5cbiAgIyBDb21waWxlciBvdmVycmlkZXMgdGhpcyBtZXRob2RcbiAgZGVmIHVzaW5nKG1vZClcbiAgICA6Oktlcm5lbC5yYWlzZSAnbWFpbi51c2luZyBpcyBwZXJtaXR0ZWQgb25seSBhdCB0b3BsZXZlbCdcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwidG9fcyIsImluY2x1ZGUiLCJtb2QiLCJPYmplY3QiLCJhdXRvbG9hZCIsInVzaW5nIiwiS2VybmVsIiwicmFpc2UiLCJzZWxmIl0sIm1hcHBpbmdzIjoiQUFBQUEsK0JBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQTs7OztBQUNFQyxJQUFBQSxvQkFBQUEsWUFDRSxNQURGQSxDQUFBQTs7QUFJQUMsSUFBQUEsdUJBQUFBLG1CQUFZQyxHQUFaRDtBQUFBQTtNQUNFQSxPQUFBRSxPQUFRRixTQUFBQSxDQUFTQyxHQUFURDtJQURWQSxDQUFBQTs7QUFJQUcsSUFBQUEsd0JBQUFBLG9CQVhGLEVBV0VBO0FBQUFBLE1BQUFBOzs7TUFYRjtNQVdlO01BQ1hBLE9BQUNBLDhDQUFEQTtJQURGQSxDQUFBQSxJQUFBQTtJQUtBLE9BQUFDLHFCQUFBQSxpQkFBVUgsR0FBVkc7QUFBQUE7TUFDRUEsT0FBQUMsT0FBUUMsT0FBQUEsQ0FBT0YsMENBQVBFO0lBRFZGLENBQUFBO0VBZEYsNEJBQVNHLElBQVQ7QUFGQVQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjU5NDAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2Vycm9yL2Vycm5vLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxuXG5tb2R1bGUgOjpFcnJub1xuICBlcnJvcnMgPSBbXG4gICAgWzpFSU5WQUwsICdJbnZhbGlkIGFyZ3VtZW50JywgMjJdLFxuICAgIFs6RUVYSVNULCAnRmlsZSBleGlzdHMnLCAxN10sXG4gICAgWzpFSVNESVIsICdJcyBhIGRpcmVjdG9yeScsIDIxXSxcbiAgICBbOkVNRklMRSwgJ1RvbyBtYW55IG9wZW4gZmlsZXMnLCAyNF0sXG4gICAgWzpFU1BJUEUsICdJbGxlZ2FsIHNlZWsnLCAyOV0sXG4gICAgWzpFQUNDRVMsICdQZXJtaXNzaW9uIGRlbmllZCcsIDEzXSxcbiAgICBbOkVQRVJNLCAnT3BlcmF0aW9uIG5vdCBwZXJtaXR0ZWQnLCAxXSxcbiAgICBbOkVOT0VOVCwgJ05vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnknLCAyXSxcbiAgICBbOkVOQU1FVE9PTE9ORywgJ0ZpbGUgbmFtZSB0b28gbG9uZycsIDM2XVxuICBdXG5cbiAga2xhc3MgPSBuaWxcblxuICAleHtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAoZnVuY3Rpb24oKSB7IC8vIENyZWF0ZSBhIGNsb3N1cmVcbiAgICAgICAgdmFyIGNsYXNzX25hbWUgPSBlcnJvcnNbaV1bMF07XG4gICAgICAgIHZhciBkZWZhdWx0X21lc3NhZ2UgPSBlcnJvcnNbaV1bMV07XG4gICAgICAgIHZhciBlcnJubyA9IGVycm9yc1tpXVsyXTtcblxuICAgICAgICBrbGFzcyA9IE9wYWwua2xhc3Moc2VsZiwgT3BhbC5TeXN0ZW1DYWxsRXJyb3IsIGNsYXNzX25hbWUpO1xuICAgICAgICBrbGFzcy5lcnJubyA9IGVycm5vO1xuXG4gICAgICAgICN7XG4gICAgICAgICAgY2xhc3MgPDwga2xhc3NcbiAgICAgICAgICAgIGRlZiBuZXcobmFtZSA9IG5pbClcbiAgICAgICAgICAgICAgbWVzc2FnZSA9IGBkZWZhdWx0X21lc3NhZ2VgXG4gICAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgLSAje25hbWV9XCIgaWYgbmFtZVxuICAgICAgICAgICAgICBzdXBlcihtZXNzYWdlKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZW5kXG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgfVxuICB9XG5lbmRcblxuY2xhc3MgOjpTeXN0ZW1DYWxsRXJyb3IgPCA6OlN0YW5kYXJkRXJyb3JcbiAgZGVmIGVycm5vXG4gICAgc2VsZi5jbGFzcy5lcnJub1xuICBlbmRcblxuICBjbGFzcyA8PCBzZWxmXG4gICAgYXR0cl9yZWFkZXIgOmVycm5vXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6RXJybm8+IiwiZXJyb3JzIiwiMjIiLCIxNyIsIjIxIiwiMjQiLCIyOSIsIjEzIiwiMSIsIjIiLCIzNiIsImtsYXNzIiwibmV3IiwibmFtZSIsIm1lc3NhZ2UiLCIrIiwic2VsZiIsIjxjbGFzczpTeXN0ZW1DYWxsRXJyb3I+IiwiZXJybm8iLCJjbGFzcyIsImF0dHJfcmVhZGVyIiwiU3RhbmRhcmRFcnJvciJdLCJtYXBwaW5ncyI6IkFBQUFBLHNDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQztFQUFBQTs7SUFBQUE7OztJQUNFQyxTQUFTLENBQ1AsQ0FBQyxRQUFELEVBQVVELGtCQUFWLEVBQThCRSxFQUE5QixDQURPLEVBRVAsQ0FBQyxRQUFELEVBQVVGLGFBQVYsRUFBeUJHLEVBQXpCLENBRk8sRUFHUCxDQUFDLFFBQUQsRUFBVUgsZ0JBQVYsRUFBNEJJLEVBQTVCLENBSE8sRUFJUCxDQUFDLFFBQUQsRUFBVUoscUJBQVYsRUFBaUNLLEVBQWpDLENBSk8sRUFLUCxDQUFDLFFBQUQsRUFBVUwsY0FBVixFQUEwQk0sRUFBMUIsQ0FMTyxFQU1QLENBQUMsUUFBRCxFQUFVTixtQkFBVixFQUErQk8sRUFBL0IsQ0FOTyxFQU9QLENBQUMsT0FBRCxFQUFTUCx5QkFBVCxFQUFvQ1EsQ0FBcEMsQ0FQTyxFQVFQLENBQUMsUUFBRCxFQUFVUiwyQkFBVixFQUF1Q1MsQ0FBdkMsQ0FSTyxFQVNQLENBQUMsY0FBRCxFQUFnQlQsb0JBQWhCLEVBQXNDVSxFQUF0QyxDQVRPO0lBWVRDLFFBQVE7O0FBR1ZYO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUEsUUFDVTs7TUFDRSxPQUFBWSxtQkFBQUEsZ0JBQVFDLElBQVJEO0FBQUFBLFFBQUFBOztRQUFBQTs7UUFBUSx5QkFBTztRQUNiRSxVQUFXRjtRQUNYLElBQUEsUUFBMkJDLElBQTNCLENBQUE7VUFBQUMsVUFBUUMsU0FBUkQsT0FBUUMsRUFBSUgsS0FBRCxHQUFBLENBQU1DLElBQU4sQ0FBSEU7UUFBUjtRQUNBSCxPQUFBLE9BQUFJLElBQUEsRUFBQSw2Q0FBQSxPQUFBLEVBQUEsQ0FBTUYsT0FBTixDQUFBLEVBQUEsSUFBQTtNQUhGRixDQUFBQSxJQUFBQTtJQURGLDRCQUFTRCxLQUFUO0FBUVZYO0FBQ0FBO0FBQ0FBO0VBckNBQSxHQUFPLElBQVBBO0VBd0NBRCxPQUFBa0I7RUFBQUE7O0lBQUFBOzs7O0FBQ0VDLElBQUFBLHFCQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFGLElBQUlHLE9BQUFBLENBQUFBLENBQU1ELE9BQUFBLENBQUFBO0lBRFpBLENBQUFBO0lBSUFELE9BQUE7O01BQ0UsT0FBQUQsSUFBQUksYUFBQUEsQ0FBWSxPQUFaQTtJQURGLDRCQUFTSixJQUFUO0VBTEZDLEdBQU0sSUFBTkEsRUFBMEJJLG9CQUExQko7QUExQ0FsQjsifX0seyJvZmZzZXQiOnsibGluZSI6NjAwMiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvZXJyb3IucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXG5cbmNsYXNzIDo6RXhjZXB0aW9uIDwgYEVycm9yYFxuICBgT3BhbC5wcm9wKHNlbGYuJCRwcm90b3R5cGUsICckJGlzX2V4Y2VwdGlvbicsIHRydWUpYFxuICBgdmFyIHN0YWNrX3RyYWNlX2xpbWl0YFxuXG4gIGBFcnJvci5zdGFja1RyYWNlTGltaXQgPSAxMDBgXG5cbiAgZGVmIHNlbGYubmV3KCphcmdzKVxuICAgICV4e1xuICAgICAgdmFyIG1lc3NhZ2UgICA9IChhcmdzLmxlbmd0aCA+IDApID8gYXJnc1swXSA6IG5pbDtcbiAgICAgIHZhciBlcnJvciAgICAgPSBuZXcgc2VsZi4kJGNvbnN0cnVjdG9yKG1lc3NhZ2UpO1xuICAgICAgZXJyb3IubmFtZSAgICA9IHNlbGYuJCRuYW1lO1xuICAgICAgZXJyb3IubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICBlcnJvci5jYXVzZSAgID0gI3skIX07XG4gICAgICBPcGFsLnNlbmQoZXJyb3IsIGVycm9yLiRpbml0aWFsaXplLCBhcmdzKTtcblxuICAgICAgLy8gRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoKSB3aWxsIHVzZSAubmFtZSBhbmQgLnRvU3RyaW5nIHRvIGJ1aWxkIHRoZVxuICAgICAgLy8gZmlyc3QgbGluZSBvZiB0aGUgc3RhY2sgdHJhY2Ugc28gaXQgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGVycm9yXG4gICAgICAvLyBoYXMgYmVlbiBpbml0aWFsaXplZC5cbiAgICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC12Ni54L2RvY3MvYXBpL2Vycm9ycy5odG1sXG4gICAgICBpZiAoT3BhbC5jb25maWcuZW5hYmxlX3N0YWNrX3RyYWNlICYmIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgIC8vIFBhc3NpbmcgS2VybmVsLnJhaXNlIHdpbGwgY3V0IHRoZSBzdGFjayB0cmFjZSBmcm9tIHRoYXQgcG9pbnQgYWJvdmVcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyb3IsIHN0YWNrX3RyYWNlX2xpbWl0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgZW5kXG4gIGBzdGFja190cmFjZV9saW1pdCA9IHNlbGYuJG5ld2BcblxuICBkZWYgc2VsZi5leGNlcHRpb24oKmFyZ3MpXG4gICAgbmV3KCphcmdzKVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZSgqYXJncylcbiAgICAjIHVzaW5nIHNlbGYubWVzc2FnZSBha2EgQG1lc3NhZ2UgdG8gcmV0YWluIGNvbXBhdGliaWxpdHkgd2l0aCBuYXRpdmUgZXhjZXB0aW9uJ3MgbWVzc2FnZSBwcm9wZXJ0eVxuICAgIGBzZWxmLm1lc3NhZ2UgPSAoYXJncy5sZW5ndGggPiAwKSA/IGFyZ3NbMF0gOiBuaWxgXG4gIGVuZFxuXG4gICMgVGhvc2UgaW5zdGFuY2UgdmFyaWFibGVzIGFyZSBub3QgZW51bWVyYWJsZS5cbiAgZGVmIGNvcHlfaW5zdGFuY2VfdmFyaWFibGVzKG90aGVyKVxuICAgIHN1cGVyXG4gICAgJXh7XG4gICAgICBzZWxmLm1lc3NhZ2UgPSBvdGhlci5tZXNzYWdlO1xuICAgICAgc2VsZi5jYXVzZSA9IG90aGVyLmNhdXNlO1xuICAgICAgc2VsZi5zdGFjayA9IG90aGVyLnN0YWNrO1xuICAgIH1cbiAgZW5kXG5cbiAgJXh7XG4gICAgLy8gQ29udmVydCBiYWNrdHJhY2UgZnJvbSBhbnkgZm9ybWF0IHRvIFJ1YnkgZm9ybWF0XG4gICAgZnVuY3Rpb24gY29ycmVjdF9iYWNrdHJhY2UoYmFja3RyYWNlKSB7XG4gICAgICB2YXIgbmV3X2J0ID0gW10sIG07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFja3RyYWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsb2MgPSBiYWNrdHJhY2VbaV07XG4gICAgICAgIGlmICghbG9jIHx8ICFsb2MuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAvKiBEbyBub3RoaW5nICovXG4gICAgICAgIH1cbiAgICAgICAgLyogQ2hyb21pdW0gZm9ybWF0ICovXG4gICAgICAgIGVsc2UgaWYgKChtID0gbG9jLm1hdGNoKC9eICAgIGF0ICguKj8pIFxcKCguKj8pXFwpJC8pKSkge1xuICAgICAgICAgIG5ld19idC5wdXNoKG1bMl0gKyBcIjppbiBgXCIgKyBtWzFdICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChtID0gbG9jLm1hdGNoKC9eICAgIGF0ICguKj8pJC8pKSkge1xuICAgICAgICAgIG5ld19idC5wdXNoKG1bMV0gKyBcIjppbiBgdW5kZWZpbmVkJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBOb2RlIGZvcm1hdCAqL1xuICAgICAgICBlbHNlIGlmICgobSA9IGxvYy5tYXRjaCgvXiAgZnJvbSAoLio/KSQvKSkpIHtcbiAgICAgICAgICBuZXdfYnQucHVzaChtWzFdKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBNb3ppbGxhL0FwcGxlIGZvcm1hdCAqL1xuICAgICAgICBlbHNlIGlmICgobSA9IGxvYy5tYXRjaCgvXiguKj8pQCguKj8pJC8pKSkge1xuICAgICAgICAgIG5ld19idC5wdXNoKG1bMl0gKyAnOmluIGAnICsgbVsxXSArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3X2J0O1xuICAgIH1cbiAgfVxuXG4gIGRlZiBiYWNrdHJhY2VcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLmJhY2t0cmFjZSkge1xuICAgICAgICAvLyBuaWwgaXMgYSB2YWxpZCBiYWNrdHJhY2VcbiAgICAgICAgcmV0dXJuIHNlbGYuYmFja3RyYWNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmFja3RyYWNlID0gc2VsZi5zdGFjaztcblxuICAgICAgaWYgKHR5cGVvZihiYWNrdHJhY2UpICE9PSAndW5kZWZpbmVkJyAmJiBiYWNrdHJhY2UuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuYmFja3RyYWNlID0gY29ycmVjdF9iYWNrdHJhY2UoYmFja3RyYWNlLnNwbGl0KFwiXFxuXCIpKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGJhY2t0cmFjZSkge1xuICAgICAgICByZXR1cm4gc2VsZi5iYWNrdHJhY2UgPSBjb3JyZWN0X2JhY2t0cmFjZShiYWNrdHJhY2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICBlbmRcblxuICBkZWYgYmFja3RyYWNlX2xvY2F0aW9uc1xuICAgICV4e1xuICAgICAgaWYgKHNlbGYuYmFja3RyYWNlX2xvY2F0aW9ucykgcmV0dXJuIHNlbGYuYmFja3RyYWNlX2xvY2F0aW9ucztcbiAgICAgIHNlbGYuYmFja3RyYWNlX2xvY2F0aW9ucyA9ICN7YmFja3RyYWNlJi5tYXAgZG8gfGxvY3xcbiAgICAgICAgOjpUaHJlYWQ6OkJhY2t0cmFjZTo6TG9jYXRpb24ubmV3KGxvYylcbiAgICAgIGVuZH1cbiAgICAgIHJldHVybiBzZWxmLmJhY2t0cmFjZV9sb2NhdGlvbnM7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2F1c2VcbiAgICBgc2VsZi5jYXVzZSB8fCBuaWxgXG4gIGVuZFxuXG4gIGRlZiBleGNlcHRpb24oc3RyID0gbmlsKVxuICAgICV4e1xuICAgICAgaWYgKHN0ciA9PT0gbmlsIHx8IHNlbGYgPT09IHN0cikge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNsb25lZCA9ICN7Y2xvbmV9O1xuICAgICAgY2xvbmVkLm1lc3NhZ2UgPSBzdHI7XG4gICAgICBpZiAoc2VsZi5iYWNrdHJhY2UpIGNsb25lZC5iYWNrdHJhY2UgPSBzZWxmLmJhY2t0cmFjZS4kZHVwKCk7XG4gICAgICBjbG9uZWQuc3RhY2sgPSBzZWxmLnN0YWNrO1xuICAgICAgY2xvbmVkLmNhdXNlID0gc2VsZi5jYXVzZTtcbiAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgfVxuICBlbmRcblxuICAjIG5vdCB1c2luZyBhbGlhcyBtZXNzYWdlIHRvX3MgYmVjYXVzZSB5b3UgbmVlZCB0byBiZSBhYmxlIHRvIG92ZXJyaWRlIHRvX3MgYW5kIGhhdmUgbWVzc2FnZSB1c2Ugb3ZlcnJpZGRlbiBtZXRob2QsIHdvbid0IHdvcmsgd2l0aCBhbGlhc1xuICBkZWYgbWVzc2FnZVxuICAgIHRvX3NcbiAgZW5kXG5cbiAgZGVmIGZ1bGxfbWVzc2FnZShrd2FyZ3MgPSBuaWwpXG4gICAgdW5sZXNzIGRlZmluZWQ/IEhhc2hcbiAgICAgICMgV2UgYXJlIGRlYWxpbmcgd2l0aCBhbiB1bmZ1bGx5IGxvYWRlZCBPcGFsIGxpYnJhcnksIHNvIHdlIHNob3VsZFxuICAgICAgIyBkbyB3aXRoIGFzIGxpdHRsZSBhcyB3ZSBjYW4uXG5cbiAgICAgIHJldHVybiBcIiN7QG1lc3NhZ2V9XFxuI3tgc2VsZi5zdGFja2B9XCJcbiAgICBlbmRcblxuICAgIGt3YXJncyA9IHsgaGlnaGxpZ2h0OiAkc3RkZXJyLnR0eT8sIG9yZGVyOiA6dG9wIH0ubWVyZ2Uoa3dhcmdzIHx8IHt9KVxuICAgIGhpZ2hsaWdodCwgb3JkZXIgPSBrd2FyZ3NbOmhpZ2hsaWdodF0sIGt3YXJnc1s6b3JkZXJdXG5cbiAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiZXhwZWN0ZWQgdHJ1ZSBvciBmYWxzZSBhcyBoaWdobGlnaHQ6ICN7aGlnaGxpZ2h0fVwiIHVubGVzcyBbdHJ1ZSwgZmFsc2VdLmluY2x1ZGU/IGhpZ2hsaWdodFxuICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJleHBlY3RlZCA6dG9wIG9yIDpib3R0b20gYXMgb3JkZXI6ICN7b3JkZXJ9XCIgdW5sZXNzICVpW3RvcCBib3R0b21dLmluY2x1ZGU/IG9yZGVyXG5cbiAgICBpZiBoaWdobGlnaHRcbiAgICAgIGJvbGRfdW5kZXJsaW5lID0gXCJcXGVbMTs0bVwiXG4gICAgICBib2xkID0gXCJcXGVbMW1cIlxuICAgICAgcmVzZXQgPSBcIlxcZVttXCJcbiAgICBlbHNlXG4gICAgICBib2xkX3VuZGVybGluZSA9IGJvbGQgPSByZXNldCA9ICcnXG4gICAgZW5kXG5cbiAgICBidCA9IGJhY2t0cmFjZS5kdXBcbiAgICBidCA9IGNhbGxlciBpZiAhYnQgfHwgYnQuZW1wdHk/XG4gICAgZmlyc3QgPSBidC5zaGlmdFxuXG4gICAgbXNnID0gXCIje2ZpcnN0fTogXCJcbiAgICBtc2cgKz0gXCIje2JvbGR9I3t0b19zfSAoI3tib2xkX3VuZGVybGluZX0je3NlbGYuY2xhc3N9I3tyZXNldH0je2JvbGR9KSN7cmVzZXR9XFxuXCJcblxuICAgIG1zZyArPSBidC5tYXAgeyB8bG9jfCBcIlxcdGZyb20gI3tsb2N9XFxuXCIgfS5qb2luXG5cbiAgICBtc2cgKz0gY2F1c2UuZnVsbF9tZXNzYWdlKGhpZ2hsaWdodDogaGlnaGxpZ2h0KSBpZiBjYXVzZVxuXG4gICAgaWYgb3JkZXIgPT0gOmJvdHRvbVxuICAgICAgbXNnID0gbXNnLnNwbGl0KFwiXFxuXCIpLnJldmVyc2Uuam9pbihcIlxcblwiKVxuICAgICAgbXNnID0gXCIje2JvbGR9VHJhY2ViYWNrI3tyZXNldH0gKG1vc3QgcmVjZW50IGNhbGwgbGFzdCk6XFxuXCIgKyBtc2dcbiAgICBlbmRcblxuICAgIG1zZ1xuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIGFzX3N0ciA9IHRvX3NcbiAgICBhc19zdHIuZW1wdHk/ID8gc2VsZi5jbGFzcy50b19zIDogXCIjPCN7c2VsZi5jbGFzcy50b19zfTogI3t0b19zfT5cIlxuICBlbmRcblxuICBkZWYgc2V0X2JhY2t0cmFjZShiYWNrdHJhY2UpXG4gICAgJXh7XG4gICAgICB2YXIgdmFsaWQgPSB0cnVlLCBpLCBpaTtcblxuICAgICAgaWYgKGJhY2t0cmFjZSA9PT0gbmlsKSB7XG4gICAgICAgIHNlbGYuYmFja3RyYWNlID0gbmlsO1xuICAgICAgICBzZWxmLnN0YWNrID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKGJhY2t0cmFjZS4kJGlzX3N0cmluZykge1xuICAgICAgICBzZWxmLmJhY2t0cmFjZSA9IFtiYWNrdHJhY2VdO1xuICAgICAgICBzZWxmLnN0YWNrID0gJyAgZnJvbSAnICsgYmFja3RyYWNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGJhY2t0cmFjZS4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgaWkgPSBiYWNrdHJhY2UubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFiYWNrdHJhY2VbaV0uJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ2JhY2t0cmFjZSBtdXN0IGJlIEFycmF5IG9mIFN0cmluZyd9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmJhY2t0cmFjZSA9IGJhY2t0cmFjZTtcbiAgICAgICAgc2VsZi5zdGFjayA9ICN7YGJhY2t0cmFjZWAubWFwIHsgfGl8ICcgIGZyb20gJyArIGkgfX0uam9pbihcIlxcblwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhY2t0cmFjZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgIyB1c2luZyBzZWxmLm1lc3NhZ2UgYWthIEBtZXNzYWdlIHRvIHJldGFpbiBjb21wYXRpYmlsaXR5IHdpdGggbmF0aXZlIGV4Y2VwdGlvbidzIG1lc3NhZ2UgcHJvcGVydHlcbiAgICAoQG1lc3NhZ2UgJiYgQG1lc3NhZ2UudG9fcykgfHwgc2VsZi5jbGFzcy50b19zXG4gIGVuZFxuZW5kXG5cbiMga2VlcCB0aGUgaW5kZW50YXRpb24sIGl0IG1ha2VzIHRoZSBleGNlcHRpb24gaGllcmFyY2h5IGNsZWFyXG5jbGFzcyA6OlNjcmlwdEVycm9yICAgICAgIDwgOjpFeGNlcHRpb247IGVuZFxuY2xhc3MgOjpTeW50YXhFcnJvciAgICAgICAgIDwgOjpTY3JpcHRFcnJvcjsgZW5kXG5jbGFzcyA6OkxvYWRFcnJvciAgICAgICAgICAgPCA6OlNjcmlwdEVycm9yOyBlbmRcbmNsYXNzIDo6Tm90SW1wbGVtZW50ZWRFcnJvciA8IDo6U2NyaXB0RXJyb3I7IGVuZFxuXG5jbGFzcyA6OlN5c3RlbUV4aXQgICAgICAgIDwgOjpFeGNlcHRpb247IGVuZFxuY2xhc3MgOjpOb01lbW9yeUVycm9yICAgICA8IDo6RXhjZXB0aW9uOyBlbmRcbmNsYXNzIDo6U2lnbmFsRXhjZXB0aW9uICAgPCA6OkV4Y2VwdGlvbjsgZW5kXG5jbGFzcyA6OkludGVycnVwdCAgICAgICAgICAgPCA6OlNpZ25hbEV4Y2VwdGlvbjsgZW5kXG5jbGFzcyA6OlNlY3VyaXR5RXJyb3IgICAgIDwgOjpFeGNlcHRpb247IGVuZFxuY2xhc3MgOjpTeXN0ZW1TdGFja0Vycm9yICA8IDo6RXhjZXB0aW9uOyBlbmRcblxuY2xhc3MgOjpTdGFuZGFyZEVycm9yICAgICA8IDo6RXhjZXB0aW9uOyBlbmRcbmNsYXNzIDo6RW5jb2RpbmdFcnJvciAgICAgICA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyA6Olplcm9EaXZpc2lvbkVycm9yICAgPCA6OlN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgOjpOYW1lRXJyb3IgICAgICAgICAgIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIDo6Tm9NZXRob2RFcnJvciAgICAgICAgIDwgOjpOYW1lRXJyb3I7IGVuZFxuY2xhc3MgOjpSdW50aW1lRXJyb3IgICAgICAgIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIDo6RnJvemVuRXJyb3IgICAgICAgICAgIDwgOjpSdW50aW1lRXJyb3I7IGVuZFxuY2xhc3MgOjpMb2NhbEp1bXBFcnJvciAgICAgIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIDo6VHlwZUVycm9yICAgICAgICAgICA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyA6OkFyZ3VtZW50RXJyb3IgICAgICAgPCA6OlN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgOjpVbmNhdWdodFRocm93RXJyb3IgICAgPCA6OkFyZ3VtZW50RXJyb3I7IGVuZFxuY2xhc3MgOjpJbmRleEVycm9yICAgICAgICAgIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIDo6U3RvcEl0ZXJhdGlvbiAgICAgICAgIDwgOjpJbmRleEVycm9yOyBlbmRcbmNsYXNzIDo6Q2xvc2VkUXVldWVFcnJvciAgICAgICAgPCA6OlN0b3BJdGVyYXRpb247IGVuZFxuY2xhc3MgOjpLZXlFcnJvciAgICAgICAgICAgICAgPCA6OkluZGV4RXJyb3I7IGVuZFxuY2xhc3MgOjpSYW5nZUVycm9yICAgICAgICAgIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIDo6RmxvYXREb21haW5FcnJvciAgICAgIDwgOjpSYW5nZUVycm9yOyBlbmRcbmNsYXNzIDo6SU9FcnJvciAgICAgICAgICAgICA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyA6OkVPRkVycm9yICAgICAgICAgICAgICA8IDo6SU9FcnJvcjsgZW5kXG5jbGFzcyA6OlN5c3RlbUNhbGxFcnJvciAgICAgPCA6OlN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgOjpSZWdleHBFcnJvciAgICAgICAgIDwgOjpTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIDo6VGhyZWFkRXJyb3IgICAgICAgICA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyA6OkZpYmVyRXJyb3IgICAgICAgICAgPCA6OlN0YW5kYXJkRXJyb3I7IGVuZFxuXG46Ok9iamVjdC5hdXRvbG9hZCA6RXJybm8sICdjb3JlbGliL2Vycm9yL2Vycm5vJ1xuXG5jbGFzcyA6OkZyb3plbkVycm9yIDwgOjpSdW50aW1lRXJyb3JcbiAgYXR0cl9yZWFkZXIgOnJlY2VpdmVyXG5cbiAgZGVmIGluaXRpYWxpemUobWVzc2FnZSwgcmVjZWl2ZXI6IG5pbClcbiAgICBzdXBlciBtZXNzYWdlXG4gICAgQHJlY2VpdmVyID0gcmVjZWl2ZXJcbiAgZW5kXG5lbmRcblxuY2xhc3MgOjpVbmNhdWdodFRocm93RXJyb3IgPCA6OkFyZ3VtZW50RXJyb3JcbiAgYXR0cl9yZWFkZXIgOnRhZywgOnZhbHVlXG5cbiAgZGVmIGluaXRpYWxpemUodGFnLCB2YWx1ZSA9IG5pbClcbiAgICBAdGFnID0gdGFnXG4gICAgQHZhbHVlID0gdmFsdWVcblxuICAgIHN1cGVyKFwidW5jYXVnaHQgdGhyb3cgI3tAdGFnLmluc3BlY3R9XCIpXG4gIGVuZFxuZW5kXG5cbmNsYXNzIDo6TmFtZUVycm9yXG4gIGF0dHJfcmVhZGVyIDpuYW1lXG5cbiAgZGVmIGluaXRpYWxpemUobWVzc2FnZSwgbmFtZSA9IG5pbClcbiAgICBzdXBlciBtZXNzYWdlXG4gICAgQG5hbWUgPSBuYW1lXG4gIGVuZFxuZW5kXG5cbmNsYXNzIDo6Tm9NZXRob2RFcnJvclxuICBhdHRyX3JlYWRlciA6YXJnc1xuXG4gIGRlZiBpbml0aWFsaXplKG1lc3NhZ2UsIG5hbWUgPSBuaWwsIGFyZ3MgPSBbXSlcbiAgICBzdXBlciBtZXNzYWdlLCBuYW1lXG4gICAgQGFyZ3MgPSBhcmdzXG4gIGVuZFxuZW5kXG5cbmNsYXNzIDo6U3RvcEl0ZXJhdGlvblxuICBhdHRyX3JlYWRlciA6cmVzdWx0XG5lbmRcblxuY2xhc3MgOjpLZXlFcnJvclxuICBkZWYgaW5pdGlhbGl6ZShtZXNzYWdlLCByZWNlaXZlcjogbmlsLCBrZXk6IG5pbClcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEByZWNlaXZlciA9IHJlY2VpdmVyXG4gICAgQGtleSA9IGtleVxuICBlbmRcblxuICBkZWYgcmVjZWl2ZXJcbiAgICBAcmVjZWl2ZXIgfHwgOjpLZXJuZWwucmFpc2UoOjpBcmd1bWVudEVycm9yLCAnbm8gcmVjZWl2ZXIgaXMgYXZhaWxhYmxlJylcbiAgZW5kXG5cbiAgZGVmIGtleVxuICAgIEBrZXkgfHwgOjpLZXJuZWwucmFpc2UoOjpBcmd1bWVudEVycm9yLCAnbm8ga2V5IGlzIGF2YWlsYWJsZScpXG4gIGVuZFxuZW5kXG5cbmNsYXNzIDo6TG9jYWxKdW1wRXJyb3JcbiAgYXR0cl9yZWFkZXIgOmV4aXRfdmFsdWUsIDpyZWFzb25cblxuICBkZWYgaW5pdGlhbGl6ZShtZXNzYWdlLCBleGl0X3ZhbHVlID0gbmlsLCByZWFzb24gPSA6bm9yZWFzb24pXG4gICAgc3VwZXIgbWVzc2FnZVxuICAgIEBleGl0X3ZhbHVlID0gZXhpdF92YWx1ZVxuICAgIEByZWFzb24gPSByZWFzb25cbiAgZW5kXG5lbmRcblxubW9kdWxlIDo6SlNcbiAgY2xhc3MgRXJyb3JcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOkV4Y2VwdGlvbj4iLCJuZXciLCJzZWxmIiwiJCEiLCJleGNlcHRpb24iLCJhcmdzIiwiaW5pdGlhbGl6ZSIsImNvcHlfaW5zdGFuY2VfdmFyaWFibGVzIiwib3RoZXIiLCJiYWNrdHJhY2UiLCJiYWNrdHJhY2VfbG9jYXRpb25zIiwiYmxvY2sgaW4gYmFja3RyYWNlX2xvY2F0aW9ucyIsImxvYyIsImJsb2NrICgyIGxldmVscykgaW4gYmFja3RyYWNlX2xvY2F0aW9ucyIsIlRocmVhZDo6QmFja3RyYWNlOjpMb2NhdGlvbiIsIlRocmVhZDo6QmFja3RyYWNlIiwiVGhyZWFkIiwiY2F1c2UiLCJzdHIiLCJjbG9uZSIsIm1lc3NhZ2UiLCJ0b19zIiwiZnVsbF9tZXNzYWdlIiwia3dhcmdzIiwiQG1lc3NhZ2UiLCIkc3RkZXJyIiwidHR5PyIsIm1lcmdlIiwiJHJldF9vcl8xIiwiW10iLCJoaWdobGlnaHQiLCJvcmRlciIsImluY2x1ZGU/IiwiS2VybmVsIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwiYm9sZF91bmRlcmxpbmUiLCJib2xkIiwicmVzZXQiLCJidCIsImR1cCIsImVtcHR5PyIsImNhbGxlciIsImZpcnN0Iiwic2hpZnQiLCJtc2ciLCIrIiwiY2xhc3MiLCJtYXAiLCJibG9jayBpbiBmdWxsX21lc3NhZ2UiLCJibG9jayAoMiBsZXZlbHMpIGluIGZ1bGxfbWVzc2FnZSIsImpvaW4iLCJzcGxpdCIsInJldmVyc2UiLCJpbnNwZWN0IiwiYXNfc3RyIiwic2V0X2JhY2t0cmFjZSIsIlR5cGVFcnJvciIsImJsb2NrIGluIHNldF9iYWNrdHJhY2UiLCJpIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzZXRfYmFja3RyYWNlIiwiJHJldF9vcl8yIiwiPGNsYXNzOlNjcmlwdEVycm9yPiIsIkV4Y2VwdGlvbiIsIjxjbGFzczpTeW50YXhFcnJvcj4iLCJTY3JpcHRFcnJvciIsIjxjbGFzczpMb2FkRXJyb3I+IiwiPGNsYXNzOk5vdEltcGxlbWVudGVkRXJyb3I+IiwiPGNsYXNzOlN5c3RlbUV4aXQ+IiwiPGNsYXNzOk5vTWVtb3J5RXJyb3I+IiwiPGNsYXNzOlNpZ25hbEV4Y2VwdGlvbj4iLCI8Y2xhc3M6SW50ZXJydXB0PiIsIlNpZ25hbEV4Y2VwdGlvbiIsIjxjbGFzczpTZWN1cml0eUVycm9yPiIsIjxjbGFzczpTeXN0ZW1TdGFja0Vycm9yPiIsIjxjbGFzczpTdGFuZGFyZEVycm9yPiIsIjxjbGFzczpFbmNvZGluZ0Vycm9yPiIsIlN0YW5kYXJkRXJyb3IiLCI8Y2xhc3M6WmVyb0RpdmlzaW9uRXJyb3I+IiwiPGNsYXNzOk5hbWVFcnJvcj4iLCI8Y2xhc3M6Tm9NZXRob2RFcnJvcj4iLCJOYW1lRXJyb3IiLCI8Y2xhc3M6UnVudGltZUVycm9yPiIsIjxjbGFzczpGcm96ZW5FcnJvcj4iLCJSdW50aW1lRXJyb3IiLCI8Y2xhc3M6TG9jYWxKdW1wRXJyb3I+IiwiPGNsYXNzOlR5cGVFcnJvcj4iLCI8Y2xhc3M6QXJndW1lbnRFcnJvcj4iLCI8Y2xhc3M6VW5jYXVnaHRUaHJvd0Vycm9yPiIsIjxjbGFzczpJbmRleEVycm9yPiIsIjxjbGFzczpTdG9wSXRlcmF0aW9uPiIsIkluZGV4RXJyb3IiLCI8Y2xhc3M6Q2xvc2VkUXVldWVFcnJvcj4iLCJTdG9wSXRlcmF0aW9uIiwiPGNsYXNzOktleUVycm9yPiIsIjxjbGFzczpSYW5nZUVycm9yPiIsIjxjbGFzczpGbG9hdERvbWFpbkVycm9yPiIsIlJhbmdlRXJyb3IiLCI8Y2xhc3M6SU9FcnJvcj4iLCI8Y2xhc3M6RU9GRXJyb3I+IiwiSU9FcnJvciIsIjxjbGFzczpTeXN0ZW1DYWxsRXJyb3I+IiwiPGNsYXNzOlJlZ2V4cEVycm9yPiIsIjxjbGFzczpUaHJlYWRFcnJvcj4iLCI8Y2xhc3M6RmliZXJFcnJvcj4iLCJPYmplY3QiLCJhdXRvbG9hZCIsImF0dHJfcmVhZGVyIiwiJGt3YXJncyIsIkByZWNlaXZlciIsInJlY2VpdmVyIiwidGFnIiwidmFsdWUiLCJAdGFnIiwiQHZhbHVlIiwibmFtZSIsIkBuYW1lIiwiQGFyZ3MiLCJAa2V5Iiwia2V5IiwiZXhpdF92YWx1ZSIsInJlYXNvbiIsIkBleGl0X3ZhbHVlIiwiQHJlYXNvbiIsIjxtb2R1bGU6SlM+IiwiPGNsYXNzOkVycm9yPiJdLCJtYXBw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QUFBQSxJQUFBQTtFQURGRCxHQUFPLElBQVBBO0FBeFVBN0g7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjY0NTgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2NvbnN0YW50cy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyI6OlJVQllfUExBVEZPUk0gICAgICAgPSAnb3BhbCdcbjo6UlVCWV9FTkdJTkUgICAgICAgICA9ICdvcGFsJ1xuOjpSVUJZX1ZFUlNJT04gICAgICAgID0gJzMuMi4wJ1xuOjpSVUJZX0VOR0lORV9WRVJTSU9OID0gJzEuOC4yJ1xuOjpSVUJZX1JFTEVBU0VfREFURSAgID0gJzIwMjMtMTEtMjMnXG46OlJVQllfUEFUQ0hMRVZFTCAgICAgPSAwXG46OlJVQllfUkVWSVNJT04gICAgICAgPSAnMCdcbjo6UlVCWV9DT1BZUklHSFQgICAgICA9ICdvcGFsIC0gQ29weXJpZ2h0IChDKSAyMDExLTIwMjMgQWRhbSBCZXlub24gYW5kIHRoZSBPcGFsIGNvbnRyaWJ1dG9ycydcbjo6UlVCWV9ERVNDUklQVElPTiAgICA9IFwib3BhbCAjezo6UlVCWV9FTkdJTkVfVkVSU0lPTn0gKCN7OjpSVUJZX1JFTEVBU0VfREFURX0gcmV2aXNpb24gI3s6OlJVQllfUkVWSVNJT059KVwiXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjAiLCJSVUJZX0VOR0lORV9WRVJTSU9OIiwiUlVCWV9SRUxFQVNFX0RBVEUiLCJSVUJZX1JFVklTSU9OIl0sIm1hcHBpbmdzIjoiQUFBQUEsb0NBQUFBLGdCQUFBQTtFQUFBQTs7O0VBQUEsV0FBQSxJQUFBLG1CQUF3QkEsTUFBeEI7RUFDQSxXQUFBLElBQUEsaUJBQXdCQSxNQUF4QjtFQUNBLFdBQUEsSUFBQSxrQkFBd0JBLE9BQXhCO0VBQ0EsV0FBQSxJQUFBLHlCQUF3QkEsT0FBeEI7RUFDQSxXQUFBLElBQUEsdUJBQXdCQSxZQUF4QjtFQUNBLFdBQUEsSUFBQSxxQkFBd0JDLENBQXhCO0VBQ0EsV0FBQSxJQUFBLG1CQUF3QkQsR0FBeEI7RUFDQSxXQUFBLElBQUEsb0JBQXdCQSxzRUFBeEI7RUFDQUEsT0FBQSxXQUFBLElBQUEsc0JBQXlCQSxPQUFELEdBQUEsQ0FBUUUsMEJBQVIsQ0FBQSxHQUE4QkYsSUFBOUIsR0FBQSxDQUFrQ0csd0JBQWxDLENBQUEsR0FBc0RILFlBQXRELEdBQUEsQ0FBa0VJLG9CQUFsRSxDQUFBLEdBQWtGSixHQUExRztBQVJBQTsifX0seyJvZmZzZXQiOnsibGluZSI6NjQ3MywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm9wYWwvYmFzZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyI6Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3J1bnRpbWUnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2hlbHBlcnMnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL21vZHVsZSdcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvY2xhc3MnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2Jhc2ljX29iamVjdCdcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIva2VybmVsJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9tYWluJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9lcnJvcidcblxuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9jb25zdGFudHMnXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIk9iamVjdCIsInJlcXVpcmUiXSwibWFwcGluZ3MiOiJBQUFBQSw0QkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsT0FBUUMsU0FBQUEsQ0FBU0YsaUJBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGlCQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixnQkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsZUFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0Ysc0JBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGdCQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixjQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixlQUFURTtFQUVSRixPQUFBQyxPQUFRQyxTQUFBQSxDQUFTRixtQkFBVEU7QUFUUkY7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjY0ODksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL25pbC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcblxuY2xhc3MgOjpOaWxDbGFzc1xuICBgc2VsZi4kJHByb3RvdHlwZS4kJG1ldGEgPSAje3NlbGZ9YFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgYWxsb2NhdGVcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImFsbG9jYXRvciB1bmRlZmluZWQgZm9yICN7bmFtZX1cIlxuICAgIGVuZFxuXG4gICAgdW5kZWYgOm5ld1xuICBlbmRcblxuICBkZWYgIVxuICAgIHRydWVcbiAgZW5kXG5cbiAgZGVmICYob3RoZXIpXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIHwob3RoZXIpXG4gICAgYG90aGVyICE9PSBmYWxzZSAmJiBvdGhlciAhPT0gbmlsYFxuICBlbmRcblxuICBkZWYgXihvdGhlcilcbiAgICBgb3RoZXIgIT09IGZhbHNlICYmIG90aGVyICE9PSBuaWxgXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBgb3RoZXIgPT09IG5pbGBcbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgY2xvbmUoZnJlZXplOiB0cnVlKVxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgICduaWwnXG4gIGVuZFxuXG4gIGRlZiBuaWw/XG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgc2luZ2xldG9uX2NsYXNzXG4gICAgOjpOaWxDbGFzc1xuICBlbmRcblxuICBkZWYgdG9fYVxuICAgIFtdXG4gIGVuZFxuXG4gIGRlZiB0b19oXG4gICAgYG5ldyBNYXAoKWBcbiAgZW5kXG5cbiAgZGVmIHRvX2lcbiAgICAwXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgJydcbiAgZW5kXG5cbiAgZGVmIHRvX2NcbiAgICA6OkNvbXBsZXgubmV3KDAsIDApXG4gIGVuZFxuXG4gIGRlZiByYXRpb25hbGl6ZSgqYXJncylcbiAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IgaWYgYXJncy5sZW5ndGggPiAxXG4gICAgOjpLZXJuZWwuUmF0aW9uYWwoMCwgMSlcbiAgZW5kXG5cbiAgZGVmIHRvX3JcbiAgICA6Oktlcm5lbC5SYXRpb25hbCgwLCAxKVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVzXG4gICAgW11cbiAgZW5kXG5cbiAgYWxpYXMgdG9fZiB0b19pXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOk5pbENsYXNzPiIsInNlbGYiLCJhbGxvY2F0ZSIsIktlcm5lbCIsInJhaXNlIiwiVHlwZUVycm9yIiwibmFtZSIsIiEiLCImIiwifCIsIm90aGVyIiwiXiIsIj09IiwiZHVwIiwiY2xvbmUiLCIka3dhcmdzIiwiaW5zcGVjdCIsIm5pbD8iLCJzaW5nbGV0b25fY2xhc3MiLCJOaWxDbGFzcyIsInRvX2EiLCJ0b19oIiwidG9faSIsIjAiLCJ0b19zIiwidG9fYyIsIkNvbXBsZXgiLCJuZXciLCJyYXRpb25hbGl6ZSIsIj4iLCJhcmdzIiwibGVuZ3RoIiwiMSIsIkFyZ3VtZW50RXJyb3IiLCJSYXRpb25hbCIsInRvX3IiLCJpbnN0YW5jZV92YXJpYWJsZXMiXSwibWFwcGluZ3MiOiJBQUFBQSw4QkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUVBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNHQSwwQkFBNEJDO0lBRTdCOzs7O0FBQ0VDLE1BQUFBLHdCQUFBQSxvQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUFDLE9BQVFDLE9BQUFBLENBQU9DLGdCQUFmLEVBQTZCSCwwQkFBRCxHQUFBLENBQTJCRCxJQUFBSyxNQUFBQSxDQUFBQSxDQUEzQixDQUFwQkY7TUFEVkYsQ0FBQUE7OztNQUlBLHNCQUFNLEtBQU47TUFWSixPQUFBO0lBS0UsNEJBQVNELElBQVQ7O0FBUUFNLElBQUFBLGlCQUFBQSxZQUNFLElBREZBLENBQUFBOztBQUlBQyxJQUFBQSxpQkFBQUEsWUFDRSxLQURGQSxDQUFBQTs7QUFJQUMsSUFBQUEsaUJBQUFBLHVCQUFNQyxLQUFORDtBQUFBQTtNQUNFQSxPQUFDQSxnQ0FBREE7SUFERkEsQ0FBQUE7O0FBSUFFLElBQUFBLGlCQUFBQSx1QkFBTUQsS0FBTkM7QUFBQUE7TUFDRUEsT0FBQ0EsZ0NBQURBO0lBREZBLENBQUFBOztBQUlBQyxJQUFBQSxrQkFBQUEsNEJBQU9GLEtBQVBFO0FBQUFBO01BQ0VBLE9BQUNBLGFBQURBO0lBREZBLENBQUFBOztBQUlBQyxJQUFBQSxtQkFBQUEsWUFDRSxHQURGQSxDQUFBQTs7QUFJQUMsSUFBQUEscUJBQUFBLGlCQXJDRkMsT0FxQ0VEO0FBQUFBLE1BQUFBOzs7TUFyQ0Y7O01BcUNZLHNDQUFBLDZCQUFRO01BQ2hCQSxPQUFBO0lBREZBLENBQUFBLElBQUFBOztBQUlBRSxJQUFBQSx1QkFBQUEsWUFDRWhCLEtBREZnQixDQUFBQTs7QUFJQUMsSUFBQUEsb0JBQUFBLFlBQ0UsSUFERkEsQ0FBQUE7O0FBSUFDLElBQUFBLCtCQUFBQSwyQkFBQUE7QUFBQUE7TUFDRUEsT0FBQUM7SUFERkQsQ0FBQUE7O0FBSUFFLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUE7TUFDRUEsT0FBQTtJQURGQSxDQUFBQTs7QUFJQUMsSUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQTtNQUNFQSxPQUFDQSxTQUFEQTtJQURGQSxDQUFBQTs7QUFJQUMsSUFBQUEsb0JBQUFBLFlBQ0VDLENBREZELENBQUFBOztBQUlBRSxJQUFBQSxvQkFBQUEsWUFDRXhCLEVBREZ3QixDQUFBQTs7QUFJQUMsSUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQTtNQUNFQSxPQUFBQyxjQUFTQyxLQUFBQSxDQUFLSixDQUFkLEVBQWlCQSxDQUFSSTtJQURYRixDQUFBQTs7QUFJQUcsSUFBQUEsMkJBQUFBLHVCQXpFRixFQXlFRUE7QUFBQUEsTUFBQUE7OztNQXpFRjtNQXlFa0I7TUFDZCxJQUFBLFFBQThDQyxPQUFaQyxJQUFJQyxRQUFBQSxDQUFBQSxDQUFRRixFQUFFRyxDQUFGSCxDQUE5QyxDQUFBO1FBQUExQixPQUFRQyxPQUFBQSxDQUFPNkIsb0JBQVA3QjtNQUFSO01BQ0F3QixPQUFBekIsT0FBUStCLFVBQUFBLENBQVVYLENBQWxCLEVBQXFCUyxDQUFiRTtJQUZWTixDQUFBQSxJQUFBQTs7QUFLQU8sSUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQTtNQUNFQSxPQUFBaEMsT0FBUStCLFVBQUFBLENBQVVYLENBQWxCLEVBQXFCUyxDQUFiRTtJQURWQyxDQUFBQTs7QUFJQUMsSUFBQUEsa0NBQUFBLDhCQUFBQTtBQUFBQTtNQUNFQSxPQUFBO0lBREZBLENBQUFBO0lBSUFwQyxPQUFBLGFBQU0sTUFBTixFQUFXLE1BQVg7RUFwRkZBLEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7QUFGQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjY1OTksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2Jvb2xlYW4ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyB1c2Vfc3RyaWN0OiB0cnVlXG4jIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcblxuY2xhc3MgOjpCb29sZWFuIDwgYEJvb2xlYW5gXG4gIGBPcGFsLnByb3Aoc2VsZi4kJHByb3RvdHlwZSwgJyQkaXNfYm9vbGVhbicsIHRydWUpYFxuXG4gICV4e1xuICAgIHZhciBwcm9wZXJ0aWVzID0gWyckJGNsYXNzJywgJyQkbWV0YSddO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi4kJHByb3RvdHlwZSwgcHJvcGVydGllc1tpXSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzID09IHRydWUgID8gT3BhbC5UcnVlQ2xhc3MgOlxuICAgICAgICAgICAgICAgICB0aGlzID09IGZhbHNlID8gT3BhbC5GYWxzZUNsYXNzIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9wYWwuQm9vbGVhbjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuJCRwcm90b3R5cGUsIFwiJCRpZFwiLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IHRydWUgID8gMiA6XG4gICAgICAgICAgICAgICB0aGlzID09IGZhbHNlID8gMCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmlsO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhbGxvY2F0ZVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiYWxsb2NhdG9yIHVuZGVmaW5lZCBmb3IgI3tuYW1lfVwiXG4gICAgZW5kXG5cbiAgICB1bmRlZiA6bmV3XG4gIGVuZFxuXG4gIGRlZiBfX2lkX19cbiAgICBgc2VsZi52YWx1ZU9mKCkgPyAyIDogMGBcbiAgZW5kXG5cbiAgZGVmICFcbiAgICBgc2VsZiAhPSB0cnVlYFxuICBlbmRcblxuICBkZWYgJihvdGhlcilcbiAgICBgKHNlbGYgPT0gdHJ1ZSkgPyAob3RoZXIgIT09IGZhbHNlICYmIG90aGVyICE9PSBuaWwpIDogZmFsc2VgXG4gIGVuZFxuXG4gIGRlZiB8KG90aGVyKVxuICAgIGAoc2VsZiA9PSB0cnVlKSA/IHRydWUgOiAob3RoZXIgIT09IGZhbHNlICYmIG90aGVyICE9PSBuaWwpYFxuICBlbmRcblxuICBkZWYgXihvdGhlcilcbiAgICBgKHNlbGYgPT0gdHJ1ZSkgPyAob3RoZXIgPT09IGZhbHNlIHx8IG90aGVyID09PSBuaWwpIDogKG90aGVyICE9PSBmYWxzZSAmJiBvdGhlciAhPT0gbmlsKWBcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIGAoc2VsZiA9PSB0cnVlKSA9PT0gb3RoZXIudmFsdWVPZigpYFxuICBlbmRcblxuICBkZWYgc2luZ2xldG9uX2NsYXNzXG4gICAgYHNlbGYuJCRtZXRhYFxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIGAoc2VsZiA9PSB0cnVlKSA/ICd0cnVlJyA6ICdmYWxzZSdgXG4gIGVuZFxuXG4gIGRlZiBkdXBcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjbG9uZShmcmVlemU6IHRydWUpXG4gICAgc2VsZlxuICBlbmRcblxuICAjIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL29wYWwvb3BhbC9pc3N1ZXMvMjIzMFxuICAjXG4gICMgVGhpcyBpcyBhIGhhY2sgdGhhdCBhbGxvd3MgeW91IHRvIGFkZCBtZXRob2RzIHRvIFRydWVDbGFzcyBhbmQgRmFsc2VDbGFzcy5cbiAgIyBEbyBub3RlLCB0aGF0IHdoaWxlIHRydWUgYW5kIGZhbHNlIGhhdmUgYSBjb3JyZWN0ICQkY2xhc3MgKGl0J3MgZWl0aGVyXG4gICMgVHJ1ZUNsYXNzIG9yIEZhbHNlQ2xhc3MpLCB0aGVpciBwcm90b3R5cGUgaXMgYEJvb2xlYW4uJCRwcm90b3R5cGVgLCB3aGljaFxuICAjIGJhc2ljYWxseSBtZWFucyB0aGF0IHdoZW4gY2FsbGluZyBgdHJ1ZS5zb21ldGhpbmdgIHdlIGFjdHVhbGx5IGNhbGxcbiAgIyBgQm9vbGVhbiNzb21ldGhpbmdgIGluc3RlYWQgb2YgYFRydWVDbGFzcyNzb21ldGhpbmdgLiBTbyB1c2luZ1xuICAjIG1ldGhvZF9taXNzaW5nIHdlIGRpc3BhdGNoIGl0IHRvIGBUcnVlQ2xhc3MvRmFsc2VDbGFzcyNzb21ldGhpbmdgIGNvcnJlY3RseS5cbiAgI1xuICAjIFRoZSBkb3duc2lkZSBpcyB0aGF0IGEgY29ycmVjdCBpbXBsZW1lbnRhdGlvbiB3b3VsZCBhbHNvIGFsbG93IHVzIHRvIG92ZXJyaWRlXG4gICMgdGhlIG1ldGhvZHMgZGVmaW5lZCBvbiBCb29sZWFuLCBidXQgb3VyIGltcGxlbWVudGF0aW9uIGRvZXNuJ3QgYWxsb3cgdGhhdCxcbiAgIyB1bmxlc3MgeW91IGRlZmluZSB0aGVtIG9uIEJvb2xlYW4gYW5kIG5vdCBvbiBUcnVlQ2xhc3MvRmFsc2VDbGFzcy5cbiAgZGVmIG1ldGhvZF9taXNzaW5nKG1ldGhvZCwgKmFyZ3MsICZibG9jaylcbiAgICBgdmFyIGJvZHkgPSBzZWxmLiQkY2xhc3MuJCRwcm90b3R5cGVbT3BhbC5qc2lkKCN7bWV0aG9kfSldYFxuICAgIHN1cGVyIHVubGVzcyBgdHlwZW9mIGJvZHkgIT09ICd1bmRlZmluZWQnICYmICFib2R5LiQkc3R1YmBcbiAgICBgT3BhbC5zZW5kKHNlbGYsIGJvZHksICN7YXJnc30sICN7YmxvY2t9KWBcbiAgZW5kXG5cbiAgZGVmIHJlc3BvbmRfdG9fbWlzc2luZz8obWV0aG9kLCBfaW5jbHVkZV9hbGwgPSBmYWxzZSlcbiAgICBgdmFyIGJvZHkgPSBzZWxmLiQkY2xhc3MuJCRwcm90b3R5cGVbT3BhbC5qc2lkKCN7bWV0aG9kfSldYFxuICAgIGB0eXBlb2YgYm9keSAhPT0gJ3VuZGVmaW5lZCcgJiYgIWJvZHkuJCRzdHViYFxuICBlbmRcblxuICBhbGlhcyBlcWw/ID09XG4gIGFsaWFzIGVxdWFsPyA9PVxuICBhbGlhcyBpbnNwZWN0IHRvX3NcbiAgYWxpYXMgb2JqZWN0X2lkIF9faWRfX1xuZW5kXG5cbmNsYXNzIDo6VHJ1ZUNsYXNzIDwgOjpCb29sZWFuOyBlbmRcbmNsYXNzIDo6RmFsc2VDbGFzcyA8IDo6Qm9vbGVhbjsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpCb29sZWFuPiIsImFsbG9jYXRlIiwiS2VybmVsIiwicmFpc2UiLCJUeXBlRXJyb3IiLCJzZWxmIiwibmFtZSIsIl9faWRfXyIsIiEiLCImIiwib3RoZXIiLCJ8IiwiXiIsIj09Iiwic2luZ2xldG9uX2NsYXNzIiwidG9fcyIsImR1cCIsImNsb25lIiwiJGt3YXJncyIsIm1ldGhvZF9taXNzaW5nIiwibWV0aG9kIiwiYXJncyIsImJsb2NrIiwicmVzcG9uZF90b19taXNzaW5nPyIsIl9pbmNsdWRlX2FsbCIsIjxjbGFzczpUcnVlQ2xhc3M+IiwiQm9vbGVhbiIsIjxjbGFzczpGYWxzZUNsYXNzPiJdLCJtYXBwaW5ncyI6IkFBQUFBLGtDQUFBQSxnQkFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBOztFQUdBQztFQUFBQTs7SUFBQUE7OztJQUNHQTs7QUFHSEE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtJQUVFOzs7O0FBQ0VDLE1BQUFBLHdCQUFBQSxvQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUFDLE9BQVFDLE9BQUFBLENBQU9DLGdCQUFmLEVBQTZCSCwwQkFBRCxHQUFBLENBQTJCSSxJQUFBQyxNQUFBQSxDQUFBQSxDQUEzQixDQUFwQkg7TUFEVkYsQ0FBQUE7OztNQUlBLHNCQUFNLEtBQU47TUFyQ0osT0FBQTtJQWdDRSw0QkFBU0ksSUFBVDs7QUFRQUUsSUFBQUEsc0JBQUFBLGtCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0Esc0JBQURBO0lBREZBLENBQUFBOztBQUlBQyxJQUFBQSxpQkFBQUEsMEJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSxZQUFEQTtJQURGQSxDQUFBQTs7QUFJQUMsSUFBQUEsaUJBQUFBLHNCQUFNQyxLQUFORDtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0EsMkRBQURBO0lBREZBLENBQUFBOztBQUlBRSxJQUFBQSxpQkFBQUEsc0JBQU1ELEtBQU5DO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSwwREFBREE7SUFERkEsQ0FBQUE7O0FBSUFDLElBQUFBLGlCQUFBQSxzQkFBTUYsS0FBTkU7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUNBLHdGQUFEQTtJQURGQSxDQUFBQTs7QUFJQUMsSUFBQUEsa0JBQUFBLDJCQUFPSCxLQUFQRztBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0Esa0NBQURBO0lBREZBLENBQUFBOztBQUlBQyxJQUFBQSwrQkFBQUEsMkJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSxXQUFEQTtJQURGQSxDQUFBQTs7QUFJQUMsSUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0EsaUNBQURBO0lBREZBLENBQUFBOztBQUlBQyxJQUFBQSxtQkFBQUEsWUFBQUE7O0FBSUFDLElBQUFBLHFCQUFBQSxpQkE1RUZDLE9BNEVFRDtBQUFBQSxNQUFBQTs7O01BNUVGOztNQTRFWSxzQ0FBQSw2QkFBUTtNQUNoQkEsT0FBQVo7SUFERlksQ0FBQUEsSUFBQUE7O0FBZ0JBRSxJQUFBQSw4QkFBQUEsMEJBQW1CQyxNQUFELEVBNUZwQixFQTRGRUQ7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUE1RkY7TUE0RjZCO01BQ3hCQSw4Q0FBZ0RDLE1BQU9EO01BQ3hELEtBQUEsUUFBY0EsMkNBQWQsQ0FBQTtRQUFBLE9BQUFkLElBQUEsRUFBQSxrRUFBQSxrQkFBQSxFQUFBLENBQUFlLE1BQUEsQ0FBQSxRQUFBLE1BQUFDLElBQUEsQ0FBQSxDQUFBLEVBQUEsS0FBQTtNQUFBO01BQ0FGLE9BQUNBLHNCQUF3QkUsSUFBS0YsRUFBSUcsS0FBTUg7SUFIMUNBLENBQUFBLElBQUFBOztBQU1BSSxJQUFBQSxtQ0FBQUEsNENBQXdCSCxNQUFELEVBQVNJLFlBQWhDRDtBQUFBQSxNQUFBQTs7O01BQWdDLHlDQUFlO01BQzVDQSw4Q0FBZ0RILE1BQU9HO01BQ3hEQSxPQUFDQSwyQ0FBREE7SUFGRkEsQ0FBQUEsSUFBQUE7SUFLQSxhQUFNLE1BQU4sRUFBVyxJQUFYO0lBQ0EsYUFBTSxRQUFOLEVBQWEsSUFBYjtJQUNBLGFBQU0sU0FBTixFQUFjLE1BQWQ7SUFDQXZCLE9BQUEsYUFBTSxXQUFOLEVBQWdCLFFBQWhCO0VBdkdGQSxHQUFNLElBQU5BLEVBQW1CRCxPQUFuQkM7RUEwR0F5QixPQUFNLElBQU5BLEVBQW9CQyxjQUFwQkQ7RUFDQTFCLE9BQUE0QixRQUFNLElBQU5BLEVBQXFCRCxjQUFyQkM7QUE5R0E1QjsifX0seyJvZmZzZXQiOnsibGluZSI6Njc0NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvY29tcGFyYWJsZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHRydXRoeVxuIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXG5cbm1vZHVsZSA6OkNvbXBhcmFibGVcbiAgJXh7XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplKHdoYXQpIHtcbiAgICAgIGlmIChPcGFsLmlzX2Eod2hhdCwgT3BhbC5JbnRlZ2VyKSkgeyByZXR1cm4gd2hhdDsgfVxuXG4gICAgICBpZiAoI3tgd2hhdGAgPiAwfSkgeyByZXR1cm4gMTsgfVxuICAgICAgaWYgKCN7YHdoYXRgIDwgMH0pIHsgcmV0dXJuIC0xOyB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmYWlsX2NvbXBhcmlzb24obGhzLCByaHMpIHtcbiAgICAgIHZhciBjbGFzc19uYW1lO1xuICAgICAgI3tcbiAgICAgICAgY2FzZSBgcmhzYFxuICAgICAgICB3aGVuIG5pbCwgdHJ1ZSwgZmFsc2UsIDo6SW50ZWdlciwgOjpGbG9hdFxuICAgICAgICAgIGBjbGFzc19uYW1lID0gcmhzLiRpbnNwZWN0KClgXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBgY2xhc3NfbmFtZSA9IHJocy4kJGNsYXNzYFxuICAgICAgICBlbmRcbiAgICAgIH1cbiAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tgbGhzYC5jbGFzc30gd2l0aCAje2BjbGFzc19uYW1lYH0gZmFpbGVkXCJ9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY21wX29yX2ZhaWwobGhzLCByaHMpIHtcbiAgICAgIHZhciBjbXAgPSAje2BsaHNgIDw9PiBgcmhzYH07XG4gICAgICBpZiAoISR0cnV0aHkoY21wKSkgZmFpbF9jb21wYXJpc29uKGxocywgcmhzKTtcbiAgICAgIHJldHVybiBub3JtYWxpemUoY21wKTtcbiAgICB9XG4gIH1cblxuICBkZWYgPT0ob3RoZXIpXG4gICAgcmV0dXJuIHRydWUgaWYgZXF1YWw/KG90aGVyKVxuXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZltcIiQ8PT5cIl0gPT0gT3BhbC5LZXJuZWxbXCIkPD0+XCJdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgZm9yIGluZmluaXRlIHJlY3Vyc2lvblxuICAgICAgaWYgKHNlbGYuJCRjb21wYXJhYmxlKSB7XG4gICAgICAgIHNlbGYuJCRjb21wYXJhYmxlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIGNtcCA9IChzZWxmIDw9PiBvdGhlcilcblxuICAgIGBub3JtYWxpemUoY21wKSA9PSAwYFxuICBlbmRcblxuICBkZWYgPihvdGhlcilcbiAgICBgY21wX29yX2ZhaWwoc2VsZiwgb3RoZXIpID4gMGBcbiAgZW5kXG5cbiAgZGVmID49KG90aGVyKVxuICAgIGBjbXBfb3JfZmFpbChzZWxmLCBvdGhlcikgPj0gMGBcbiAgZW5kXG5cbiAgZGVmIDwob3RoZXIpXG4gICAgYGNtcF9vcl9mYWlsKHNlbGYsIG90aGVyKSA8IDBgXG4gIGVuZFxuXG4gIGRlZiA8PShvdGhlcilcbiAgICBgY21wX29yX2ZhaWwoc2VsZiwgb3RoZXIpIDw9IDBgXG4gIGVuZFxuXG4gIGRlZiBiZXR3ZWVuPyhtaW4sIG1heClcbiAgICByZXR1cm4gZmFsc2UgaWYgc2VsZiA8IG1pblxuICAgIHJldHVybiBmYWxzZSBpZiBzZWxmID4gbWF4XG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgY2xhbXAobWluLCBtYXggPSBuaWwpXG4gICAgJXh7XG4gICAgICB2YXIgYywgZXhjbDtcblxuICAgICAgaWYgKG1heCA9PT0gbmlsKSB7XG4gICAgICAgIC8vIFdlIGFyZSBkZWFsaW5nIHdpdGggYSBuZXcgUnVieSAyLjcgYmVoYXZpb3VyIHRoYXQgd2UgYXJlIGFibGUgdG9cbiAgICAgICAgLy8gcHJvdmlkZSBhIHNpbmdsZSBSYW5nZSBhcmd1bWVudCBpbnN0ZWFkIG9mIDIgQ29tcGFyYWJsZXMuXG5cbiAgICAgICAgaWYgKCFPcGFsLmlzX2EobWluLCBPcGFsLlJhbmdlKSkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje21pbi5jbGFzc30gKGV4cGVjdGVkIFJhbmdlKVwifVxuICAgICAgICB9XG5cbiAgICAgICAgZXhjbCA9IG1pbi5leGNsO1xuICAgICAgICBtYXggPSBtaW4uZW5kO1xuICAgICAgICBtaW4gPSBtaW4uYmVnaW47XG5cbiAgICAgICAgaWYgKG1heCAhPT0gbmlsICYmIGV4Y2wpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2Nhbm5vdCBjbGFtcCB3aXRoIGFuIGV4Y2x1c2l2ZSByYW5nZSd9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1pbiAhPT0gbmlsICYmIG1heCAhPT0gbmlsICYmIGNtcF9vcl9mYWlsKG1pbiwgbWF4KSA+IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdtaW4gYXJndW1lbnQgbXVzdCBiZSBzbWFsbGVyIHRoYW4gbWF4IGFyZ3VtZW50J31cbiAgICAgIH1cblxuICAgICAgaWYgKG1pbiAhPT0gbmlsKSB7XG4gICAgICAgIGMgPSBjbXBfb3JfZmFpbChzZWxmLCBtaW4pO1xuXG4gICAgICAgIGlmIChjID09IDApIHJldHVybiBzZWxmO1xuICAgICAgICBpZiAoYyA8IDApIHJldHVybiBtaW47XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXggIT09IG5pbCkge1xuICAgICAgICBjID0gY21wX29yX2ZhaWwoc2VsZiwgbWF4KTtcblxuICAgICAgICBpZiAoYyA+IDApIHJldHVybiBtYXg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpDb21wYXJhYmxlPiIsIj4iLCIwIiwiPCIsIiRyZXRfb3JfMSIsIkludGVnZXIiLCJGbG9hdCIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsImNsYXNzIiwiPD0+IiwiPT0iLCJvdGhlciIsInNlbGYiLCJlcXVhbD8iLCJjbXAiLCI+PSIsIjw9IiwiYmV0d2Vlbj8iLCJtaW4iLCJtYXgiLCJjbGFtcCIsIlR5cGVFcnJvciJdLCJtYXBwaW5ncyI6IkFBQUFBLHFDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBR0FBLE9BQUFDO0VBQUFBOztJQUFBQTs7OztBQUVBQTtBQUNBQTs7QUFFQUEsVUFBbUJDLE9BQU5ELElBQU1DLEVBQUVDLENBQUZELENBQUlEO0FBQ3ZCQSxVQUFtQkcsT0FBTkgsSUFBTUcsRUFBRUQsQ0FBRkMsQ0FBSUg7QUFDdkJBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQSxNQUVRLENBakJSLENBQUEsUUFpQmEsR0FqQmIsRUFnQlFJLENBQUFBLFlBQU1K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RnRCLEdBQU8sSUFBUEE7QUFIQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjY4ODQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3JlZ2V4cC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IGNvZXJjZV90bywgcHJvcCwgZnJlZXplXG4jIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcblxuY2xhc3MgOjpSZWdleHBFcnJvciA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXG5cbmNsYXNzIDo6UmVnZXhwIDwgYFJlZ0V4cGBcbiAgc2VsZjo6SUdOT1JFQ0FTRSA9IDFcbiAgc2VsZjo6RVhURU5ERUQgPSAyXG4gIHNlbGY6Ok1VTFRJTElORSA9IDRcblxuICBgT3BhbC5wcm9wKHNlbGYuJCRwcm90b3R5cGUsICckJGlzX3JlZ2V4cCcsIHRydWUpYFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgYWxsb2NhdGVcbiAgICAgIGFsbG9jYXRlZCA9IHN1cGVyXG4gICAgICBgI3thbGxvY2F0ZWR9LnVuaW5pdGlhbGl6ZWQgPSB0cnVlYFxuICAgICAgYWxsb2NhdGVkXG4gICAgZW5kXG5cbiAgICBkZWYgZXNjYXBlKHN0cmluZylcbiAgICAgICV4e1xuICAgICAgICBzdHJpbmcgPSAkY29lcmNlX3RvKHN0cmluZywgI3s6OlN0cmluZ30sICd0b19zdHInKTtcbiAgICAgICAgcmV0dXJuIE9wYWwuZXNjYXBlX3JlZ2V4cChzdHJpbmcpO1xuICAgICAgfVxuICAgIGVuZFxuXG4gICAgZGVmIGxhc3RfbWF0Y2gobiA9IG5pbClcbiAgICAgIGlmIG4ubmlsP1xuICAgICAgICAkflxuICAgICAgZWxzaWYgJH5cbiAgICAgICAgJH5bbl1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIHVuaW9uKCpwYXJ0cylcbiAgICAgICV4e1xuICAgICAgICB2YXIgaXNfZmlyc3RfcGFydF9hcnJheSwgcXVvdGVkX3ZhbGlkYXRlZCwgcGFydCwgb3B0aW9ucywgZWFjaF9wYXJ0X29wdGlvbnM7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgIHJldHVybiAvKD8hKS87XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0dXJuIGZhc3QgaWYgdGhlcmUncyBvbmx5IG9uZSBlbGVtZW50XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT0gMSAmJiBwYXJ0c1swXS4kJGlzX3JlZ2V4cCkge1xuICAgICAgICAgIHJldHVybiBwYXJ0c1swXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3ZlciB0aGUgMiBhcnJheXMgcGFzc2VkIGFzIGFyZ3VtZW50cyBjYXNlXG4gICAgICAgIGlzX2ZpcnN0X3BhcnRfYXJyYXkgPSBwYXJ0c1swXS4kJGlzX2FycmF5O1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSAmJiBpc19maXJzdF9wYXJ0X2FycmF5KSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ25vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgQXJyYXkgaW50byBTdHJpbmcnfVxuICAgICAgICB9XG4gICAgICAgIC8vIGRlYWwgd2l0aCBzcGxhdCBpc3N1ZXMgKHJlbGF0ZWQgdG8gaHR0cHM6Ly9naXRodWIuY29tL29wYWwvb3BhbC9pc3N1ZXMvODU4KVxuICAgICAgICBpZiAoaXNfZmlyc3RfcGFydF9hcnJheSkge1xuICAgICAgICAgIHBhcnRzID0gcGFydHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgcXVvdGVkX3ZhbGlkYXRlZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICBpZiAocGFydC4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgcXVvdGVkX3ZhbGlkYXRlZC5wdXNoKCN7ZXNjYXBlKGBwYXJ0YCl9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAocGFydC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICAgICAgZWFjaF9wYXJ0X29wdGlvbnMgPSAje2BwYXJ0YC5vcHRpb25zfTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zICE9IHVuZGVmaW5lZCAmJiBvcHRpb25zICE9IGVhY2hfcGFydF9vcHRpb25zKSB7XG4gICAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdBbGwgZXhwcmVzc2lvbnMgbXVzdCB1c2UgdGhlIHNhbWUgb3B0aW9ucyd9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zID0gZWFjaF9wYXJ0X29wdGlvbnM7XG4gICAgICAgICAgICBxdW90ZWRfdmFsaWRhdGVkLnB1c2goJygnK3BhcnQuc291cmNlKycpJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcXVvdGVkX3ZhbGlkYXRlZC5wdXNoKCN7ZXNjYXBlKGBwYXJ0YC50b19zdHIpfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAjIFRha2UgYWR2YW50YWdlIG9mIGxvZ2ljIHRoYXQgY2FuIHBhcnNlIG9wdGlvbnMgZnJvbSBKUyBSZWdleFxuICAgICAgbmV3KGBxdW90ZWRfdmFsaWRhdGVkYC5qb2luKCd8JyksIGBvcHRpb25zYClcbiAgICBlbmRcblxuICAgIGRlZiBuZXcocmVnZXhwLCBvcHRpb25zID0gdW5kZWZpbmVkKVxuICAgICAgJXh7XG4gICAgICAgIGlmIChyZWdleHAuJCRpc19yZWdleHApIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleHApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnZXhwID0gI3s6Ok9wYWwuY29lcmNlX3RvIShyZWdleHAsIDo6U3RyaW5nLCA6dG9fc3RyKX07XG5cbiAgICAgICAgaWYgKHJlZ2V4cC5jaGFyQXQocmVnZXhwLmxlbmd0aCAtIDEpID09PSAnXFxcXCcgJiYgcmVnZXhwLmNoYXJBdChyZWdleHAubGVuZ3RoIC0gMikgIT09ICdcXFxcJykge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpSZWdleHBFcnJvciwgXCJ0b28gc2hvcnQgZXNjYXBlIHNlcXVlbmNlOiAvI3tyZWdleHB9L1wifVxuICAgICAgICB9XG5cbiAgICAgICAgcmVnZXhwID0gcmVnZXhwLnJlcGxhY2UoJ1xcXFxBJywgJ14nKS5yZXBsYWNlKCdcXFxceicsICckJylcblxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8ICN7IW9wdGlvbnN9KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXhwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICAgdmFyIHRlbXAgPSAnJztcbiAgICAgICAgICBpZiAoI3tJR05PUkVDQVNFfSAmIG9wdGlvbnMpIHsgdGVtcCArPSAnaSc7IH1cbiAgICAgICAgICBpZiAoI3tNVUxUSUxJTkV9ICAmIG9wdGlvbnMpIHsgdGVtcCArPSAnbSc7IH1cbiAgICAgICAgICBvcHRpb25zID0gdGVtcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zID0gJ2knO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXhwLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGFsaWFzIGNvbXBpbGUgbmV3XG4gICAgYWxpYXMgcXVvdGUgZXNjYXBlXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBgb3RoZXIgaW5zdGFuY2VvZiBSZWdFeHAgJiYgc2VsZi50b1N0cmluZygpID09PSBvdGhlci50b1N0cmluZygpYFxuICBlbmRcblxuICBkZWYgPT09KHN0cmluZylcbiAgICBgI3ttYXRjaCg6Ok9wYWwuY29lcmNlX3RvPyhzdHJpbmcsIDo6U3RyaW5nLCA6dG9fc3RyKSl9ICE9PSBuaWxgXG4gIGVuZFxuXG4gIGRlZiA9fihzdHJpbmcpXG4gICAgbWF0Y2goc3RyaW5nKSAmJiAkfi5iZWdpbigwKVxuICBlbmRcblxuICBkZWYgZnJlZXplXG4gICAgIyBTcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGZyZWV6ZSwgYmVjYXVzZSB0aGUgJCRnbSBhbmQgJCRnIHByb3BlcnRpZXMgbmVlZCB0byBiZSBzZXRcbiAgICAjIGVzcGVjaWFsbHkgZm9yIFJlZ0V4cC5cblxuICAgIHJldHVybiBzZWxmIGlmIGZyb3plbj9cblxuICAgICV4e1xuICAgICAgaWYgKCFzZWxmLmhhc093blByb3BlcnR5KCckJGcnKSkgeyAkcHJvcChzZWxmLCAnJCRnJywgbnVsbCk7IH1cbiAgICAgIGlmICghc2VsZi5oYXNPd25Qcm9wZXJ0eSgnJCRnbScpKSB7ICRwcm9wKHNlbGYsICckJGdtJywgbnVsbCk7IH1cblxuICAgICAgcmV0dXJuICRmcmVlemUoc2VsZik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgICMgVXNlIGEgcmVnZXhwIHRvIGV4dHJhY3QgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBhbmQgdGhlIG9wdGlvbmFsIG1vZGUgbW9kaWZpZXJzIGZyb20gdGhlIHN0cmluZy5cbiAgICAjIEluIHRoZSByZWd1bGFyIGV4cHJlc3Npb24sIGVzY2FwZSBhbnkgZnJvbnQgc2xhc2ggKG5vdCBhbHJlYWR5IGVzY2FwZWQpIHdpdGggYSBiYWNrc2xhc2guXG4gICAgJXh7XG4gICAgICB2YXIgcmVnZXhwX2Zvcm1hdCA9IC9eXFwvKC4qKVxcLyhbXlxcL10qKSQvO1xuICAgICAgdmFyIHZhbHVlID0gc2VsZi50b1N0cmluZygpO1xuICAgICAgdmFyIG1hdGNoZXMgPSByZWdleHBfZm9ybWF0LmV4ZWModmFsdWUpO1xuICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgdmFyIHJlZ2V4cF9wYXR0ZXJuID0gbWF0Y2hlc1sxXTtcbiAgICAgICAgdmFyIHJlZ2V4cF9mbGFncyA9IG1hdGNoZXNbMl07XG4gICAgICAgIHZhciBjaGFycyA9IHJlZ2V4cF9wYXR0ZXJuLnNwbGl0KCcnKTtcbiAgICAgICAgdmFyIGNoYXJzX2xlbmd0aCA9IGNoYXJzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNoYXJfZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgcmVnZXhwX3BhdHRlcm5fZXNjYXBlZCA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRfY2hhciA9IGNoYXJzW2ldO1xuICAgICAgICAgIGlmICghY2hhcl9lc2NhcGVkICYmIGN1cnJlbnRfY2hhciA9PSAnLycpIHtcbiAgICAgICAgICAgIHJlZ2V4cF9wYXR0ZXJuX2VzY2FwZWQgPSByZWdleHBfcGF0dGVybl9lc2NhcGVkLmNvbmNhdCgnXFxcXCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZWdleHBfcGF0dGVybl9lc2NhcGVkID0gcmVnZXhwX3BhdHRlcm5fZXNjYXBlZC5jb25jYXQoY3VycmVudF9jaGFyKTtcbiAgICAgICAgICBpZiAoY3VycmVudF9jaGFyID09ICdcXFxcJykge1xuICAgICAgICAgICAgaWYgKGNoYXJfZXNjYXBlZCkge1xuICAgICAgICAgICAgICAvLyBkb2VzIG5vdCBvdmVyIGVzY2FwZVxuICAgICAgICAgICAgICBjaGFyX2VzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNoYXJfZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoYXJfZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJy8nICsgcmVnZXhwX3BhdHRlcm5fZXNjYXBlZCArICcvJyArIHJlZ2V4cF9mbGFncztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtYXRjaChzdHJpbmcsIHBvcyA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYudW5pbml0aWFsaXplZCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAndW5pbml0aWFsaXplZCBSZWdleHAnfVxuICAgICAgfVxuXG4gICAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHN0cmluZyA9PT0gbmlsKSByZXR1cm4gI3skfiA9IG5pbH07XG4gICAgICAgIHZhciBtID0gc2VsZi5leGVjKCRjb2VyY2VfdG8oc3RyaW5nLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpKTtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAjeyR+ID0gOjpNYXRjaERhdGEubmV3KGBzZWxmYCwgYG1gKX07XG4gICAgICAgICAgcmV0dXJuIGJsb2NrID09PSBuaWwgPyAjeyR+fSA6ICN7eWllbGQgJH59O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAjeyR+ID0gbmlsfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwb3MgPSAkY29lcmNlX3RvKHBvcywgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChzdHJpbmcgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gI3skfiA9IG5pbH07XG4gICAgICB9XG5cbiAgICAgIHN0cmluZyA9ICRjb2VyY2VfdG8oc3RyaW5nLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuXG4gICAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICBwb3MgKz0gc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgICByZXR1cm4gI3skfiA9IG5pbH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZ2xvYmFsIFJlZ0V4cCBtYWludGFpbnMgc3RhdGUsIHNvIG5vdCB1c2luZyBzZWxmL3RoaXNcbiAgICAgIHZhciBtZCwgcmUgPSBPcGFsLmdsb2JhbF9yZWdleHAoc2VsZik7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIG1kID0gcmUuZXhlYyhzdHJpbmcpO1xuICAgICAgICBpZiAobWQgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gI3skfiA9IG5pbH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1kLmluZGV4ID49IHBvcykge1xuICAgICAgICAgICN7JH4gPSA6Ok1hdGNoRGF0YS5uZXcoYHJlYCwgYG1kYCl9O1xuICAgICAgICAgIHJldHVybiBibG9jayA9PT0gbmlsID8gI3skfn0gOiAje3lpZWxkICR+fTtcbiAgICAgICAgfVxuICAgICAgICByZS5sYXN0SW5kZXggPSBtZC5pbmRleCArIDE7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWF0Y2g/KHN0cmluZywgcG9zID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYudW5pbml0aWFsaXplZCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAndW5pbml0aWFsaXplZCBSZWdleHAnfVxuICAgICAgfVxuXG4gICAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZyA9PT0gbmlsID8gZmFsc2UgOiBzZWxmLnRlc3QoJGNvZXJjZV90byhzdHJpbmcsICN7OjpTdHJpbmd9LCAndG9fc3RyJykpO1xuICAgICAgfVxuXG4gICAgICBwb3MgPSAkY29lcmNlX3RvKHBvcywgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChzdHJpbmcgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHN0cmluZyA9ICRjb2VyY2VfdG8oc3RyaW5nLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuXG4gICAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICBwb3MgKz0gc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZ2xvYmFsIFJlZ0V4cCBtYWludGFpbnMgc3RhdGUsIHNvIG5vdCB1c2luZyBzZWxmL3RoaXNcbiAgICAgIHZhciBtZCwgcmUgPSBPcGFsLmdsb2JhbF9yZWdleHAoc2VsZik7XG5cbiAgICAgIG1kID0gcmUuZXhlYyhzdHJpbmcpO1xuICAgICAgaWYgKG1kID09PSBudWxsIHx8IG1kLmluZGV4IDwgcG9zKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG5hbWVzXG4gICAgc291cmNlLnNjYW4oL1xcKD88KFxcdyspPi8sIG5vX21hdGNoZGF0YTogdHJ1ZSkubWFwKCY6Zmlyc3QpLnVuaXFcbiAgZW5kXG5cbiAgZGVmIG5hbWVkX2NhcHR1cmVzXG4gICAgc291cmNlLnNjYW4oL1xcKD88KFxcdyspPi8sIG5vX21hdGNoZGF0YTogdHJ1ZSkgIyBTY2FuIGZvciBjYXB0dXJlIGdyb3Vwc1xuICAgICAgICAgIC5tYXAoJjpmaXJzdCkgICAgICAgICAgICAgICAgICAgICAgICAgICAjIEdldCB0aGUgZmlyc3QgcmVnZXhwIG1hdGNoIChcXHcrKVxuICAgICAgICAgIC5lYWNoX3dpdGhfaW5kZXggICAgICAgICAgICAgICAgICAgICAgICAjIEFkZCBpbmRleCB0byBhbiBpdGVyYXRvclxuICAgICAgICAgIC5ncm91cF9ieSgmOmZpcnN0KSAgICAgICAgICAgICAgICAgICAgICAjIEdyb3VwIGJ5IHRoZSBjYXB0dXJlIGdyb3VwIG5hbWVzXG4gICAgICAgICAgLnRyYW5zZm9ybV92YWx1ZXMgZG8gfGl8ICAgICAgICAgICAgICAgICMgQ29udmVydCBoYXNoIHZhbHVlc1xuICAgICAgICAgICAgaS5tYXAgeyB8anwgai5sYXN0ICsgMSB9ICAgICAgICAgICAgICAjIERyb3AgdGhlIGNhcHR1cmUgZ3JvdXAgbmFtZXM7IGluY3JlYXNlIGluZGV4ZXMgYnkgMVxuICAgICAgICAgIGVuZFxuICBlbmRcblxuICBkZWYgflxuICAgIHNlbGYgPX4gJF9cbiAgZW5kXG5cbiAgZGVmIHNvdXJjZVxuICAgIGBzZWxmLnNvdXJjZWBcbiAgZW5kXG5cbiAgZGVmIG9wdGlvbnNcbiAgICAjIEZsYWdzIHdvdWxkIGJlIG5pY2UgdG8gdXNlIHdpdGggdGhpcywgYnV0IHN0aWxsIGV4cGVyaW1lbnRhbCAtIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1JlZ0V4cC9mbGFnc1xuICAgICV4e1xuICAgICAgaWYgKHNlbGYudW5pbml0aWFsaXplZCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAndW5pbml0aWFsaXplZCBSZWdleHAnfVxuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgICAvLyBzaG91bGQgYmUgc3VwcG9ydGVkIGluIElFNiBhY2NvcmRpbmcgdG8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS83ZjV6MjZ3NCh2PXZzLjk0KS5hc3B4XG4gICAgICBpZiAoc2VsZi5tdWx0aWxpbmUpIHtcbiAgICAgICAgcmVzdWx0IHw9ICN7TVVMVElMSU5FfTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLmlnbm9yZUNhc2UpIHtcbiAgICAgICAgcmVzdWx0IHw9ICN7SUdOT1JFQ0FTRX07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNhc2Vmb2xkP1xuICAgIGBzZWxmLmlnbm9yZUNhc2VgXG4gIGVuZFxuXG4gIGFsaWFzIGVxbD8gPT1cbiAgYWxpYXMgdG9fcyBzb3VyY2VcbmVuZFxuXG5jbGFzcyBNYXRjaERhdGFcbiAgYXR0cl9yZWFkZXIgOnBvc3RfbWF0Y2gsIDpwcmVfbWF0Y2gsIDpyZWdleHAsIDpzdHJpbmdcblxuICBkZWYgaW5pdGlhbGl6ZShyZWdleHAsIG1hdGNoX2dyb3Vwcywgbm9fbWF0Y2hkYXRhOiBmYWxzZSlcbiAgICAkfiAgICAgICAgICA9IHNlbGYgdW5sZXNzIG5vX21hdGNoZGF0YVxuICAgIEByZWdleHAgICAgID0gcmVnZXhwXG4gICAgQGJlZ2luICAgICAgPSBgbWF0Y2hfZ3JvdXBzLmluZGV4YFxuICAgIEBzdHJpbmcgICAgID0gYG1hdGNoX2dyb3Vwcy5pbnB1dGBcbiAgICBAcHJlX21hdGNoICA9IGBtYXRjaF9ncm91cHMuaW5wdXQuc2xpY2UoMCwgbWF0Y2hfZ3JvdXBzLmluZGV4KWBcbiAgICBAcG9zdF9tYXRjaCA9IGBtYXRjaF9ncm91cHMuaW5wdXQuc2xpY2UobWF0Y2hfZ3JvdXBzLmluZGV4ICsgbWF0Y2hfZ3JvdXBzWzBdLmxlbmd0aClgXG4gICAgQG1hdGNoZXMgICAgPSBbXVxuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbWF0Y2hfZ3JvdXBzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBncm91cCA9IG1hdGNoX2dyb3Vwc1tpXTtcblxuICAgICAgICBpZiAoZ3JvdXAgPT0gbnVsbCkge1xuICAgICAgICAgICN7QG1hdGNoZXN9LnB1c2gobmlsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAje0BtYXRjaGVzfS5wdXNoKGdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1hdGNoKGlkeClcbiAgICBpZiAobWF0Y2ggPSBzZWxmW2lkeF0pXG4gICAgICBtYXRjaFxuICAgIGVsc2lmIGlkeC5pc19hPyhJbnRlZ2VyKSAmJiBpZHggPj0gbGVuZ3RoXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkluZGV4RXJyb3IsIFwiaW5kZXggI3tpZHh9IG91dCBvZiBtYXRjaGVzXCJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIG1hdGNoX2xlbmd0aChpZHgpXG4gICAgbWF0Y2goaWR4KSYubGVuZ3RoXG4gIGVuZFxuXG4gIGRlZiBbXSgqYXJncylcbiAgICAleHtcbiAgICAgIGlmIChhcmdzWzBdLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIGlmICgjeyFyZWdleHAubmFtZXMuaW5jbHVkZT8oYXJnc1swXSl9KSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkluZGV4RXJyb3IsIFwidW5kZWZpbmVkIGdyb3VwIG5hbWUgcmVmZXJlbmNlOiAje2FyZ3NbMF19XCJ9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICN7bmFtZWRfY2FwdHVyZXNbYXJnc1swXV19XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7QG1hdGNoZXNbKmFyZ3NdfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG9mZnNldChuKVxuICAgICV4e1xuICAgICAgaWYgKG4gIT09IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdNYXRjaERhdGEjb2Zmc2V0IG9ubHkgc3VwcG9ydHMgMHRoIGVsZW1lbnQnfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFtzZWxmLmJlZ2luLCBzZWxmLmJlZ2luICsgc2VsZi5tYXRjaGVzW25dLmxlbmd0aF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyA6Ok1hdGNoRGF0YSA9PT0gb3RoZXJcblxuICAgIGBzZWxmLnN0cmluZyA9PSBvdGhlci5zdHJpbmdgICYmXG4gICAgICBgc2VsZi5yZWdleHAudG9TdHJpbmcoKSA9PSBvdGhlci5yZWdleHAudG9TdHJpbmcoKWAgJiZcbiAgICAgIGBzZWxmLnByZV9tYXRjaCA9PSBvdGhlci5wcmVfbWF0Y2hgICYmXG4gICAgICBgc2VsZi5wb3N0X21hdGNoID09IG90aGVyLnBvc3RfbWF0Y2hgICYmXG4gICAgICBgc2VsZi5iZWdpbiA9PSBvdGhlci5iZWdpbmBcbiAgZW5kXG5cbiAgZGVmIGJlZ2luKG4pXG4gICAgJXh7XG4gICAgICBpZiAobiAhPT0gMCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ01hdGNoRGF0YSNiZWdpbiBvbmx5IHN1cHBvcnRzIDB0aCBlbGVtZW50J31cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLmJlZ2luO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVuZChuKVxuICAgICV4e1xuICAgICAgaWYgKG4gIT09IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdNYXRjaERhdGEjZW5kIG9ubHkgc3VwcG9ydHMgMHRoIGVsZW1lbnQnfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYuYmVnaW4gKyBzZWxmLm1hdGNoZXNbbl0ubGVuZ3RoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNhcHR1cmVzXG4gICAgYCN7QG1hdGNoZXN9LnNsaWNlKDEpYFxuICBlbmRcblxuICBkZWYgbmFtZWRfY2FwdHVyZXNcbiAgICBtYXRjaGVzID0gY2FwdHVyZXNcbiAgICByZWdleHAubmFtZWRfY2FwdHVyZXMudHJhbnNmb3JtX3ZhbHVlcyBkbyB8aXxcbiAgICAgIG1hdGNoZXNbaS5sYXN0IC0gMV1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIG5hbWVzXG4gICAgcmVnZXhwLm5hbWVzXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgJXh7XG4gICAgICB2YXIgc3RyID0gXCIjPE1hdGNoRGF0YSBcIiArICN7YCN7QG1hdGNoZXN9WzBdYC5pbnNwZWN0fTtcblxuICAgICAgaWYgKCN7cmVnZXhwLm5hbWVzLmVtcHR5P30pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDEsIGxlbmd0aCA9ICN7QG1hdGNoZXN9Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3RyICs9IFwiIFwiICsgaSArIFwiOlwiICsgI3tgI3tAbWF0Y2hlc31baV1gLmluc3BlY3R9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgI3sgbmFtZWRfY2FwdHVyZXMuZWFjaCBkbyB8aywgdnxcbiAgICAgICAgICAgICAleHtcbiAgICAgICAgICAgICAgIHN0ciArPSBcIiBcIiArICN7a30gKyBcIjpcIiArICN7di5pbnNwZWN0fVxuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgZW5kIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0ciArIFwiPlwiO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxlbmd0aFxuICAgIGAje0BtYXRjaGVzfS5sZW5ndGhgXG4gIGVuZFxuXG4gIGRlZiB0b19hXG4gICAgQG1hdGNoZXNcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBgI3tAbWF0Y2hlc31bMF1gXG4gIGVuZFxuXG4gIGRlZiB2YWx1ZXNfYXQoKmFyZ3MpXG4gICAgJXh7XG4gICAgICB2YXIgaSwgYSwgaW5kZXgsIHZhbHVlcyA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgIGlmIChhcmdzW2ldLiQkaXNfcmFuZ2UpIHtcbiAgICAgICAgICBhID0gI3tgYXJnc1tpXWAudG9fYX07XG4gICAgICAgICAgYS51bnNoaWZ0KGksIDEpO1xuICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkoYXJncywgYSk7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCA9ICN7OjpPcGFsLmNvZXJjZV90byEoYGFyZ3NbaV1gLCA6OkludGVnZXIsIDp0b19pbnQpfTtcblxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgaW5kZXggKz0gI3tAbWF0Y2hlc30ubGVuZ3RoO1xuICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKG5pbCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZXMucHVzaCgje0BtYXRjaGVzfVtpbmRleF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZXFsPyA9PVxuICBhbGlhcyBzaXplIGxlbmd0aFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpSZWdleHBFcnJvcj4iLCJTdGFuZGFyZEVycm9yIiwiPGNsYXNzOlJlZ2V4cD4iLCJzZWxmIiwiMSIsIjIiLCI0IiwiYWxsb2NhdGUiLCJhbGxvY2F0ZWQiLCJlc2NhcGUiLCJzdHJpbmciLCJTdHJpbmciLCJsYXN0X21hdGNoIiwibiIsIm5pbD8iLCIkfiIsIltdIiwidW5pb24iLCJLZXJuZWwiLCJyYWlzZSIsIlR5cGVFcnJvciIsIm9wdGlvbnMiLCJ0b19zdHIiLCJuZXciLCJqb2luIiwicmVnZXhwIiwiT3BhbCIsImNvZXJjZV90byEiLCJSZWdleHBFcnJvciIsIiEiLCJJR05PUkVDQVNFIiwiTVVMVElMSU5FIiwiPT0iLCJvdGhlciIsIj09PSIsIm1hdGNoIiwiY29lcmNlX3RvPyIsIj1+IiwiJHJldF9vcl8xIiwiYmVnaW4iLCIwIiwiZnJlZXplIiwiZnJvemVuPyIsImluc3BlY3QiLCJwb3MiLCJNYXRjaERhdGEiLCJJbnRlZ2VyIiwibWF0Y2g/IiwibmFtZXMiLCJtYXAiLCJzb3VyY2UiLCJzY2FuIiwidG9fcHJvYyIsInVuaXEiLCJuYW1lZF9jYXB0dXJlcyIsInRyYW5zZm9ybV92YWx1ZXMiLCJncm91cF9ieSIsImVhY2hfd2l0aF9pbmRleCIsImJsb2NrIGluIG5hbWVkX2NhcHR1cmVzIiwiaSIsImJsb2NrICgyIGxldmVscykgaW4gbmFtZWRfY2FwdHVyZXMiLCJqIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiBuYW1lZF9jYXB0dXJlcyIsIisiLCJsYXN0IiwifiIsIiRfIiwiY2FzZWZvbGQ/IiwiPGNsYXNzOk1hdGNoRGF0YT4iLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJtYXRjaF9ncm91cHMiLCIka3dhcmdzIiwibm9fbWF0Y2hkYXRhIiwiQHJlZ2V4cCIsIkBiZWdpbiIsIkBzdHJpbmciLCJAcHJlX21hdGNoIiwiQHBvc3RfbWF0Y2giLCJAbWF0Y2hlcyIsImlkeCIsImlzX2E/IiwiPj0iLCJsZW5ndGgiLCJJbmRleEVycm9yIiwibWF0Y2hfbGVuZ3RoIiwiaW5jbHVkZT8iLCJhcmdzIiwib2Zmc2V0IiwiQXJndW1lbnRFcnJvciIsIiRyZXRfb3JfMiIsIiRyZXRfb3JfMyIsIiRyZXRfb3JfNCIsImVuZCIsImNhcHR1cmVzIiwibWF0Y2hlcyIsIi0iLCJlbXB0eT8iLCJlYWNoIiwiYmxvY2sgaW4gaW5zcGVjdCIsImsiLCJ2IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbnNwZWN0IiwidG9fYSIsInRvX3MiLCJ2YWx1ZXNfYXQiXSwibWFwcGluZ3MiOiJBQUFBQSxpQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFHQUMsT0FBTSxJQUFOQSxFQUFzQkMsb0JBQXRCRDtFQUVBRTtFQUFBQTs7SUFBQUE7OztJQUNFLFdBQUFDLElBQUEsZ0JBQW1CQyxDQUFuQjtJQUNBLFdBQUFELElBQUEsY0FBaUJFLENBQWpCO0lBQ0EsV0FBQUYsSUFBQSxlQUFrQkcsQ0FBbEI7SUFFQ0o7SUFFRDtNQUFBOzs7O0FBQ0VLLE1BQUFBLHdCQUFBQSxvQkFBQUE7QUFBQUEsUUFBQUE7O1FBQUFBOztRQUNFQyxZQUFZLE9BQUFMLElBQUEsRUFBQSxzREFBQSxZQUFBLEVBQUEsRUFBQSxFQUFBLE1BQUE7UUFDVEssU0FBVUQ7UUFDYkEsT0FBQUM7TUFIRkQsQ0FBQUE7O0FBTUFFLE1BQUFBLHNCQUFBQSxrQkFBV0MsTUFBWEQ7QUFBQUE7O0FBRUpBLG9DQUFzQ0UsYUFBU0Y7QUFDL0NBO0FBQ0FBO01BSklBLENBQUFBOztBQU9BRyxNQUFBQSwwQkFBQUEsc0JBQWVDLENBQWZEO0FBQUFBLFFBQUFB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QUEscUJBaGNGLEVBZ2NFQTtBQUFBQSxNQUFBQTs7O01BaGNGO01BZ2NnQjs7QUFFaEJBOztBQUVBQTs7QUFFQUE7QUFDQUEsY0FBZ0JBLENBQUNBLE9BQURBLENBQVNGLE1BQUFBLENBQUFBLENBQU1FO0FBQy9CQTtBQUNBQTtBQUNBQTs7QUFFQUEsZ0JBQWtCL0UsS0FBTUMsZUFBQUEsQ0FBYThFLE9BQW5CLEVBQTZCM0QsY0FBN0IsRUFBd0MsUUFBbENuQixDQUEyQzhFOztBQUVuRUE7QUFDQUEsbUJBQXFCMUIsWUFBUzBCO0FBQzlCQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUEsb0JBQXNCMUIsWUFBUzBCO0FBQy9CQTs7QUFFQUE7QUFDQUE7SUExQkVBLENBQUFBLElBQUFBO0lBNkJBLGFBQU0sTUFBTixFQUFXLElBQVg7SUFDQXJDLE9BQUEsYUFBTSxNQUFOLEVBQVcsUUFBWDtFQXZLRkEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUF2VEFyRTsifX0seyJvZmZzZXQiOnsibGluZSI6NzQ3NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvc3RyaW5nLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogY29lcmNlX3RvLCByZXNwb25kX3RvLCBnbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cCwgcHJvcCwgb3BhbDMyX2luaXQsIG9wYWwzMl9hZGRcbiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxuXG5yZXF1aXJlICdjb3JlbGliL2NvbXBhcmFibGUnXG5yZXF1aXJlICdjb3JlbGliL3JlZ2V4cCdcblxuY2xhc3MgOjpTdHJpbmcgPCBgU3RyaW5nYFxuICBpbmNsdWRlIDo6Q29tcGFyYWJsZVxuXG4gICV4e1xuICAgIE9wYWwucHJvcCgje3NlbGZ9LiQkcHJvdG90eXBlLCAnJCRpc19zdHJpbmcnLCB0cnVlKTtcblxuICAgIHZhciBzdHJpbmdfaWRfbWFwID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgIyBGb3JjZSBzdHJpY3QgbW9kZSB0byBzdXBwcmVzcyBhdXRvYm94aW5nIG9mIGB0aGlzYFxuICAleHtcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAndXNlIHN0cmljdCc7XG4gICAgICAje1xuICAgICAgICBkZWYgX19pZF9fXG4gICAgICAgICAgJXh7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlbGYgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgIHJldHVybiAje3N1cGVyfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cmluZ19pZF9tYXAuaGFzKHNlbGYpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzdHJpbmdfaWRfbWFwLmdldChzZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpZCA9IE9wYWwudWlkKCk7XG4gICAgICAgICAgICBzdHJpbmdfaWRfbWFwLnNldChzZWxmLCBpZCk7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgfVxuICAgICAgICBlbmRcblxuICAgICAgICBkZWYgaGFzaFxuICAgICAgICAgICV4e1xuICAgICAgICAgICAgdmFyIGhhc2ggPSAkb3BhbDMyX2luaXQoKSwgaSwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7XG4gICAgICAgICAgICBoYXNoID0gJG9wYWwzMl9hZGQoaGFzaCwgMHg1KTtcbiAgICAgICAgICAgIGhhc2ggPSAkb3BhbDMyX2FkZChoYXNoLCBsZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGhhc2ggPSAkb3BhbDMyX2FkZChoYXNoLCBzZWxmLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICAgICAgfVxuICAgICAgICBlbmRcbiAgICAgIH1cbiAgICB9KSgpO1xuICB9XG5cbiAgZGVmIHNlbGYudHJ5X2NvbnZlcnQod2hhdClcbiAgICA6Ok9wYWwuY29lcmNlX3RvPyh3aGF0LCA6OlN0cmluZywgOnRvX3N0cilcbiAgZW5kXG5cbiAgZGVmIHNlbGYubmV3KCphcmdzKVxuICAgICV4e1xuICAgICAgdmFyIHN0ciA9IGFyZ3NbMF0gfHwgXCJcIjtcbiAgICAgIHZhciBvcHRzID0gYXJnc1thcmdzLmxlbmd0aC0xXTtcbiAgICAgIHN0ciA9ICRjb2VyY2VfdG8oc3RyLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgaWYgKG9wdHMgJiYgb3B0cy4kJGlzX2hhc2gpIHtcbiAgICAgICAgaWYgKG9wdHMuaGFzKCdlbmNvZGluZycpKSBzdHIgPSBzdHIuJGZvcmNlX2VuY29kaW5nKG9wdHMuZ2V0KCdlbmNvZGluZycpLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHN0ciA9IG5ldyBzZWxmLiQkY29uc3RydWN0b3Ioc3RyKTtcbiAgICAgIGlmICghc3RyLiRpbml0aWFsaXplLiQkcHJpc3RpbmUpICN7YHN0cmAuaW5pdGlhbGl6ZSgqYXJncyl9O1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIGVuZFxuXG4gICMgT3VyIGluaXRpYWxpemUgbWV0aG9kIGRvZXMgbm90aGluZywgdGhlIHN0cmluZyB2YWx1ZSBzZXR1cCBpcyBiZWluZ1xuICAjIGRvbmUgYnkgU3RyaW5nLm5ldy4gVGhlcmVmb3JlIG5vdCBhbGwga2luZHMgb2Ygc3ViY2xhc3Npbmcgd2lsbCB3b3JrLlxuICAjIEFzIGEgcnVsZSBvZiB0aHVtYiwgd2hlbiBzdWJjbGFzc2luZyBTdHJpbmcsIGVpdGhlciBtYWtlIHN1cmUgdG8gb3ZlcnJpZGVcbiAgIyAubmV3IG9yIG1ha2Ugc3VyZSB0aGF0IHRoZSBmaXJzdCBhcmd1bWVudCBnaXZlbiB0byBhIGNvbnN0cnVjdG9yIGlzXG4gICMgYSBzdHJpbmcgd2Ugd2FudCBvdXIgc3ViY2xhc3Mtc3RyaW5nIHRvIGhvbGQuXG4gIGRlZiBpbml0aWFsaXplKHN0ciA9IHVuZGVmaW5lZCwgZW5jb2Rpbmc6IG5pbCwgY2FwYWNpdHk6IG5pbClcbiAgZW5kXG5cbiAgZGVmICUoZGF0YSlcbiAgICBpZiA6OkFycmF5ID09PSBkYXRhXG4gICAgICBmb3JtYXQoc2VsZiwgKmRhdGEpXG4gICAgZWxzZVxuICAgICAgZm9ybWF0KHNlbGYsIGRhdGEpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAqKGNvdW50KVxuICAgICV4e1xuICAgICAgY291bnQgPSAkY29lcmNlX3RvKGNvdW50LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKGNvdW50IDwgMCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFyZ3VtZW50J31cbiAgICAgIH1cblxuICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9ICcnLFxuICAgICAgICAgIHN0cmluZyA9IHNlbGYudG9TdHJpbmcoKTtcblxuICAgICAgLy8gQWxsIGNyZWRpdCBmb3IgdGhlIGJpdC10d2lkZGxpbmcgbWFnaWMgY29kZSBiZWxvdyBnb2VzIHRvIE1vemlsbGFcbiAgICAgIC8vIHBvbHlmaWxsIGltcGxlbWVudGF0aW9uIG9mIFN0cmluZy5wcm90b3R5cGUucmVwZWF0KCkgcG9zdGVkIGhlcmU6XG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvcmVwZWF0XG5cbiAgICAgIGlmIChzdHJpbmcubGVuZ3RoICogY291bnQgPj0gMSA8PCAyOCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ211bHRpcGx5IGNvdW50IG11c3Qgbm90IG92ZXJmbG93IG1heGltdW0gc3RyaW5nIHNpemUnfVxuICAgICAgfVxuXG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmICgoY291bnQgJiAxKSA9PT0gMSkge1xuICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgY291bnQgPj4+PSAxO1xuICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdHJpbmcgKz0gc3RyaW5nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgb3RoZXIgPSBgJGNvZXJjZV90bygje290aGVyfSwgI3s6OlN0cmluZ30sICd0b19zdHInKWBcblxuICAgICV4e1xuICAgICAgaWYgKG90aGVyID09IFwiXCIgJiYgc2VsZi4kJGNsYXNzID09PSBPcGFsLlN0cmluZykgcmV0dXJuICN7c2VsZn07XG4gICAgICBpZiAoc2VsZiA9PSBcIlwiICYmIG90aGVyLiQkY2xhc3MgPT09IE9wYWwuU3RyaW5nKSByZXR1cm4gI3tvdGhlcn07XG4gICAgICB2YXIgb3V0ID0gc2VsZiArIG90aGVyO1xuICAgICAgaWYgKHNlbGYuZW5jb2RpbmcgPT09IG91dC5lbmNvZGluZyAmJiBvdGhlci5lbmNvZGluZyA9PT0gb3V0LmVuY29kaW5nKSByZXR1cm4gb3V0O1xuICAgICAgaWYgKHNlbGYuZW5jb2RpbmcubmFtZSA9PT0gXCJVVEYtOFwiIHx8IG90aGVyLmVuY29kaW5nLm5hbWUgPT09IFwiVVRGLThcIikgcmV0dXJuIG91dDtcbiAgICAgIHJldHVybiBPcGFsLmVuYyhvdXQsIHNlbGYuZW5jb2RpbmcpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICBpZiBvdGhlci5yZXNwb25kX3RvPyA6dG9fc3RyXG4gICAgICBvdGhlciA9IG90aGVyLnRvX3N0ci50b19zXG5cbiAgICAgIGBzZWxmID4gb3RoZXIgPyAxIDogKHNlbGYgPCBvdGhlciA/IC0xIDogMClgXG4gICAgZWxzZVxuICAgICAgJXh7XG4gICAgICAgIHZhciBjbXAgPSAje290aGVyIDw9PiBzZWxmfTtcblxuICAgICAgICBpZiAoY21wID09PSBuaWwpIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjbXAgPiAwID8gLTEgOiAoY21wIDwgMCA/IDEgOiAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYudG9TdHJpbmcoKSA9PT0gb3RoZXIudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmICgkcmVzcG9uZF90byhvdGhlciwgJyR0b19zdHInKSkge1xuICAgICAgICByZXR1cm4gI3tvdGhlciA9PSBzZWxmfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA9fihvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX3N0cmluZykge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAndHlwZSBtaXNtYXRjaDogU3RyaW5nIGdpdmVuJ307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje290aGVyID1+IHNlbGZ9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIFtdKGluZGV4LCBsZW5ndGggPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICB2YXIgc2l6ZSA9IHNlbGYubGVuZ3RoLCBleGNsdWRlLCByYW5nZTtcblxuICAgICAgaWYgKGluZGV4LiQkaXNfcmFuZ2UpIHtcbiAgICAgICAgZXhjbHVkZSA9IGluZGV4LmV4Y2w7XG4gICAgICAgIHJhbmdlICAgPSBpbmRleDtcbiAgICAgICAgbGVuZ3RoICA9IGluZGV4LmVuZCA9PT0gbmlsID8gLTEgOiAkY29lcmNlX3RvKGluZGV4LmVuZCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgICAgIGluZGV4ICAgPSBpbmRleC5iZWdpbiA9PT0gbmlsID8gMCA6ICRjb2VyY2VfdG8oaW5kZXguYmVnaW4sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhpbmRleCkgPiBzaXplKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICBpbmRleCArPSBzaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICBsZW5ndGggKz0gc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZXhjbHVkZSB8fCByYW5nZS5lbmQgPT09IG5pbCkge1xuICAgICAgICAgIGxlbmd0aCArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuZ3RoID0gbGVuZ3RoIC0gaW5kZXg7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICBsZW5ndGggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGYuc3Vic3RyKGluZGV4LCBsZW5ndGgpO1xuICAgICAgfVxuXG5cbiAgICAgIGlmIChpbmRleC4kJGlzX3N0cmluZykge1xuICAgICAgICBpZiAobGVuZ3RoICE9IG51bGwpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmLmluZGV4T2YoaW5kZXgpICE9PSAtMSA/IGluZGV4IDogbmlsO1xuICAgICAgfVxuXG5cbiAgICAgIGlmIChpbmRleC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBzZWxmLm1hdGNoKGluZGV4KTtcblxuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAjeyR+ID0gbmlsfVxuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICAjeyR+ID0gOjpNYXRjaERhdGEubmV3KGBpbmRleGAsIGBtYXRjaGApfVxuXG4gICAgICAgIGlmIChsZW5ndGggPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBtYXRjaFswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxlbmd0aCA9ICRjb2VyY2VfdG8obGVuZ3RoLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgICBpZiAobGVuZ3RoIDwgMCAmJiAtbGVuZ3RoIDwgbWF0Y2gubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoW2xlbmd0aCArPSBtYXRjaC5sZW5ndGhdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+PSAwICYmIGxlbmd0aCA8IG1hdGNoLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBtYXRjaFtsZW5ndGhdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuXG4gICAgICBpbmRleCA9ICRjb2VyY2VfdG8oaW5kZXgsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ICs9IHNpemU7XG4gICAgICB9XG5cbiAgICAgIGlmIChsZW5ndGggPT0gbnVsbCkge1xuICAgICAgICBpZiAoaW5kZXggPj0gc2l6ZSB8fCBpbmRleCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmLnN1YnN0cihpbmRleCwgMSk7XG4gICAgICB9XG5cbiAgICAgIGxlbmd0aCA9ICRjb2VyY2VfdG8obGVuZ3RoLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ID4gc2l6ZSB8fCBpbmRleCA8IDApIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuc3Vic3RyKGluZGV4LCBsZW5ndGgpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGJcbiAgICBgbmV3IFN0cmluZygje3NlbGZ9KWAuZm9yY2VfZW5jb2RpbmcoJ2JpbmFyeScpXG4gIGVuZFxuXG4gIGRlZiBjYXBpdGFsaXplXG4gICAgYHNlbGYuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzZWxmLnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpYFxuICBlbmRcblxuICBkZWYgY2FzZWNtcChvdGhlcilcbiAgICByZXR1cm4gbmlsIHVubGVzcyBvdGhlci5yZXNwb25kX3RvPyg6dG9fc3RyKVxuICAgIG90aGVyID0gYCRjb2VyY2VfdG8ob3RoZXIsICN7OjpTdHJpbmd9LCAndG9fc3RyJylgLnRvX3NcbiAgICAleHtcbiAgICAgIHZhciBhc2NpaV9vbmx5ID0gL15bXFx4MDAtXFx4N0ZdKiQvO1xuICAgICAgaWYgKGFzY2lpX29ubHkudGVzdChzZWxmKSAmJiBhc2NpaV9vbmx5LnRlc3Qob3RoZXIpKSB7XG4gICAgICAgIHNlbGYgPSBzZWxmLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIG90aGVyID0gb3RoZXIudG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZiA8PT4gb3RoZXJcbiAgZW5kXG5cbiAgZGVmIGNhc2VjbXA/KG90aGVyKVxuICAgICV4e1xuICAgICAgdmFyIGNtcCA9ICN7Y2FzZWNtcChvdGhlcil9O1xuICAgICAgaWYgKGNtcCA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY21wID09PSAwO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNlbnRlcih3aWR0aCwgcGFkc3RyID0gJyAnKVxuICAgIHdpZHRoICA9IGAkY29lcmNlX3RvKCN7d2lkdGh9LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICBwYWRzdHIgPSBgJGNvZXJjZV90bygje3BhZHN0cn0sICN7OjpTdHJpbmd9LCAndG9fc3RyJylgLnRvX3NcblxuICAgIGlmIHBhZHN0ci5lbXB0eT9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3plcm8gd2lkdGggcGFkZGluZydcbiAgICBlbmRcblxuICAgIHJldHVybiBzZWxmIGlmIGB3aWR0aCA8PSBzZWxmLmxlbmd0aGBcblxuICAgICV4e1xuICAgICAgdmFyIGxqdXN0aWZpZWQgPSAje2xqdXN0ICgod2lkdGggKyBgc2VsZi5sZW5ndGhgKSAvIDIpLmNlaWwsIHBhZHN0cn0sXG4gICAgICAgICAgcmp1c3RpZmllZCA9ICN7cmp1c3QgKCh3aWR0aCArIGBzZWxmLmxlbmd0aGApIC8gMikuZmxvb3IsIHBhZHN0cn07XG5cbiAgICAgIHJldHVybiByanVzdGlmaWVkICsgbGp1c3RpZmllZC5zbGljZShzZWxmLmxlbmd0aCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2hvbXAoc2VwYXJhdG9yID0gJC8pXG4gICAgcmV0dXJuIHNlbGYgaWYgYHNlcGFyYXRvciA9PT0gbmlsIHx8IHNlbGYubGVuZ3RoID09PSAwYFxuXG4gICAgc2VwYXJhdG9yID0gOjpPcGFsLmNvZXJjZV90byEoc2VwYXJhdG9yLCA6OlN0cmluZywgOnRvX3N0cikudG9fc1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBpZiAoc2VwYXJhdG9yID09PSBcIlxcblwiKSB7XG4gICAgICAgIHJlc3VsdCA9IHNlbGYucmVwbGFjZSgvXFxyP1xcbj8kLywgJycpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2VwYXJhdG9yID09PSBcIlwiKSB7XG4gICAgICAgIHJlc3VsdCA9IHNlbGYucmVwbGFjZSgvKFxccj9cXG4pKyQvLCAnJyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzZWxmLmxlbmd0aCA+PSBzZXBhcmF0b3IubGVuZ3RoKSB7XG4gICAgICAgIHZhciB0YWlsID0gc2VsZi5zdWJzdHIoc2VsZi5sZW5ndGggLSBzZXBhcmF0b3IubGVuZ3RoLCBzZXBhcmF0b3IubGVuZ3RoKTtcblxuICAgICAgICBpZiAodGFpbCA9PT0gc2VwYXJhdG9yKSB7XG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5zdWJzdHIoMCwgc2VsZi5sZW5ndGggLSBzZXBhcmF0b3IubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjaG9wXG4gICAgJXh7XG4gICAgICB2YXIgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIHJlc3VsdDtcblxuICAgICAgaWYgKGxlbmd0aCA8PSAxKSB7XG4gICAgICAgIHJlc3VsdCA9IFwiXCI7XG4gICAgICB9IGVsc2UgaWYgKHNlbGYuY2hhckF0KGxlbmd0aCAtIDEpID09PSBcIlxcblwiICYmIHNlbGYuY2hhckF0KGxlbmd0aCAtIDIpID09PSBcIlxcclwiKSB7XG4gICAgICAgIHJlc3VsdCA9IHNlbGYuc3Vic3RyKDAsIGxlbmd0aCAtIDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gc2VsZi5zdWJzdHIoMCwgbGVuZ3RoIC0gMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2hyXG4gICAgYHNlbGYuY2hhckF0KDApYFxuICBlbmRcblxuICBkZWYgY2xvbmUoZnJlZXplOiBuaWwpXG4gICAgdW5sZXNzIGZyZWV6ZS5uaWw/IHx8IGZyZWV6ZSA9PSB0cnVlIHx8IGZyZWV6ZSA9PSBmYWxzZVxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJ1bmV4cGVjdGVkIHZhbHVlIGZvciBmcmVlemU6ICN7ZnJlZXplLmNsYXNzfVwiXG4gICAgZW5kXG5cbiAgICBjb3B5ID0gYG5ldyBTdHJpbmcoc2VsZilgXG4gICAgY29weS5jb3B5X3NpbmdsZXRvbl9tZXRob2RzKHNlbGYpXG4gICAgY29weS5pbml0aWFsaXplX2Nsb25lKHNlbGYsIGZyZWV6ZTogZnJlZXplKVxuXG4gICAgaWYgZnJlZXplID09IHRydWVcbiAgICAgIGBpZiAoIWNvcHkuJCRmcm96ZW4pIHsgY29weS4kJGZyb3plbiA9IHRydWU7IH1gXG4gICAgZWxzaWYgZnJlZXplLm5pbD9cbiAgICAgIGBpZiAoc2VsZi4kJGZyb3plbikgeyBjb3B5LiQkZnJvemVuID0gdHJ1ZTsgfWBcbiAgICBlbmRcblxuICAgIGNvcHlcbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgIGNvcHkgPSBgbmV3IFN0cmluZyhzZWxmKWBcbiAgICBjb3B5LmluaXRpYWxpemVfZHVwKHNlbGYpXG4gICAgY29weVxuICBlbmRcblxuICBkZWYgY291bnQoKnNldHMpXG4gICAgJXh7XG4gICAgICBpZiAoc2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdBcmd1bWVudEVycm9yOiB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxKyknfVxuICAgICAgfVxuICAgICAgdmFyIGNoYXJfY2xhc3MgPSBjaGFyX2NsYXNzX2Zyb21fY2hhcl9zZXRzKHNldHMpO1xuICAgICAgaWYgKGNoYXJfY2xhc3MgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5sZW5ndGggLSBzZWxmLnJlcGxhY2UobmV3IFJlZ0V4cChjaGFyX2NsYXNzLCAnZycpLCAnJykubGVuZ3RoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZSgqc2V0cylcbiAgICAleHtcbiAgICAgIGlmIChzZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ0FyZ3VtZW50RXJyb3I6IHdyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKDAgZm9yIDErKSd9XG4gICAgICB9XG4gICAgICB2YXIgY2hhcl9jbGFzcyA9IGNoYXJfY2xhc3NfZnJvbV9jaGFyX3NldHMoc2V0cyk7XG4gICAgICBpZiAoY2hhcl9jbGFzcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLnJlcGxhY2UobmV3IFJlZ0V4cChjaGFyX2NsYXNzLCAnZycpLCAnJyk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVsZXRlX3ByZWZpeChwcmVmaXgpXG4gICAgJXh7XG4gICAgICBpZiAoIXByZWZpeC4kJGlzX3N0cmluZykge1xuICAgICAgICBwcmVmaXggPSAkY29lcmNlX3RvKHByZWZpeCwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuc2xpY2UoMCwgcHJlZml4Lmxlbmd0aCkgPT09IHByZWZpeCkge1xuICAgICAgICByZXR1cm4gc2VsZi5zbGljZShwcmVmaXgubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZV9zdWZmaXgoc3VmZml4KVxuICAgICV4e1xuICAgICAgaWYgKCFzdWZmaXguJCRpc19zdHJpbmcpIHtcbiAgICAgICAgc3VmZml4ID0gJGNvZXJjZV90byhzdWZmaXgsICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLnNsaWNlKHNlbGYubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkgPT09IHN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gc2VsZi5zbGljZSgwLCBzZWxmLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgZG93bmNhc2VcbiAgICBgc2VsZi50b0xvd2VyQ2FzZSgpYFxuICBlbmRcblxuICBkZWYgZWFjaF9saW5lKHNlcGFyYXRvciA9ICQvLCBjaG9tcDogZmFsc2UsICZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmVhY2hfbGluZSwgc2VwYXJhdG9yLCBjaG9tcDogY2hvbXAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICBpZiAoc2VwYXJhdG9yID09PSBuaWwpIHtcbiAgICAgICAgT3BhbC55aWVsZDEoYmxvY2ssIHNlbGYpO1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICBzZXBhcmF0b3IgPSAkY29lcmNlX3RvKHNlcGFyYXRvciwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcblxuICAgICAgdmFyIGEsIGksIG4sIGxlbmd0aCwgY2hvbXBlZCwgdHJhaWxpbmcsIHNwbGl0dGVkLCB2YWx1ZTtcblxuICAgICAgaWYgKHNlcGFyYXRvci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZm9yIChhID0gc2VsZi5zcGxpdCgvKCg/Olxccj9cXG4pezJ9KSg/Oig/Olxccj9cXG4pKikvKSwgaSA9IDAsIG4gPSBhLmxlbmd0aDsgaSA8IG47IGkgKz0gMikge1xuICAgICAgICAgIGlmIChhW2ldIHx8IGFbaSArIDFdKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IChhW2ldIHx8IFwiXCIpICsgKGFbaSArIDFdIHx8IFwiXCIpO1xuICAgICAgICAgICAgaWYgKGNob21wKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gI3tgdmFsdWVgLmNob21wKFwiXFxuXCIpfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIGNob21wZWQgID0gI3tjaG9tcChzZXBhcmF0b3IpfTtcbiAgICAgIHRyYWlsaW5nID0gc2VsZi5sZW5ndGggIT0gY2hvbXBlZC5sZW5ndGg7XG4gICAgICBzcGxpdHRlZCA9IGNob21wZWQuc3BsaXQoc2VwYXJhdG9yKTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc3BsaXR0ZWQubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBzcGxpdHRlZFtpXTtcbiAgICAgICAgaWYgKGkgPCBsZW5ndGggLSAxIHx8IHRyYWlsaW5nKSB7XG4gICAgICAgICAgdmFsdWUgKz0gc2VwYXJhdG9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaG9tcCkge1xuICAgICAgICAgIHZhbHVlID0gI3tgdmFsdWVgLmNob21wKHNlcGFyYXRvcil9O1xuICAgICAgICB9XG4gICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZW1wdHk/XG4gICAgYHNlbGYubGVuZ3RoID09PSAwYFxuICBlbmRcblxuICBkZWYgZW5kX3dpdGg/KCpzdWZmaXhlcylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdWZmaXhlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3VmZml4ID0gJGNvZXJjZV90byhzdWZmaXhlc1tpXSwgI3s6OlN0cmluZ30sICd0b19zdHInKS4kdG9fcygpO1xuXG4gICAgICAgIGlmIChzZWxmLmxlbmd0aCA+PSBzdWZmaXgubGVuZ3RoICYmXG4gICAgICAgICAgICBzZWxmLnN1YnN0cihzZWxmLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgsIHN1ZmZpeC5sZW5ndGgpID09IHN1ZmZpeCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIGdzdWIocGF0dGVybiwgcmVwbGFjZW1lbnQgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkICYmIGJsb2NrID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuICN7ZW51bV9mb3IgOmdzdWIsIHBhdHRlcm59O1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gJycsIG1hdGNoX2RhdGEgPSBuaWwsIGluZGV4ID0gMCwgbWF0Y2gsIF9yZXBsYWNlbWVudDtcblxuICAgICAgaWYgKHBhdHRlcm4uJCRpc19yZWdleHApIHtcbiAgICAgICAgcGF0dGVybiA9ICRnbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChwYXR0ZXJuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdHRlcm4gPSAkY29lcmNlX3RvKHBhdHRlcm4sICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKHBhdHRlcm4ucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKSwgJ2dtJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsYXN0SW5kZXg7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBtYXRjaCA9IHBhdHRlcm4uZXhlYyhzZWxmKTtcblxuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAjeyR+ID0gbmlsfVxuICAgICAgICAgIHJlc3VsdCArPSBzZWxmLnNsaWNlKGluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIG1hdGNoX2RhdGEgPSAjezo6TWF0Y2hEYXRhLm5ldyBgcGF0dGVybmAsIGBtYXRjaGB9O1xuXG4gICAgICAgIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGFzdEluZGV4ID0gcGF0dGVybi5sYXN0SW5kZXg7XG4gICAgICAgICAgX3JlcGxhY2VtZW50ID0gYmxvY2sobWF0Y2hbMF0pO1xuICAgICAgICAgIHBhdHRlcm4ubGFzdEluZGV4ID0gbGFzdEluZGV4OyAvLyBzYXZlIGFuZCByZXN0b3JlIGxhc3RJbmRleFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlcGxhY2VtZW50LiQkaXNfaGFzaCkge1xuICAgICAgICAgIF9yZXBsYWNlbWVudCA9ICN7YHJlcGxhY2VtZW50YFtgbWF0Y2hbMF1gXS50b19zfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoIXJlcGxhY2VtZW50LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgICByZXBsYWNlbWVudCA9ICRjb2VyY2VfdG8ocmVwbGFjZW1lbnQsICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9yZXBsYWNlbWVudCA9IHJlcGxhY2VtZW50LnJlcGxhY2UoLyhbXFxcXF0rKShbMC05KyZgJ10pL2csIGZ1bmN0aW9uIChvcmlnaW5hbCwgc2xhc2hlcywgY29tbWFuZCkge1xuICAgICAgICAgICAgaWYgKHNsYXNoZXMubGVuZ3RoICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSBtYXRjaC5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgbWF0Y2hbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIGNhc2UgXCImXCI6IHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgbWF0Y2hbMF07XG4gICAgICAgICAgICBjYXNlIFwiYFwiOiByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIHNlbGYuc2xpY2UoMCwgbWF0Y2guaW5kZXgpO1xuICAgICAgICAgICAgY2FzZSBcIidcIjogcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBzZWxmLnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6ICByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIChtYXRjaFtjb21tYW5kXSB8fCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkucmVwbGFjZSgvXFxcXFxcXFwvZywgJ1xcXFwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXR0ZXJuLmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHtcbiAgICAgICAgICByZXN1bHQgKz0gKHNlbGYuc2xpY2UoaW5kZXgsIG1hdGNoLmluZGV4KSArIF9yZXBsYWNlbWVudCArIChzZWxmW21hdGNoLmluZGV4XSB8fCBcIlwiKSk7XG4gICAgICAgICAgcGF0dGVybi5sYXN0SW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgKz0gKHNlbGYuc2xpY2UoaW5kZXgsIG1hdGNoLmluZGV4KSArIF9yZXBsYWNlbWVudClcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IHBhdHRlcm4ubGFzdEluZGV4O1xuICAgICAgfVxuXG4gICAgICAjeyR+ID0gYG1hdGNoX2RhdGFgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBoZXhcbiAgICB0b19pIDE2XG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlPyhvdGhlcilcbiAgICAleHtcbiAgICAgIGlmICghb3RoZXIuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgb3RoZXIgPSAkY29lcmNlX3RvKG90aGVyLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYuaW5kZXhPZihvdGhlcikgIT09IC0xO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluZGV4KHNlYXJjaCwgb2Zmc2V0ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgdmFyIGluZGV4LFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIHJlZ2V4O1xuXG4gICAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCA9ICRjb2VyY2VfdG8ob2Zmc2V0LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICBvZmZzZXQgKz0gc2VsZi5sZW5ndGg7XG4gICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWFyY2guJCRpc19yZWdleHApIHtcbiAgICAgICAgcmVnZXggPSAkZ2xvYmFsX211bHRpbGluZV9yZWdleHAoc2VhcmNoKTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBtYXRjaCA9IHJlZ2V4LmV4ZWMoc2VsZik7XG4gICAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICAjeyR+ID0gbmlsfTtcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1hdGNoLmluZGV4ID49IG9mZnNldCkge1xuICAgICAgICAgICAgI3skfiA9IDo6TWF0Y2hEYXRhLm5ldyhgcmVnZXhgLCBgbWF0Y2hgKX1cbiAgICAgICAgICAgIGluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVnZXgubGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWFyY2ggPSAkY29lcmNlX3RvKHNlYXJjaCwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcbiAgICAgICAgaWYgKHNlYXJjaC5sZW5ndGggPT09IDAgJiYgb2Zmc2V0ID4gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGV4ID0gc2VsZi5pbmRleE9mKHNlYXJjaCwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5kZXggPT09IC0xID8gbmlsIDogaW5kZXg7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgICV4e1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tbWlzbGVhZGluZy1jaGFyYWN0ZXItY2xhc3MgKi9cbiAgICAgIHZhciBlc2NhcGFibGUgPSAvW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHUwMDdGLVxcdTAwOUZcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgICAgICAgIG1ldGEgPSB7XG4gICAgICAgICAgICAnXFx1MDAwNyc6ICdcXFxcYScsXG4gICAgICAgICAgICAnXFx1MDAxYic6ICdcXFxcZScsXG4gICAgICAgICAgICAnXFxiJzogJ1xcXFxiJyxcbiAgICAgICAgICAgICdcXHQnOiAnXFxcXHQnLFxuICAgICAgICAgICAgJ1xcbic6ICdcXFxcbicsXG4gICAgICAgICAgICAnXFxmJzogJ1xcXFxmJyxcbiAgICAgICAgICAgICdcXHInOiAnXFxcXHInLFxuICAgICAgICAgICAgJ1xcdic6ICdcXFxcdicsXG4gICAgICAgICAgICAnXCInIDogJ1xcXFxcIicsXG4gICAgICAgICAgICAnXFxcXCc6ICdcXFxcXFxcXCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVzY2FwZWQgPSBzZWxmLnJlcGxhY2UoZXNjYXBhYmxlLCBmdW5jdGlvbiAoY2hyKSB7XG4gICAgICAgICAgICBpZiAobWV0YVtjaHJdKSByZXR1cm4gbWV0YVtjaHJdO1xuICAgICAgICAgICAgY2hyID0gY2hyLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBpZiAoY2hyIDw9IDB4ZmYgJiYgKHNlbGYuZW5jb2RpbmdbXCIkYmluYXJ5P1wiXSgpIHx8IHNlbGYuaW50ZXJuYWxfZW5jb2RpbmdbXCIkYmluYXJ5P1wiXSgpKSkge1xuICAgICAgICAgICAgICByZXR1cm4gJ1xcXFx4JyArICgnMDAnICsgY2hyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKS5zbGljZSgtMik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gJ1xcXFx1JyArICgnMDAwMCcgKyBjaHIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC00KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIHJldHVybiAnXCInICsgZXNjYXBlZC5yZXBsYWNlKC9cXCNbXFwkXFxAXFx7XS9nLCAnXFxcXCQmJykgKyAnXCInO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1taXNsZWFkaW5nLWNoYXJhY3Rlci1jbGFzcyAqL1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGludGVyblxuICAgIGBzZWxmLnRvU3RyaW5nKClgXG4gIGVuZFxuXG4gIGRlZiBsZW5ndGhcbiAgICBgc2VsZi5sZW5ndGhgXG4gIGVuZFxuXG4gIGFsaWFzIHNpemUgbGVuZ3RoXG5cbiAgZGVmIGxpbmVzKHNlcGFyYXRvciA9ICQvLCBjaG9tcDogZmFsc2UsICZibG9jaylcbiAgICBlID0gZWFjaF9saW5lKHNlcGFyYXRvciwgY2hvbXA6IGNob21wLCAmYmxvY2spXG4gICAgYmxvY2sgPyBzZWxmIDogZS50b19hXG4gIGVuZFxuXG4gIGRlZiBsanVzdCh3aWR0aCwgcGFkc3RyID0gJyAnKVxuICAgIHdpZHRoICA9IGAkY29lcmNlX3RvKCN7d2lkdGh9LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICBwYWRzdHIgPSBgJGNvZXJjZV90bygje3BhZHN0cn0sICN7OjpTdHJpbmd9LCAndG9fc3RyJylgLnRvX3NcblxuICAgIGlmIHBhZHN0ci5lbXB0eT9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3plcm8gd2lkdGggcGFkZGluZydcbiAgICBlbmRcblxuICAgIHJldHVybiBzZWxmIGlmIGB3aWR0aCA8PSBzZWxmLmxlbmd0aGBcblxuICAgICV4e1xuICAgICAgdmFyIGluZGV4ICA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IFwiXCI7XG5cbiAgICAgIHdpZHRoIC09IHNlbGYubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IHdpZHRoKSB7XG4gICAgICAgIHJlc3VsdCArPSBwYWRzdHI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmICsgcmVzdWx0LnNsaWNlKDAsIHdpZHRoKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsc3RyaXBcbiAgICBgc2VsZi5yZXBsYWNlKC9eW1xceDAwXFx4MDlcXHgwYS1cXHgwZFxceDIwXSovLCAnJylgXG4gIGVuZFxuXG4gIGRlZiBhc2NpaV9vbmx5P1xuICAgICMgbm9uLUFTQ0lJLWNvbXBhdGlibGUgZW5jb2RpbmcgbXVzdCByZXR1cm4gZmFsc2VcbiAgICAleHtcbiAgICAgIGlmICghc2VsZi5lbmNvZGluZy5hc2NpaSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIC9eW1xceDAwLVxceDdGXSokLy50ZXN0KHNlbGYpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1hdGNoKHBhdHRlcm4sIHBvcyA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIFN0cmluZyA9PT0gcGF0dGVybiB8fCBwYXR0ZXJuLnJlc3BvbmRfdG8/KDp0b19zdHIpXG4gICAgICBwYXR0ZXJuID0gOjpSZWdleHAubmV3KHBhdHRlcm4udG9fc3RyKVxuICAgIGVuZFxuXG4gICAgdW5sZXNzIDo6UmVnZXhwID09PSBwYXR0ZXJuXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7cGF0dGVybi5jbGFzc30gKGV4cGVjdGVkIFJlZ2V4cClcIlxuICAgIGVuZFxuXG4gICAgcGF0dGVybi5tYXRjaChzZWxmLCBwb3MsICZibG9jaylcbiAgZW5kXG5cbiAgZGVmIG1hdGNoPyhwYXR0ZXJuLCBwb3MgPSB1bmRlZmluZWQpXG4gICAgaWYgU3RyaW5nID09PSBwYXR0ZXJuIHx8IHBhdHRlcm4ucmVzcG9uZF90bz8oOnRvX3N0cilcbiAgICAgIHBhdHRlcm4gPSA6OlJlZ2V4cC5uZXcocGF0dGVybi50b19zdHIpXG4gICAgZW5kXG5cbiAgICB1bmxlc3MgOjpSZWdleHAgPT09IHBhdHRlcm5cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3twYXR0ZXJuLmNsYXNzfSAoZXhwZWN0ZWQgUmVnZXhwKVwiXG4gICAgZW5kXG5cbiAgICBwYXR0ZXJuLm1hdGNoPyhzZWxmLCBwb3MpXG4gIGVuZFxuXG4gIGRlZiBuZXh0XG4gICAgJXh7XG4gICAgICB2YXIgaSA9IHNlbGYubGVuZ3RoO1xuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHNlbGY7XG4gICAgICB2YXIgZmlyc3RfYWxwaGFudW1fY2hhcl9pbmRleCA9IHNlbGYuc2VhcmNoKC9bYS16QS1aMC05XS8pO1xuICAgICAgdmFyIGNhcnJ5ID0gZmFsc2U7XG4gICAgICB2YXIgY29kZTtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY29kZSA9IHNlbGYuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHx8XG4gICAgICAgICAgKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA5MCkgfHxcbiAgICAgICAgICAoY29kZSA+PSA5NyAmJiBjb2RlIDw9IDEyMikpIHtcbiAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICBjYXNlIDU3OlxuICAgICAgICAgICAgY2FycnkgPSB0cnVlO1xuICAgICAgICAgICAgY29kZSA9IDQ4O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA5MDpcbiAgICAgICAgICAgIGNhcnJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvZGUgPSA2NTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTIyOlxuICAgICAgICAgICAgY2FycnkgPSB0cnVlO1xuICAgICAgICAgICAgY29kZSA9IDk3O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhcnJ5ID0gZmFsc2U7XG4gICAgICAgICAgICBjb2RlICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChmaXJzdF9hbHBoYW51bV9jaGFyX2luZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKGNvZGUgPT09IDI1NSkge1xuICAgICAgICAgICAgICBjYXJyeSA9IHRydWU7XG4gICAgICAgICAgICAgIGNvZGUgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2FycnkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgY29kZSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYXJyeSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBpKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgKyByZXN1bHQuc2xpY2UoaSArIDEpO1xuICAgICAgICBpZiAoY2FycnkgJiYgKGkgPT09IDAgfHwgaSA9PT0gZmlyc3RfYWxwaGFudW1fY2hhcl9pbmRleCkpIHtcbiAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICBjYXNlIDY1OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA5NzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb2RlICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpICsgcmVzdWx0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgaSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpICsgcmVzdWx0LnNsaWNlKGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXJyeSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2FycnkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBvY3RcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgc3RyaW5nID0gc2VsZixcbiAgICAgICAgICByYWRpeCA9IDg7XG5cbiAgICAgIGlmICgvXlxccypfLy50ZXN0KHN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9eKFxccypbKy1dPykoMFtib2R4XT8pKC4rKSQvaSwgZnVuY3Rpb24gKG9yaWdpbmFsLCBoZWFkLCBmbGFnLCB0YWlsKSB7XG4gICAgICAgIHN3aXRjaCAodGFpbC5jaGFyQXQoMCkpIHtcbiAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgICAgaWYgKHRhaWwuY2hhckF0KDEpID09PSAneCcgJiYgZmxhZyA9PT0gJzB4Jykge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGZsYWcpIHtcbiAgICAgICAgY2FzZSAnMGInOlxuICAgICAgICAgIHJhZGl4ID0gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgIGNhc2UgJzBvJzpcbiAgICAgICAgICByYWRpeCA9IDg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzBkJzpcbiAgICAgICAgICByYWRpeCA9IDEwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcweCc6XG4gICAgICAgICAgcmFkaXggPSAxNjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZCArIHRhaWw7XG4gICAgICB9KTtcblxuICAgICAgcmVzdWx0ID0gcGFyc2VJbnQoc3RyaW5nLnJlcGxhY2UoL18oPyFfKS9nLCAnJyksIHJhZGl4KTtcbiAgICAgIHJldHVybiBpc05hTihyZXN1bHQpID8gMCA6IHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBvcmRcbiAgICAleHtcbiAgICAgIGlmICh0eXBlb2Ygc2VsZi5jb2RlUG9pbnRBdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmNvZGVQb2ludEF0KDApO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxmLmNoYXJDb2RlQXQoMCk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgcGFydGl0aW9uKHNlcClcbiAgICAleHtcbiAgICAgIHZhciBpLCBtO1xuXG4gICAgICBpZiAoc2VwLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgIG0gPSBzZXAuZXhlYyhzZWxmKTtcbiAgICAgICAgaWYgKG0gPT09IG51bGwpIHtcbiAgICAgICAgICBpID0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgI3s6Ok1hdGNoRGF0YS5uZXcgYHNlcGAsIGBtYH07XG4gICAgICAgICAgc2VwID0gbVswXTtcbiAgICAgICAgICBpID0gbS5pbmRleDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VwID0gJGNvZXJjZV90byhzZXAsICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICAgIGkgPSBzZWxmLmluZGV4T2Yoc2VwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBbc2VsZiwgJycsICcnXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgc2VsZi5zbGljZSgwLCBpKSxcbiAgICAgICAgc2VsZi5zbGljZShpLCBpICsgc2VwLmxlbmd0aCksXG4gICAgICAgIHNlbGYuc2xpY2UoaSArIHNlcC5sZW5ndGgpXG4gICAgICBdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJldmVyc2VcbiAgICBgc2VsZi5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpYFxuICBlbmRcblxuICBkZWYgcmluZGV4KHNlYXJjaCwgb2Zmc2V0ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgdmFyIGksIG0sIHIsIF9tO1xuXG4gICAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb2Zmc2V0ID0gc2VsZi5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgPSAkY29lcmNlX3RvKG9mZnNldCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VhcmNoLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgIG0gPSBudWxsO1xuICAgICAgICByID0gJGdsb2JhbF9tdWx0aWxpbmVfcmVnZXhwKHNlYXJjaCk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgX20gPSByLmV4ZWMoc2VsZik7XG4gICAgICAgICAgaWYgKF9tID09PSBudWxsIHx8IF9tLmluZGV4ID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbSA9IF9tO1xuICAgICAgICAgIHIubGFzdEluZGV4ID0gbS5pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG0gPT09IG51bGwpIHtcbiAgICAgICAgICAjeyR+ID0gbmlsfVxuICAgICAgICAgIGkgPSAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAjezo6TWF0Y2hEYXRhLm5ldyBgcmAsIGBtYH07XG4gICAgICAgICAgaSA9IG0uaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlYXJjaCA9ICRjb2VyY2VfdG8oc2VhcmNoLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBpID0gc2VsZi5sYXN0SW5kZXhPZihzZWFyY2gsIG9mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpID09PSAtMSA/IG5pbCA6IGk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmp1c3Qod2lkdGgsIHBhZHN0ciA9ICcgJylcbiAgICB3aWR0aCAgPSBgJGNvZXJjZV90bygje3dpZHRofSwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG4gICAgcGFkc3RyID0gYCRjb2VyY2VfdG8oI3twYWRzdHJ9LCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpYC50b19zXG5cbiAgICBpZiBwYWRzdHIuZW1wdHk/XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd6ZXJvIHdpZHRoIHBhZGRpbmcnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gc2VsZiBpZiBgd2lkdGggPD0gc2VsZi5sZW5ndGhgXG5cbiAgICAleHtcbiAgICAgIHZhciBjaGFycyAgICAgPSBNYXRoLmZsb29yKHdpZHRoIC0gc2VsZi5sZW5ndGgpLFxuICAgICAgICAgIHBhdHRlcm5zICA9IE1hdGguZmxvb3IoY2hhcnMgLyBwYWRzdHIubGVuZ3RoKSxcbiAgICAgICAgICByZXN1bHQgICAgPSBBcnJheShwYXR0ZXJucyArIDEpLmpvaW4ocGFkc3RyKSxcbiAgICAgICAgICByZW1haW5pbmcgPSBjaGFycyAtIHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgIHJldHVybiByZXN1bHQgKyBwYWRzdHIuc2xpY2UoMCwgcmVtYWluaW5nKSArIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcnBhcnRpdGlvbihzZXApXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbSwgciwgX207XG5cbiAgICAgIGlmIChzZXAuJCRpc19yZWdleHApIHtcbiAgICAgICAgbSA9IG51bGw7XG4gICAgICAgIHIgPSAkZ2xvYmFsX211bHRpbGluZV9yZWdleHAoc2VwKTtcblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIF9tID0gci5leGVjKHNlbGYpO1xuICAgICAgICAgIGlmIChfbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIG0gPSBfbTtcbiAgICAgICAgICByLmxhc3RJbmRleCA9IG0uaW5kZXggKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG0gPT09IG51bGwpIHtcbiAgICAgICAgICBpID0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgI3s6Ok1hdGNoRGF0YS5uZXcgYHJgLCBgbWB9O1xuICAgICAgICAgIHNlcCA9IG1bMF07XG4gICAgICAgICAgaSA9IG0uaW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VwID0gJGNvZXJjZV90byhzZXAsICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICAgIGkgPSBzZWxmLmxhc3RJbmRleE9mKHNlcCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gWycnLCAnJywgc2VsZl07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHNlbGYuc2xpY2UoMCwgaSksXG4gICAgICAgIHNlbGYuc2xpY2UoaSwgaSArIHNlcC5sZW5ndGgpLFxuICAgICAgICBzZWxmLnNsaWNlKGkgKyBzZXAubGVuZ3RoKVxuICAgICAgXTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByc3RyaXBcbiAgICBgc2VsZi5yZXBsYWNlKC9bXFx4MDBcXHgwOVxceDBhLVxceDBkXFx4MjBdKiQvLCAnJylgXG4gIGVuZFxuXG4gIGRlZiBzY2FuKHBhdHRlcm4sIG5vX21hdGNoZGF0YTogZmFsc2UsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICBtYXRjaF9kYXRhID0gbmlsLFxuICAgICAgICAgIG1hdGNoO1xuXG4gICAgICBpZiAocGF0dGVybi4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBwYXR0ZXJuID0gJGdsb2JhbF9tdWx0aWxpbmVfcmVnZXhwKHBhdHRlcm4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0dGVybiA9ICRjb2VyY2VfdG8ocGF0dGVybiwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcbiAgICAgICAgcGF0dGVybiA9IG5ldyBSZWdFeHAocGF0dGVybi5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpLCAnZ20nKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKChtYXRjaCA9IHBhdHRlcm4uZXhlYyhzZWxmKSkgIT0gbnVsbCkge1xuICAgICAgICBtYXRjaF9kYXRhID0gI3s6Ok1hdGNoRGF0YS5uZXcgYHBhdHRlcm5gLCBgbWF0Y2hgLCBub19tYXRjaGRhdGE6IG5vX21hdGNoZGF0YX07XG4gICAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgICAgbWF0Y2gubGVuZ3RoID09IDEgPyByZXN1bHQucHVzaChtYXRjaFswXSkgOiByZXN1bHQucHVzaCgje2BtYXRjaF9kYXRhYC5jYXB0dXJlc30pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoLmxlbmd0aCA9PSAxID8gT3BhbC55aWVsZDEoYmxvY2ssIG1hdGNoWzBdKSA6IE9wYWwueWllbGQxKGJsb2NrLCAje2BtYXRjaF9kYXRhYC5jYXB0dXJlc30pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXR0ZXJuLmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHtcbiAgICAgICAgICBwYXR0ZXJuLmxhc3RJbmRleCArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghbm9fbWF0Y2hkYXRhKSAjeyR+ID0gYG1hdGNoX2RhdGFgfTtcblxuICAgICAgcmV0dXJuIChibG9jayAhPT0gbmlsID8gc2VsZiA6IHJlc3VsdCk7XG4gICAgfVxuICBlbmRcblxuICAjIFdlIHJlZGVmaW5lIHRoaXMgbWV0aG9kIG9uIFN0cmluZywgYXMga2VybmVsLnJiIGlzIGluIHN0cmljdCBtb2RlXG4gICMgc28gdGhhdCB0aGluZ3MgbGlrZSBCb29sZWFuIGRvbid0IGdldCBib3hlZC4gRm9yIFN0cmluZyB0aG91Z2ggLVxuICAjIHdlIGVpdGhlciBuZWVkIHRvIGJveCBpdCB0byBkZWZpbmUgcHJvcGVydGllcyBvbiBpdCwgb3IgcnVuIGl0IGluXG4gICMgbm9uLXN0cmljdCBtb2RlLiBUaGlzIGlzIGEgbWVzcyBhbmQgd2UgbmVlZCB0byBjb21lIGJhY2sgdG8gaXRcbiAgIyBhdCBhIGxhdGVyIHRpbWUuXG4gIGRlZiBzaW5nbGV0b25fY2xhc3NcbiAgICBgT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzKHNlbGYpYFxuICBlbmRcblxuICBkZWYgc3BsaXQocGF0dGVybiA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsaW1pdCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW1pdCA9ICN7OjpPcGFsLmNvZXJjZV90byEobGltaXQsIDo6SW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgICBpZiAobGltaXQgPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gW3NlbGZdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQgfHwgcGF0dGVybiA9PT0gbmlsKSB7XG4gICAgICAgIHBhdHRlcm4gPSAjeyQ7IHx8ICcgJ307XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICBzdHJpbmcgPSBzZWxmLnRvU3RyaW5nKCksXG4gICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIG1hdGNoX2NvdW50ID0gMCxcbiAgICAgICAgICB2YWxpZF9yZXN1bHRfbGVuZ3RoID0gMCxcbiAgICAgICAgICBpLCBtYXg7XG5cbiAgICAgIGlmIChwYXR0ZXJuLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgIHBhdHRlcm4gPSAkZ2xvYmFsX211bHRpbGluZV9yZWdleHAocGF0dGVybik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXR0ZXJuID0gJGNvZXJjZV90byhwYXR0ZXJuLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpLiR0b19zKCk7XG5cbiAgICAgICAgaWYgKHBhdHRlcm4gPT09ICcgJykge1xuICAgICAgICAgIHBhdHRlcm4gPSAvXFxzKy9nbTtcbiAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXlxccysvLCAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzdWx0ID0gc3RyaW5nLnNwbGl0KHBhdHRlcm4pO1xuXG4gICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMSAmJiByZXN1bHRbMF0gPT09IHN0cmluZykge1xuICAgICAgICByZXR1cm4gW3Jlc3VsdFswXV07XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICgoaSA9IHJlc3VsdC5pbmRleE9mKHVuZGVmaW5lZCkpICE9PSAtMSkge1xuICAgICAgICByZXN1bHQuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAobGltaXQgPT09IDApIHtcbiAgICAgICAgd2hpbGUgKHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPT09ICcnKSB7XG4gICAgICAgICAgcmVzdWx0LnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghcGF0dGVybi4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBwYXR0ZXJuID0gT3BhbC5lc2NhcGVfcmVnZXhwKHBhdHRlcm4pXG4gICAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKHBhdHRlcm4sICdnbScpO1xuICAgICAgfVxuXG4gICAgICBtYXRjaCA9IHBhdHRlcm4uZXhlYyhzdHJpbmcpO1xuXG4gICAgICBpZiAobGltaXQgPCAwKSB7XG4gICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCAmJiBtYXRjaFswXSA9PT0gJycgJiYgcGF0dGVybi5zb3VyY2UuaW5kZXhPZignKD89JykgPT09IC0xKSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgbWF4ID0gbWF0Y2gubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoICE9PSBudWxsICYmIG1hdGNoWzBdID09PSAnJykge1xuICAgICAgICB2YWxpZF9yZXN1bHRfbGVuZ3RoID0gKG1hdGNoLmxlbmd0aCAtIDEpICogKGxpbWl0IC0gMSkgKyBsaW1pdFxuICAgICAgICByZXN1bHQuc3BsaWNlKHZhbGlkX3Jlc3VsdF9sZW5ndGggLSAxLCByZXN1bHQubGVuZ3RoIC0gMSwgcmVzdWx0LnNsaWNlKHZhbGlkX3Jlc3VsdF9sZW5ndGggLSAxKS5qb2luKCcnKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChsaW1pdCA+PSByZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICBtYXRjaF9jb3VudCsrO1xuICAgICAgICBpbmRleCA9IHBhdHRlcm4ubGFzdEluZGV4O1xuICAgICAgICB2YWxpZF9yZXN1bHRfbGVuZ3RoICs9IG1hdGNoLmxlbmd0aFxuICAgICAgICBpZiAobWF0Y2hfY291bnQgKyAxID09PSBsaW1pdCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoID0gcGF0dGVybi5leGVjKHN0cmluZyk7XG4gICAgICB9XG4gICAgICByZXN1bHQuc3BsaWNlKHZhbGlkX3Jlc3VsdF9sZW5ndGgsIHJlc3VsdC5sZW5ndGggLSAxLCBzdHJpbmcuc2xpY2UoaW5kZXgpKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3F1ZWV6ZSgqc2V0cylcbiAgICAleHtcbiAgICAgIGlmIChzZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gc2VsZi5yZXBsYWNlKC8oLilcXDErL2csICckMScpO1xuICAgICAgfVxuICAgICAgdmFyIGNoYXJfY2xhc3MgPSBjaGFyX2NsYXNzX2Zyb21fY2hhcl9zZXRzKHNldHMpO1xuICAgICAgaWYgKGNoYXJfY2xhc3MgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5yZXBsYWNlKG5ldyBSZWdFeHAoJygnICsgY2hhcl9jbGFzcyArICcpXFxcXDErJywgJ2cnKSwgJyQxJyk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3RhcnRfd2l0aD8oKnByZWZpeGVzKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHByZWZpeGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwcmVmaXhlc1tpXS4kJGlzX3JlZ2V4cCkge1xuICAgICAgICAgIHZhciByZWdleHAgPSBwcmVmaXhlc1tpXTtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSByZWdleHAuZXhlYyhzZWxmKTtcblxuICAgICAgICAgIGlmIChtYXRjaCAhPSBudWxsICYmIG1hdGNoLmluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAjeyR+ID0gOjpNYXRjaERhdGEubmV3KGByZWdleHBgLCBgbWF0Y2hgKX07XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgI3skfiA9IG5pbH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZWZpeCA9ICRjb2VyY2VfdG8ocHJlZml4ZXNbaV0sICN7OjpTdHJpbmd9LCAndG9fc3RyJykuJHRvX3MoKTtcblxuICAgICAgICAgIGlmIChzZWxmLmxlbmd0aCA+PSBwcmVmaXgubGVuZ3RoICYmIHNlbGYuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHN0cmlwXG4gICAgYHNlbGYucmVwbGFjZSgvXltcXHgwMFxceDA5XFx4MGEtXFx4MGRcXHgyMF0qfFtcXHgwMFxceDA5XFx4MGEtXFx4MGRcXHgyMF0qJC9nLCAnJylgXG4gIGVuZFxuXG4gIGRlZiBzdWIocGF0dGVybiwgcmVwbGFjZW1lbnQgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmICghcGF0dGVybi4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBwYXR0ZXJuID0gJGNvZXJjZV90byhwYXR0ZXJuLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJykpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0LCBtYXRjaCA9IHBhdHRlcm4uZXhlYyhzZWxmKTtcblxuICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICN7JH4gPSBuaWx9XG4gICAgICAgIHJlc3VsdCA9IHNlbGYudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICN7OjpNYXRjaERhdGEubmV3IGBwYXR0ZXJuYCwgYG1hdGNoYH1cblxuICAgICAgICBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgaWYgKGJsb2NrID09PSBuaWwpIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMSBmb3IgMiknfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBzZWxmLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArIGJsb2NrKG1hdGNoWzBdKSArIHNlbGYuc2xpY2UobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVwbGFjZW1lbnQuJCRpc19oYXNoKSB7XG5cbiAgICAgICAgICByZXN1bHQgPSBzZWxmLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArICN7YHJlcGxhY2VtZW50YFtgbWF0Y2hbMF1gXS50b19zfSArIHNlbGYuc2xpY2UobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICByZXBsYWNlbWVudCA9ICRjb2VyY2VfdG8ocmVwbGFjZW1lbnQsICN7OjpTdHJpbmd9LCAndG9fc3RyJyk7XG5cbiAgICAgICAgICByZXBsYWNlbWVudCA9IHJlcGxhY2VtZW50LnJlcGxhY2UoLyhbXFxcXF0rKShbMC05KyZgJ10pL2csIGZ1bmN0aW9uIChvcmlnaW5hbCwgc2xhc2hlcywgY29tbWFuZCkge1xuICAgICAgICAgICAgaWYgKHNsYXNoZXMubGVuZ3RoICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSBtYXRjaC5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgbWF0Y2hbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIGNhc2UgXCImXCI6IHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgbWF0Y2hbMF07XG4gICAgICAgICAgICBjYXNlIFwiYFwiOiByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIHNlbGYuc2xpY2UoMCwgbWF0Y2guaW5kZXgpO1xuICAgICAgICAgICAgY2FzZSBcIidcIjogcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBzZWxmLnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6ICByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIChtYXRjaFtjb21tYW5kXSB8fCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkucmVwbGFjZSgvXFxcXFxcXFwvZywgJ1xcXFwnKTtcblxuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgcmVwbGFjZW1lbnQgKyBzZWxmLnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHN1bShuID0gMTYpXG4gICAgJXh7XG4gICAgICBuID0gJGNvZXJjZV90byhuLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGgsXG4gICAgICAgICAgaSA9IDA7XG5cbiAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICs9IHNlbGYuY2hhckNvZGVBdChpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPD0gMCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0ICYgKE1hdGgucG93KDIsIG4pIC0gMSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3dhcGNhc2VcbiAgICAleHtcbiAgICAgIHZhciBzdHIgPSBzZWxmLnJlcGxhY2UoLyhbYS16XSspfChbQS1aXSspL2csIGZ1bmN0aW9uKCQwLCQxLCQyKSB7XG4gICAgICAgIHJldHVybiAkMSA/ICQwLnRvVXBwZXJDYXNlKCkgOiAkMC50b0xvd2VyQ2FzZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9fZlxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuY2hhckF0KDApID09PSAnXycpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBwYXJzZUZsb2F0KHNlbGYucmVwbGFjZSgvXy9nLCAnJykpO1xuXG4gICAgICBpZiAoaXNOYU4ocmVzdWx0KSB8fCByZXN1bHQgPT0gSW5maW5pdHkgfHwgcmVzdWx0ID09IC1JbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRvX2koYmFzZSA9IDEwKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBzdHJpbmcgPSBzZWxmLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgcmFkaXggPSAkY29lcmNlX3RvKGJhc2UsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAocmFkaXggPT09IDEgfHwgcmFkaXggPCAwIHx8IHJhZGl4ID4gMzYpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCByYWRpeCAje2ByYWRpeGB9XCJ9XG4gICAgICB9XG5cbiAgICAgIGlmICgvXlxccypfLy50ZXN0KHN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9eKFxccypbKy1dPykoMFtib2R4XT8pKC4rKSQvLCBmdW5jdGlvbiAob3JpZ2luYWwsIGhlYWQsIGZsYWcsIHRhaWwpIHtcbiAgICAgICAgc3dpdGNoICh0YWlsLmNoYXJBdCgwKSkge1xuICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgICBpZiAodGFpbC5jaGFyQXQoMSkgPT09ICd4JyAmJiBmbGFnID09PSAnMHgnICYmIChyYWRpeCA9PT0gMCB8fCByYWRpeCA9PT0gMTYpKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZmxhZykge1xuICAgICAgICBjYXNlICcwYic6XG4gICAgICAgICAgaWYgKHJhZGl4ID09PSAwIHx8IHJhZGl4ID09PSAyKSB7XG4gICAgICAgICAgICByYWRpeCA9IDI7XG4gICAgICAgICAgICByZXR1cm4gaGVhZCArIHRhaWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgY2FzZSAnMG8nOlxuICAgICAgICAgIGlmIChyYWRpeCA9PT0gMCB8fCByYWRpeCA9PT0gOCkge1xuICAgICAgICAgICAgcmFkaXggPSA4O1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQgKyB0YWlsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnMGQnOlxuICAgICAgICAgIGlmIChyYWRpeCA9PT0gMCB8fCByYWRpeCA9PT0gMTApIHtcbiAgICAgICAgICAgIHJhZGl4ID0gMTA7XG4gICAgICAgICAgICByZXR1cm4gaGVhZCArIHRhaWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcweCc6XG4gICAgICAgICAgaWYgKHJhZGl4ID09PSAwIHx8IHJhZGl4ID09PSAxNikge1xuICAgICAgICAgICAgcmFkaXggPSAxNjtcbiAgICAgICAgICAgIHJldHVybiBoZWFkICsgdGFpbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsXG4gICAgICB9KTtcblxuICAgICAgcmVzdWx0ID0gcGFyc2VJbnQoc3RyaW5nLnJlcGxhY2UoL18oPyFfKS9nLCAnJyksIHJhZGl4KTtcbiAgICAgIHJldHVybiBpc05hTihyZXN1bHQpID8gMCA6IHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19wcm9jXG4gICAgbWV0aG9kX25hbWUgPSBgc2VsZi52YWx1ZU9mKClgXG4gICAganNpZCA9IGBPcGFsLmpzaWQobWV0aG9kX25hbWUpYFxuXG4gICAgcHJvYyA9IDo6S2VybmVsLnByb2MgZG8gfCphcmdzLCAmYmxvY2t8XG4gICAgICAleHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdubyByZWNlaXZlciBnaXZlbid9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVjdiA9IGFyZ3NbMF07XG5cbiAgICAgICAgaWYgKHJlY3YgPT0gbnVsbCkgcmVjdiA9IG5pbDtcblxuICAgICAgICB2YXIgYm9keSA9IHJlY3ZbanNpZF07XG5cbiAgICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgICAgYm9keSA9IHJlY3YuJG1ldGhvZF9taXNzaW5nO1xuICAgICAgICAgIGFyZ3NbMF0gPSAje21ldGhvZF9uYW1lfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcmdzID0gYXJncy5zbGljZSgxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYmxvY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBib2R5LiQkcCA9IGJsb2NrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGJvZHkuY2FsbChyZWN2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYm9keS5hcHBseShyZWN2LCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuXG4gICAgYHByb2MuJCRzb3VyY2VfbG9jYXRpb24gPSBuaWxgXG5cbiAgICBwcm9jXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgYHNlbGYudG9TdHJpbmcoKWBcbiAgZW5kXG5cbiAgZGVmIHRyKGZyb20sIHRvKVxuICAgICV4e1xuICAgICAgZnJvbSA9ICRjb2VyY2VfdG8oZnJvbSwgI3s6OlN0cmluZ30sICd0b19zdHInKS4kdG9fcygpO1xuICAgICAgdG8gPSAkY29lcmNlX3RvKHRvLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpLiR0b19zKCk7XG5cbiAgICAgIGlmIChmcm9tLmxlbmd0aCA9PSAwIHx8IGZyb20gPT09IHRvKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICB2YXIgaSwgaW5fcmFuZ2UsIGMsIGNoLCBzdGFydCwgZW5kLCBsZW5ndGg7XG4gICAgICB2YXIgc3VicyA9IHt9O1xuICAgICAgdmFyIGZyb21fY2hhcnMgPSBmcm9tLnNwbGl0KCcnKTtcbiAgICAgIHZhciBmcm9tX2xlbmd0aCA9IGZyb21fY2hhcnMubGVuZ3RoO1xuICAgICAgdmFyIHRvX2NoYXJzID0gdG8uc3BsaXQoJycpO1xuICAgICAgdmFyIHRvX2xlbmd0aCA9IHRvX2NoYXJzLmxlbmd0aDtcblxuICAgICAgdmFyIGludmVyc2UgPSBmYWxzZTtcbiAgICAgIHZhciBnbG9iYWxfc3ViID0gbnVsbDtcbiAgICAgIGlmIChmcm9tX2NoYXJzWzBdID09PSAnXicgJiYgZnJvbV9jaGFycy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGludmVyc2UgPSB0cnVlO1xuICAgICAgICBmcm9tX2NoYXJzLnNoaWZ0KCk7XG4gICAgICAgIGdsb2JhbF9zdWIgPSB0b19jaGFyc1t0b19sZW5ndGggLSAxXVxuICAgICAgICBmcm9tX2xlbmd0aCAtPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgZnJvbV9jaGFyc19leHBhbmRlZCA9IFtdO1xuICAgICAgdmFyIGxhc3RfZnJvbSA9IG51bGw7XG4gICAgICBpbl9yYW5nZSA9IGZhbHNlO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGZyb21fbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2ggPSBmcm9tX2NoYXJzW2ldO1xuICAgICAgICBpZiAobGFzdF9mcm9tID09IG51bGwpIHtcbiAgICAgICAgICBsYXN0X2Zyb20gPSBjaDtcbiAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAnLScpIHtcbiAgICAgICAgICBpZiAobGFzdF9mcm9tID09PSAnLScpIHtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGkgPT0gZnJvbV9sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbl9yYW5nZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluX3JhbmdlKSB7XG4gICAgICAgICAgc3RhcnQgPSBsYXN0X2Zyb20uY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICBlbmQgPSBjaC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCByYW5nZSBcXFwiI3tgU3RyaW5nLmZyb21DaGFyQ29kZShzdGFydClgfS0je2BTdHJpbmcuZnJvbUNoYXJDb2RlKGVuZClgfVxcXCIgaW4gc3RyaW5nIHRyYW5zbGl0ZXJhdGlvblwifVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGMgPSBzdGFydCArIDE7IGMgPCBlbmQ7IGMrKykge1xuICAgICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICAgIGluX3JhbmdlID0gbnVsbDtcbiAgICAgICAgICBsYXN0X2Zyb20gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnJvbV9jaGFycyA9IGZyb21fY2hhcnNfZXhwYW5kZWQ7XG4gICAgICBmcm9tX2xlbmd0aCA9IGZyb21fY2hhcnMubGVuZ3RoO1xuXG4gICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZnJvbV9sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHN1YnNbZnJvbV9jaGFyc1tpXV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHRvX2xlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgdG9fY2hhcnNfZXhwYW5kZWQgPSBbXTtcbiAgICAgICAgICB2YXIgbGFzdF90byA9IG51bGw7XG4gICAgICAgICAgaW5fcmFuZ2UgPSBmYWxzZTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9fbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNoID0gdG9fY2hhcnNbaV07XG4gICAgICAgICAgICBpZiAobGFzdF90byA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGxhc3RfdG8gPSBjaDtcbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0X3RvID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGkgPT0gdG9fbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbl9yYW5nZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluX3JhbmdlKSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gbGFzdF90by5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICBlbmQgPSBjaC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhbmdlIFxcXCIje2BTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXJ0KWB9LSN7YFN0cmluZy5mcm9tQ2hhckNvZGUoZW5kKWB9XFxcIiBpbiBzdHJpbmcgdHJhbnNsaXRlcmF0aW9uXCJ9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yIChjID0gc3RhcnQgKyAxOyBjIDwgZW5kOyBjKyspIHtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICAgICAgICBpbl9yYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgIGxhc3RfdG8gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRvX2NoYXJzID0gdG9fY2hhcnNfZXhwYW5kZWQ7XG4gICAgICAgICAgdG9fbGVuZ3RoID0gdG9fY2hhcnMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbmd0aF9kaWZmID0gZnJvbV9sZW5ndGggLSB0b19sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGhfZGlmZiA+IDApIHtcbiAgICAgICAgICB2YXIgcGFkX2NoYXIgPSAodG9fbGVuZ3RoID4gMCA/IHRvX2NoYXJzW3RvX2xlbmd0aCAtIDFdIDogJycpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGhfZGlmZjsgaSsrKSB7XG4gICAgICAgICAgICB0b19jaGFycy5wdXNoKHBhZF9jaGFyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZnJvbV9sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHN1YnNbZnJvbV9jaGFyc1tpXV0gPSB0b19jaGFyc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbmV3X3N0ciA9ICcnXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoID0gc2VsZi5jaGFyQXQoaSk7XG4gICAgICAgIHZhciBzdWIgPSBzdWJzW2NoXTtcbiAgICAgICAgaWYgKGludmVyc2UpIHtcbiAgICAgICAgICBuZXdfc3RyICs9IChzdWIgPT0gbnVsbCA/IGdsb2JhbF9zdWIgOiBjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbmV3X3N0ciArPSAoc3ViICE9IG51bGwgPyBzdWIgOiBjaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdfc3RyO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRyX3MoZnJvbSwgdG8pXG4gICAgJXh7XG4gICAgICBmcm9tID0gJGNvZXJjZV90byhmcm9tLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpLiR0b19zKCk7XG4gICAgICB0byA9ICRjb2VyY2VfdG8odG8sICN7OjpTdHJpbmd9LCAndG9fc3RyJykuJHRvX3MoKTtcblxuICAgICAgaWYgKGZyb20ubGVuZ3RoID09IDApIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBpLCBpbl9yYW5nZSwgYywgY2gsIHN0YXJ0LCBlbmQsIGxlbmd0aDtcbiAgICAgIHZhciBzdWJzID0ge307XG4gICAgICB2YXIgZnJvbV9jaGFycyA9IGZyb20uc3BsaXQoJycpO1xuICAgICAgdmFyIGZyb21fbGVuZ3RoID0gZnJvbV9jaGFycy5sZW5ndGg7XG4gICAgICB2YXIgdG9fY2hhcnMgPSB0by5zcGxpdCgnJyk7XG4gICAgICB2YXIgdG9fbGVuZ3RoID0gdG9fY2hhcnMubGVuZ3RoO1xuXG4gICAgICB2YXIgaW52ZXJzZSA9IGZhbHNlO1xuICAgICAgdmFyIGdsb2JhbF9zdWIgPSBudWxsO1xuICAgICAgaWYgKGZyb21fY2hhcnNbMF0gPT09ICdeJyAmJiBmcm9tX2NoYXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaW52ZXJzZSA9IHRydWU7XG4gICAgICAgIGZyb21fY2hhcnMuc2hpZnQoKTtcbiAgICAgICAgZ2xvYmFsX3N1YiA9IHRvX2NoYXJzW3RvX2xlbmd0aCAtIDFdXG4gICAgICAgIGZyb21fbGVuZ3RoIC09IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBmcm9tX2NoYXJzX2V4cGFuZGVkID0gW107XG4gICAgICB2YXIgbGFzdF9mcm9tID0gbnVsbDtcbiAgICAgIGluX3JhbmdlID0gZmFsc2U7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZnJvbV9sZW5ndGg7IGkrKykge1xuICAgICAgICBjaCA9IGZyb21fY2hhcnNbaV07XG4gICAgICAgIGlmIChsYXN0X2Zyb20gPT0gbnVsbCkge1xuICAgICAgICAgIGxhc3RfZnJvbSA9IGNoO1xuICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09ICctJykge1xuICAgICAgICAgIGlmIChsYXN0X2Zyb20gPT09ICctJykge1xuICAgICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaSA9PSBmcm9tX2xlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluX3JhbmdlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5fcmFuZ2UpIHtcbiAgICAgICAgICBzdGFydCA9IGxhc3RfZnJvbS5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIGVuZCA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhbmdlIFxcXCIje2BTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXJ0KWB9LSN7YFN0cmluZy5mcm9tQ2hhckNvZGUoZW5kKWB9XFxcIiBpbiBzdHJpbmcgdHJhbnNsaXRlcmF0aW9uXCJ9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoYyA9IHN0YXJ0ICsgMTsgYyA8IGVuZDsgYysrKSB7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgaW5fcmFuZ2UgPSBudWxsO1xuICAgICAgICAgIGxhc3RfZnJvbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmcm9tX2NoYXJzID0gZnJvbV9jaGFyc19leHBhbmRlZDtcbiAgICAgIGZyb21fbGVuZ3RoID0gZnJvbV9jaGFycy5sZW5ndGg7XG5cbiAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3Vic1tmcm9tX2NoYXJzW2ldXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodG9fbGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciB0b19jaGFyc19leHBhbmRlZCA9IFtdO1xuICAgICAgICAgIHZhciBsYXN0X3RvID0gbnVsbDtcbiAgICAgICAgICBpbl9yYW5nZSA9IGZhbHNlO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b19sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2ggPSB0b19jaGFyc1tpXTtcbiAgICAgICAgICAgIGlmIChsYXN0X2Zyb20gPT0gbnVsbCkge1xuICAgICAgICAgICAgICBsYXN0X2Zyb20gPSBjaDtcbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0X3RvID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGkgPT0gdG9fbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbl9yYW5nZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluX3JhbmdlKSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gbGFzdF9mcm9tLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgIGVuZCA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFuZ2UgXFxcIiN7YFN0cmluZy5mcm9tQ2hhckNvZGUoc3RhcnQpYH0tI3tgU3RyaW5nLmZyb21DaGFyQ29kZShlbmQpYH1cXFwiIGluIHN0cmluZyB0cmFuc2xpdGVyYXRpb25cIn1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKGMgPSBzdGFydCArIDE7IGMgPCBlbmQ7IGMrKykge1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICAgIGluX3JhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgbGFzdF9mcm9tID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b19jaGFycyA9IHRvX2NoYXJzX2V4cGFuZGVkO1xuICAgICAgICAgIHRvX2xlbmd0aCA9IHRvX2NoYXJzLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW5ndGhfZGlmZiA9IGZyb21fbGVuZ3RoIC0gdG9fbGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoX2RpZmYgPiAwKSB7XG4gICAgICAgICAgdmFyIHBhZF9jaGFyID0gKHRvX2xlbmd0aCA+IDAgPyB0b19jaGFyc1t0b19sZW5ndGggLSAxXSA6ICcnKTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoX2RpZmY7IGkrKykge1xuICAgICAgICAgICAgdG9fY2hhcnMucHVzaChwYWRfY2hhcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZyb21fbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzdWJzW2Zyb21fY2hhcnNbaV1dID0gdG9fY2hhcnNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBuZXdfc3RyID0gJydcbiAgICAgIHZhciBsYXN0X3N1YnN0aXR1dGUgPSBudWxsXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoID0gc2VsZi5jaGFyQXQoaSk7XG4gICAgICAgIHZhciBzdWIgPSBzdWJzW2NoXVxuICAgICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICAgIGlmIChzdWIgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGxhc3Rfc3Vic3RpdHV0ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIG5ld19zdHIgKz0gZ2xvYmFsX3N1YjtcbiAgICAgICAgICAgICAgbGFzdF9zdWJzdGl0dXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdfc3RyICs9IGNoO1xuICAgICAgICAgICAgbGFzdF9zdWJzdGl0dXRlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHN1YiAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobGFzdF9zdWJzdGl0dXRlID09IG51bGwgfHwgbGFzdF9zdWJzdGl0dXRlICE9PSBzdWIpIHtcbiAgICAgICAgICAgICAgbmV3X3N0ciArPSBzdWI7XG4gICAgICAgICAgICAgIGxhc3Rfc3Vic3RpdHV0ZSA9IHN1YjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdfc3RyICs9IGNoO1xuICAgICAgICAgICAgbGFzdF9zdWJzdGl0dXRlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdfc3RyO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHVwY2FzZVxuICAgIGBzZWxmLnRvVXBwZXJDYXNlKClgXG4gIGVuZFxuXG4gIGRlZiB1cHRvKHN0b3AsIGV4Y2wgPSBmYWxzZSwgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6dXB0bywgc3RvcCwgZXhjbCB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgJXh7XG4gICAgICB2YXIgYSwgYiwgcyA9IHNlbGYudG9TdHJpbmcoKTtcblxuICAgICAgc3RvcCA9ICRjb2VyY2VfdG8oc3RvcCwgI3s6OlN0cmluZ30sICd0b19zdHInKTtcblxuICAgICAgaWYgKHMubGVuZ3RoID09PSAxICYmIHN0b3AubGVuZ3RoID09PSAxKSB7XG5cbiAgICAgICAgYSA9IHMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgYiA9IHN0b3AuY2hhckNvZGVBdCgwKTtcblxuICAgICAgICB3aGlsZSAoYSA8PSBiKSB7XG4gICAgICAgICAgaWYgKGV4Y2wgJiYgYSA9PT0gYikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYmxvY2soU3RyaW5nLmZyb21DaGFyQ29kZShhKSk7XG5cbiAgICAgICAgICBhICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmIChwYXJzZUludChzLCAxMCkudG9TdHJpbmcoKSA9PT0gcyAmJiBwYXJzZUludChzdG9wLCAxMCkudG9TdHJpbmcoKSA9PT0gc3RvcCkge1xuXG4gICAgICAgIGEgPSBwYXJzZUludChzLCAxMCk7XG4gICAgICAgIGIgPSBwYXJzZUludChzdG9wLCAxMCk7XG5cbiAgICAgICAgd2hpbGUgKGEgPD0gYikge1xuICAgICAgICAgIGlmIChleGNsICYmIGEgPT09IGIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJsb2NrKGEudG9TdHJpbmcoKSk7XG5cbiAgICAgICAgICBhICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICB3aGlsZSAocy5sZW5ndGggPD0gc3RvcC5sZW5ndGggJiYgcyA8PSBzdG9wKSB7XG4gICAgICAgICAgaWYgKGV4Y2wgJiYgcyA9PT0gc3RvcCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYmxvY2socyk7XG5cbiAgICAgICAgICBzID0gI3tgc2Auc3VjY307XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICAleHtcbiAgICBmdW5jdGlvbiBjaGFyX2NsYXNzX2Zyb21fY2hhcl9zZXRzKHNldHMpIHtcbiAgICAgIGZ1bmN0aW9uIGV4cGxvZGVfc2VxdWVuY2VzX2luX2NoYXJhY3Rlcl9zZXQoc2V0KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJyxcbiAgICAgICAgICAgIGksIGxlbiA9IHNldC5sZW5ndGgsXG4gICAgICAgICAgICBjdXJyX2NoYXIsXG4gICAgICAgICAgICBza2lwX25leHRfZGFzaCxcbiAgICAgICAgICAgIGNoYXJfY29kZV9mcm9tLFxuICAgICAgICAgICAgY2hhcl9jb2RlX3VwdG8sXG4gICAgICAgICAgICBjaGFyX2NvZGU7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGN1cnJfY2hhciA9IHNldC5jaGFyQXQoaSk7XG4gICAgICAgICAgaWYgKGN1cnJfY2hhciA9PT0gJy0nICYmIGkgPiAwICYmIGkgPCAobGVuIC0gMSkgJiYgIXNraXBfbmV4dF9kYXNoKSB7XG4gICAgICAgICAgICBjaGFyX2NvZGVfZnJvbSA9IHNldC5jaGFyQ29kZUF0KGkgLSAxKTtcbiAgICAgICAgICAgIGNoYXJfY29kZV91cHRvID0gc2V0LmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgICAgICAgaWYgKGNoYXJfY29kZV9mcm9tID4gY2hhcl9jb2RlX3VwdG8pIHtcbiAgICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCByYW5nZSBcXFwiI3tgY2hhcl9jb2RlX2Zyb21gfS0je2BjaGFyX2NvZGVfdXB0b2B9XFxcIiBpbiBzdHJpbmcgdHJhbnNsaXRlcmF0aW9uXCJ9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNoYXJfY29kZSA9IGNoYXJfY29kZV9mcm9tICsgMTsgY2hhcl9jb2RlIDwgY2hhcl9jb2RlX3VwdG8gKyAxOyBjaGFyX2NvZGUrKykge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyX2NvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2tpcF9uZXh0X2Rhc2ggPSB0cnVlO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBza2lwX25leHRfZGFzaCA9IChjdXJyX2NoYXIgPT09ICdcXFxcJyk7XG4gICAgICAgICAgICByZXN1bHQgKz0gY3Vycl9jaGFyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbnRlcnNlY3Rpb24oc2V0QSwgc2V0Qikge1xuICAgICAgICBpZiAoc2V0QS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gc2V0QjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICAgICAgICBpLCBsZW4gPSBzZXRBLmxlbmd0aCxcbiAgICAgICAgICAgIGNocjtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY2hyID0gc2V0QS5jaGFyQXQoaSk7XG4gICAgICAgICAgaWYgKHNldEIuaW5kZXhPZihjaHIpICE9PSAtMSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGNocjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgdmFyIGksIGxlbiwgc2V0LCBuZWcsIGNociwgdG1wLFxuICAgICAgICAgIHBvc19pbnRlcnNlY3Rpb24gPSAnJyxcbiAgICAgICAgICBuZWdfaW50ZXJzZWN0aW9uID0gJyc7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHNldHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc2V0ID0gJGNvZXJjZV90byhzZXRzW2ldLCAjezo6U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBuZWcgPSAoc2V0LmNoYXJBdCgwKSA9PT0gJ14nICYmIHNldC5sZW5ndGggPiAxKTtcbiAgICAgICAgc2V0ID0gZXhwbG9kZV9zZXF1ZW5jZXNfaW5fY2hhcmFjdGVyX3NldChuZWcgPyBzZXQuc2xpY2UoMSkgOiBzZXQpO1xuICAgICAgICBpZiAobmVnKSB7XG4gICAgICAgICAgbmVnX2ludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbihuZWdfaW50ZXJzZWN0aW9uLCBzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvc19pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb24ocG9zX2ludGVyc2VjdGlvbiwgc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocG9zX2ludGVyc2VjdGlvbi5sZW5ndGggPiAwICYmIG5lZ19pbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCkge1xuICAgICAgICB0bXAgPSAnJztcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcG9zX2ludGVyc2VjdGlvbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGNociA9IHBvc19pbnRlcnNlY3Rpb24uY2hhckF0KGkpO1xuICAgICAgICAgIGlmIChuZWdfaW50ZXJzZWN0aW9uLmluZGV4T2YoY2hyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRtcCArPSBjaHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBvc19pbnRlcnNlY3Rpb24gPSB0bXA7XG4gICAgICAgIG5lZ19pbnRlcnNlY3Rpb24gPSAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKHBvc19pbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gJ1snICsgI3s6OlJlZ2V4cC5lc2NhcGUoYHBvc19pbnRlcnNlY3Rpb25gKX0gKyAnXSc7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZWdfaW50ZXJzZWN0aW9uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuICdbXicgKyAjezo6UmVnZXhwLmVzY2FwZShgbmVnX2ludGVyc2VjdGlvbmApfSArICddJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgZGVmIGluc3RhbmNlX3ZhcmlhYmxlc1xuICAgIFtdXG4gIGVuZFxuXG4gIGRlZiBzZWxmLl9sb2FkKCphcmdzKVxuICAgIG5ldygqYXJncylcbiAgZW5kXG5cbiAgZGVmIHVuaWNvZGVfbm9ybWFsaXplKGZvcm0gPSA6bmZjKVxuICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJJbnZhbGlkIG5vcm1hbGl6YXRpb24gZm9ybSAje2Zvcm19XCIgdW5sZXNzICVpW25mYyBuZmQgbmZrYyBuZmtkXS5pbmNsdWRlPyhmb3JtKVxuICAgIGBzZWxmLm5vcm1hbGl6ZSgje2Zvcm0udXBjYXNlfSlgXG4gIGVuZFxuXG4gIGRlZiB1bmljb2RlX25vcm1hbGl6ZWQ/KGZvcm0gPSA6bmZjKVxuICAgIHVuaWNvZGVfbm9ybWFsaXplKGZvcm0pID09IHNlbGZcbiAgZW5kXG5cbiAgZGVmIHVucGFjayhmb3JtYXQpXG4gICAgOjpLZXJuZWwucmFpc2UgXCJUbyB1c2UgU3RyaW5nI3VucGFjaywgeW91IG11c3QgZmlyc3QgcmVxdWlyZSAnY29yZWxpYi9zdHJpbmcvdW5wYWNrJy5cIlxuICBlbmRcblxuICBkZWYgdW5wYWNrMShmb3JtYXQpXG4gICAgOjpLZXJuZWwucmFpc2UgXCJUbyB1c2UgU3RyaW5nI3VucGFjazEsIHlvdSBtdXN0IGZpcnN0IHJlcXVpcmUgJ2NvcmVsaWIvc3RyaW5nL3VucGFjaycuXCJcbiAgZW5kXG5cbiAgZGVmIGZyZWV6ZVxuICAgICV4e1xuICAgICAgaWYgKHR5cGVvZiBzZWxmID09PSAnc3RyaW5nJykgeyByZXR1cm4gc2VsZjsgfVxuICAgICAgJHByb3Aoc2VsZiwgXCIkJGZyb3plblwiLCB0cnVlKTtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIC1AXG4gICAgJXh7XG4gICAgICBpZiAodHlwZW9mIHNlbGYgPT09ICdzdHJpbmcnKSByZXR1cm4gc2VsZjtcbiAgICAgIGlmIChzZWxmLiQkZnJvemVuKSByZXR1cm4gc2VsZjtcbiAgICAgIGlmIChzZWxmLmVuY29kaW5nLm5hbWUgPT0gJ1VURi04JyAmJiBzZWxmLmludGVybmFsX2VuY29kaW5nLm5hbWUgPT0gJ1VURi04JykgcmV0dXJuIHNlbGYudG9TdHJpbmcoKTtcbiAgICAgIHJldHVybiBzZWxmLiRkdXAoKS4kZnJlZXplKCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZnJvemVuP1xuICAgIGB0eXBlb2Ygc2VsZiA9PT0gJ3N0cmluZycgfHwgc2VsZi4kJGZyb3plbiA9PT0gdHJ1ZWBcbiAgZW5kXG5cbiAgYWxpYXMgK0AgZHVwXG4gIGFsaWFzID09PSA9PVxuICBhbGlhcyBieXRlc2xpY2UgW11cbiAgYWxpYXMgZXFsPyA9PVxuICBhbGlhcyBlcXVhbD8gPT09XG4gIGFsaWFzIG9iamVjdF9pZCBfX2lkX19cbiAgYWxpYXMgc2xpY2UgW11cbiAgYWxpYXMgc3VjYyBuZXh0XG4gIGFsaWFzIHRvX3N0ciB0b19zXG4gIGFsaWFzIHRvX3N5bSBpbnRlcm5cblxuICA6Ok9wYWwucHJpc3RpbmUgc2VsZiwgOmluaXRpYWxpemVcbmVuZFxuXG5TeW1ib2wgPSBTdHJpbmdcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6U3RyaW5nPiIsImluY2x1ZGUiLCJDb21wYXJhYmxlIiwiX19pZF9fIiwiaGFzaCIsInRyeV9jb252ZXJ0Iiwid2hhdCIsIk9wYWwiLCJjb2VyY2VfdG8/IiwiU3RyaW5nIiwibmV3IiwiaW5pdGlhbGl6ZSIsImFyZ3MiLCIlIiwiZGF0YSIsIkFycmF5IiwiZm9ybWF0IiwiKiIsImNvdW50IiwiSW50ZWdlciIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsIlJhbmdlRXJyb3IiLCIrIiwib3RoZXIiLCI8PT4iLCJyZXNwb25kX3RvPyIsInRvX3N0ciIsInRvX3MiLCI9PSIsIj1+IiwiVHlwZUVycm9yIiwiW10iLCJpbmRleCIsImxlbmd0aCIsIiR+IiwiTWF0Y2hEYXRhIiwiYiIsImZvcmNlX2VuY29kaW5nIiwiY2FwaXRhbGl6ZSIsImNhc2VjbXAiLCJjYXNlY21wPyIsImNlbnRlciIsIndpZHRoIiwicGFkc3RyIiwiZW1wdHk/IiwibGp1c3QiLCIvIiwiMiIsImNlaWwiLCJyanVzdCIsImZsb29yIiwiY2hvbXAiLCJzZXBhcmF0b3IiLCIkLyIsImNvZXJjZV90byEiLCJjaG9wIiwiY2hyIiwiY2xvbmUiLCIka3dhcmdzIiwiZnJlZXplIiwibmlsPyIsImNsYXNzIiwiY29weSIsImNvcHlfc2luZ2xldG9uX21ldGhvZHMiLCJpbml0aWFsaXplX2Nsb25lIiwiZHVwIiwiaW5pdGlhbGl6ZV9kdXAiLCJkZWxldGUiLCJkZWxldGVfcHJlZml4IiwicHJlZml4IiwiZGVsZXRlX3N1ZmZpeCIsInN1ZmZpeCIsImRvd25jYXNlIiwiZWFjaF9saW5lIiwiYmxvY2tfZ2l2ZW4/IiwiZW51bV9mb3IiLCJlbmRfd2l0aD8iLCJnc3ViIiwicGF0dGVybiIsInJlcGxhY2VtZW50IiwiaGV4IiwidG9faSIsIjE2IiwiaW5jbHVkZT8iLCJzZWFyY2giLCJvZmZzZXQiLCJpbnNwZWN0IiwiaW50ZXJuIiwibGluZXMiLCJlIiwiYmxvY2siLCJ0b19wcm9jIiwidG9fYSIsImxzdHJpcCIsImFzY2lpX29ubHk/IiwibWF0Y2giLCJwb3MiLCJSZWdleHAiLCJtYXRjaD8iLCJuZXh0Iiwib2N0Iiwib3JkIiwicGFydGl0aW9uIiwic2VwIiwicmV2ZXJzZSIsInJpbmRleCIsInJwYXJ0aXRpb24iLCJyc3RyaXAiLCJzY2FuIiwibm9fbWF0Y2hkYXRhIiwiY2FwdHVyZXMiLCJzaW5nbGV0b25fY2xhc3MiLCJzcGxpdCIsImxpbWl0IiwiJHJldF9vcl8xIiwiJDsiLCJzcXVlZXplIiwic3RhcnRfd2l0aD8iLCJzdHJpcCIsInN1YiIsInN1bSIsIm4iLCJzd2FwY2FzZSIsInRvX2YiLCJiYXNlIiwiMTAiLCJtZXRob2RfbmFtZSIsImpzaWQiLCJwcm9jIiwiYmxvY2sgaW4gdG9fcHJvYyIsImJsb2NrICgyIGxldmVscykgaW4gdG9fcHJvYyIsInRyIiwiZnJvbSIsInRvIiwidHJfcyIsInVwY2FzZSIsInVwdG8iLCJzdG9wIiwiZXhjbCIsInN1Y2MiLCJlc2NhcGUiLCJpbnN0YW5jZV92YXJpYWJsZXMiLCJfbG9hZCIsInVuaWNvZGVfbm9ybWFsaXplIiwiZm9ybSIsInVuaWNvZGVfbm9ybWFsaXplZD8iLCJ1bnBhY2siLCJ1bnBhY2sxIiwiLUAiLCJmcm96ZW4/IiwicHJpc3RpbmUiXSwibWFwcGluZ3MiOiJBQUFBQSxpQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFHQUMsSUFBQUMsU0FBQUEsQ0FBUUYsb0JBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLGdCQUFSRTtFQUVBQztFQUFBQTs7SUFBQUE7OztJQUNFRixJQUFBRyxTQUFBQSxDQUFRQyxpQkFBUkQ7O0FBR0ZELGNBQWdCRixJQUFLRTs7QUFFckJBO0FBQ0FBOztBQUlBQTtBQUNBQTtBQUNBQSxNQUFNQSxDQUNFRyxzQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOztNQUFBQTs7QUFFUkE7QUFDQUEscUJBQXVCLE9BQUFMLElBQUEsRUFBQSxrREFBQSxVQUFBLEVBQUEsRUFBQSxFQUFBLE1BQUE7QUFDdkJLO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBWFFBLENBQUFBLEdBY0FDLG9CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7OztBQUVSQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtJQVRRQSxDQUFBQSxDQWZGSjtBQTJCTkE7QUFDQUE7SUFFRUssTUFBSVAsSUFBSk8sa0JBQUFBLHVCQUFxQkMsSUFBckJEO0FBQUFBO01BQ0VBLE9BQUFFLEtBQU1DLGVBQUFBLENBQVlGLElBQWxCLEVBQXdCRyxhQUF4QixFQUFrQyxRQUE1QkQ7SUFEUkgsQ0FBQUE7SUFJQUssTUFBSVosSUFBSlksVUFBQUEsdUJBckRGLEVBcURFQTtBQUFBQSxNQUFBQTs7O01BckRGO01BcURlOztBQUVmQTtBQUNBQTtBQUNBQSw0QkFBOEJELGFBQVNDO0FBQ3ZDQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSx1Q0FBOENDLE1BQUxELENBQUNBLEdBQURBLENBQUtDLGNBQUFBLEVBQVksTUFBQ0MsSUFBRCxDQUFaRCxDQUFtQkQ7QUFDakVBO0FBQ0FBO0lBWEVBLENBQUFBLElBQUFBOztBQW1CQUMsSUFBQUEsMEJBQUFBLHNCQXhFRixFQXdFZ0IsRUF4RWhCLEVBd0VFQTtBQUFBQSxNQUFBQTs7O01BeEVGO01BQUE7TUFBQTs7TUF3RWlCOztNQUFpQiwwQ0FBQSxpQ0FBVTs7TUFBSywwQ0FBQSxpQ0FBVTtNQXhFM0RBLE9BQUE7SUF3RUVBLENBQUFBLElBQUFBOztBQUdBRSxJQUFBQSxpQkFBQUEsNEJBQU1DLElBQU5EO0FBQUFBLE1BQUFBOztNQUNFLElBQUEsUUFBR0UsWUFBSCxFQUFlRCxJQUFmLENBQUE7UUFDRUQsT0FBQUcsTUFBQWxCLElBQUFrQixVQUFBQSxFQUFBLENBQU9sQixJQUFQLENBQUEsUUFBYSxNQUFDZ0IsSUFBRCxDQUFiLENBQUFFO01BREY7UUFHRUgsT0FBQWYsSUFBQWtCLFFBQUFBLENBQU9sQixJQUFQLEVBQWFnQixJQUFiRTtNQUhGO0lBREZILENBQUFBOztBQVFBSSxJQUFBQSxpQkFBQUEscUJBQU1DLEtBQU5EO0FBQUFBLE1BQUFBOzs7QUFFRkEsZ0NBQWtDRSxjQUFVRjs7QUFFNUNBO0FBQ0FBLFFBQVVHLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWdDTCxtQkFBeEJJO0FBQ2xCSjs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUEsUUFBVUcsT0FBUUMsT0FBQUEsQ0FBT0UsaUJBQWYsRUFBNkJOLHNEQUFyQkk7QUFDbEJKOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7SUFuQ0VBLENBQUFBOztBQXNDQU8sSUFBQUEsaUJBQUFBLHlCQUFNQyxLQUFORDtBQUFBQSxNQUFBQTs7O01BQ0VDLFFBQVNELFdBQWFDLEtBQU1ELEVBQUlmLGFBQVNlOztBQUc3Q0EsOERBQWdFMUIsSUFBSzBCO0FBQ3JFQSw4REFBZ0VDLEtBQU1EO0FBQ3RFQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtJQVZFQSxDQUFBQTs7QUFhQUUsSUFBQUEsbUJBQUFBLDZCQUFRRCxLQUFSQztBQUFBQSxNQUFBQTs7TUFDRSxJQUFBLFFBQUdELEtBQUtFLGdCQUFBQSxDQUFhLFFBQWJBLENBQVIsQ0FBQTs7UUFDRUYsUUFBUUEsS0FBS0csUUFBQUEsQ0FBQUEsQ0FBT0MsTUFBQUEsQ0FBQUE7UUFFcEJILE9BQUNBLDBDQUFEQTtNQUhGOztBQU1KQSxrQkFBb0JELEtBQU1DLFFBQUFBLENBQUk1QixJQUFKNEIsQ0FBU0E7O0FBRW5DQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtNQWRJO0lBREZBLENBQUFBOztBQW1CQUksSUFBQUEsa0JBQUFBLDBCQUFPTCxLQUFQSztBQUFBQSxNQUFBQTs7O0FBRUZBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLGVBQWlCTCxLQUFNSyxPQUFBQSxDQUFHaEMsSUFBSGdDLENBQVFBO0FBQy9CQTtBQUNBQTtBQUNBQTtJQVRFQSxDQUFBQTs7QUFZQUMsSUFBQUEsa0JBQUFBLDZCQUFPTixLQUFQTTtBQUFBQSxNQUFBQTs7O0FBRUZBO0FBQ0FBLFFBQVVYLE9BQVFDLE9BQUFBLENBQU9XLGdCQUFmLEVBQTRCRCw2QkFBcEJWLENBQWtEVTtBQUNwRUE7O0FBRUFBLGFBQWVOLEtBQU1NLE9BQUFBLENBQUdqQyxJQUFIaUMsQ0FBUUE7QUFDN0JBO0lBUEVBLENBQUFBOztBQVVBRSxJQUFBQSxrQkFBQUEsc0JBQU9DLEtBQUQsRUFBUUMsTUFBZEY7QUFBQUEsTUFBQUE7Ozs7O0FBRUZBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQSxpRUFBbUVkLGNBQVVjO0FBQzdFQSxvRUFBc0VkLGNBQVVjOztBQUVoRkE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7OztBQUdBQTtBQUNBQTtBQUNBQSxVQUFZYixPQUFRQyxPQUFBQSxDQUFPVyxnQkFBUFg7QUFDcEJZO0FBQ0FBO0FBQ0FBOzs7QUFHQUE7QUFDQUE7O0FBRUFBO0FBQ0FBLFVBQVlHLENBQUFBLGNBQUssR0FBTEE7QUFDWkg7QUFDQUE7O0FBRUFBLFFBQVVHLENBQUFBLGNBQUtDLGdCQUFXM0IsS0FBQUEsQ0FBTXVCLEtBQWpCLEVBQTBCQSxLQUFmdkIsQ0FBaEIwQjs7QUFFVkg7QUFDQUE7QUFDQUE7O0FBRUFBLG9DQUFzQ2QsY0FBVWM7O0FBRWhEQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOzs7QUFHQUEsZ0NBQWtDZCxjQUFVYzs7QUFFNUNBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUEsa0NBQW9DZCxjQUFVYzs7QUFFOUNBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7SUFoR0VBLENBQUFBLElBQUFBOztBQW1HQUssSUFBQUEsaUJBQUFBLGFBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBQSxDQUFDQSxXQUFheEMsSUFBS3dDLENBQW5CQSxDQUFxQkMsZ0JBQUFBLENBQWdCRCxRQUFoQkM7SUFEdkJELENBQUFBOztBQUlBRSxJQUFBQSwwQkFBQUEsc0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSwyREFBREE7SUFERkEsQ0FBQUE7O0FBSUFDLElBQUFBLHVCQUFBQSxtQkFBWWhCLEtBQVpnQjtBQUFBQSxNQUFBQTs7O01BQ0UsS0FBQSxRQUFrQmhCLEtBQUtFLGdCQUFBQSxDQUFhLFFBQWJBLENBQXZCLENBQUE7UUFBQSxPQUFPO01BQVA7TUFDQUYsUUFBUWdCLENBQUNBLGtCQUFvQmhDLGFBQVNnQyxXQUE5QkEsQ0FBMENaLE1BQUFBLENBQUFBOztBQUV0RFk7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7TUFDSUEsT0FBQTNDLElBQUs0QixRQUFBQSxDQUFJRCxLQUFKQztJQVZQZSxDQUFBQTs7QUFhQUMsSUFBQUEsd0JBQUFBLGdDQUFhakIsS0FBYmlCO0FBQUFBLE1BQUFBOzs7QUFFRkEsZ0JBQWtCNUMsSUFBQTJDLFNBQUFBLENBQVFoQixLQUFSZ0IsQ0FBZUM7QUFDakNBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBUkVBLENBQUFBOztBQVdBQyxJQUFBQSxzQkFBQUEsa0JBQVdDLEtBQUQsRUFBUUMsTUFBbEJGO0FBQUFBLE1BQUFBOzs7TUFBa0IsNkJBQVNBO01BQ3pCQyxRQUFVRCxXQUFhQyxLQUFNRCxFQUFJeEIsY0FBVXdCO01BQzNDRSxTQUFTRixDQUFDQSxXQUFhRSxNQUFPRixFQUFJbEMsYUFBU2tDLFdBQWxDQSxDQUE4Q2QsTUFBQUEsQ0FBQUE7TUFFdkQsSUFBQSxRQUFHZ0IsTUFBTUMsV0FBQUEsQ0FBQUEsQ0FBVCxDQUFBO1FBQ0UxQixPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixFQUFnQ3FCLG9CQUF4QnRCO01BRFY7TUFJQSxJQUFBLFFBQWdCc0Isb0JBQWhCLENBQUE7UUFBQSxPQUFPN0M7TUFBUDs7QUFHSjZDLHVCQUF5QjdDLElBQUFpRCxPQUFBQSxDQUErQkMsV0FBakJ4QixTQUFOb0IsS0FBTXBCLEVBQUdtQixXQUFIbkIsQ0FBaUJ3QixFQUFFQyxDQUFGRCxDQUFJRSxNQUFBQSxDQUFBQSxDQUFuQyxFQUEwQ0wsTUFBMUNFLENBQWlESjtBQUMxRUEsdUJBQXlCN0MsSUFBQXFELE9BQUFBLENBQStCSCxXQUFqQnhCLFNBQU5vQixLQUFNcEIsRUFBR21CLFdBQUhuQixDQUFpQndCLEVBQUVDLENBQUZELENBQUlJLE9BQUFBLENBQUFBLENBQW5DLEVBQTJDUCxNQUEzQ00sQ0FBa0RSOztBQUUzRUE7QUFDQUE7SUFmRUEsQ0FBQUEsSUFBQUE7O0FBa0JBVSxJQUFBQSxxQkFBQUEsaUJBQVVDLFNBQVZEO0FBQUFBLE1BQUFBO0FBQUFBOzs7TUFBVSxtQ0FBWUU7TUFDcEIsSUFBQSxRQUFnQkYsc0NBQWhCLENBQUE7UUFBQSxPQUFPdkQ7TUFBUDtNQUVBd0QsWUFBWS9DLEtBQU1pRCxlQUFBQSxDQUFZRixTQUFsQixFQUE2QjdDLGFBQTdCLEVBQXVDLFFBQWpDK0MsQ0FBeUMzQixNQUFBQSxDQUFBQTs7QUFHL0R3Qjs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtNQUVJQSxPQUFBdkQ7SUEzQkZ1RCxDQUFBQSxJQUFBQTs7QUE4QkFJLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7OztBQUVGQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0lBYkVBLENBQUFBOztBQWdCQUMsSUFBQUEsbUJBQUFBLGVBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSxjQUFEQTtJQURGQSxDQUFBQTs7QUFJQUMsSUFBQUEscUJBQUFBLGlCQXRYRkMsT0FzWEVEO0FBQUFBLE1BQUFBOzs7TUF0WEY7O01Bc1hZLHNDQUFBLDZCQUFRO01BQ2hCLEtBQU8sQ0FBQSxDQUFBLFFBQUFFLE1BQU1DLFNBQUFBLENBQUFBLENBQU4sQ0FBQSxJQUFBLENBQUEsTUFBZUQsTUFBZixFQUF5QixJQUF6QixDQUFBLENBQUEsQ0FBQSxJQUFBLENBQUEsTUFBaUNBLE1BQWpDLEVBQTJDLEtBQTNDLENBQUEsQ0FBQSxDQUFQO1FBQ0UvRCxJQUFBdUIsT0FBQUEsQ0FBTUMsbUJBQU4sRUFBc0JxQywrQkFBRCxHQUFBLENBQWdDRSxNQUFNRSxPQUFBQSxDQUFBQSxDQUF0QyxDQUFyQjFDO01BREY7TUFJQTJDLE9BQVFMO01BQ1JLLElBQUlDLHdCQUFBQSxDQUF3Qm5FLElBQXhCbUU7TUFDSkQsSUFBSUUsa0JBQUFBLENBQWtCcEUsSUFBdEIsRUFBNEIsVUFBQSxTQUFBLEVBQVErRCxNQUFSLENBQUEsR0FBeEJLO01BRUosSUFBQSxNQUFHTCxNQUFILEVBQWEsSUFBYixDQUFBO1FBQ0dGO01BREgsT0FFQSxJQUFBLFFBQU1FLE1BQU1DLFNBQUFBLENBQUFBLENBQVosQ0FBQTtRQUNHSDtNQURIO01BSUFBLE9BQUFLO0lBZkZMLENBQUFBLElBQUFBOztBQWtCQVEsSUFBQUEsbUJBQUFBLGVBQUFBO0FBQUFBLE1BQUFBOzs7TUFDRUgsT0FBUUc7TUFDUkgsSUFBSUksZ0JBQUFBLENBQWdCdEUsSUFBaEJzRTtNQUNKRCxPQUFBSDtJQUhGRyxDQUFBQTs7QUFNQWpELElBQUFBLHFCQUFBQSxpQkE5WUYsRUE4WUVBO0FBQUFBLE1BQUFBOzs7TUE5WUY7TUE4WVk7O0FBRVpBO0FBQ0FBLFFBQVVFLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWdDSixxREFBeEJHO0FBQ2xCSDtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtJQVZFQSxDQUFBQSxJQUFBQTs7QUFhQW1ELElBQUFBLHNCQUFBQSwyQkEzWkYsRUEyWkVBO0FBQUFBLE1BQUFBOzs7TUEzWkY7TUEyWmE7O0FBRWJBO0FBQ0FBLFFBQVVqRCxPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixFQUFnQytDLHFEQUF4QmhEO0FBQ2xCZ0Q7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUFWRUEsQ0FBQUEsSUFBQUE7O0FBYUFDLElBQUFBLDZCQUFBQSx5QkFBa0JDLE1BQWxCRDtBQUFBQSxNQUFBQTs7O0FBRUZBO0FBQ0FBLG9DQUFzQzdELGFBQVM2RDtBQUMvQ0E7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBWEVBLENBQUFBOztBQWNBRSxJQUFBQSw2QkFBQUEseUJBQWtCQyxNQUFsQkQ7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQSxvQ0FBc0MvRCxhQUFTK0Q7QUFDL0NBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtJQVhFQSxDQUFBQTs7QUFjQUUsSUFBQUEsd0JBQUFBLG9CQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0Esa0JBQURBO0lBREZBLENBQUFBOztBQUlBQyxJQUFBQSx5QkFBQUEscUJBeGNGLEVBd2NlLEVBeGNmLEVBd2NFQTtBQUFBQSxNQUFBQTtBQUFBQTs7TUFBQUE7OztNQXhjRjtNQUFBO01BQUE7O01Bd2NnQiwwREFBQSxtQ0FBWXBCOztNQUFJLG9DQUFBLDJCQUFPO01BQ25DLEtBQTJEcUIsZUFBM0Q7UUFBQSxPQUFPOUUsSUFBQStFLFVBQUFBLENBQVMsV0FBVCxFQUFxQnZCLFNBQXJCLEVBQWdDLFVBQUEsUUFBQSxFQUFPRCxLQUFQLENBQUEsR0FBaEN3QjtNQUFQOztBQUdKRjtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBLHdDQUEwQ2xFLGFBQVNrRTs7QUFFbkRBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSxzQkFBd0JBLENBQUNBLEtBQURBLENBQU90QixPQUFBQSxDQUFPc0IsSUFBUHRCLENBQWFzQjtBQUM1Q0E7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQSxpQkFBbUI3RSxJQUFBdUQsT0FBQUEsQ0FBTUMsU0FBTkQsQ0FBaUJzQjtBQUNwQ0E7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLGtCQUFvQkEsQ0FBQ0EsS0FBREEsQ0FBT3RCLE9BQUFBLENBQU9DLFNBQVBELENBQWtCc0I7QUFDN0NBO0FBQ0FBO0FBQ0FBO0FBQ0FBO01BRUlBLE9BQUE3RTtJQTVDRjZFLENBQUFBLElBQUFBOztBQStDQTdCLElBQUFBLHNCQUFBQSwrQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUNBLGlCQUFEQTtJQURGQSxDQUFBQTs7QUFJQWdDLElBQUFBLHlCQUFBQSxrQ0EzZkYsRUEyZkVBO0FBQUFBLE1BQUFBOzs7TUEzZkY7TUEyZmdCOztBQUVoQkE7QUFDQUEsNkNBQStDckUsYUFBU3FFOztBQUV4REE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7TUFFSUEsT0FBQTtJQVpGQSxDQUFBQSxJQUFBQTs7QUFlQUMsSUFBQUEsb0JBQUFBLGdCQUFTQyxPQUFELEVBQVVDLFdBQWxCRjtBQUFBQSxNQUFBQTs7TUFBQUE7Ozs7O0FBRUZBO0FBQ0FBLGVBQWlCakYsSUFBQStFLFVBQUFBLENBQVMsTUFBVCxFQUFnQkcsT0FBaEJILENBQXdCRTtBQUN6Q0E7O0FBRUFBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQSxzQ0FBd0N0RSxhQUFTc0U7QUFDakRBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUEsVUFBWTNDLENBQUFBLGNBQUssR0FBTEE7QUFDWjJDO0FBQ0FBO0FBQ0FBOztBQUVBQSxxQkFBdUIxQyxnQkFBVzNCLEtBQUFBLENBQU1xRSxPQUFqQixFQUE0QkEsS0FBakJyRSxDQUF3QnFFOztBQUUxREE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEseUJBQTJCQSxDQUFDQSxXQUFEQSxDQUFhOUMsT0FBQUEsQ0FBRThDLFFBQUY5QyxDQUFZSixNQUFBQSxDQUFBQSxDQUFNa0Q7QUFDMURBO0FBQ0FBO0FBQ0FBO0FBQ0FBLGtEQUFvRHRFLGFBQVNzRTtBQUM3REE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQSxNQUFRM0MsQ0FBQUEsY0FBTTJDLFVBQU4zQztBQUNSMkM7QUFDQUE7SUF2RUVBLENBQUFBLElBQUFBOztBQTBFQUcsSUFBQUEsbUJBQUFBLGVBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBcEYsSUFBQXFGLE1BQUFBLENBQUtDLEVBQUxEO0lBREZELENBQUFBOztBQUlBRyxJQUFBQSx3QkFBQUEsaUNBQWE1RCxLQUFiNEQ7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQSxrQ0FBb0M1RSxhQUFTNEU7QUFDN0NBO0FBQ0FBO0FBQ0FBO0lBTkVBLENBQUFBOztBQVNBbkQsSUFBQUEscUJBQUFBLGlCQUFVb0QsTUFBRCxFQUFTQyxNQUFsQnJEO0FBQUFBLE1BQUFBOzs7OztBQUVGQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUEsb0NBQXNDZixjQUFVZTtBQUNoREE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLFlBQWNFLENBQUFBLGNBQUssR0FBTEEsQ0FBU0Y7QUFDdkJBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLFlBQWNFLENBQUFBLGNBQUtDLGdCQUFXM0IsS0FBQUEsQ0FBTXdCLEtBQWpCLEVBQTBCQSxLQUFmeEIsQ0FBaEIwQjtBQUNkRjtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSxvQ0FBc0N6QixhQUFTeUI7QUFDL0NBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtJQTVDRUEsQ0FBQUEsSUFBQUE7O0FBK0NBc0QsSUFBQUEsdUJBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7O0FBRUZBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBM0JFQSxDQUFBQTs7QUE4QkFDLElBQUFBLHNCQUFBQSxrQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUNBLGVBQURBO0lBREZBLENBQUFBOztBQUlBdEQsSUFBQUEsc0JBQUFBLGtCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0EsV0FBREE7SUFERkEsQ0FBQUE7SUFJQSxhQUFNLE1BQU4sRUFBVyxRQUFYOztBQUVBdUQsSUFBQUEscUJBQUFBLGlCQXhyQkYsRUF3ckJXLEVBeHJCWCxFQXdyQkVBO0FBQUFBLE1BQUFBO0FBQUFBOztNQUFBQTs7O01BeHJCRjtNQUFBO01BQUE7O01Bd3JCWSwwREFBQSxtQ0FBWW5DOztNQUFJLG9DQUFBLDJCQUFPO01BQy9Cb0MsSUFBSWhCLE1BQUE3RSxJQUFBNkUsYUFBQUEsRUFBQUEsQ0FBVXJCLFNBQVYsRUFBcUIsVUFBQSxRQUFBLEVBQU9ELEtBQVAsQ0FBQSxHQUFyQnNCLENBQUFBLEVBQW9DaUIsS0FBREMsU0FBQUEsQ0FBQUEsQ0FBbkNsQjtNQUNKLElBQUEsUUFBQWlCLEtBQUEsQ0FBQTtRQUFRRixPQUFBNUY7TUFBUjtRQUFlNEYsT0FBQUMsQ0FBQ0csTUFBQUEsQ0FBQUE7TUFBaEI7SUFGRkosQ0FBQUEsSUFBQUE7O0FBS0EzQyxJQUFBQSxxQkFBQUEsaUJBQVVILEtBQUQsRUFBUUMsTUFBakJFO0FBQUFBLE1BQUFBOzs7TUFBaUIsNkJBQVNBO01BQ3hCSCxRQUFVRyxXQUFhSCxLQUFNRyxFQUFJNUIsY0FBVTRCO01BQzNDRixTQUFTRSxDQUFDQSxXQUFhRixNQUFPRSxFQUFJdEMsYUFBU3NDLFdBQWxDQSxDQUE4Q2xCLE1BQUFBLENBQUFBO01BRXZELElBQUEsUUFBR2dCLE1BQU1DLFdBQUFBLENBQUFBLENBQVQsQ0FBQTtRQUNFMUIsT0FBUUMsT0FBQUEsQ0FBT0Msb0JBQWYsRUFBZ0N5QixvQkFBeEIxQjtNQURWO01BSUEsSUFBQSxRQUFnQjBCLG9CQUFoQixDQUFBO1FBQUEsT0FBT2pEO01BQVA7O0FBR0ppRDtBQUNBQTs7QUFFQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtJQXJCRUEsQ0FBQUEsSUFBQUE7O0FBd0JBZ0QsSUFBQUEsc0JBQUFBLGtCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0EsNkNBQURBO0lBREZBLENBQUFBOztBQUlBQyxJQUFBQSwyQkFBQUEsb0NBQUFBO0FBQUFBLE1BQUFBOzs7QUFHRkE7QUFDQUE7QUFDQUE7SUFMRUEsQ0FBQUE7O0FBUUFDLElBQUFBLHFCQUFBQSxpQkFBVWpCLE9BQUQsRUFBVWtCLEdBQW5CRDtBQUFBQSxNQUFBQTs7TUFBQUE7Ozs7TUFDRSxJQUFHLENBQUEsUUFBQXhGLFlBQUEsRUFBV3VFLE9BQVgsQ0FBQSxJQUFBLENBQUEsUUFBc0JBLE9BQU9yRCxnQkFBQUEsQ0FBYSxRQUFiQSxDQUE3QixDQUFBLENBQUEsQ0FBSDtRQUNFcUQsVUFBVW1CLGFBQVF6RixLQUFBQSxDQUFLc0UsT0FBT3BELFFBQUFBLENBQUFBLENBQVpsQjtNQURwQjtNQUlBLEtBQUEsUUFBT3lGLGFBQVAsRUFBb0JuQixPQUFwQixDQUFBO1FBQ0U1RCxPQUFRQyxPQUFBQSxDQUFPVyxnQkFBZixFQUE2QmlFLHNCQUFELEdBQUEsQ0FBdUJqQixPQUFPakIsT0FBQUEsQ0FBQUEsQ0FBOUIsQ0FBQSxHQUFxQ2tDLG9CQUF6RDVFO01BRFY7TUFJQTRFLE9BQU9BLE1BQVBqQixPQUFPaUIsU0FBQUEsRUFBQUEsQ0FBT25HLElBQWQsRUFBb0JvRyxHQUFiRCxDQUFBQSxFQUFtQkwsS0FBREMsU0FBQUEsQ0FBQUEsQ0FBbEJJO0lBVFRBLENBQUFBLElBQUFBOztBQVlBRyxJQUFBQSxzQkFBQUEsK0JBQVdwQixPQUFELEVBQVVrQixHQUFwQkU7QUFBQUEsTUFBQUE7Ozs7TUFDRSxJQUFHLENBQUEsUUFBQTNGLFlBQUEsRUFBV3VFLE9BQVgsQ0FBQSxJQUFBLENBQUEsUUFBc0JBLE9BQU9yRCxnQkFBQUEsQ0FBYSxRQUFiQSxDQUE3QixDQUFBLENBQUEsQ0FBSDtRQUNFcUQsVUFBVW1CLGFBQVF6RixLQUFBQSxDQUFLc0UsT0FBT3BELFFBQUFBLENBQUFBLENBQVpsQjtNQURwQjtNQUlBLEtBQUEsUUFBT3lGLGFBQVAsRUFBb0JuQixPQUFwQixDQUFBO1FBQ0U1RCxPQUFRQyxPQUFBQSxDQUFPVyxnQkFBZixFQUE2Qm9FLHNCQUFELEdBQUEsQ0FBdUJwQixPQUFPakIsT0FBQUEsQ0FBQUEsQ0FBOUIsQ0FBQSxHQUFxQ3FDLG9CQUF6RC9FO01BRFY7TUFJQStFLE9BQUFwQixPQUFPb0IsV0FBQUEsQ0FBUXRHLElBQWYsRUFBcUJvRyxHQUFkRTtJQVRUQSxDQUFBQSxJQUFBQTs7QUFZQUMsSUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7O0FBRUZBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBbkVFQSxDQUFBQTs7QUFzRUFDLElBQUFBLG1CQUFBQSxlQUFBQTtBQUFBQSxNQUFBQTs7O0FBRUZBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0lBeENFQSxDQUFBQTs7QUEyQ0FDLElBQUFBLG1CQUFBQSxlQUFBQTtBQUFBQSxNQUFBQTs7O0FBRUZBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBUkVBLENBQUFBOztBQVdBQyxJQUFBQSx5QkFBQUEscUJBQWNDLEdBQWREO0FBQUFBLE1BQUFBOzs7QUFFRkE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLFVBQVluRSxnQkFBVzNCLEtBQUFBLENBQU04RixHQUFqQixFQUF3QkEsQ0FBYjlGLENBQWdCOEY7QUFDdkNBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLDhCQUFnQy9GLGFBQVMrRjtBQUN6Q0E7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtJQTNCRUEsQ0FBQUE7O0FBOEJBRSxJQUFBQSx1QkFBQUEsbUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSxpQ0FBREE7SUFERkEsQ0FBQUE7O0FBSUFDLElBQUFBLHNCQUFBQSxrQkFBV3JCLE1BQUQsRUFBU0MsTUFBbkJvQjtBQUFBQSxNQUFBQTs7Ozs7QUFFRkE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBLG9DQUFzQ3hGLGNBQVV3RjtBQUNoREE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLFVBQVl2RSxDQUFBQSxjQUFLLEdBQUxBO0FBQ1p1RTtBQUNBQTtBQUNBQSxVQUFZdEUsZ0JBQVczQixLQUFBQSxDQUFNaUcsQ0FBakIsRUFBc0JBLENBQVhqRyxDQUFjaUc7QUFDckNBO0FBQ0FBO0FBQ0FBO0FBQ0FBLG9DQUFzQ2xHLGFBQVNrRztBQUMvQ0E7QUFDQUE7O0FBRUFBO0FBQ0FBO0lBeENFQSxDQUFBQSxJQUFBQTs7QUEyQ0F4RCxJQUFBQSxxQkFBQUEsaUJBQVVQLEtBQUQsRUFBUUMsTUFBakJNO0FBQUFBLE1BQUFBOzs7TUFBaUIsNkJBQVNBO01BQ3hCUCxRQUFVTyxXQUFhUCxLQUFNTyxFQUFJaEMsY0FBVWdDO01BQzNDTixTQUFTTSxDQUFDQSxXQUFhTixNQUFPTSxFQUFJMUMsYUFBUzBDLFdBQWxDQSxDQUE4Q3RCLE1BQUFBLENBQUFBO01BRXZELElBQUEsUUFBR2dCLE1BQU1DLFdBQUFBLENBQUFBLENBQVQsQ0FBQTtRQUNFMUIsT0FBUUMsT0FBQUEsQ0FBT0Msb0JBQWYsRUFBZ0M2QixvQkFBeEI5QjtNQURWO01BSUEsSUFBQSxRQUFnQjhCLG9CQUFoQixDQUFBO1FBQUEsT0FBT3JEO01BQVA7O0FBR0pxRDtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7SUFqQkVBLENBQUFBLElBQUFBOztBQW9CQXlELElBQUFBLDBCQUFBQSxzQkFBZUgsR0FBZkc7QUFBQUEsTUFBQUE7OztBQUVGQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQSxVQUFZdkUsZ0JBQVczQixLQUFBQSxDQUFNa0csQ0FBakIsRUFBc0JBLENBQVhsRyxDQUFja0c7QUFDckNBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQSw4QkFBZ0NuRyxhQUFTbUc7QUFDekNBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUF2Q0VBLENBQUFBOztBQTBDQUMsSUFBQUEsc0JBQUFBLGtCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0EsNkNBQURBO0lBREZBLENBQUFBOztBQUlBQyxJQUFBQSxvQkFBQUEsZ0JBQVM5QixPQUFELEVBcGdDVnBCLE9Bb2dDRWtEO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BcGdDRjs7TUFvZ0NvQixrREFBQSx5Q0FBYzs7QUFFbENBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQSxzQ0FBd0NyRyxhQUFTcUc7QUFDakRBO0FBQ0FBOztBQUVBQTtBQUNBQSxxQkFBdUJ6RSxnQkFBVzNCLEtBQUFBLENBQU1vRyxPQUFqQixFQUE0QkEsS0FBNUIsRUFBb0MsVUFBQSxlQUFBLEVBQWNDLFlBQWQsQ0FBQSxHQUF6QnJHLENBQW9Eb0c7QUFDdEZBO0FBQ0FBLGtFQUFvRUEsQ0FBQ0EsVUFBREEsQ0FBWUUsVUFBQUEsQ0FBQUEsQ0FBVUY7QUFDMUZBO0FBQ0FBLGdGQUFrRkEsQ0FBQ0EsVUFBREEsQ0FBWUUsVUFBQUEsQ0FBQUEsQ0FBVUY7QUFDeEdBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQSx5QkFBMkIxRSxDQUFBQSxjQUFNMEUsVUFBTjFFLENBQWtCMEU7O0FBRTdDQTtBQUNBQTtJQTVCRUEsQ0FBQUEsSUFBQUE7O0FBb0NBRyxJQUFBQSwrQkFBQUEsMkJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSw4QkFBREE7SUFERkEsQ0FBQUE7O0FBSUFDLElBQUFBLHFCQUFBQSxpQkFBVWxDLE9BQUQsRUFBc0JtQyxLQUEvQkQ7QUFBQUEsTUFBQUE7QUFBQUE7Ozs7OztBQUVGQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUEsZ0JBQWtCM0csS0FBTWlELGVBQUFBLENBQVkyRCxLQUFsQixFQUF5QmhHLGNBQXpCLEVBQW9DLFFBQTlCcUMsQ0FBdUMwRDtBQUMvREE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBLGtCQUFvQixDQUFBLFFBQUFFLENBQUFBLFlBQUFDLFdBQUFELENBQUEsQ0FBQSxHQUFBLENBQUEsU0FBQSxJQUFBLENBQU1GLEdBQU4sQ0FBQSxDQUFVQTtBQUM5QkE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQSxzQ0FBd0N6RyxhQUFTeUc7O0FBRWpEQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUE1RkVBLENBQUFBLElBQUFBOztBQStGQUksSUFBQUEsdUJBQUFBLG1CQTNvQ0YsRUEyb0NFQTtBQUFBQSxNQUFBQTs7O01BM29DRjtNQTJvQ2M7O0FBRWRBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBVkVBLENBQUFBLElBQUFBOztBQWFBQyxJQUFBQSwyQkFBQUEsb0NBeHBDRixFQXdwQ0VBO0FBQUFBLE1BQUFBOzs7TUF4cENGO01Bd3BDa0I7O0FBRWxCQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUEsWUFBY25GLENBQUFBLGNBQUtDLGdCQUFXM0IsS0FBQUEsQ0FBTTZHLE1BQWpCLEVBQTJCQSxLQUFoQjdHLENBQWhCMEIsQ0FBd0NtRjtBQUN0REE7QUFDQUE7QUFDQUEsWUFBY25GLENBQUFBLGNBQUssR0FBTEE7QUFDZG1GO0FBQ0FBO0FBQ0FBLCtDQUFpRDlHLGFBQVM4Rzs7QUFFMURBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtJQXZCRUEsQ0FBQUEsSUFBQUE7O0FBMEJBQyxJQUFBQSxxQkFBQUEsaUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSx3RUFBREE7SUFERkEsQ0FBQUE7O0FBSUFDLElBQUFBLG1CQUFBQSxlQUFRekMsT0FBRCxFQUFVQyxXQUFqQndDO0FBQUFBLE1BQUFBOztNQUFBQTs7Ozs7QUFFRkE7QUFDQUEsc0NBQXdDaEgsYUFBU2dIO0FBQ2pEQTtBQUNBQTs7QUFFQUE7O0FBRUFBO0FBQ0FBLFFBQVVyRixDQUFBQSxjQUFLLEdBQUxBO0FBQ1ZxRjtBQUNBQTtBQUNBQSxRQUFVcEYsZ0JBQVczQixLQUFBQSxDQUFNK0csT0FBakIsRUFBNEJBLEtBQWpCL0c7O0FBRXJCK0c7O0FBRUFBO0FBQ0FBLFlBQWNyRyxPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixFQUFnQ21HLHFDQUF4QnBHO0FBQ3RCb0c7QUFDQUE7O0FBRUFBOztBQUVBQSxnREFBa0RBLENBQUNBLFdBQURBLENBQWF4RixPQUFBQSxDQUFFd0YsUUFBRnhGLENBQVlKLE1BQUFBLENBQUFBLENBQU00Rjs7QUFFakZBOztBQUVBQSxnREFBa0RoSCxhQUFTZ0g7O0FBRTNEQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0lBdERFQSxDQUFBQSxJQUFBQTs7QUF5REFDLElBQUFBLG1CQUFBQSxlQUFRQyxDQUFSRDtBQUFBQSxNQUFBQTs7O01BQVEsbUJBQUl0Qzs7QUFFZHNDLHdCQUEwQnZHLGNBQVV1Rzs7QUFFcENBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0lBakJFQSxDQUFBQSxJQUFBQTs7QUFvQkFFLElBQUFBLHdCQUFBQSxvQkFBQUE7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7SUFQRUEsQ0FBQUE7O0FBVUFDLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQTtBQUNBQTs7QUFFQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBZEVBLENBQUFBOztBQWlCQTFDLElBQUFBLG9CQUFBQSxnQkFBUzJDLElBQVQzQztBQUFBQSxNQUFBQTs7O01BQVMseUJBQU80Qzs7QUFFbEI1QztBQUNBQTtBQUNBQSxtQ0FBcUNoRSxjQUFVZ0U7O0FBRS9DQTtBQUNBQSxRQUFVL0QsT0FBUUMsT0FBQUEsQ0FBT0Msb0JBQWYsRUFBaUM2RCxnQkFBRCxHQUFBLENBQWtCQSxLQUFsQixDQUF4QjlEO0FBQ2xCOEQ7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7SUF4REVBLENBQUFBLElBQUFBOztBQTJEQVUsSUFBQUEsdUJBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7TUFBQUE7O01BQ0VtQyxjQUFlbkM7TUFDZm9DLE9BQVFwQztNQUVScUMsT0FBZUEsTUFBUjlHLE9BQVE4RyxRQUFBQSxFQUFBQSxFQUFBQSxFQUFSQyxjQTcxQ1gsRUE2MUNXQSxFQUFBQzs7UUFBQUE7OztRQTcxQ1g7UUE2MUM2Qjs7QUFFN0JBO0FBQ0FBLFVBQVloSCxPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixFQUFnQzhHLG1CQUF4Qi9HO0FBQ3BCK0c7O0FBRUFBOztBQUVBQTs7QUFFQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBLG9CQUFzQkosV0FBWUk7QUFDbENBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsT0E1QldELENBQUFBLElBQVFEO01BK0JkckM7TUFFREEsT0FBQXFDO0lBckNGckMsQ0FBQUE7O0FBd0NBaEUsSUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0EsZUFBREE7SUFERkEsQ0FBQUE7O0FBSUF3RyxJQUFBQSxrQkFBQUEsY0FBT0MsSUFBRCxFQUFPQyxFQUFiRjtBQUFBQSxNQUFBQTs7O0FBRUZBLDhCQUFnQzVILGFBQVM0SDtBQUN6Q0EsMEJBQTRCNUgsYUFBUzRIOztBQUVyQ0E7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsWUFBY2pILE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWlDK0csa0JBQUQsR0FBQSxDQUFvQkEsMEJBQXBCLENBQUEsR0FBZ0RBLEdBQWhELEdBQUEsQ0FBb0RBLHdCQUFwRCxDQUFBLEdBQThFQSw4QkFBdEdoSDtBQUN0QmdIO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsZ0JBQWtCakgsT0FBUUMsT0FBQUEsQ0FBT0Msb0JBQWYsRUFBaUMrRyxrQkFBRCxHQUFBLENBQW9CQSwwQkFBcEIsQ0FBQSxHQUFnREEsR0FBaEQsR0FBQSxDQUFvREEsd0JBQXBELENBQUEsR0FBOEVBLDhCQUF0R2hIO0FBQzFCZ0g7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBOUlFQSxDQUFBQTs7QUFpSkFHLElBQUFBLG9CQUFBQSxnQkFBU0YsSUFBRCxFQUFPQyxFQUFmQztBQUFBQSxNQUFBQTs7O0FBRUZBLDhCQUFnQy9ILGFBQVMrSDtBQUN6Q0EsMEJBQTRCL0gsYUFBUytIOztBQUVyQ0E7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsWUFBY3BILE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWlDa0gsa0JBQUQsR0FBQSxDQUFvQkEsMEJBQXBCLENBQUEsR0FBZ0RBLEdBQWhELEdBQUEsQ0FBb0RBLHdCQUFwRCxDQUFBLEdBQThFQSw4QkFBdEduSDtBQUN0Qm1IO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsZ0JBQWtCcEgsT0FBUUMsT0FBQUEsQ0FBT0Msb0JBQWYsRUFBaUNrSCxrQkFBRCxHQUFBLENBQW9CQSwwQkFBcEIsQ0FBQSxHQUFnREEsR0FBaEQsR0FBQSxDQUFvREEsd0JBQXBELENBQUEsR0FBOEVBLDhCQUF0R25IO0FBQzFCbUg7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUFoS0VBLENBQUFBOztBQW1LQUMsSUFBQUEsc0JBQUFBLGtCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0Esa0JBQURBO0lBREZBLENBQUFBOztBQUlBQyxJQUFBQSxvQkFBQUEsZ0JBQVNDLElBQUQsRUFBT0MsSUFBZkY7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFBZSx5QkFBTztNQUNwQixLQUF5QzlELGVBQXpDO1FBQUEsT0FBTzlFLElBQUErRSxVQUFBQSxDQUFTLE1BQVQsRUFBZ0I4RCxJQUFoQixFQUFzQkMsSUFBdEIvRDtNQUFQOztBQUVKNkQ7O0FBRUFBLDhCQUFnQ2pJLGFBQVNpSTs7QUFFekNBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBOztBQUVBQTtBQUNBQTs7QUFFQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBOztBQUVBQSxjQUFnQkEsQ0FBQ0EsQ0FBREEsQ0FBR0csTUFBQUEsQ0FBQUEsQ0FBTUg7QUFDekJBOztBQUVBQTtBQUNBQTtBQUNBQTtJQW5ERUEsQ0FBQUEsSUFBQUE7O0FBdURGMUk7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsY0FBZ0JvQixPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixFQUFpQ3RCLGtCQUFELEdBQUEsQ0FBb0JBLGNBQXBCLENBQUEsR0FBb0NBLEdBQXBDLEdBQUEsQ0FBd0NBLGNBQXhDLENBQUEsR0FBd0RBLDhCQUFoRnFCO0FBQ3hCckI7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUEsa0NBQW9DUyxhQUFTVDtBQUM3Q0E7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQSxxQkFBdUJtRyxhQUFRMkMsUUFBQUEsQ0FBUzlJLGdCQUFUOEksQ0FBNEI5STtBQUMzREE7O0FBRUFBO0FBQ0FBLHNCQUF3Qm1HLGFBQVEyQyxRQUFBQSxDQUFTOUksZ0JBQVQ4SSxDQUE0QjlJO0FBQzVEQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUUrSSxJQUFBQSxrQ0FBQUEsOEJBQUFBO0FBQUFBO01BQ0VBLE9BQUE7SUFERkEsQ0FBQUE7SUFJQUMsTUFBSWxKLElBQUprSixZQUFBQSxpQkE3MERGLEVBNjBERUE7QUFBQUEsTUFBQUE7OztNQTcwREY7TUE2MERpQjtNQUNiQSxPQUFBdEksTUFBQVosSUFBQVksT0FBQUEsRUFBSSxNQUFDRSxJQUFELENBQUpGO0lBREZzSSxDQUFBQSxJQUFBQTs7QUFJQUMsSUFBQUEsaUNBQUFBLDZCQUFzQkMsSUFBdEJEO0FBQUFBLE1BQUFBOzs7TUFBc0IseUJBQU87TUFDM0IsS0FBQSxRQUE0RSxDQUFHLEtBQUgsRUFBTyxLQUFQLEVBQVcsTUFBWCxFQUFnQixNQUFoQixDQUFxQjVELGFBQUFBLENBQVU2RCxJQUFWN0QsQ0FBakcsQ0FBQTtRQUFBakUsT0FBUUMsT0FBQUEsQ0FBT0Msb0JBQWYsRUFBaUMySCw2QkFBRCxHQUFBLENBQThCQyxJQUE5QixDQUF4QjdIO01BQVI7TUFDQTRILE9BQUNBLGVBQWlCQyxJQUFJVCxRQUFBQSxDQUFBQSxDQUFRUTtJQUZoQ0EsQ0FBQUEsSUFBQUE7O0FBS0FFLElBQUFBLG1DQUFBQSw0Q0FBd0JELElBQXhCQztBQUFBQSxNQUFBQTs7O01BQXdCLHlCQUFPO01BQzdCQSxPQUFBckosSUFBQW1KLG1CQUFBQSxDQUFrQkMsSUFBbEJELENBQXdCbkgsT0FBQUEsQ0FBR2hDLElBQUhnQztJQUQxQnFILENBQUFBLElBQUFBOztBQUlBQyxJQUFBQSxzQkFBQUEsa0JBQVdwSSxNQUFYb0k7QUFBQUE7TUFDRUEsT0FBQWhJLE9BQVFDLE9BQUFBLENBQU8rSCx1RUFBUC9IO0lBRFYrSCxDQUFBQTs7QUFJQUMsSUFBQUEsdUJBQUFBLG1CQUFZckksTUFBWnFJO0FBQUFBO01BQ0VBLE9BQUFqSSxPQUFRQyxPQUFBQSxDQUFPZ0ksd0VBQVBoSTtJQURWZ0ksQ0FBQUE7O0FBSUF4RixJQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOzs7QUFFRkE7QUFDQUE7QUFDQUE7QUFDQUE7SUFMRUEsQ0FBQUE7O0FBUUF5RixJQUFBQSxrQkFBQUEsNEJBQUFBO0FBQUFBLE1BQUFBOzs7QUFFRkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUFORUEsQ0FBQUE7O0FBU0FDLElBQUFBLHVCQUFBQSxnQ0FBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUNBLGtEQUFEQTtJQURGQSxDQUFBQTtJQUlBLGFBQU0sSUFBTixFQUFTLEtBQVQ7SUFDQSxhQUFNLEtBQU4sRUFBVSxJQUFWO0lBQ0EsYUFBTSxXQUFOLEVBQWdCLElBQWhCO0lBQ0EsYUFBTSxNQUFOLEVBQVcsSUFBWDtJQUNBLGFBQU0sUUFBTixFQUFhLEtBQWI7SUFDQSxhQUFNLFdBQU4sRUFBZ0IsUUFBaEI7SUFDQSxhQUFNLE9BQU4sRUFBWSxJQUFaO0lBQ0EsYUFBTSxNQUFOLEVBQVcsTUFBWDtJQUNBLGFBQU0sUUFBTixFQUFhLE1BQWI7SUFDQSxhQUFNLFFBQU4sRUFBYSxRQUFiO0lBRUF2SixPQUFBTyxLQUFNaUosVUFBQUEsQ0FBVTFKLElBQWhCLEVBQXNCLFlBQWhCMEo7RUE1M0RSeEosR0FBTSxJQUFOQSxFQUFrQkgsTUFBbEJHO0VBKzNEQUgsT0FBQSxrQ0FBU1ksWUFBVDtBQXI0REFaOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo5NjQ4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9lbnVtZXJhYmxlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHJ1dGh5LCBjb2VyY2VfdG8sIHlpZWxkMSwgeWllbGRYLCBkZW55X2Zyb3plbl9hY2Nlc3NcbiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxuXG5tb2R1bGUgOjpFbnVtZXJhYmxlXG4gICV4e1xuICAgIGZ1bmN0aW9uIGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhbHVlID0gW25pbF07XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGRlZiBhbGw/KHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkYFxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBjb21wYXJhYmxlID0gYGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKWBcblxuICAgICAgICByZXR1cm4gZmFsc2UgdW5sZXNzIHBhdHRlcm4ucHVibGljX3NlbmQoOj09PSwgKmNvbXBhcmFibGUpXG4gICAgICBlbmRcbiAgICBlbHNpZiBibG9ja19naXZlbj9cbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgdW5sZXNzIHlpZWxkKCp2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIHVubGVzcyA6Ok9wYWwuZGVzdHJ1Y3R1cmUodmFsdWUpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICB0cnVlXG4gIGVuZFxuXG4gIGRlZiBhbnk/KHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkYFxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBjb21wYXJhYmxlID0gYGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKWBcblxuICAgICAgICByZXR1cm4gdHJ1ZSBpZiBwYXR0ZXJuLnB1YmxpY19zZW5kKDo9PT0sICpjb21wYXJhYmxlKVxuICAgICAgZW5kXG4gICAgZWxzaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGlmIHlpZWxkKCp2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgaWYgOjpPcGFsLmRlc3RydWN0dXJlKHZhbHVlKVxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgY2h1bmsoJmJsb2NrKVxuICAgIHJldHVybiB0b19lbnVtKDpjaHVuaykgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICA6OkVudW1lcmF0b3IubmV3IGRvIHx5aWVsZGVyfFxuICAgICAgJXh7XG4gICAgICAgIHZhciBwcmV2aW91cyA9IG5pbCwgYWNjdW11bGF0ZSA9IFtdO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlbGVhc2VBY2N1bXVsYXRlKCkge1xuICAgICAgICAgIGlmIChhY2N1bXVsYXRlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICN7eWllbGRlci55aWVsZChgcHJldmlvdXNgLCBgYWNjdW11bGF0ZWApfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICB2YXIga2V5ID0gJHlpZWxkMShibG9jaywgdmFsdWUpO1xuXG4gICAgICAgICAgaWYgKGtleSA9PT0gbmlsKSB7XG4gICAgICAgICAgICByZWxlYXNlQWNjdW11bGF0ZSgpO1xuICAgICAgICAgICAgYWNjdW11bGF0ZSA9IFtdO1xuICAgICAgICAgICAgcHJldmlvdXMgPSBuaWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcmV2aW91cyA9PT0gbmlsIHx8IHByZXZpb3VzID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgYWNjdW11bGF0ZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlbGVhc2VBY2N1bXVsYXRlKCk7XG4gICAgICAgICAgICAgIGFjY3VtdWxhdGUgPSBbdmFsdWVdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmV2aW91cyA9IGtleTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgICAgcmVsZWFzZUFjY3VtdWxhdGUoKTtcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGNodW5rX3doaWxlKCZibG9jaylcbiAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgc2xpY2Vfd2hlbiB7IHxiZWZvcmUsIGFmdGVyfCAhKHlpZWxkIGJlZm9yZSwgYWZ0ZXIpIH1cbiAgZW5kXG5cbiAgZGVmIGNvbGxlY3QoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6Y29sbGVjdCkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gJHlpZWxkWChibG9jaywgYXJndW1lbnRzKTtcblxuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29sbGVjdF9jb25jYXQoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6Y29sbGVjdF9jb25jYXQpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgIG1hcCgmYmxvY2spLmZsYXR0ZW4oMSlcbiAgZW5kXG5cbiAgZGVmIGNvbXBhY3RcbiAgICB0b19hLmNvbXBhY3RcbiAgZW5kXG5cbiAgZGVmIGNvdW50KG9iamVjdCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIHJlc3VsdCA9IDBcblxuICAgICV4e1xuICAgICAgaWYgKG9iamVjdCAhPSBudWxsICYmIGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgI3t3YXJuKCd3YXJuaW5nOiBnaXZlbiBibG9jayBub3QgdXNlZCcpfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIGBvYmplY3QgIT0gbnVsbGBcbiAgICAgIGJsb2NrID0gOjpLZXJuZWwucHJvYyBkbyB8KmFyZ3N8XG4gICAgICAgIDo6T3BhbC5kZXN0cnVjdHVyZShhcmdzKSA9PSBvYmplY3RcbiAgICAgIGVuZFxuICAgIGVsc2lmIGJsb2NrLm5pbD9cbiAgICAgIGJsb2NrID0gOjpLZXJuZWwucHJvYyB7IHRydWUgfVxuICAgIGVuZFxuXG4gICAgZWFjaCBkbyB8KmFyZ3N8XG4gICAgICBgcmVzdWx0KytgIGlmIGAkeWllbGRYKGJsb2NrLCBhcmdzKWBcbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgY3ljbGUobiA9IG5pbCwgJmJsb2NrKVxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6Y3ljbGUsIG4pIGRvXG4gICAgICAgIGlmIG4ubmlsP1xuICAgICAgICAgIHJlc3BvbmRfdG8/KDpzaXplKSA/IDo6RmxvYXQ6OklORklOSVRZIDogbmlsXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBuID0gOjpPcGFsLmNvZXJjZV90byEobiwgOjpJbnRlZ2VyLCA6dG9faW50KVxuICAgICAgICAgIG4gPiAwID8gZW51bWVyYXRvcl9zaXplICogbiA6IDBcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIHVubGVzcyBuLm5pbD9cbiAgICAgIG4gPSA6Ok9wYWwuY29lcmNlX3RvISBuLCA6OkludGVnZXIsIDp0b19pbnRcblxuICAgICAgcmV0dXJuIGlmIGBuIDw9IDBgXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBhbGwgPSBbXSwgaSwgbGVuZ3RoLCB2YWx1ZTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgIGFsbC5wdXNoKHBhcmFtKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICBpZiAoYWxsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICBpZiAobiA9PT0gbmlsKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYWxsLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIGFsbFtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgd2hpbGUgKG4gPiAxKSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYWxsLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIGFsbFtpXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbi0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGV0ZWN0KGlmbm9uZSA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZGV0ZWN0LCBpZm5vbmUgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgZWFjaCBkbyB8KmFyZ3N8XG4gICAgICB2YWx1ZSA9IDo6T3BhbC5kZXN0cnVjdHVyZShhcmdzKVxuICAgICAgaWYgeWllbGQodmFsdWUpXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmIChpZm5vbmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mKGlmbm9uZSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gaWZub25lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGlmbm9uZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgZHJvcChudW1iZXIpXG4gICAgbnVtYmVyID0gYCRjb2VyY2VfdG8obnVtYmVyLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgIGlmIGBudW1iZXIgPCAwYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnYXR0ZW1wdCB0byBkcm9wIG5lZ2F0aXZlIHNpemUnXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgID0gW10sXG4gICAgICAgICAgY3VycmVudCA9IDA7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChudW1iZXIgPD0gY3VycmVudCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKCN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCsrO1xuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpXG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZHJvcF93aGlsZSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDpkcm9wX3doaWxlIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCAgID0gW10sXG4gICAgICAgICAgZHJvcHBpbmcgPSB0cnVlO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgIGlmIChkcm9wcGluZykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICAgIGlmICghJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGRyb3BwaW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJhbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVhY2hfY29ucyhuLCAmYmxvY2spXG4gICAgaWYgYGFyZ3VtZW50cy5sZW5ndGggIT0gMWBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2Bhcmd1bWVudHMubGVuZ3RoYH0gZm9yIDEpXCJcbiAgICBlbmRcblxuICAgIG4gPSA6Ok9wYWwudHJ5X2NvbnZlcnQgbiwgOjpJbnRlZ2VyLCA6dG9faW50XG5cbiAgICBpZiBgbiA8PSAwYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnaW52YWxpZCBzaXplJ1xuICAgIGVuZFxuXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX2NvbnMsIG4pIGRvXG4gICAgICAgIGVudW1fc2l6ZSA9IGVudW1lcmF0b3Jfc2l6ZVxuICAgICAgICBpZiBlbnVtX3NpemUubmlsP1xuICAgICAgICAgIG5pbFxuICAgICAgICBlbHNpZiBlbnVtX3NpemUgPT0gMCB8fCBlbnVtX3NpemUgPCBuXG4gICAgICAgICAgMFxuICAgICAgICBlbHNlXG4gICAgICAgICAgZW51bV9zaXplIC0gbiArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIGJ1ZmZlciA9IFtdO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZWxlbWVudCA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG4gICAgICAgIGJ1ZmZlci5wdXNoKGVsZW1lbnQpO1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IG4pIHtcbiAgICAgICAgICBidWZmZXIuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PSBuKSB7XG4gICAgICAgICAgJHlpZWxkMShibG9jaywgYnVmZmVyLnNsaWNlKDAsIG4pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVhY2hfZW50cnkoKmRhdGEsICZibG9jaylcbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gdG9fZW51bSg6ZWFjaF9lbnRyeSwgKmRhdGEpIHsgZW51bWVyYXRvcl9zaXplIH1cbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgICR5aWVsZDEoYmxvY2ssIGl0ZW0pO1xuICAgICAgfVxuXG4gICAgICBzZWxmLiRlYWNoLmFwcGx5KHNlbGYsIGRhdGEpO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlYWNoX3NsaWNlKG4sICZibG9jaylcbiAgICBuID0gYCRjb2VyY2VfdG8oI3tufSwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICBpZiBgbiA8PSAwYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnaW52YWxpZCBzbGljZSBzaXplJ1xuICAgIGVuZFxuXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3NsaWNlLCBuKSB7IHJlc3BvbmRfdG8/KDpzaXplKSA/IChzaXplIC8gbikuY2VpbCA6IG5pbCB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHNsaWNlID0gW11cblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICBzbGljZS5wdXNoKHBhcmFtKTtcblxuICAgICAgICBpZiAoc2xpY2UubGVuZ3RoID09PSBuKSB7XG4gICAgICAgICAgJHlpZWxkMShibG9jaywgc2xpY2UpO1xuICAgICAgICAgIHNsaWNlID0gW107XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgLy8gb3VyIFwibGFzdFwiIGdyb3VwLCBpZiBzbWFsbGVyIHRoYW4gbiB0aGVuIHdvbid0IGhhdmUgYmVlbiB5aWVsZGVkXG4gICAgICBpZiAoc2xpY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAkeWllbGQxKGJsb2NrLCBzbGljZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZWFjaF93aXRoX2luZGV4KCphcmdzLCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3dpdGhfaW5kZXgsICphcmdzKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIGluZGV4ID0gMDtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICBibG9jayhwYXJhbSwgaW5kZXgpO1xuXG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVhY2hfd2l0aF9vYmplY3Qob2JqZWN0LCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3dpdGhfb2JqZWN0LCBvYmplY3QpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgIGJsb2NrKHBhcmFtLCBvYmplY3QpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuICAgIH1cblxuICAgIG9iamVjdFxuICBlbmRcblxuICBkZWYgZW50cmllcygqYXJncylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZpbHRlcl9tYXAoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZmlsdGVyX21hcCkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBtYXAoJmJsb2NrKS5zZWxlY3QoJjppdHNlbGYpXG4gIGVuZFxuXG4gIGRlZiBmaW5kX2FsbCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpmaW5kX2FsbCkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZpbmRfaW5kZXgob2JqZWN0ID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDpmaW5kX2luZGV4IGlmIGBvYmplY3QgPT09IHVuZGVmaW5lZCAmJiBibG9jayA9PT0gbmlsYFxuXG4gICAgJXh7XG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwgJiYgYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAje3dhcm4oJ3dhcm5pbmc6IGdpdmVuIGJsb2NrIG5vdCB1c2VkJyl9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5kZXggPSAwXG5cbiAgICBpZiBgb2JqZWN0ICE9IG51bGxgXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGlmIDo6T3BhbC5kZXN0cnVjdHVyZSh2YWx1ZSkgPT0gb2JqZWN0XG4gICAgICAgICAgcmV0dXJuIGluZGV4XG4gICAgICAgIGVuZFxuXG4gICAgICAgIGBpbmRleCArPSAxYFxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBpZiB5aWVsZCgqdmFsdWUpXG4gICAgICAgICAgcmV0dXJuIGluZGV4XG4gICAgICAgIGVuZFxuXG4gICAgICAgIGBpbmRleCArPSAxYFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGZpcnN0KG51bWJlciA9IHVuZGVmaW5lZClcbiAgICBpZiBgbnVtYmVyID09PSB1bmRlZmluZWRgXG4gICAgICBlYWNoIGRvIHx2YWx1ZXxcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICByZXN1bHQgPSBbXVxuICAgICAgbnVtYmVyID0gYCRjb2VyY2VfdG8obnVtYmVyLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgICAgaWYgYG51bWJlciA8IDBgXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2F0dGVtcHQgdG8gdGFrZSBuZWdhdGl2ZSBzaXplJ1xuICAgICAgZW5kXG5cbiAgICAgIGlmIGBudW1iZXIgPT0gMGBcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICBlbmRcblxuICAgICAgY3VycmVudCA9IDBcblxuICAgICAgZWFjaCBkbyB8KmFyZ3N8XG4gICAgICAgIGByZXN1bHQucHVzaCgjezo6T3BhbC5kZXN0cnVjdHVyZShhcmdzKX0pYFxuXG4gICAgICAgIGlmIGBudW1iZXIgPD0gKytjdXJyZW50YFxuICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcblxuICAgICAgcmVzdWx0XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBncmVwKHBhdHRlcm4sICZibG9jaylcbiAgICByZXN1bHQgPSBbXVxuXG4gICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgY21wID0gYGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKWBcbiAgICAgIG5leHQgdW5sZXNzIHBhdHRlcm4uX19zZW5kX18oOj09PSwgKmNtcClcbiAgICAgIGlmIGJsb2NrX2dpdmVuP1xuICAgICAgICB2YWx1ZSA9IFt2YWx1ZV0gaWYgdmFsdWUubGVuZ3RoID4gMVxuICAgICAgICB2YWx1ZSA9IHlpZWxkKCp2YWx1ZSlcbiAgICAgIGVsc2lmIHZhbHVlLmxlbmd0aCA8PSAxXG4gICAgICAgIHZhbHVlID0gdmFsdWVbMF1cbiAgICAgIGVuZFxuXG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSlcbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgZ3JlcF92KHBhdHRlcm4sICZibG9jaylcbiAgICByZXN1bHQgPSBbXVxuXG4gICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgY21wID0gYGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKWBcbiAgICAgIG5leHQgaWYgcGF0dGVybi5fX3NlbmRfXyg6PT09LCAqY21wKVxuICAgICAgaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICAgIHZhbHVlID0gW3ZhbHVlXSBpZiB2YWx1ZS5sZW5ndGggPiAxXG4gICAgICAgIHZhbHVlID0geWllbGQoKnZhbHVlKVxuICAgICAgZWxzaWYgdmFsdWUubGVuZ3RoIDw9IDFcbiAgICAgICAgdmFsdWUgPSB2YWx1ZVswXVxuICAgICAgZW5kXG5cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKVxuICAgIGVuZFxuXG4gICAgcmVzdWx0XG4gIGVuZFxuXG4gIGRlZiBncm91cF9ieSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpncm91cF9ieSkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBoYXNoID0ge31cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgICN7KGhhc2hbYHZhbHVlYF0gfHw9IFtdKSA8PCBgcGFyYW1gfTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoYXNoXG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlPyhvYmopXG4gICAgZWFjaCBkbyB8KmFyZ3N8XG4gICAgICBpZiA6Ok9wYWwuZGVzdHJ1Y3R1cmUoYXJncykgPT0gb2JqXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiBpbmplY3Qob2JqZWN0ID0gdW5kZWZpbmVkLCBzeW0gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBvYmplY3Q7XG5cbiAgICAgIGlmIChibG9jayAhPT0gbmlsICYmIHN5bSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFsdWUgPSAkeWllbGRYKGJsb2NrLCBbcmVzdWx0LCB2YWx1ZV0pO1xuXG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHN5bSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKCEjezo6U3ltYm9sID09PSBvYmplY3R9KSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIiN7b2JqZWN0Lmluc3BlY3R9IGlzIG5vdCBhIFN5bWJvbFwifTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzeW0gICAgPSBvYmplY3Q7XG4gICAgICAgICAgcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXN1bHQgPSAje2ByZXN1bHRgLl9fc2VuZF9fIHN5bSwgYHZhbHVlYH07XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdCA9PSB1bmRlZmluZWQgPyBuaWwgOiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbGF6eVxuICAgIDo6RW51bWVyYXRvcjo6TGF6eS5uZXcoc2VsZiwgZW51bWVyYXRvcl9zaXplKSBkbyB8ZW51bSwgKmFyZ3N8XG4gICAgICBlbnVtLnlpZWxkKCphcmdzKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgZW51bWVyYXRvcl9zaXplXG4gICAgcmVzcG9uZF90bz8oOnNpemUpID8gc2l6ZSA6IG5pbFxuICBlbmRcblxuICBkZWYgbWF4KG4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChuID09PSB1bmRlZmluZWQgfHwgbiA9PT0gbmlsKSB7XG4gICAgICAgIHZhciByZXN1bHQsIHZhbHVlO1xuXG4gICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpdGVtO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZFgoYmxvY2ssIFtpdGVtLCByZXN1bHRdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSAje2BpdGVtYCA8PT4gYHJlc3VsdGB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbmlsKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2NvbXBhcmlzb24gZmFpbGVkJ307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gaXRlbTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG4gPSAkY29lcmNlX3RvKG4sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuICAgIH1cblxuICAgIHNvcnQoJmJsb2NrKS5yZXZlcnNlLmZpcnN0KG4pXG4gIGVuZFxuXG4gIGRlZiBtYXhfYnkobiA9IG5pbCwgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6bWF4X2J5LCBuKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgdW5sZXNzIG4ubmlsP1xuICAgICAgcmV0dXJuIHNvcnRfYnkoJmJsb2NrKS5yZXZlcnNlLnRha2UgblxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIGJ5O1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcGFyYW07XG4gICAgICAgICAgYnkgICAgID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCN7YHZhbHVlYCA8PT4gYGJ5YH0gPiAwKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcGFyYW1cbiAgICAgICAgICBieSAgICAgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBuaWwgOiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWluKG4gPSBuaWwsICZibG9jaylcbiAgICB1bmxlc3Mgbi5uaWw/XG4gICAgICBpZiBibG9ja19naXZlbj9cbiAgICAgICAgcmV0dXJuIHNvcnQgeyB8YSwgYnwgeWllbGQgYSwgYiB9LnRha2UgblxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gc29ydC50YWtlIG5cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcmFtO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB2YWx1ZSA9IGJsb2NrKHBhcmFtLCByZXN1bHQpO1xuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSBuaWwpIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnY29tcGFyaXNvbiBmYWlsZWQnfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoI3s6Ok9wYWwuY29tcGFyZShgcGFyYW1gLCBgcmVzdWx0YCl9IDwgMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcGFyYW07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IG5pbCA6IHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtaW5fYnkobiA9IG5pbCwgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6bWluX2J5LCBuKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgdW5sZXNzIG4ubmlsP1xuICAgICAgcmV0dXJuIHNvcnRfYnkoJmJsb2NrKS50YWtlIG5cbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBieTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlc3VsdCA9IHBhcmFtO1xuICAgICAgICAgIGJ5ICAgICA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgje2B2YWx1ZWAgPD0+IGBieWB9IDwgMCkge1xuICAgICAgICAgIHJlc3VsdCA9IHBhcmFtXG4gICAgICAgICAgYnkgICAgID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gbmlsIDogcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1pbm1heCgmYmxvY2spXG4gICAgYmxvY2sgfHw9IDo6S2VybmVsLnByb2MgeyB8YSwgYnwgYSA8PT4gYiB9XG5cbiAgICAleHtcbiAgICAgIHZhciBtaW4gPSBuaWwsIG1heCA9IG5pbCwgZmlyc3RfdGltZSA9IHRydWU7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcbiAgICAgICAgaWYgKGZpcnN0X3RpbWUpIHtcbiAgICAgICAgICBtaW4gPSBtYXggPSBlbGVtZW50O1xuICAgICAgICAgIGZpcnN0X3RpbWUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbWluX2NtcCA9ICN7YmxvY2suY2FsbChgbWluYCwgYGVsZW1lbnRgKX07XG5cbiAgICAgICAgICBpZiAobWluX2NtcCA9PT0gbmlsKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2NvbXBhcmlzb24gZmFpbGVkJ31cbiAgICAgICAgICB9IGVsc2UgaWYgKG1pbl9jbXAgPiAwKSB7XG4gICAgICAgICAgICBtaW4gPSBlbGVtZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBtYXhfY21wID0gI3tibG9jay5jYWxsKGBtYXhgLCBgZWxlbWVudGApfTtcblxuICAgICAgICAgIGlmIChtYXhfY21wID09PSBuaWwpIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnY29tcGFyaXNvbiBmYWlsZWQnfVxuICAgICAgICAgIH0gZWxzZSBpZiAobWF4X2NtcCA8IDApIHtcbiAgICAgICAgICAgIG1heCA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIFttaW4sIG1heF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWlubWF4X2J5KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOm1pbm1heF9ieSkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIG1pbl9yZXN1bHQgPSBuaWwsXG4gICAgICAgICAgbWF4X3Jlc3VsdCA9IG5pbCxcbiAgICAgICAgICBtaW5fYnksXG4gICAgICAgICAgbWF4X2J5O1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgaWYgKChtaW5fYnkgPT09IHVuZGVmaW5lZCkgfHwgI3tgdmFsdWVgIDw9PiBgbWluX2J5YH0gPCAwKSB7XG4gICAgICAgICAgbWluX3Jlc3VsdCA9IHBhcmFtO1xuICAgICAgICAgIG1pbl9ieSAgICAgPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgobWF4X2J5ID09PSB1bmRlZmluZWQpIHx8ICN7YHZhbHVlYCA8PT4gYG1heF9ieWB9ID4gMCkge1xuICAgICAgICAgIG1heF9yZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICBtYXhfYnkgICAgID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIFttaW5fcmVzdWx0LCBtYXhfcmVzdWx0XTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBub25lPyhwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgaWYgYHBhdHRlcm4gIT09IHVuZGVmaW5lZGBcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgY29tcGFyYWJsZSA9IGBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSlgXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlIGlmIHBhdHRlcm4ucHVibGljX3NlbmQoOj09PSwgKmNvbXBhcmFibGUpXG4gICAgICBlbmRcbiAgICBlbHNpZiBibG9ja19naXZlbj9cbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgaWYgeWllbGQoKnZhbHVlKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgaXRlbSA9IDo6T3BhbC5kZXN0cnVjdHVyZSh2YWx1ZSlcblxuICAgICAgICByZXR1cm4gZmFsc2UgaWYgaXRlbVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICB0cnVlXG4gIGVuZFxuXG4gIGRlZiBvbmU/KHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBjb3VudCA9IDBcblxuICAgIGlmIGBwYXR0ZXJuICE9PSB1bmRlZmluZWRgXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGNvbXBhcmFibGUgPSBgY29tcGFyYWJsZUZvclBhdHRlcm4odmFsdWUpYFxuXG4gICAgICAgIGlmIHBhdHRlcm4ucHVibGljX3NlbmQoOj09PSwgKmNvbXBhcmFibGUpXG4gICAgICAgICAgY291bnQgKz0gMVxuICAgICAgICAgIHJldHVybiBmYWxzZSBpZiBjb3VudCA+IDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbHNpZiBibG9ja19naXZlbj9cbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgbmV4dCB1bmxlc3MgeWllbGQoKnZhbHVlKVxuICAgICAgICBjb3VudCArPSAxXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlIGlmIGNvdW50ID4gMVxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBuZXh0IHVubGVzcyA6Ok9wYWwuZGVzdHJ1Y3R1cmUodmFsdWUpXG4gICAgICAgIGNvdW50ICs9IDFcblxuICAgICAgICByZXR1cm4gZmFsc2UgaWYgY291bnQgPiAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGNvdW50ID09IDFcbiAgZW5kXG5cbiAgZGVmIHBhcnRpdGlvbigmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpwYXJ0aXRpb24pIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgdHJ1dGh5ID0gW10sIGZhbHN5ID0gW10sIHJlc3VsdDtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSkge1xuICAgICAgICAgIHRydXRoeS5wdXNoKHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmYWxzeS5wdXNoKHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gW3RydXRoeSwgZmFsc3ldO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlamVjdCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZWplY3QpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBpZiAoISR0cnV0aHkodmFsdWUpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2gocGFyYW0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmV2ZXJzZV9lYWNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJldmVyc2VfZWFjaCkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goYXJndW1lbnRzKTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IHJlc3VsdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAkeWllbGRYKGJsb2NrLCByZXN1bHRbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNsaWNlX2JlZm9yZShwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgaWYgYHBhdHRlcm4gPT09IHVuZGVmaW5lZCAmJiBibG9jayA9PT0gbmlsYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnYm90aCBwYXR0ZXJuIGFuZCBibG9jayBhcmUgZ2l2ZW4nXG4gICAgZW5kXG5cbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkICYmIGJsb2NrICE9PSBuaWwgfHwgYXJndW1lbnRzLmxlbmd0aCA+IDFgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGV4cGVjdGVkIDEpXCJcbiAgICBlbmRcblxuICAgIDo6RW51bWVyYXRvci5uZXcgZG8gfGV8XG4gICAgICAleHtcbiAgICAgICAgdmFyIHNsaWNlID0gW107XG5cbiAgICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgICBpZiAocGF0dGVybiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgICAgICAgaWYgKCR0cnV0aHkodmFsdWUpICYmIHNsaWNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAje2UgPDwgYHNsaWNlYH07XG4gICAgICAgICAgICAgICAgc2xpY2UgPSBbXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHNsaWNlLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBibG9jayhwYXJhbSwgI3twYXR0ZXJuLmR1cH0pO1xuXG4gICAgICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSAmJiBzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgI3tlIDw8IGBzbGljZWB9O1xuICAgICAgICAgICAgICAgIHNsaWNlID0gW107XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzbGljZS5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgICAgIHZhbHVlID0gI3twYXR0ZXJuID09PSBgcGFyYW1gfTtcblxuICAgICAgICAgICAgaWYgKCR0cnV0aHkodmFsdWUpICYmIHNsaWNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgI3tlIDw8IGBzbGljZWB9O1xuICAgICAgICAgICAgICBzbGljZSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzbGljZS5wdXNoKHBhcmFtKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICAgIGlmIChzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgI3tlIDw8IGBzbGljZWB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzbGljZV9hZnRlcihwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgaWYgYHBhdHRlcm4gPT09IHVuZGVmaW5lZCAmJiBibG9jayA9PT0gbmlsYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnYm90aCBwYXR0ZXJuIGFuZCBibG9jayBhcmUgZ2l2ZW4nXG4gICAgZW5kXG5cbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkICYmIGJsb2NrICE9PSBuaWwgfHwgYXJndW1lbnRzLmxlbmd0aCA+IDFgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGV4cGVjdGVkIDEpXCJcbiAgICBlbmRcblxuICAgIGlmIGBwYXR0ZXJuICE9PSB1bmRlZmluZWRgXG4gICAgICBibG9jayA9IDo6S2VybmVsLnByb2MgeyB8ZXwgcGF0dGVybiA9PT0gZSB9XG4gICAgZW5kXG5cbiAgICA6OkVudW1lcmF0b3IubmV3IGRvIHx5aWVsZGVyfFxuICAgICAgJXh7XG4gICAgICAgIHZhciBhY2N1bXVsYXRlO1xuXG4gICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgICBlbmRfY2h1bmsgPSAkeWllbGQxKGJsb2NrLCBlbGVtZW50KTtcblxuICAgICAgICAgIGlmIChhY2N1bXVsYXRlID09IG51bGwpIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdGUgPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoJHRydXRoeShlbmRfY2h1bmspKSB7XG4gICAgICAgICAgICBhY2N1bXVsYXRlLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICAje3lpZWxkZXIueWllbGQoYGFjY3VtdWxhdGVgKX07XG4gICAgICAgICAgICBhY2N1bXVsYXRlID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWNjdW11bGF0ZS5wdXNoKGVsZW1lbnQpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICAgIGlmIChhY2N1bXVsYXRlICE9IG51bGwpIHtcbiAgICAgICAgICAje3lpZWxkZXIueWllbGQoYGFjY3VtdWxhdGVgKX07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNsaWNlX3doZW4oJmJsb2NrKVxuICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKDAgZm9yIDEpJyB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICA6OkVudW1lcmF0b3IubmV3IGRvIHx5aWVsZGVyfFxuICAgICAgJXh7XG4gICAgICAgIHZhciBzbGljZSA9IG5pbCwgbGFzdF9hZnRlciA9IG5pbDtcblxuICAgICAgICBzZWxmLiRlYWNoX2NvbnMuJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHBhcmFtcyA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICAgIGJlZm9yZSA9IHBhcmFtc1swXSxcbiAgICAgICAgICAgICAgYWZ0ZXIgPSBwYXJhbXNbMV0sXG4gICAgICAgICAgICAgIG1hdGNoID0gJHlpZWxkWChibG9jaywgW2JlZm9yZSwgYWZ0ZXJdKTtcblxuICAgICAgICAgIGxhc3RfYWZ0ZXIgPSBhZnRlcjtcblxuICAgICAgICAgIGlmIChzbGljZSA9PT0gbmlsKSB7XG4gICAgICAgICAgICBzbGljZSA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgkdHJ1dGh5KG1hdGNoKSkge1xuICAgICAgICAgICAgc2xpY2UucHVzaChiZWZvcmUpO1xuICAgICAgICAgICAgI3t5aWVsZGVyLnlpZWxkKGBzbGljZWApfTtcbiAgICAgICAgICAgIHNsaWNlID0gW107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNsaWNlLnB1c2goYmVmb3JlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoX2NvbnMoMik7XG5cbiAgICAgICAgaWYgKHNsaWNlICE9PSBuaWwpIHtcbiAgICAgICAgICBzbGljZS5wdXNoKGxhc3RfYWZ0ZXIpO1xuICAgICAgICAgICN7eWllbGRlci55aWVsZChgc2xpY2VgKX07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNvcnQoJmJsb2NrKVxuICAgIGFyeSA9IHRvX2FcbiAgICBibG9jayA9IC0+KGEsIGIpIHsgYSA8PT4gYiB9IHVubGVzcyBibG9ja19naXZlbj9cbiAgICBhcnkuc29ydCgmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBzb3J0X2J5KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnNvcnRfYnkpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgZHVwID0gbWFwIGRvXG4gICAgICBhcmcgPSA6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApXG4gICAgICBbeWllbGQoYXJnKSwgYXJnXVxuICAgIGVuZFxuICAgIGR1cC5zb3J0ISB7IHxhLCBifCBgYVswXWAgPD0+IGBiWzBdYCB9XG4gICAgZHVwLm1hcCEgeyB8aXwgYGlbMV1gIH1cbiAgZW5kXG5cbiAgIyBUaGlzIG1ldGhvZCBpbXBsZW1lbnRzIHRoZSBLYWhhbiBzdW1tYXRpb24gYWxnb3JpdGhtIGlmIGl0IGlzIHBvc3NpYmxlIHRvIGFwcGx5IG9uZS5cbiAgZGVmIHN1bShpbml0aWFsID0gMClcbiAgICByZXN1bHQgPSBpbml0aWFsXG4gICAgY29tcGVuc2F0aW9uID0gMFxuXG4gICAgZWFjaCBkbyB8KmFyZ3N8XG4gICAgICBpdGVtID0gaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICAgICAgICAgICB5aWVsZCgqYXJncylcbiAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICA6Ok9wYWwuZGVzdHJ1Y3R1cmUoYXJncylcbiAgICAgICAgICAgICBlbmRcblxuICAgICAgaWYgIVs6OkZsb2F0OjpJTkZJTklUWSwgLTo6RmxvYXQ6OklORklOSVRZXS5pbmNsdWRlPyhpdGVtKSAmJiBpdGVtLnJlc3BvbmRfdG8/KDotKVxuICAgICAgICB5ID0gaXRlbSAtIGNvbXBlbnNhdGlvblxuICAgICAgICB0ID0gcmVzdWx0ICsgeVxuICAgICAgICBjb21wZW5zYXRpb24gPSAodCAtIHJlc3VsdCkgLSB5XG4gICAgICAgIHJlc3VsdCA9IHRcbiAgICAgIGVsc2VcbiAgICAgICAgcmVzdWx0ICs9IGl0ZW1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgcmVzdWx0XG4gIGVuZFxuXG4gIGRlZiB0YWtlKG51bSlcbiAgICBmaXJzdChudW0pXG4gIGVuZFxuXG4gIGRlZiB0YWtlX3doaWxlKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOnRha2Vfd2hpbGUgdW5sZXNzIGJsb2NrXG5cbiAgICByZXN1bHQgPSBbXVxuXG4gICAgZWFjaCBkbyB8KmFyZ3N8XG4gICAgICB2YWx1ZSA9IDo6T3BhbC5kZXN0cnVjdHVyZShhcmdzKVxuXG4gICAgICB1bmxlc3MgeWllbGQodmFsdWUpXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIGVuZFxuXG4gICAgICBgcmVzdWx0LnB1c2godmFsdWUpYFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgdW5pcSgmYmxvY2spXG4gICAgaGFzaCA9IHt9XG5cbiAgICBlYWNoIGRvIHwqYXJnc3xcbiAgICAgIHZhbHVlID0gOjpPcGFsLmRlc3RydWN0dXJlKGFyZ3MpXG5cbiAgICAgIHByb2R1Y2VkID0gaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICAgICAgICAgICAgICAgeWllbGQodmFsdWUpXG4gICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICBlbmRcblxuICAgICAgdW5sZXNzIGhhc2gua2V5Pyhwcm9kdWNlZClcbiAgICAgICAgaGFzaFtwcm9kdWNlZF0gPSB2YWx1ZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBoYXNoLnZhbHVlc1xuICBlbmRcblxuICBkZWYgdGFsbHkoaGFzaCA9IHVuZGVmaW5lZClcbiAgICBgaWYgKGhhc2ggJiYgaGFzaCAhPT0gbmlsKSB7ICRkZW55X2Zyb3plbl9hY2Nlc3MoaGFzaCk7IH1gXG5cbiAgICBvdXQgPSBncm91cF9ieSgmOml0c2VsZikudHJhbnNmb3JtX3ZhbHVlcygmOmNvdW50KVxuICAgIGlmIGhhc2hcbiAgICAgIG91dC5lYWNoIHsgfGssIHZ8IGhhc2hba10gPSBoYXNoLmZldGNoKGssIDApICsgdiB9XG4gICAgICBoYXNoXG4gICAgZWxzZVxuICAgICAgb3V0XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB0b19oKCphcmdzLCAmYmxvY2spXG4gICAgcmV0dXJuIG1hcCgmYmxvY2spLnRvX2goKmFyZ3MpIGlmIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgaGFzaCA9ICN7e319O1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAjezo6T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuICAgICAgICB2YXIgYXJ5ID0gI3s6Ok9wYWwuY29lcmNlX3RvPyhgcGFyYW1gLCA6OkFycmF5LCA6dG9fYXJ5KX0sIGtleSwgdmFsO1xuICAgICAgICBpZiAoIWFyeS4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJ3cm9uZyBlbGVtZW50IHR5cGUgI3tgcGFyYW1gLmNsYXNzfSAoZXhwZWN0ZWQgYXJyYXkpXCJ9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyeS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJlbGVtZW50IGhhcyB3cm9uZyBhcnJheSBsZW5ndGggKGV4cGVjdGVkIDIsIHdhcyAje2BhcnlgLmxlbmd0aH0pXCJ9XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gYXJ5WzBdO1xuICAgICAgICB2YWwgPSBhcnlbMV07XG5cbiAgICAgICAgT3BhbC5oYXNoX3B1dChoYXNoLCBrZXksIHZhbCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19zZXQoa2xhc3MgPSBTZXQsICphcmdzLCAmYmxvY2spXG4gICAga2xhc3MubmV3KHNlbGYsICphcmdzLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiB6aXAoKm90aGVycywgJmJsb2NrKVxuICAgIHRvX2EuemlwKCpvdGhlcnMpXG4gIGVuZFxuXG4gIGFsaWFzIGZpbmQgZGV0ZWN0XG4gIGFsaWFzIGZpbHRlciBmaW5kX2FsbFxuICBhbGlhcyBmbGF0X21hcCBjb2xsZWN0X2NvbmNhdFxuICBhbGlhcyBtYXAgY29sbGVjdFxuICBhbGlhcyBtZW1iZXI/IGluY2x1ZGU/XG4gIGFsaWFzIHJlZHVjZSBpbmplY3RcbiAgYWxpYXMgc2VsZWN0IGZpbmRfYWxsXG4gIGFsaWFzIHRvX2EgZW50cmllc1xuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6RW51bWVyYWJsZT4iLCJhbGw/IiwicGF0dGVybiIsImVhY2giLCJzZWxmIiwiYmxvY2sgaW4gYWxsPyIsImJsb2NrICgyIGxldmVscykgaW4gYWxsPyIsImNvbXBhcmFibGUiLCJwdWJsaWNfc2VuZCIsImJsb2NrX2dpdmVuPyIsInZhbHVlIiwiT3BhbCIsImRlc3RydWN0dXJlIiwiYW55PyIsImJsb2NrIGluIGFueT8iLCJibG9jayAoMiBsZXZlbHMpIGluIGFueT8iLCJjaHVuayIsInRvX2VudW0iLCJibG9jayBpbiBjaHVuayIsImJsb2NrICgyIGxldmVscykgaW4gY2h1bmsiLCJlbnVtZXJhdG9yX3NpemUiLCJuZXciLCJFbnVtZXJhdG9yIiwieWllbGRlciIsInlpZWxkIiwiY2h1bmtfd2hpbGUiLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJzbGljZV93aGVuIiwiYmxvY2sgaW4gY2h1bmtfd2hpbGUiLCJiZWZvcmUiLCJhZnRlciIsImJsb2NrICgyIGxldmVscykgaW4gY2h1bmtfd2hpbGUiLCIhIiwiY29sbGVjdCIsImVudW1fZm9yIiwiYmxvY2sgaW4gY29sbGVjdCIsImJsb2NrICgyIGxldmVscykgaW4gY29sbGVjdCIsImNvbGxlY3RfY29uY2F0IiwiYmxvY2sgaW4gY29sbGVjdF9jb25jYXQiLCJibG9jayAoMiBsZXZlbHMpIGluIGNvbGxlY3RfY29uY2F0IiwibWFwIiwiYmxvY2siLCJ0b19wcm9jIiwiZmxhdHRlbiIsIjEiLCJjb21wYWN0IiwidG9fYSIsImNvdW50Iiwib2JqZWN0IiwicmVzdWx0IiwiMCIsIndhcm4iLCJwcm9jIiwiYmxvY2sgaW4gY291bnQiLCJibG9jayAoMiBsZXZlbHMpIGluIGNvdW50IiwiYXJncyIsIj09IiwibmlsPyIsImN5Y2xlIiwibiIsImJsb2NrIGluIGN5Y2xlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjeWNsZSIsInJlc3BvbmRfdG8/IiwiRmxvYXQ6OklORklOSVRZIiwiRmxvYXQiLCJjb2VyY2VfdG8hIiwiSW50ZWdlciIsIj4iLCIqIiwiZGV0ZWN0IiwiaWZub25lIiwiYmxvY2sgaW4gZGV0ZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkZXRlY3QiLCJkcm9wIiwibnVtYmVyIiwiZHJvcF93aGlsZSIsImVhY2hfY29ucyIsInRyeV9jb252ZXJ0IiwiYmxvY2sgaW4gZWFjaF9jb25zIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX2NvbnMiLCJlbnVtX3NpemUiLCI8IiwiKyIsIi0iLCJlYWNoX2VudHJ5IiwiZGF0YSIsImJsb2NrIGluIGVhY2hfZW50cnkiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfZW50cnkiLCJlYWNoX3NsaWNlIiwiYmxvY2sgaW4gZWFjaF9zbGljZSIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF9zbGljZSIsIi8iLCJzaXplIiwiY2VpbCIsImVhY2hfd2l0aF9pbmRleCIsImJsb2NrIGluIGVhY2hfd2l0aF9pbmRleCIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF93aXRoX2luZGV4IiwiZWFjaF93aXRoX29iamVjdCIsImJsb2NrIGluIGVhY2hfd2l0aF9vYmplY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfd2l0aF9vYmplY3QiLCJlbnRyaWVzIiwiZmlsdGVyX21hcCIsImJsb2NrIGluIGZpbHRlcl9tYXAiLCJibG9jayAoMiBsZXZlbHMpIGluIGZpbHRlcl9tYXAiLCJzZWxlY3QiLCJmaW5kX2FsbCIsImJsb2NrIGluIGZpbmRfYWxsIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBmaW5kX2FsbCIsImZpbmRfaW5kZXgiLCJpbmRleCIsImJsb2NrIGluIGZpbmRfaW5kZXgiLCJibG9jayAoMiBsZXZlbHMpIGluIGZpbmRfaW5kZXgiLCJmaXJzdCIsImJsb2NrIGluIGZpcnN0IiwiY3VycmVudCIsImJsb2NrICgyIGxldmVscykgaW4gZmlyc3QiLCJncmVwIiwiYmxvY2sgaW4gZ3JlcCIsImJsb2NrICgyIGxldmVscykgaW4gZ3JlcCIsImNtcCIsIl9fc2VuZF9fIiwibGVuZ3RoIiwiPD0iLCJbXSIsInB1c2giLCJncmVwX3YiLCJibG9jayBpbiBncmVwX3YiLCJibG9jayAoMiBsZXZlbHMpIGluIGdyZXBfdiIsImdyb3VwX2J5IiwiYmxvY2sgaW4gZ3JvdXBfYnkiLCJibG9jayAoMiBsZXZlbHMpIGluIGdyb3VwX2J5IiwiaGFzaCIsIiRyZXRfb3JfMSIsIltdPSIsIjw8IiwiaW5jbHVkZT8iLCJvYmoiLCJibG9jayBpbiBpbmNsdWRlPyIsImJsb2NrICgyIGxldmVscykgaW4gaW5jbHVkZT8iLCJpbmplY3QiLCJzeW0iLCJTeW1ib2wiLCI9PT0iLCJUeXBlRXJyb3IiLCJpbnNwZWN0IiwibGF6eSIsIkVudW1lcmF0b3I6OkxhenkiLCJibG9jayBpbiBsYXp5IiwiZW51bSQiLCJibG9jayAoMiBsZXZlbHMpIGluIGxhenkiLCJtYXgiLCI8PT4iLCJzb3J0IiwicmV2ZXJzZSIsIm1heF9ieSIsImJsb2NrIGluIG1heF9ieSIsImJsb2NrICgyIGxldmVscykgaW4gbWF4X2J5Iiwic29ydF9ieSIsInRha2UiLCJtaW4iLCJibG9jayBpbiBtaW4iLCJhIiwiYiIsImNvbXBhcmUiLCJtaW5fYnkiLCJibG9jayBpbiBtaW5fYnkiLCJibG9jayAoMiBsZXZlbHMpIGluIG1pbl9ieSIsIm1pbm1heCIsImJsb2NrIGluIG1pbm1heCIsImJsb2NrICgyIGxldmVscykgaW4gbWlubWF4IiwiY2FsbCIsIm1pbm1heF9ieSIsImJsb2NrIGluIG1pbm1heF9ieSIsImJsb2NrICgyIGxldmVscykgaW4gbWlubWF4X2J5Iiwibm9uZT8iLCJibG9jayBpbiBub25lPyIsImJsb2NrICgyIGxldmVscykgaW4gbm9uZT8iLCJpdGVtIiwib25lPyIsImJsb2NrIGluIG9uZT8iLCJibG9jayAoMiBsZXZlbHMpIGluIG9uZT8iLCJwYXJ0aXRpb24iLCJibG9jayBpbiBwYXJ0aXRpb24iLCJibG9jayAoMiBsZXZlbHMpIGluIHBhcnRpdGlvbiIsInJlamVjdCIsImJsb2NrIGluIHJlamVjdCIsImJsb2NrICgyIGxldmVscykgaW4gcmVqZWN0IiwicmV2ZXJzZV9lYWNoIiwiYmxvY2sgaW4gcmV2ZXJzZV9lYWNoIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZXZlcnNlX2VhY2giLCJzbGljZV9iZWZvcmUiLCJibG9jayBpbiBzbGljZV9iZWZvcmUiLCJlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzbGljZV9iZWZvcmUiLCJkdXAiLCJzbGljZV9hZnRlciIsImJsb2NrIGluIHNsaWNlX2FmdGVyIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzbGljZV9hZnRlciIsImJsb2NrIGluIHNsaWNlX3doZW4iLCJibG9jayAoMiBsZXZlbHMpIGluIHNsaWNlX3doZW4iLCJhcnkiLCJibG9jayBpbiBzb3J0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzb3J0IiwiYmxvY2sgaW4gc29ydF9ieSIsImJsb2NrICgyIGxldmVscykgaW4gc29ydF9ieSIsImFyZyIsInNvcnQhIiwibWFwISIsImkiLCJzdW0iLCJpbml0aWFsIiwiY29tcGVuc2F0aW9uIiwiYmxvY2sgaW4gc3VtIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzdW0iLCItQCIsInkiLCJ0IiwibnVtIiwidGFrZV93aGlsZSIsImJsb2NrIGluIHRha2Vfd2hpbGUiLCJibG9jayAoMiBsZXZlbHMpIGluIHRha2Vfd2hpbGUiLCJ1bmlxIiwiYmxvY2sgaW4gdW5pcSIsImJsb2NrICgyIGxldmVscykgaW4gdW5pcSIsInByb2R1Y2VkIiwia2V5PyIsInZhbHVlcyIsInRhbGx5Iiwib3V0IiwidHJhbnNmb3JtX3ZhbHVlcyIsImJsb2NrIGluIHRhbGx5IiwiayIsInYiLCJibG9jayAoMiBsZXZlbHMpIGluIHRhbGx5IiwiZmV0Y2giLCJ0b19oIiwiY29lcmNlX3RvPyIsIkFycmF5IiwiY2xhc3MiLCJ0b19zZXQiLCJTZXQiLCJrbGFzcyIsInppcCIsIm90aGVycyJdLCJtYXBwaW5ncyI6IkFBQUFBLHFDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBR0FBLE9BQUFDO0VBQUFBOztJQUFBQTs7OztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVFQyxJQUFBQSxvQkFBQUEsZ0NBQVNDLE9BQVRELEdBQUFBLE1BQUFBLElBQUFBLDhCQUFBQTtBQUFBQSxNQUFBQTs7TUFBQUE7Ozs7TUFDRSxJQUFBLFFBQUlBLHFCQUFKLENBQUE7UUFDRUUsTUFBQUMsSUFBQUQsUUFBQUEsRUFBQUEsRUFBQUEsRUFBQUUsYUFwQk4sRUFvQk1BLEVBQUFDOzs7VUFwQk47VUFvQmU7VUFDUEMsYUFBY0Q7VUFFZCxJQUFBLFFBQTJCRSxNQUFQTixPQUFPTSxlQUFBQSxFQUFQLENBQW9CLEtBQXBCLENBQUEsUUFBMEIsTUFBQ0QsVUFBRCxDQUExQixDQUFPQyxDQUEzQixDQUFBO1lBdkJSRixPQUFBO1VBdUJRO1lBQUEsU0FBQSxRQUFPLEtBQVAsRUFBQSxHQUFBO1VBQUEsRUFIRkQsQ0FBQUEsR0FBQUEsNkJBQUFBLENBQUFGO01BREYsT0FNQSxJQUFNTSxlQUFOO1FBQ0VOLE1BQUFDLElBQUFELFFBQUFBLEVBQUFBLEVBQUFBLEVBQUFFLGFBMUJOLEVBMEJNQSxFQUFBQzs7O1VBMUJOO1VBMEJlO1VBQ1AsSUFBQSxRQUFPLG1CQUFNLE1BQUNJLEtBQUQsQ0FBTixDQUFQLENBQUE7WUEzQlJKLE9BQUE7VUEyQlE7WUFDRSxTQUFBLFFBQU8s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LEVBQWEsVUFBYjtJQUNBcFAsT0FBQSxhQUFNLE1BQU4sRUFBVyxTQUFYO0VBbndDRkEsR0FBTyxJQUFQQTtBQUhBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MTE0MzAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2VudW1lcmF0b3IvYXJpdGhtZXRpY19zZXF1ZW5jZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcblxuY2xhc3MgOjpFbnVtZXJhdG9yXG4gIGNsYXNzIHNlbGY6OkFyaXRobWV0aWNTZXF1ZW5jZSA8IHNlbGZcbiAgICBgT3BhbC5wcm9wKHNlbGYuJCRwcm90b3R5cGUsICckJGlzX2FyaXRobWV0aWNfc2VxJywgdHJ1ZSlgXG5cbiAgICBgdmFyIGluZiA9IEluZmluaXR5YFxuXG4gICAgIyBAcHJpdmF0ZVxuICAgIGRlZiBpbml0aWFsaXplKHJhbmdlLCBzdGVwID0gdW5kZWZpbmVkLCBjcmVhdGlvbl9tZXRob2QgPSA6c3RlcClcbiAgICAgIEBjcmVhdGlvbl9tZXRob2QgPSBjcmVhdGlvbl9tZXRob2RcbiAgICAgIGlmIHJhbmdlLmlzX2E/IDo6QXJyYXlcbiAgICAgICAgQHN0ZXBfYXJnMSwgQHN0ZXBfYXJnMiwgQHRvcGZ4LCBAYnlwZnggPSAqcmFuZ2VcbiAgICAgICAgQHJlY2VpdmVyX251bSA9IHN0ZXBcbiAgICAgICAgQHN0ZXAgPSAxXG5cbiAgICAgICAgQHJhbmdlID0gaWYgQHN0ZXBfYXJnMlxuICAgICAgICAgICAgICAgICAgIEBzdGVwID0gQHN0ZXBfYXJnMlxuICAgICAgICAgICAgICAgICAgIChAcmVjZWl2ZXJfbnVtLi5Ac3RlcF9hcmcxKVxuICAgICAgICAgICAgICAgICBlbHNpZiBAc3RlcF9hcmcxXG4gICAgICAgICAgICAgICAgICAgKEByZWNlaXZlcl9udW0uLkBzdGVwX2FyZzEpXG4gICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAoQHJlY2VpdmVyX251bS4ubmlsKVxuICAgICAgICAgICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgQHNraXBwZWRfYXJnID0gdHJ1ZSB1bmxlc3Mgc3RlcFxuICAgICAgICBAcmFuZ2UsIEBzdGVwID0gcmFuZ2UsIHN0ZXAgfHwgMVxuICAgICAgZW5kXG5cbiAgICAgIEBvYmplY3QgPSBzZWxmXG5cbiAgICAgIDo6S2VybmVsLnJhaXNlIEFyZ3VtZW50RXJyb3IsIFwic3RlcCBjYW4ndCBiZSAwXCIgaWYgQHN0ZXAgPT0gMFxuICAgICAgdW5sZXNzIEBzdGVwLnJlc3BvbmRfdG8/IDp0b19pbnRcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgQXJndW1lbnRFcnJvciwgXCJubyBpbXBsaWNpdCBjb252ZXJzaW9uIG9mICN7QHN0ZXAuY2xhc3N9IFwiIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpbnRvIEludGVnZXInXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGF0dHJfcmVhZGVyIDpzdGVwXG5cbiAgICBkZWYgYmVnaW5cbiAgICAgIEByYW5nZS5iZWdpblxuICAgIGVuZFxuXG4gICAgZGVmIGVuZFxuICAgICAgQHJhbmdlLmVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGV4Y2x1ZGVfZW5kP1xuICAgICAgQHJhbmdlLmV4Y2x1ZGVfZW5kP1xuICAgIGVuZFxuXG4gICAgIyBAcHJpdmF0ZVxuICAgIGRlZiBfbGVzc2VyX3RoYW5fZW5kPyh2YWwpXG4gICAgICBlbmRfID0gc2VsZi5lbmQgfHwgYGluZmBcbiAgICAgIGlmIHN0ZXAgPiAwXG4gICAgICAgIGV4Y2x1ZGVfZW5kPyA/IHZhbCA8IGVuZF8gOiB2YWwgPD0gZW5kX1xuICAgICAgZWxzZVxuICAgICAgICBleGNsdWRlX2VuZD8gPyB2YWwgPiBlbmRfIDogdmFsID49IGVuZF9cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgIyBAcHJpdmF0ZVxuICAgIGRlZiBfZ3JlYXRlcl90aGFuX2JlZ2luPyh2YWwpXG4gICAgICBiZWdpbl8gPSBzZWxmLmJlZ2luIHx8IC1gaW5mYFxuICAgICAgaWYgc3RlcCA+IDBcbiAgICAgICAgdmFsID4gYmVnaW5fXG4gICAgICBlbHNlXG4gICAgICAgIHZhbCA8IGJlZ2luX1xuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgZmlyc3QoY291bnQgPSB1bmRlZmluZWQpXG4gICAgICBpdGVyID0gc2VsZi5iZWdpbiB8fCAtYGluZmBcblxuICAgICAgcmV0dXJuIF9sZXNzZXJfdGhhbl9lbmQ/KGl0ZXIpID8gaXRlciA6IG5pbCB1bmxlc3MgY291bnRcblxuICAgICAgb3V0ID0gW11cblxuICAgICAgd2hpbGUgX2xlc3Nlcl90aGFuX2VuZD8oaXRlcikgJiYgY291bnQgPiAwXG4gICAgICAgIG91dCA8PCBpdGVyXG4gICAgICAgIGl0ZXIgKz0gc3RlcFxuICAgICAgICBjb3VudCAtPSAxXG4gICAgICBlbmRcblxuICAgICAgb3V0XG4gICAgZW5kXG5cbiAgICBkZWYgZWFjaCgmYmxvY2spXG4gICAgICByZXR1cm4gc2VsZiB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAgIGNhc2Ugc2VsZi5iZWdpblxuICAgICAgd2hlbiBuaWxcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgVHlwZUVycm9yLCBcIm5pbCBjYW4ndCBiZSBjb2VyY2VkIGludG8gSW50ZWdlclwiXG4gICAgICBlbmRcblxuICAgICAgaXRlciA9IHNlbGYuYmVnaW4gfHwgLWBpbmZgXG5cbiAgICAgIHdoaWxlIF9sZXNzZXJfdGhhbl9lbmQ/KGl0ZXIpXG4gICAgICAgIHlpZWxkIGl0ZXJcbiAgICAgICAgaXRlciArPSBzdGVwXG4gICAgICBlbmRcbiAgICAgIHNlbGZcbiAgICBlbmRcblxuICAgIGRlZiBsYXN0KGNvdW50ID0gdW5kZWZpbmVkKVxuICAgICAgY2FzZSBzZWxmLmVuZFxuICAgICAgd2hlbiBgaW5mYCwgLWBpbmZgXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6RmxvYXREb21haW5FcnJvciwgc2VsZi5lbmRcbiAgICAgIHdoZW4gbmlsXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ2Nhbm5vdCBnZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBlbmRsZXNzIGFyaXRobWV0aWMgc2VxdWVuY2UnXG4gICAgICBlbmRcblxuICAgICAgaXRlciA9IHNlbGYuZW5kIC0gKChzZWxmLmVuZCAtIHNlbGYuYmVnaW4pICUgc3RlcClcbiAgICAgIGl0ZXIgLT0gc3RlcCB1bmxlc3MgX2xlc3Nlcl90aGFuX2VuZD8oaXRlcilcblxuICAgICAgcmV0dXJuIF9ncmVhdGVyX3RoYW5fYmVnaW4/KGl0ZXIpID8gaXRlciA6IG5pbCB1bmxlc3MgY291bnRcblxuICAgICAgb3V0ID0gW11cblxuICAgICAgd2hpbGUgX2dyZWF0ZXJfdGhhbl9iZWdpbj8oaXRlcikgJiYgY291bnQgPiAwXG4gICAgICAgIG91dCA8PCBpdGVyXG4gICAgICAgIGl0ZXIgLT0gc3RlcFxuICAgICAgICBjb3VudCAtPSAxXG4gICAgICBlbmRcblxuICAgICAgb3V0LnJldmVyc2VcbiAgICBlbmRcblxuICAgIGRlZiBzaXplXG4gICAgICBzdGVwX3NpZ24gPSBzdGVwID4gMCA/IDEgOiAtMVxuXG4gICAgICBpZiAhX2xlc3Nlcl90aGFuX2VuZD8oc2VsZi5iZWdpbilcbiAgICAgICAgMFxuICAgICAgZWxzaWYgWy1gaW5mYCwgYGluZmBdLmluY2x1ZGU/KHN0ZXApXG4gICAgICAgIDFcbiAgICAgIGVsc2lmIFstYGluZmAgKiBzdGVwX3NpZ24sIG5pbF0uaW5jbHVkZT8oc2VsZi5iZWdpbikgfHxcbiAgICAgICAgICAgIFtgaW5mYCAqIHN0ZXBfc2lnbiwgbmlsXS5pbmNsdWRlPyhzZWxmLmVuZClcbiAgICAgICAgYGluZmBcbiAgICAgIGVsc2VcbiAgICAgICAgaXRlciA9IHNlbGYuZW5kIC0gKChzZWxmLmVuZCAtIHNlbGYuYmVnaW4pICUgc3RlcClcbiAgICAgICAgaXRlciAtPSBzdGVwIHVubGVzcyBfbGVzc2VyX3RoYW5fZW5kPyhpdGVyKVxuICAgICAgICAoKGl0ZXIgLSBzZWxmLmJlZ2luKSAvIHN0ZXApLmFicy50b19pICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgPT0ob3RoZXIpXG4gICAgICBzZWxmLmNsYXNzID09IG90aGVyLmNsYXNzICYmXG4gICAgICAgIHNlbGYuYmVnaW4gPT0gb3RoZXIuYmVnaW4gJiZcbiAgICAgICAgc2VsZi5lbmQgPT0gb3RoZXIuZW5kICYmXG4gICAgICAgIHN0ZXAgPT0gb3RoZXIuc3RlcCAmJlxuICAgICAgICBleGNsdWRlX2VuZD8gPT0gb3RoZXIuZXhjbHVkZV9lbmQ/XG4gICAgZW5kXG5cbiAgICBkZWYgaGFzaFxuICAgICAgW0FyaXRobWV0aWNTZXF1ZW5jZSwgc2VsZi5iZWdpbiwgc2VsZi5lbmQsIHN0ZXAsIGV4Y2x1ZGVfZW5kP10uaGFzaFxuICAgIGVuZFxuXG4gICAgZGVmIGluc3BlY3RcbiAgICAgIGlmIEByZWNlaXZlcl9udW1cbiAgICAgICAgYXJncyA9IGlmIEBzdGVwX2FyZzJcbiAgICAgICAgICAgICAgICAgXCIoI3tAdG9wZnh9I3tAc3RlcF9hcmcxLmluc3BlY3R9LCAje0BieXBmeH0je0BzdGVwX2FyZzIuaW5zcGVjdH0pXCJcbiAgICAgICAgICAgICAgIGVsc2lmIEBzdGVwX2FyZzFcbiAgICAgICAgICAgICAgICAgXCIoI3tAdG9wZnh9I3tAc3RlcF9hcmcxLmluc3BlY3R9KVwiXG4gICAgICAgICAgICAgICBlbmRcblxuICAgICAgICBcIigje0ByZWNlaXZlcl9udW0uaW5zcGVjdH0uI3tAY3JlYXRpb25fbWV0aG9kfSN7YXJnc30pXCJcbiAgICAgIGVsc2VcbiAgICAgICAgYXJncyA9IHVubGVzcyBAc2tpcHBlZF9hcmdcbiAgICAgICAgICAgICAgICAgXCIoI3tAc3RlcH0pXCJcbiAgICAgICAgICAgICAgIGVuZFxuICAgICAgICBcIigoI3tAcmFuZ2UuaW5zcGVjdH0pLiN7QGNyZWF0aW9uX21ldGhvZH0je2FyZ3N9KVwiXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGFsaWFzID09PSA9PVxuICAgIGFsaWFzIGVxbD8gPT1cbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOkVudW1lcmF0b3I+IiwiPGNsYXNzOnNlbGY6OkFyaXRobWV0aWNTZXF1ZW5jZT4iLCJpbml0aWFsaXplIiwicmFuZ2UiLCJzdGVwIiwiY3JlYXRpb25fbWV0aG9kIiwiQGNyZWF0aW9uX21ldGhvZCIsImlzX2E/IiwiQXJyYXkiLCJAc3RlcF9hcmcxIiwiQHN0ZXBfYXJnMiIsIkB0b3BmeCIsIkBieXBmeCIsIkByZWNlaXZlcl9udW0iLCJAc3RlcCIsIjEiLCJAcmFuZ2UiLCJAc2tpcHBlZF9hcmciLCIkcmV0X29yXzEiLCJAb2JqZWN0Iiwic2VsZiIsIjAiLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJyZXNwb25kX3RvPyIsImNsYXNzIiwiYXR0cl9yZWFkZXIiLCJiZWdpbiIsImVuZCIsImV4Y2x1ZGVfZW5kPyIsIl9sZXNzZXJfdGhhbl9lbmQ/IiwidmFsIiwiZW5kXyIsIj4iLCI8IiwiPD0iLCI+PSIsIl9ncmVhdGVyX3RoYW5fYmVnaW4/IiwiYmVnaW5fIiwiLUAiLCJmaXJzdCIsImNvdW50IiwiaXRlciIsIm91dCIsIjw8IiwiKyIsIi0iLCJlYWNoIiwiYmxvY2tfZ2l2ZW4/IiwiVHlwZUVycm9yIiwibGFzdCIsIkZsb2F0RG9tYWluRXJyb3IiLCJSYW5nZUVycm9yIiwiJSIsInJldmVyc2UiLCJzaXplIiwic3RlcF9zaWduIiwiLTEiLCJpbmNsdWRlPyIsIioiLCIvIiwiYWJzIiwidG9faSIsIj09Iiwib3RoZXIiLCIkcmV0X29yXzIiLCIkcmV0X29yXzMiLCIkcmV0X29yXzQiLCJoYXNoIiwiQXJpdGhtZXRpY1NlcXVlbmNlIiwiaW5zcGVjdCIsImFyZ3MiXSwibWFwcGluZ3MiOiJBQUFBQSx5REFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUVB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QUE2QmpFLG9CQUE3QixDQUFBLEdBQUEsQ0FBZ0RrRSxJQUFoRCxDQUFBLEdBQXFERDtRQVB2RDs7VUFTRUMsT0FBTyxDQUFBLFFBQU92RCxnQkFBUCxDQUFBLEdBQUEsQ0FBQSxHQUFBLElBQUEsQ0FDR3NELEdBQUQsR0FBQSxDQUFJekQsU0FBSixDQUFBLEdBQVV5RCxHQURaLENBQUE7VUFHUEEsT0FBQ0EsSUFBRCxHQUFBLENBQUt2RCxVQUFNdUQsU0FBQUEsQ0FBQUEsQ0FBWCxDQUFBLEdBQW9CQSxJQUFwQixHQUFBLENBQXdCakUsb0JBQXhCLENBQUEsR0FBQSxDQUEyQ2tFLElBQTNDLENBQUEsR0FBZ0REO1FBWmxEO01BREZBLENBQUFBO01BaUJBLGFBQU0sS0FBTixFQUFVLElBQVY7TUFDQXRFLE9BQUEsYUFBTSxNQUFOLEVBQVcsSUFBWDtJQTdLRkEsR0FBTW1CLElBQU5uQixFQUFpQ21CLElBQWpDbkI7RUFERkQsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQUZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MTE2NTYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2VudW1lcmF0b3IvY2hhaW4ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBkZW55X2Zyb3plbl9hY2Nlc3NcbiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxuXG5jbGFzcyA6OkVudW1lcmF0b3JcbiAgY2xhc3Mgc2VsZjo6Q2hhaW4gPCBzZWxmXG4gICAgZGVmIGluaXRpYWxpemUoKmVudW1zKVxuICAgICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXG5cbiAgICAgIEBlbnVtcyA9IGVudW1zXG4gICAgICBAaXRlcmF0ZWQgPSBbXVxuICAgICAgQG9iamVjdCA9IHNlbGZcbiAgICBlbmRcblxuICAgIGRlZiBlYWNoKCphcmdzLCAmYmxvY2spXG4gICAgICByZXR1cm4gdG9fZW51bSg6ZWFjaCwgKmFyZ3MpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICAgQGVudW1zLmVhY2ggZG8gfGVudW18XG4gICAgICAgIEBpdGVyYXRlZCA8PCBlbnVtXG4gICAgICAgIGVudW0uZWFjaCgqYXJncywgJmJsb2NrKVxuICAgICAgZW5kXG5cbiAgICAgIHNlbGZcbiAgICBlbmRcblxuICAgIGRlZiBzaXplKCphcmdzKVxuICAgICAgYWNjdW0gPSAwXG4gICAgICBAZW51bXMuZWFjaCBkbyB8ZW51bXxcbiAgICAgICAgc2l6ZSA9IGVudW0uc2l6ZSgqYXJncylcbiAgICAgICAgcmV0dXJuIHNpemUgaWYgW25pbCwgOjpGbG9hdDo6SU5GSU5JVFldLmluY2x1ZGU/IHNpemVcbiAgICAgICAgYWNjdW0gKz0gc2l6ZVxuICAgICAgZW5kXG4gICAgICBhY2N1bVxuICAgIGVuZFxuXG4gICAgZGVmIHJld2luZFxuICAgICAgQGl0ZXJhdGVkLnJldmVyc2VfZWFjaCBkbyB8ZW51bXxcbiAgICAgICAgZW51bS5yZXdpbmQgaWYgZW51bS5yZXNwb25kX3RvPyA6cmV3aW5kXG4gICAgICBlbmRcbiAgICAgIEBpdGVyYXRlZCA9IFtdXG4gICAgICBzZWxmXG4gICAgZW5kXG5cbiAgICBkZWYgaW5zcGVjdFxuICAgICAgXCIjPEVudW1lcmF0b3I6OkNoYWluOiAje0BlbnVtcy5pbnNwZWN0fT5cIlxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6RW51bWVyYXRvcj4iLCI8Y2xhc3M6c2VsZjo6Q2hhaW4+IiwiaW5pdGlhbGl6ZSIsIkBlbnVtcyIsImVudW1zIiwiQGl0ZXJhdGVkIiwiQG9iamVjdCIsInNlbGYiLCJlYWNoIiwiYmxvY2tfZ2l2ZW4/IiwidG9fZW51bSIsImFyZ3MiLCJibG9jayBpbiBlYWNoIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoIiwic2l6ZSIsImVudW0kIiwiPDwiLCJibG9jayIsInRvX3Byb2MiLCJhY2N1bSIsIjAiLCJibG9jayBpbiBzaXplIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzaXplIiwiRmxvYXQ6OklORklOSVRZIiwiRmxvYXQiLCJpbmNsdWRlPyIsIisiLCJyZXdpbmQiLCJyZXZlcnNlX2VhY2giLCJibG9jayBpbiByZXdpbmQiLCJyZXNwb25kX3RvPyIsImJsb2NrICgyIGxldmVscykgaW4gcmV3aW5kIiwiaW5zcGVjdCJdLCJtYXBwaW5ncyI6IkFBQUFBLDJDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBR0FBLE9BQUFDO0VBQUFBOzs7SUFDRUEsT0FBQUM7SUFBQUE7O01BQUFBOztBQUFBQTs7O0FBQ0VDLE1BQUFBLDBCQUFBQSxzQkFMSixFQUtJQTtBQUFBQSxRQUFBQTs7O1FBTEo7UUFLbUI7UUFDWkE7UUFFREMsYUFBU0M7UUFDVEMsZ0JBQVk7UUFDWkgsT0FBQUksQ0FBQUEsY0FBVUMsSUFBVkQ7TUFMRkosQ0FBQUEsSUFBQUE7O0FBUUFNLE1BQUFBLG9CQUFBQSxnQkFiSixFQWFJQTtBQUFBQSxRQUFBQTs7UUFBQUE7OztRQWJKO1FBYWE7UUFDUCxLQUE2Q0MsZUFBN0M7VUFBQSxPQUFPQyxNQUFBSCxJQUFBRyxXQUFBQSxFQUFBLENBQVEsTUFBUixDQUFBLFFBQWUsTUFBQ0MsSUFBRCxDQUFmLENBQUFELEVBQUFFLGFBQUFBLEVBQUFDOztZQUF3QkEsT0FBQU4sSUFBQU8sTUFBQUEsQ0FBQUEsQ0FBeEJGLENBQUFBLEdBQUFBLFNBQUFBLENBQUFGO1FBQVA7UUFFTUYsTUFBTkwsVUFBTUssUUFBQUEsRUFBQUEsRUFBQUEsRUFBTkksYUFBZ0JHLEtBQWhCSCxFQUFBQztBQUFBQTs7O1VBQWdCO1VBQ2RSLGFBQVVXLE9BQUFBLENBQUdELEtBQUhDO1VBQ1ZILE9BQUlMLE1BQUpPLEtBQUlQLFFBQUFBLEVBQU0sTUFBQ0csSUFBRCxDQUFOSCxFQUFjUyxLQUFEQyxTQUFBQSxDQUFBQSxDQUFiVixFQUZOSSxDQUFBQSxHQUFBQSxTQUFBQSxDQUFNSjtRQUtOQSxPQUFBRDtNQVJGQyxDQUFBQSxJQUFBQTs7QUFXQU0sTUFBQUEsb0JBQUFBLGdCQXhCSixFQXdCSUEsR0FBQUEsTUFBQUEsSUFBQUEsOEJBQUFBO0FBQUFBLFFBQUFBOzs7UUF4Qko7UUF3QmE7UUFDUEssUUFBUUM7UUFDRlosTUFBTkwsVUFBTUssUUFBQUEsRUFBQUEsRUFBQUEsRUFBTmEsYUFBZ0JOLEtBQWhCTSxFQUFBQzs7O1VBQWdCO1VBQ2RSLE9BQVdBLE1BQUpDLEtBQUlELFFBQUFBLEVBQU0sTUFBQ0gsSUFBRCxDQUFORztVQUNYLElBQUEsUUFBZSxDQUFDLEdBQUQsRUFBTVMsSUFBQUMsWUFBQUQsYUFBTixDQUF3QkUsYUFBQUEsQ0FBVVgsSUFBVlcsQ0FBdkMsQ0FBQTtZQUFBLFNBQUEsUUFBT1gsSUFBUCxFQUFBLEdBQUE7VUFBQTtVQUNBUSxPQUFBSCxDQUFBQSxRQUFNTyxTQUFOUCxLQUFNTyxFQUFHWixJQUFIWSxDQUFOUCxFQUhGRSxDQUFBQSxHQUFBQSxnQkFBQUEsQ0FBTWI7UUFLTk0sT0FBQUssTUFQRkw7VUFBQUE7VUFBQUE7UUFBQUEsQ0FBQUEsVUFBQUEsMkJBQUFBO01BQUFBLENBQUFBLElBQUFBOztBQVVBYSxNQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLFFBQUFBOzs7UUFDV0MsTUFBVHZCLGFBQVN1QixnQkFBQUEsRUFBQUEsRUFBQUEsRUFBVEMsYUFBMkJkLEtBQTNCYzs7VUFBMkI7VUFDekIsSUFBQSxRQUFlZCxLQUFJZSxnQkFBQUEsQ0FBYSxRQUFiQSxDQUFuQixDQUFBO1lBQUFDLE9BQUFoQixLQUFJWSxRQUFBQSxDQUFBQTtVQUFKO1lBcENSSSxPQUFBO1VBb0NRLEVBREZGLENBQVNEO1FBR1R2QixnQkFBWTtRQUNac0IsT0FBQXBCO01BTEZvQixDQUFBQTtNQVFBMUIsT0FBQStCLHVCQUFBQSxtQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUNBLHVCQUFELEdBQUEsQ0FBd0I3QixVQUFNNkIsU0FBQUEsQ0FBQUEsQ0FBOUIsQ0FBQSxHQUF1Q0E7TUFEekNBLENBQUFBO0lBdENGL0IsR0FBTU0sSUFBTk4sRUFBb0JNLElBQXBCTjtFQURGRCxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBSEFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxMTc1MywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvZW51bWVyYXRvci9nZW5lcmF0b3IucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBkZW55X2Zyb3plbl9hY2Nlc3NcbiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxuXG5jbGFzcyBFbnVtZXJhdG9yXG4gIGNsYXNzIEdlbmVyYXRvclxuICAgIGluY2x1ZGUgOjpFbnVtZXJhYmxlXG5cbiAgICBkZWYgaW5pdGlhbGl6ZSgmYmxvY2spXG4gICAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcblxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpMb2NhbEp1bXBFcnJvciwgJ25vIGJsb2NrIGdpdmVuJyB1bmxlc3MgYmxvY2tcblxuICAgICAgQGJsb2NrID0gYmxvY2tcbiAgICBlbmRcblxuICAgIGRlZiBlYWNoKCphcmdzLCAmYmxvY2spXG4gICAgICB5aWVsZGVyID0gWWllbGRlci5uZXcoJmJsb2NrKVxuXG4gICAgICAleHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhcmdzLnVuc2hpZnQoI3t5aWVsZGVyfSk7XG5cbiAgICAgICAgICBPcGFsLnlpZWxkWCgje0BibG9ja30sIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGUgJiYgZS4kdGhyb3dlcl90eXBlID09IFwiYnJlYWtlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZS4kdjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpFbnVtZXJhdG9yPiIsIjxjbGFzczpHZW5lcmF0b3I+Iiwic2VsZiIsImluY2x1ZGUiLCJFbnVtZXJhYmxlIiwiaW5pdGlhbGl6ZSIsImJsb2NrIiwiS2VybmVsIiwicmFpc2UiLCJMb2NhbEp1bXBFcnJvciIsIkBibG9jayIsImVhY2giLCJ5aWVsZGVyIiwibmV3IiwiWWllbGRlciIsInRvX3Byb2MiXSwibWFwcGluZ3MiOiJBQUFBQSwrQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUdBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQ0VBLE9BQUFDO0lBQUFBOztNQUFBQTs7QUFBQUE7O01BQ0VDLElBQUFDLFNBQUFBLENBQVFDLGlCQUFSRDs7QUFFQUUsTUFBQUEsMEJBQUFBLHNCQUFBQTtBQUFBQSxRQUFBQTs7UUFBQUE7OztRQUNHQTtRQUVELEtBQUEsUUFBeURDLEtBQXpELENBQUE7VUFBQUMsT0FBUUMsT0FBQUEsQ0FBT0MscUJBQWYsRUFBaUNKLGdCQUF6Qkc7UUFBUjtRQUVBSCxPQUFBSyxDQUFBQSxhQUFTSixLQUFUSTtNQUxGTCxDQUFBQTtNQVFBSixPQUFBVSxvQkFBQUEsZ0JBZkosRUFlSUE7QUFBQUEsUUFBQUE7O1FBQUFBOzs7UUFmSjtRQWVhO1FBQ1BDLFVBQWlCQyxNQUFQQyxhQUFPRCxPQUFBQSxFQUFBQSxFQUFBQSxFQUFNUCxLQUFEUyxTQUFBQSxDQUFBQSxDQUFMRjs7QUFHdkJGO0FBQ0FBLHVCQUF5QkMsT0FBUUQ7O0FBRWpDQSxzQkFBd0JELFVBQU9DO0FBQy9CQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtRQUVNQSxPQUFBVDtNQW5CRlMsQ0FBQUEsSUFBQUE7SUFYRlYsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFERkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFIQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjExODEzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9lbnVtZXJhdG9yL2xhenkucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiB0cnV0aHksIGNvZXJjZV90bywgeWllbGQxLCB5aWVsZFgsIGRlbnlfZnJvemVuX2FjY2Vzc1xuIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXG5cbmNsYXNzIDo6RW51bWVyYXRvclxuICBjbGFzcyBzZWxmOjpMYXp5IDwgc2VsZlxuICAgIGNsYXNzIHNlbGY6OlN0b3BMYXp5RXJyb3IgPCA6OkV4Y2VwdGlvbjsgZW5kXG5cbiAgICBkZWYgc2VsZi5mb3Iob2JqZWN0LCAqKVxuICAgICAgbGF6eSA9IHN1cGVyXG4gICAgICBgbGF6eS5lbnVtZXJhdG9yID0gb2JqZWN0YFxuICAgICAgbGF6eVxuICAgIGVuZFxuXG4gICAgZGVmIGluaXRpYWxpemUob2JqZWN0LCBzaXplID0gbmlsLCAmYmxvY2spXG4gICAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcblxuICAgICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjYWxsIGxhenkgbmV3IHdpdGhvdXQgYSBibG9jaydcbiAgICAgIGVuZFxuXG4gICAgICBAZW51bWVyYXRvciA9IG9iamVjdFxuXG4gICAgICBzdXBlciBzaXplIGRvIHx5aWVsZGVyLCAqZWFjaF9hcmdzfFxuICAgICAgICBvYmplY3QuZWFjaCgqZWFjaF9hcmdzKSBkbyB8KmFyZ3N8XG4gICAgICAgICAgJXh7XG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQoI3t5aWVsZGVyfSk7XG5cbiAgICAgICAgICAgICR5aWVsZFgoYmxvY2ssIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgZW5kXG4gICAgICByZXNjdWUgU3RvcExhenlFcnJvclxuICAgICAgICBuaWxcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGxhenlcbiAgICAgIHNlbGZcbiAgICBlbmRcblxuICAgIGRlZiBjb2xsZWN0KCZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja1xuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjYWxsIGxhenkgbWFwIHdpdGhvdXQgYSBibG9jaydcbiAgICAgIGVuZFxuXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBlbnVtZXJhdG9yX3NpemUpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgJXh7XG4gICAgICAgICAgdmFyIHZhbHVlID0gJHlpZWxkWChibG9jaywgYXJncyk7XG5cbiAgICAgICAgICAje2VudW0ueWllbGQgYHZhbHVlYH07XG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGNvbGxlY3RfY29uY2F0KCZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja1xuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjYWxsIGxhenkgbWFwIHdpdGhvdXQgYSBibG9jaydcbiAgICAgIGVuZFxuXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgJXh7XG4gICAgICAgICAgdmFyIHZhbHVlID0gJHlpZWxkWChibG9jaywgYXJncyk7XG5cbiAgICAgICAgICBpZiAoI3tgdmFsdWVgLnJlc3BvbmRfdG8/IDpmb3JjZX0gJiYgI3tgdmFsdWVgLnJlc3BvbmRfdG8/IDplYWNofSkge1xuICAgICAgICAgICAgI3tgdmFsdWVgLmVhY2ggeyB8dnwgZW51bS55aWVsZCB2IH19XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFycmF5ID0gI3s6Ok9wYWwudHJ5X2NvbnZlcnQgYHZhbHVlYCwgOjpBcnJheSwgOnRvX2FyeX07XG5cbiAgICAgICAgICAgIGlmIChhcnJheSA9PT0gbmlsKSB7XG4gICAgICAgICAgICAgICN7ZW51bS55aWVsZCBgdmFsdWVgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAje2B2YWx1ZWAuZWFjaCB7IHx2fCBlbnVtLnlpZWxkIHYgfX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBkcm9wKG4pXG4gICAgICBuID0gYCRjb2VyY2VfdG8oI3tufSwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICAgIGlmIG4gPCAwXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2F0dGVtcHQgdG8gZHJvcCBuZWdhdGl2ZSBzaXplJ1xuICAgICAgZW5kXG5cbiAgICAgIGN1cnJlbnRfc2l6ZSA9IGVudW1lcmF0b3Jfc2l6ZVxuICAgICAgc2V0X3NpemUgICAgID0gaWYgOjpJbnRlZ2VyID09PSBjdXJyZW50X3NpemVcbiAgICAgICAgICAgICAgICAgICAgICAgbiA8IGN1cnJlbnRfc2l6ZSA/IG4gOiBjdXJyZW50X3NpemVcbiAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF9zaXplXG4gICAgICAgICAgICAgICAgICAgICBlbmRcblxuICAgICAgZHJvcHBlZCA9IDBcbiAgICAgIExhenkubmV3KHNlbGYsIHNldF9zaXplKSBkbyB8ZW51bSwgKmFyZ3N8XG4gICAgICAgIGlmIGRyb3BwZWQgPCBuXG4gICAgICAgICAgZHJvcHBlZCArPSAxXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBlbnVtLnlpZWxkKCphcmdzKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGRyb3Bfd2hpbGUoJmJsb2NrKVxuICAgICAgdW5sZXNzIGJsb2NrXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSBkcm9wX3doaWxlIHdpdGhvdXQgYSBibG9jaydcbiAgICAgIGVuZFxuXG4gICAgICBzdWNjZWVkaW5nID0gdHJ1ZVxuICAgICAgTGF6eS5uZXcoc2VsZiwgbmlsKSBkbyB8ZW51bSwgKmFyZ3N8XG4gICAgICAgIGlmIHN1Y2NlZWRpbmdcbiAgICAgICAgICAleHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9ICR5aWVsZFgoYmxvY2ssIGFyZ3MpO1xuXG4gICAgICAgICAgICBpZiAoISR0cnV0aHkodmFsdWUpKSB7XG4gICAgICAgICAgICAgIHN1Y2NlZWRpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAje2VudW0ueWllbGQoKmFyZ3MpfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBlbnVtLnlpZWxkKCphcmdzKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGVudW1fZm9yKG1ldGhvZCA9IDplYWNoLCAqYXJncywgJmJsb2NrKVxuICAgICAgc2VsZi5jbGFzcy5mb3Ioc2VsZiwgbWV0aG9kLCAqYXJncywgJmJsb2NrKVxuICAgIGVuZFxuXG4gICAgZGVmIGZpbmRfYWxsKCZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja1xuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjYWxsIGxhenkgc2VsZWN0IHdpdGhvdXQgYSBibG9jaydcbiAgICAgIGVuZFxuXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgJXh7XG4gICAgICAgICAgdmFyIHZhbHVlID0gJHlpZWxkWChibG9jaywgYXJncyk7XG5cbiAgICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICN7ZW51bS55aWVsZCgqYXJncyl9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgZ3JlcChwYXR0ZXJuLCAmYmxvY2spXG4gICAgICBpZiBibG9ja1xuICAgICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgICAleHtcbiAgICAgICAgICAgIHZhciBwYXJhbSA9ICN7OjpPcGFsLmRlc3RydWN0dXJlKGFyZ3MpfSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICN7cGF0dGVybiA9PT0gYHBhcmFtYH07XG5cbiAgICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICAgICAgICAje2VudW0ueWllbGQgYCR5aWVsZDEoYmxvY2ssIHBhcmFtKWB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAgICV4e1xuICAgICAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYXJncyl9LFxuICAgICAgICAgICAgICAgIHZhbHVlID0gI3twYXR0ZXJuID09PSBgcGFyYW1gfTtcblxuICAgICAgICAgICAgaWYgKCR0cnV0aHkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICN7ZW51bS55aWVsZCBgcGFyYW1gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgcmVqZWN0KCZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja1xuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjYWxsIGxhenkgcmVqZWN0IHdpdGhvdXQgYSBibG9jaydcbiAgICAgIGVuZFxuXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgJXh7XG4gICAgICAgICAgdmFyIHZhbHVlID0gJHlpZWxkWChibG9jaywgYXJncyk7XG5cbiAgICAgICAgICBpZiAoISR0cnV0aHkodmFsdWUpKSB7XG4gICAgICAgICAgICAje2VudW0ueWllbGQoKmFyZ3MpfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIHRha2UobilcbiAgICAgIG4gPSBgJGNvZXJjZV90bygje259LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgICAgaWYgbiA8IDBcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnYXR0ZW1wdCB0byB0YWtlIG5lZ2F0aXZlIHNpemUnXG4gICAgICBlbmRcblxuICAgICAgY3VycmVudF9zaXplID0gZW51bWVyYXRvcl9zaXplXG4gICAgICBzZXRfc2l6ZSAgICAgPSBpZiA6OkludGVnZXIgPT09IGN1cnJlbnRfc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICBuIDwgY3VycmVudF9zaXplID8gbiA6IGN1cnJlbnRfc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50X3NpemVcbiAgICAgICAgICAgICAgICAgICAgIGVuZFxuXG4gICAgICB0YWtlbiA9IDBcbiAgICAgIExhenkubmV3KHNlbGYsIHNldF9zaXplKSBkbyB8ZW51bSwgKmFyZ3N8XG4gICAgICAgIGlmIHRha2VuIDwgblxuICAgICAgICAgIGVudW0ueWllbGQoKmFyZ3MpXG4gICAgICAgICAgdGFrZW4gKz0gMVxuICAgICAgICBlbHNlXG4gICAgICAgICAgOjpLZXJuZWwucmFpc2UgU3RvcExhenlFcnJvclxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIHRha2Vfd2hpbGUoJmJsb2NrKVxuICAgICAgdW5sZXNzIGJsb2NrXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSB0YWtlX3doaWxlIHdpdGhvdXQgYSBibG9jaydcbiAgICAgIGVuZFxuXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgJXh7XG4gICAgICAgICAgdmFyIHZhbHVlID0gJHlpZWxkWChibG9jaywgYXJncyk7XG5cbiAgICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICN7ZW51bS55aWVsZCgqYXJncyl9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgU3RvcExhenlFcnJvcn07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBpbnNwZWN0XG4gICAgICBcIiM8I3tzZWxmLmNsYXNzfTogI3tAZW51bWVyYXRvci5pbnNwZWN0fT5cIlxuICAgIGVuZFxuXG4gICAgYWxpYXMgZm9yY2UgdG9fYVxuICAgIGFsaWFzIGZpbHRlciBmaW5kX2FsbFxuICAgIGFsaWFzIGZsYXRfbWFwIGNvbGxlY3RfY29uY2F0XG4gICAgYWxpYXMgbWFwIGNvbGxlY3RcbiAgICBhbGlhcyBzZWxlY3QgZmluZF9hbGxcbiAgICBhbGlhcyB0b19lbnVtIGVudW1fZm9yXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpFbnVtZXJhdG9yPiIsIjxjbGFzczpzZWxmOjpMYXp5PiIsIjxjbGFzczpzZWxmOjpTdG9wTGF6eUVycm9yPiIsInNlbGYiLCJFeGNlcHRpb24iLCJmb3IiLCJvYmplY3QiLCJsYXp5IiwiJGZ3ZF9yZXN0IiwiaW5pdGlhbGl6ZSIsInNpemUiLCJibG9ja19naXZlbj8iLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJAZW51bWVyYXRvciIsImJsb2NrIGluIGluaXRpYWxpemUiLCJ5aWVsZGVyIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbml0aWFsaXplIiwiZWFjaCIsImVhY2hfYXJncyIsImJsb2NrICgzIGxldmVscykgaW4gaW5pdGlhbGl6ZSIsIlN0b3BMYXp5RXJyb3IiLCJjb2xsZWN0IiwiYmxvY2siLCJuZXciLCJMYXp5IiwiZW51bWVyYXRvcl9zaXplIiwiYmxvY2sgaW4gY29sbGVjdCIsImVudW0kIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb2xsZWN0IiwieWllbGQiLCJjb2xsZWN0X2NvbmNhdCIsImJsb2NrIGluIGNvbGxlY3RfY29uY2F0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb2xsZWN0X2NvbmNhdCIsInJlc3BvbmRfdG8/IiwidiIsImJsb2NrICgzIGxldmVscykgaW4gY29sbGVjdF9jb25jYXQiLCJPcGFsIiwidHJ5X2NvbnZlcnQiLCJBcnJheSIsImRyb3AiLCJuIiwiSW50ZWdlciIsIjwiLCIwIiwiY3VycmVudF9zaXplIiwic2V0X3NpemUiLCJkcm9wcGVkIiwiYmxvY2sgaW4gZHJvcCIsImJsb2NrICgyIGxldmVscykgaW4gZHJvcCIsIisiLCIxIiwiYXJncyIsImRyb3Bfd2hpbGUiLCJzdWNjZWVkaW5nIiwiYmxvY2sgaW4gZHJvcF93aGlsZSIsImJsb2NrICgyIGxldmVscykgaW4gZHJvcF93aGlsZSIsImVudW1fZm9yIiwiY2xhc3MiLCJtZXRob2QiLCJ0b19wcm9jIiwiZmluZF9hbGwiLCJibG9jayBpbiBmaW5kX2FsbCIsImJsb2NrICgyIGxldmVscykgaW4gZmluZF9hbGwiLCJncmVwIiwicGF0dGVybiIsImJsb2NrIGluIGdyZXAiLCJibG9jayAoMiBsZXZlbHMpIGluIGdyZXAiLCJkZXN0cnVjdHVyZSIsIj09PSIsInJlamVjdCIsImJsb2NrIGluIHJlamVjdCIsImJsb2NrICgyIGxldmVscykgaW4gcmVqZWN0IiwidGFrZSIsInRha2VuIiwiYmxvY2sgaW4gdGFrZSIsImJsb2NrICgyIGxldmVscykgaW4gdGFrZSIsInRha2Vfd2hpbGUiLCJibG9jayBpbiB0YWtlX3doaWxlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0YWtlX3doaWxlIiwiaW5zcGVjdCJdLCJt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Q0E7QUFDQUEsU0FWTUQsQ0FBQUEsSUFBSXREO01BTE5xRCxDQUFBQTs7QUFtQkFHLE1BQUFBLHVCQUFBQSxtQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUNBLElBQUQsR0FBQSxDQUFLOUUsSUFBSXdELE9BQUFBLENBQUFBLENBQVQsQ0FBQSxHQUFnQnNCLElBQWhCLEdBQUEsQ0FBb0JsRSxlQUFXa0UsU0FBQUEsQ0FBQUEsQ0FBL0IsQ0FBQSxHQUF3Q0E7TUFEMUNBLENBQUFBO01BSUEsYUFBTSxPQUFOLEVBQVksTUFBWjtNQUNBLGFBQU0sUUFBTixFQUFhLFVBQWI7TUFDQSxhQUFNLFVBQU4sRUFBZSxnQkFBZjtNQUNBLGFBQU0sS0FBTixFQUFVLFNBQVY7TUFDQSxhQUFNLFFBQU4sRUFBYSxVQUFiO01BQ0FoRixPQUFBLGFBQU0sU0FBTixFQUFjLFVBQWQ7SUEvT0ZBLEdBQU1FLElBQU5GLEVBQW1CRSxJQUFuQkY7RUFERkQsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQUhBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MTIxNjksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2VudW1lcmF0b3IveWllbGRlci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcblxuY2xhc3MgRW51bWVyYXRvclxuICBjbGFzcyBZaWVsZGVyXG4gICAgZGVmIGluaXRpYWxpemUoJmJsb2NrKVxuICAgICAgQGJsb2NrID0gYmxvY2tcbiAgICAgICMgcnVib2NvcDpkaXNhYmxlIExpbnQvVm9pZFxuICAgICAgc2VsZlxuICAgICAgIyBydWJvY29wOmVuYWJsZSBMaW50L1ZvaWRcbiAgICBlbmRcblxuICAgIGRlZiB5aWVsZCgqdmFsdWVzKVxuICAgICAgJXh7XG4gICAgICAgIHZhciB2YWx1ZSA9IE9wYWwueWllbGRYKCN7QGJsb2NrfSwgdmFsdWVzKTtcblxuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUuJHRocm93ZXJfdHlwZSA9PSBcImJyZWFrXCIpIHtcbiAgICAgICAgICB0aHJvdyB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGRlZiA8PCh2YWx1ZSlcbiAgICAgIHNlbGYueWllbGQodmFsdWUpXG5cbiAgICAgIHNlbGZcbiAgICBlbmRcblxuICAgIGRlZiB0b19wcm9jXG4gICAgICBwcm9jIGRvIHwqdmFsdWVzfFxuICAgICAgICBzZWxmLnlpZWxkKCp2YWx1ZXMpXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOkVudW1lcmF0b3I+IiwiPGNsYXNzOllpZWxkZXI+IiwiaW5pdGlhbGl6ZSIsIkBibG9jayIsImJsb2NrIiwic2VsZiIsInlpZWxkIiwiPDwiLCJ2YWx1ZSIsInRvX3Byb2MiLCJwcm9jIiwiYmxvY2sgaW4gdG9fcHJvYyIsImJsb2NrICgyIGxldmVscykgaW4gdG9fcHJvYyIsInZhbHVlcyJdLCJtYXBwaW5ncyI6IkFBQUFBLDZDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBRUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUM7SUFBQUE7O01BQUFBOztBQUFBQTs7O0FBQ0VDLE1BQUFBLDBCQUFBQSxzQkFBQUE7QUFBQUEsUUFBQUE7O1FBQUFBOzs7UUFDRUMsYUFBU0M7UUFFVEYsT0FBQUc7TUFIRkgsQ0FBQUE7O0FBT0FJLE1BQUFBLHFCQUFBQSwwQkFYSixFQVdJQTtBQUFBQSxRQUFBQTs7O1FBWEo7UUFXYzs7QUFFZEEsZ0NBQWtDSCxVQUFPRzs7QUFFekNBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtNQVRJQSxDQUFBQSxJQUFBQTs7QUFZQUMsTUFBQUEsa0JBQUFBLDJCQUFPQyxLQUFQRDtBQUFBQSxRQUFBQTs7O1FBQ0VGLElBQUlDLE9BQUFBLENBQU9FLEtBQVBGO1FBRUpDLE9BQUFGO01BSEZFLENBQUFBO01BTUFOLE9BQUFRLHVCQUFBQSxtQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUFDLE1BQUFMLElBQUFLLFFBQUFBLEVBQUFBLEVBQUFBLEVBQUFDLGFBOUJOLEVBOEJNQSxFQUFBQzs7O1VBOUJOO1VBOEJlO1VBQ1BBLE9BQUlOLE1BQUpELElBQUlDLFNBQUFBLEVBQU8sTUFBQ08sTUFBRCxDQUFQUCxFQUROSyxDQUFBQSxHQUFBQSxzQkFBQUEsQ0FBQUQ7TUFERkQsQ0FBQUE7SUExQkZSLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBREZELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBRkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxMjIzNCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvZW51bWVyYXRvci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHNsaWNlLCBjb2VyY2VfdG8sIGRlbnlfZnJvemVuX2FjY2Vzc1xuIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXG5cbnJlcXVpcmUgJ2NvcmVsaWIvZW51bWVyYWJsZSdcblxuY2xhc3MgOjpFbnVtZXJhdG9yXG4gIGluY2x1ZGUgOjpFbnVtZXJhYmxlXG5cbiAgYHNlbGYuJCRwcm90b3R5cGUuJCRpc19lbnVtZXJhdG9yID0gdHJ1ZWBcblxuICBkZWYgc2VsZi5mb3Iob2JqZWN0LCBtZXRob2QgPSA6ZWFjaCwgKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBvYmogPSAje2FsbG9jYXRlfTtcblxuICAgICAgb2JqLm9iamVjdCA9IG9iamVjdDtcbiAgICAgIG9iai5zaXplICAgPSBibG9jaztcbiAgICAgIG9iai5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBvYmouYXJncyAgID0gYXJncztcbiAgICAgIG9iai5jdXJzb3IgPSAwO1xuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoKiwgJmJsb2NrKVxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxuXG4gICAgQGN1cnNvciA9IDBcbiAgICBpZiBibG9ja1xuICAgICAgQG9iamVjdCA9IEdlbmVyYXRvci5uZXcoJmJsb2NrKVxuICAgICAgQG1ldGhvZCA9IDplYWNoXG4gICAgICBAYXJncyAgID0gW11cbiAgICAgIEBzaXplICAgPSBgYXJndW1lbnRzWzBdIHx8IG5pbGBcblxuICAgICAgaWYgQHNpemUgJiYgIUBzaXplLnJlc3BvbmRfdG8/KDpjYWxsKVxuICAgICAgICBAc2l6ZSA9IGAkY29lcmNlX3RvKCN7QHNpemV9LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIEBvYmplY3QgPSBgYXJndW1lbnRzWzBdYFxuICAgICAgQG1ldGhvZCA9IGBhcmd1bWVudHNbMV0gfHwgXCJlYWNoXCJgXG4gICAgICBAYXJncyAgID0gYCRzbGljZShhcmd1bWVudHMsIDIpYFxuICAgICAgQHNpemUgICA9IG5pbFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgZWFjaCgqYXJncywgJmJsb2NrKVxuICAgIHJldHVybiBzZWxmIGlmIGJsb2NrLm5pbD8gJiYgYXJncy5lbXB0eT9cblxuICAgIGFyZ3MgPSBAYXJncyArIGFyZ3NcblxuICAgIHJldHVybiBzZWxmLmNsYXNzLm5ldyhAb2JqZWN0LCBAbWV0aG9kLCAqYXJncykgaWYgYmxvY2submlsP1xuXG4gICAgQG9iamVjdC5fX3NlbmRfXyhAbWV0aG9kLCAqYXJncywgJmJsb2NrKVxuICBlbmRcblxuICBkZWYgc2l6ZVxuICAgIEBzaXplLnJlc3BvbmRfdG8/KDpjYWxsKSA/IEBzaXplLmNhbGwoKkBhcmdzKSA6IEBzaXplXG4gIGVuZFxuXG4gIGRlZiB3aXRoX2luZGV4KG9mZnNldCA9IDAsICZibG9jaylcbiAgICBvZmZzZXQgPSBpZiBvZmZzZXRcbiAgICAgICAgICAgICAgIGAkY29lcmNlX3RvKG9mZnNldCwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG4gICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgIGVuZFxuXG4gICAgcmV0dXJuIGVudW1fZm9yKDp3aXRoX2luZGV4LCBvZmZzZXQpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0LCBpbmRleCA9IG9mZnNldDtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3s6Ok9wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gYmxvY2socGFyYW0sIGluZGV4KTtcblxuICAgICAgICBpbmRleCsrO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJGVhY2goKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlYWNoX3dpdGhfaW5kZXgoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF93aXRoX2luZGV4KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBzdXBlclxuICAgIEBvYmplY3RcbiAgZW5kXG5cbiAgZGVmIHJld2luZFxuICAgIEBjdXJzb3IgPSAwXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBwZWVrX3ZhbHVlc1xuICAgIEB2YWx1ZXMgfHw9IG1hcCB7IHwqaXwgaSB9XG4gICAgOjpLZXJuZWwucmFpc2UgOjpTdG9wSXRlcmF0aW9uLCAnaXRlcmF0aW9uIHJlYWNoZWQgYW4gZW5kJyBpZiBAY3Vyc29yID49IEB2YWx1ZXMubGVuZ3RoXG4gICAgQHZhbHVlc1tAY3Vyc29yXVxuICBlbmRcblxuICBkZWYgcGVla1xuICAgIHZhbHVlcyA9IHBlZWtfdmFsdWVzXG4gICAgdmFsdWVzLmxlbmd0aCA8PSAxID8gdmFsdWVzWzBdIDogdmFsdWVzXG4gIGVuZFxuXG4gIGRlZiBuZXh0X3ZhbHVlc1xuICAgIG91dCA9IHBlZWtfdmFsdWVzXG4gICAgQGN1cnNvciArPSAxXG4gICAgb3V0XG4gIGVuZFxuXG4gIGRlZiBuZXh0XG4gICAgdmFsdWVzID0gbmV4dF92YWx1ZXNcbiAgICB2YWx1ZXMubGVuZ3RoIDw9IDEgPyB2YWx1ZXNbMF0gOiB2YWx1ZXNcbiAgZW5kXG5cbiAgZGVmIGZlZWQoYXJnKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIFwiT3BhbCBkb2Vzbid0IHN1cHBvcnQgRW51bWVyYXRvciNmZWVkXCJcbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgOjpFbnVtZXJhdG9yOjpDaGFpbi5uZXcoc2VsZiwgb3RoZXIpXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgcmVzdWx0ID0gXCIjPCN7c2VsZi5jbGFzc306ICN7QG9iamVjdC5pbnNwZWN0fToje0BtZXRob2R9XCJcblxuICAgIGlmIEBhcmdzLmFueT9cbiAgICAgIHJlc3VsdCArPSBcIigje0BhcmdzLmluc3BlY3RbOjpSYW5nZS5uZXcoMSwgLTIpXX0pXCJcbiAgICBlbmRcblxuICAgIHJlc3VsdCArICc+J1xuICBlbmRcblxuICBhbGlhcyB3aXRoX29iamVjdCBlYWNoX3dpdGhfb2JqZWN0XG5cbiAgYXV0b2xvYWQgOkFyaXRobWV0aWNTZXF1ZW5jZSwgJ2NvcmVsaWIvZW51bWVyYXRvci9hcml0aG1ldGljX3NlcXVlbmNlJ1xuICBhdXRvbG9hZCA6Q2hhaW4sICdjb3JlbGliL2VudW1lcmF0b3IvY2hhaW4nXG4gIGF1dG9sb2FkIDpHZW5lcmF0b3IsICdjb3JlbGliL2VudW1lcmF0b3IvZ2VuZXJhdG9yJ1xuICBhdXRvbG9hZCA6TGF6eSwgJ2NvcmVsaWIvZW51bWVyYXRvci9sYXp5J1xuICBhdXRvbG9hZCA6WWllbGRlciwgJ2NvcmVsaWIvZW51bWVyYXRvci95aWVsZGVyJ1xuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOkVudW1lcmF0b3I+IiwiaW5jbHVkZSIsIkVudW1lcmFibGUiLCJmb3IiLCJvYmplY3QiLCJhbGxvY2F0ZSIsImluaXRpYWxpemUiLCJAY3Vyc29yIiwiMCIsImJsb2NrIiwiQG9iamVjdCIsIm5ldyIsIkdlbmVyYXRvciIsInRvX3Byb2MiLCJAbWV0aG9kIiwiQGFyZ3MiLCJAc2l6ZSIsInJlc3BvbmRfdG8/IiwiSW50ZWdlciIsImVhY2giLCJuaWw/IiwiYXJncyIsImVtcHR5PyIsIisiLCJjbGFzcyIsIl9fc2VuZF9fIiwic2l6ZSIsImNhbGwiLCJ3aXRoX2luZGV4Iiwib2Zmc2V0IiwiZW51bV9mb3IiLCJibG9jayBpbiB3aXRoX2luZGV4IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB3aXRoX2luZGV4IiwiT3BhbCIsImRlc3RydWN0dXJlIiwiZWFjaF93aXRoX2luZGV4IiwiYmxvY2tfZ2l2ZW4/IiwiYmxvY2sgaW4gZWFjaF93aXRoX2luZGV4IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX3dpdGhfaW5kZXgiLCJyZXdpbmQiLCJwZWVrX3ZhbHVlcyIsIkB2YWx1ZXMiLCIkcmV0X29yXzEiLCJtYXAiLCJibG9jayBpbiBwZWVrX3ZhbHVlcyIsImJsb2NrICgyIGxldmVscykgaW4gcGVla192YWx1ZXMiLCJpIiwiPj0iLCJsZW5ndGgiLCJLZXJuZWwiLCJyYWlzZSIsIlN0b3BJdGVyYXRpb24iLCJbXSIsInBlZWsiLCJ2YWx1ZXMiLCI8PSIsIjEiLCJuZXh0X3ZhbHVlcyIsIm91dCIsIm5leHQiLCJmZWVkIiwiYXJnIiwiTm90SW1wbGVtZW50ZWRFcnJvciIsIm90aGVyIiwiRW51bWVyYXRvcjo6Q2hhaW4iLCJFbnVtZXJhdG9yIiwiaW5zcGVjdCIsInJlc3VsdCIsImFueT8iLCJSYW5nZSIsIi0yIiwiYXV0b2xvYWQiXSwibWFwcGluZ3MiOiJBQUFBQSxxQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFHQUMsSUFBQUMsU0FBQUEsQ0FBUUYsb0JBQVJFO0VBRUFGLE9BQUFHO0VBQUFBOztJQUFBQTs7QUFBQUE7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aEIsR0FBQSxDQUFvQnhELFdBQU93RCxTQUFBQSxDQUFBQSxDQUEzQixDQUFBLEdBQW9DQSxHQUFwQyxHQUFBLENBQXVDcEQsV0FBdkM7TUFFVCxJQUFBLFFBQUdDLFNBQUtxRCxTQUFBQSxDQUFBQSxDQUFSLENBQUE7UUFDRUQsU0FBTzVDLFNBQVA0QyxNQUFPNUMsRUFBSTJDLEdBQUQsR0FBQSxDQUFJbkQsU0FBS21ELFNBQUFBLENBQUFBLENBQVFkLE9BQUFBLENBQUNpQixZQUFPMUQsS0FBQUEsQ0FBSzZDLENBQVosRUFBZWMsRUFBUjNELENBQVJ5QyxDQUFqQixDQUFBLEdBQXNDYyxHQUF6QzNDO01BRFQ7TUFJQTJDLE9BQU8zQyxTQUFQNEMsTUFBTzVDLEVBQUUyQyxHQUFGM0M7SUFQVDJDLENBQUFBO0lBVUEsYUFBTSxhQUFOLEVBQWtCLGtCQUFsQjtJQUVBcEUsSUFBQXlFLFVBQUFBLENBQVMsb0JBQVQsRUFBOEJ2RSx3Q0FBOUJ1RTtJQUNBekUsSUFBQXlFLFVBQUFBLENBQVMsT0FBVCxFQUFpQnZFLDBCQUFqQnVFO0lBQ0F6RSxJQUFBeUUsVUFBQUEsQ0FBUyxXQUFULEVBQXFCdkUsOEJBQXJCdUU7SUFDQXpFLElBQUF5RSxVQUFBQSxDQUFTLE1BQVQsRUFBZ0J2RSx5QkFBaEJ1RTtJQUNBdkUsT0FBQUYsSUFBQXlFLFVBQUFBLENBQVMsU0FBVCxFQUFtQnZFLDRCQUFuQnVFO0VBMUlGdkUsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQUxBSDsifX0seyJvZmZzZXQiOnsibGluZSI6MTI0NjIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL251bWVyaWMucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXG5cbnJlcXVpcmUgJ2NvcmVsaWIvY29tcGFyYWJsZSdcblxuY2xhc3MgOjpOdW1lcmljXG4gIGluY2x1ZGUgOjpDb21wYXJhYmxlXG5cbiAgZGVmIGNvZXJjZShvdGhlcilcbiAgICBpZiBvdGhlci5pbnN0YW5jZV9vZj8gc2VsZi5jbGFzc1xuICAgICAgcmV0dXJuIFtvdGhlciwgc2VsZl1cbiAgICBlbmRcblxuICAgIFs6Oktlcm5lbC5GbG9hdChvdGhlciksIDo6S2VybmVsLkZsb2F0KHNlbGYpXVxuICBlbmRcblxuICBkZWYgX19jb2VyY2VkX18obWV0aG9kLCBvdGhlcilcbiAgICBpZiBvdGhlci5yZXNwb25kX3RvPyg6Y29lcmNlKVxuICAgICAgYSwgYiA9IG90aGVyLmNvZXJjZShzZWxmKVxuICAgICAgYS5fX3NlbmRfXyBtZXRob2QsIGJcbiAgICBlbHNlXG4gICAgICBjYXNlIG1ldGhvZFxuICAgICAgd2hlbiA6KywgOi0sIDoqLCA6LywgOiUsIDomLCA6fCwgOl4sIDoqKlxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCIje290aGVyLmNsYXNzfSBjYW4ndCBiZSBjb2VyY2VkIGludG8gTnVtZXJpY1wiXG4gICAgICB3aGVuIDo+LCA6Pj0sIDo8LCA6PD0sIDo8PT5cbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tzZWxmLmNsYXNzfSB3aXRoICN7b3RoZXIuY2xhc3N9IGZhaWxlZFwiXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICBpZiBlcXVhbD8gb3RoZXJcbiAgICAgIHJldHVybiAwXG4gICAgZW5kXG5cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmICtAXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgLUBcbiAgICAwIC0gc2VsZlxuICBlbmRcblxuICBkZWYgJShvdGhlcilcbiAgICBzZWxmIC0gb3RoZXIgKiBkaXYob3RoZXIpXG4gIGVuZFxuXG4gIGRlZiBhYnNcbiAgICBzZWxmIDwgMCA/IC1zZWxmIDogc2VsZlxuICBlbmRcblxuICBkZWYgYWJzMlxuICAgIHNlbGYgKiBzZWxmXG4gIGVuZFxuXG4gIGRlZiBhbmdsZVxuICAgIHNlbGYgPCAwID8gOjpNYXRoOjpQSSA6IDBcbiAgZW5kXG5cbiAgZGVmIGNlaWwobmRpZ2l0cyA9IDApXG4gICAgdG9fZi5jZWlsKG5kaWdpdHMpXG4gIGVuZFxuXG4gIGRlZiBjb25qXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZGVub21pbmF0b3JcbiAgICB0b19yLmRlbm9taW5hdG9yXG4gIGVuZFxuXG4gIGRlZiBkaXYob3RoZXIpXG4gICAgOjpLZXJuZWwucmFpc2UgOjpaZXJvRGl2aXNpb25FcnJvciwgJ2RpdmlkZWQgYnkgbycgaWYgb3RoZXIgPT0gMFxuXG4gICAgKHNlbGYgLyBvdGhlcikuZmxvb3JcbiAgZW5kXG5cbiAgZGVmIGRpdm1vZChvdGhlcilcbiAgICBbZGl2KG90aGVyKSwgc2VsZiAlIG90aGVyXVxuICBlbmRcblxuICBkZWYgZmRpdihvdGhlcilcbiAgICB0b19mIC8gb3RoZXJcbiAgZW5kXG5cbiAgZGVmIGZsb29yKG5kaWdpdHMgPSAwKVxuICAgIHRvX2YuZmxvb3IobmRpZ2l0cylcbiAgZW5kXG5cbiAgZGVmIGlcbiAgICA6Oktlcm5lbC5Db21wbGV4KDAsIHNlbGYpXG4gIGVuZFxuXG4gIGRlZiBpbWFnXG4gICAgMFxuICBlbmRcblxuICBkZWYgaW50ZWdlcj9cbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgbm9uemVybz9cbiAgICB6ZXJvPyA/IG5pbCA6IHNlbGZcbiAgZW5kXG5cbiAgZGVmIG51bWVyYXRvclxuICAgIHRvX3IubnVtZXJhdG9yXG4gIGVuZFxuXG4gIGRlZiBwb2xhclxuICAgIFthYnMsIGFyZ11cbiAgZW5kXG5cbiAgZGVmIHF1byhvdGhlcilcbiAgICA6Ok9wYWwuY29lcmNlX3RvIShzZWxmLCA6OlJhdGlvbmFsLCA6dG9fcikgLyBvdGhlclxuICBlbmRcblxuICBkZWYgcmVhbFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHJlYWw/XG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgcmVjdFxuICAgIFtzZWxmLCAwXVxuICBlbmRcblxuICBkZWYgcm91bmQoZGlnaXRzID0gdW5kZWZpbmVkKVxuICAgIHRvX2Yucm91bmQoZGlnaXRzKVxuICBlbmRcblxuICBkZWYgc3RlcChsaW1pdCA9IHVuZGVmaW5lZCwgc3RlcCA9IHVuZGVmaW5lZCwgdG86IHVuZGVmaW5lZCwgYnk6IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQgJiYgdG8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RvIGlzIGdpdmVuIHR3aWNlJ31cbiAgICAgIH1cblxuICAgICAgaWYgKHN0ZXAgIT09IHVuZGVmaW5lZCAmJiBieSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnc3RlcCBpcyBnaXZlbiB0d2ljZSd9XG4gICAgICB9XG5cbiAgICAgIGlmICh0byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxpbWl0ID0gdG87XG4gICAgICB9XG5cbiAgICAgIGlmIChieSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN0ZXAgPSBieTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGltaXQgPSBuaWw7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlUGFyYW1ldGVycygpIHtcbiAgICAgICAgaWYgKHN0ZXAgPT09IG5pbCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdzdGVwIG11c3QgYmUgbnVtZXJpYyd9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RlcCAhPSBudWxsICYmICN7c3RlcCA9PSAwfSkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcInN0ZXAgY2FuJ3QgYmUgMFwifVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0ZXAgPT09IG5pbCB8fCBzdGVwID09IG51bGwpIHtcbiAgICAgICAgICBzdGVwID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaWduID0gI3tzdGVwIDw9PiAwfTtcblxuICAgICAgICBpZiAoc2lnbiA9PT0gbmlsKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiMCBjYW4ndCBiZSBjb2VyY2VkIGludG8gI3tzdGVwLmNsYXNzfVwifVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpbWl0ID09PSBuaWwgfHwgbGltaXQgPT0gbnVsbCkge1xuICAgICAgICAgIGxpbWl0ID0gc2lnbiA+IDAgPyAjezo6RmxvYXQ6OklORklOSVRZfSA6ICN7LTo6RmxvYXQ6OklORklOSVRZfTtcbiAgICAgICAgfVxuXG4gICAgICAgICN7OjpPcGFsLmNvbXBhcmUoc2VsZiwgbGltaXQpfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzdGVwRmxvYXRTaXplKCkge1xuICAgICAgICBpZiAoKHN0ZXAgPiAwICYmIHNlbGYgPiBsaW1pdCkgfHwgKHN0ZXAgPCAwICYmIHNlbGYgPCBsaW1pdCkpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIGlmIChzdGVwID09PSBJbmZpbml0eSB8fCBzdGVwID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYWJzID0gTWF0aC5hYnMsIGZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgICAgICAgICAgZXJyID0gKGFicyhzZWxmKSArIGFicyhsaW1pdCkgKyBhYnMobGltaXQgLSBzZWxmKSkgLyBhYnMoc3RlcCkgKiAjezo6RmxvYXQ6OkVQU0lMT059O1xuXG4gICAgICAgICAgaWYgKGVyciA9PT0gSW5maW5pdHkgfHwgZXJyID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZXJyID4gMC41KSB7XG4gICAgICAgICAgICAgIGVyciA9IDAuNTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZsb29yKChsaW1pdCAtIHNlbGYpIC8gc3RlcCArIGVycikgKyAxXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHN0ZXBTaXplKCkge1xuICAgICAgICB2YWxpZGF0ZVBhcmFtZXRlcnMoKTtcblxuICAgICAgICBpZiAoc3RlcCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGVwICUgMSAhPT0gMCkge1xuICAgICAgICAgIHJldHVybiBzdGVwRmxvYXRTaXplKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoKHN0ZXAgPiAwICYmIHNlbGYgPiBsaW1pdCkgfHwgKHN0ZXAgPCAwICYmIHNlbGYgPCBsaW1pdCkpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY2VpbCA9IE1hdGguY2VpbCwgYWJzID0gTWF0aC5hYnMsXG4gICAgICAgICAgICAgIGxocyA9IGFicyhzZWxmIC0gbGltaXQpICsgMSxcbiAgICAgICAgICAgICAgcmhzID0gYWJzKHN0ZXApO1xuXG4gICAgICAgICAgcmV0dXJuIGNlaWwobGhzIC8gcmhzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgaWYgKCFsaW1pdCB8fCBsaW1pdC5pc19hPyg6Ok51bWVyaWMpKSAmJlxuICAgICAgICAgKCFzdGVwIHx8IHN0ZXAuaXNfYT8oOjpOdW1lcmljKSlcblxuICAgICAgICByZXR1cm4gOjpFbnVtZXJhdG9yOjpBcml0aG1ldGljU2VxdWVuY2UubmV3KFxuICAgICAgICAgIFtsaW1pdCwgc3RlcCwgKCd0bzogJyBpZiB0byksICgnYnk6ICcgaWYgYnkpXSwgc2VsZlxuICAgICAgICApXG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBlbnVtX2Zvcig6c3RlcCwgbGltaXQsIHN0ZXAsICZgc3RlcFNpemVgKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhbGlkYXRlUGFyYW1ldGVycygpO1xuXG4gICAgICB2YXIgaXNEZXNjID0gI3tzdGVwLm5lZ2F0aXZlP30sXG4gICAgICAgICAgaXNJbmYgPSAje3N0ZXAgPT0gMH0gfHxcbiAgICAgICAgICAgICAgICAgIChsaW1pdCA9PT0gSW5maW5pdHkgJiYgIWlzRGVzYykgfHxcbiAgICAgICAgICAgICAgICAgIChsaW1pdCA9PT0gLUluZmluaXR5ICYmIGlzRGVzYyk7XG5cbiAgICAgIGlmIChzZWxmLiQkaXNfbnVtYmVyICYmIHN0ZXAuJCRpc19udW1iZXIgJiYgbGltaXQuJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKHNlbGYgJSAxID09PSAwICYmIChpc0luZiB8fCBsaW1pdCAlIDEgPT09IDApICYmIHN0ZXAgJSAxID09PSAwKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc2VsZjtcblxuICAgICAgICAgIGlmIChpc0luZikge1xuICAgICAgICAgICAgZm9yICg7OyB2YWx1ZSArPSBzdGVwKSB7XG4gICAgICAgICAgICAgIGJsb2NrKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRGVzYykge1xuICAgICAgICAgICAgZm9yICg7IHZhbHVlID49IGxpbWl0OyB2YWx1ZSArPSBzdGVwKSB7XG4gICAgICAgICAgICAgIGJsb2NrKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICg7IHZhbHVlIDw9IGxpbWl0OyB2YWx1ZSArPSBzdGVwKSB7XG4gICAgICAgICAgICAgIGJsb2NrKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYmVnaW4gPSAje3RvX2Z9LnZhbHVlT2YoKTtcbiAgICAgICAgICBzdGVwID0gI3tzdGVwLnRvX2Z9LnZhbHVlT2YoKTtcbiAgICAgICAgICBsaW1pdCA9ICN7bGltaXQudG9fZn0udmFsdWVPZigpO1xuXG4gICAgICAgICAgdmFyIG4gPSBzdGVwRmxvYXRTaXplKCk7XG5cbiAgICAgICAgICBpZiAoIWlzRmluaXRlKHN0ZXApKSB7XG4gICAgICAgICAgICBpZiAobiAhPT0gMCkgYmxvY2soYmVnaW4pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RlcCA9PT0gMCkge1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgYmxvY2soYmVnaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICB2YXIgZCA9IGkgKiBzdGVwICsgc2VsZjtcbiAgICAgICAgICAgICAgaWYgKHN0ZXAgPj0gMCA/IGxpbWl0IDwgZCA6IGxpbWl0ID4gZCkge1xuICAgICAgICAgICAgICAgIGQgPSBsaW1pdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBibG9jayhkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvdW50ZXIgPSBzZWxmXG5cbiAgICB3aGlsZSBgaXNEZXNjID8gI3tjb3VudGVyID49IGxpbWl0fSA6ICN7Y291bnRlciA8PSBsaW1pdH1gXG4gICAgICB5aWVsZCBjb3VudGVyXG4gICAgICBjb3VudGVyICs9IHN0ZXBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHRvX2NcbiAgICA6Oktlcm5lbC5Db21wbGV4KHNlbGYsIDApXG4gIGVuZFxuXG4gIGRlZiB0b19pbnRcbiAgICB0b19pXG4gIGVuZFxuXG4gIGRlZiB0cnVuY2F0ZShuZGlnaXRzID0gMClcbiAgICB0b19mLnRydW5jYXRlKG5kaWdpdHMpXG4gIGVuZFxuXG4gIGRlZiB6ZXJvP1xuICAgIHNlbGYgPT0gMFxuICBlbmRcblxuICBkZWYgcG9zaXRpdmU/XG4gICAgc2VsZiA+IDBcbiAgZW5kXG5cbiAgZGVmIG5lZ2F0aXZlP1xuICAgIHNlbGYgPCAwXG4gIGVuZFxuXG4gIGRlZiBkdXBcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjbG9uZShmcmVlemU6IHRydWUpXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZmluaXRlP1xuICAgIHRydWVcbiAgZW5kXG5cbiAgZGVmIGluZmluaXRlP1xuICAgIG5pbFxuICBlbmRcblxuICBhbGlhcyBhcmcgYW5nbGVcbiAgYWxpYXMgY29uanVnYXRlIGNvbmpcbiAgYWxpYXMgaW1hZ2luYXJ5IGltYWdcbiAgYWxpYXMgbWFnbml0dWRlIGFic1xuICBhbGlhcyBtb2R1bG8gJVxuICBhbGlhcyBwaGFzZSBhcmdcbiAgYWxpYXMgcmVjdGFuZ3VsYXIgcmVjdFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOk51bWVyaWM+IiwiaW5jbHVkZSIsIkNvbXBhcmFibGUiLCJjb2VyY2UiLCJvdGhlciIsImluc3RhbmNlX29mPyIsImNsYXNzIiwiS2VybmVsIiwiRmxvYXQiLCJfX2NvZXJjZWRfXyIsIm1ldGhvZCIsInJlc3BvbmRfdG8/IiwiYSIsImIiLCJfX3NlbmRfXyIsInJhaXNlIiwiVHlwZUVycm9yIiwiQXJndW1lbnRFcnJvciIsIjw9PiIsImVxdWFsPyIsIjAiLCIrQCIsIi1AIiwiLSIsIiUiLCIqIiwiZGl2IiwiYWJzIiwiPCIsImFiczIiLCJhbmdsZSIsIk1hdGg6OlBJIiwiTWF0aCIsImNlaWwiLCJuZGlnaXRzIiwidG9fZiIsImNvbmoiLCJkZW5vbWluYXRvciIsInRvX3IiLCJaZXJvRGl2aXNpb25FcnJvciIsIi8iLCJmbG9vciIsImRpdm1vZCIsImZkaXYiLCJpIiwiQ29tcGxleCIsImltYWciLCJpbnRlZ2VyPyIsIm5vbnplcm8/IiwiemVybz8iLCJudW1lcmF0b3IiLCJwb2xhciIsImFyZyIsInF1byIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiUmF0aW9uYWwiLCJyZWFsIiwicmVhbD8iLCJyZWN0Iiwicm91bmQiLCJkaWdpdHMiLCJzdGVwIiwiPT0iLCJGbG9hdDo6SU5GSU5JVFkiLCJjb21wYXJlIiwibGltaXQiLCJGbG9hdDo6RVBTSUxPTiIsImJsb2NrX2dpdmVuPyIsImlzX2E/IiwiTnVtZXJpYyIsIkVudW1lcmF0b3I6OkFyaXRobWV0aWNTZXF1ZW5jZSIsIkVudW1lcmF0b3IiLCJuZXciLCJ0byIsImJ5IiwiZW51bV9mb3IiLCJ0b19wcm9jIiwibmVnYXRpdmU/IiwiY291bnRlciIsIj49IiwiPD0iLCIrIiwidG9fYyIsInRvX2ludCIsInRvX2kiLCJ0cnVuY2F0ZSIsInBvc2l0aXZlPyIsIj4iLCJkdXAiLCJjbG9uZSIsIiRrd2FyZ3MiLCJmaW5pdGU/IiwiaW5maW5pdGU/Il0sIm1hcHBpbmdzIjoiQUFBQUEsa0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBRUFDLElBQUFDLFNBQUFBLENBQVFGLG9CQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7OztJQUNFRixJQUFBRyxTQUFBQSxDQUFRQyxpQkFBUkQ7O0FBRUFFLElBQUFBLHNCQUFBQSxrQkFBV0MsS0FBWEQ7QUFBQUEsTUFBQUE7OztNQUNFLElBQUEsUUFBR0MsS0FBS0MsaUJBQUFBLENBQWNQLElBQUlRLE9BQUFBLENBQUFBLENBQWxCRCxDQUFSLENBQUE7UUFDRSxPQUFPLENBQUNELEtBQUQsRUFBUU4sSUFBUjtNQURUO01BSUFLLE9BQUEsQ0FBQ0ksT0FBUUMsT0FBQUEsQ0FBT0osS0FBUEksQ0FBVCxFQUF3QkQsT0FBUUMsT0FBQUEsQ0FBT1YsSUFBUFUsQ0FBaEM7SUFMRkwsQ0FBQUE7O0FBUUFNLElBQUFBLDJCQUFBQSx1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QSxPQUFLbEQsT0FBTDlCLElBQUs4QixFQUFFUixDQUFGUTtJQURQa0QsQ0FBQUE7O0FBSUFXLElBQUFBLG1CQUFBQSxZQUFBQTs7QUFJQUMsSUFBQUEscUJBQUFBLGlCQXpVRkMsT0F5VUVEO0FBQUFBLE1BQUFBOzs7TUF6VUY7O01BeVVZLHNDQUFBLDZCQUFRO01BQ2hCQSxPQUFBNUY7SUFERjRGLENBQUFBLElBQUFBOztBQUlBRSxJQUFBQSx1QkFBQUEsWUFDRSxJQURGQSxDQUFBQTs7QUFJQUMsSUFBQUEseUJBQUFBLFlBQ0UsR0FERkEsQ0FBQUE7SUFJQSxhQUFNLEtBQU4sRUFBVSxPQUFWO0lBQ0EsYUFBTSxXQUFOLEVBQWdCLE1BQWhCO0lBQ0EsYUFBTSxXQUFOLEVBQWdCLE1BQWhCO0lBQ0EsYUFBTSxXQUFOLEVBQWdCLEtBQWhCO0lBQ0EsYUFBTSxRQUFOLEVBQWEsR0FBYjtJQUNBLGFBQU0sT0FBTixFQUFZLEtBQVo7SUFDQTdGLE9BQUEsYUFBTSxhQUFOLEVBQWtCLE1BQWxCO0VBdlZGQSxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBSkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxMjkwNSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvYXJyYXkucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiB0cnV0aHksIGZhbHN5LCB5aWVsZDEsIGhhc2hfZ2V0LCBoYXNoX3B1dCwgaGFzaF9kZWxldGUsIGNvZXJjZV90bywgcmVzcG9uZF90bywgZGVueV9mcm96ZW5fYWNjZXNzLCBmcmVlemUsIG9wYWwzMl9pbml0LCBvcGFsMzJfYWRkXG4jIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcblxucmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhYmxlJ1xucmVxdWlyZSAnY29yZWxpYi9udW1lcmljJ1xuXG5jbGFzcyA6OkFycmF5IDwgYEFycmF5YFxuICBpbmNsdWRlIDo6RW51bWVyYWJsZVxuXG4gICMgTWFyayBhbGwgamF2YXNjcmlwdCBhcnJheXMgYXMgYmVpbmcgdmFsaWQgcnVieSBhcnJheXNcbiAgYE9wYWwucHJvcChzZWxmLiQkcHJvdG90eXBlLCAnJCRpc19hcnJheScsIHRydWUpYFxuXG4gICV4e1xuICAgIC8vIFJlY2VudCB2ZXJzaW9ucyBvZiBWOCAoPiA3LjEpIG9ubHkgdXNlIGFuIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbiB3aGVuIEFycmF5LnByb3RvdHlwZSBpcyB1bm1vZGlmaWVkLlxuICAgIC8vIEZvciBpbnN0YW5jZSwgXCJhcnJheS1zcGxpY2UudHFcIiBoYXMgYSBcImZhc3QgcGF0aFwiIChFeHRyYWN0RmFzdEpTQXJyYXksIGRlZmluZWQgaW4gXCJzcmMvY29kZWdlbi9jb2RlLXN0dWItYXNzZW1ibGVyLmNjXCIpXG4gICAgLy8gYnV0IGl0J3Mgb25seSBlbmFibGVkIHdoZW4gXCJJc1Byb3RvdHlwZUluaXRpYWxBcnJheVByb3RvdHlwZSgpXCIgaXMgdHJ1ZS5cbiAgICAvL1xuICAgIC8vIE9sZGVyIHZlcnNpb25zIG9mIFY4IHdlcmUgdXNpbmcgcmVsYXRpdmVseSBmYXN0IEpTLXdpdGgtZXh0ZW5zaW9ucyBjb2RlIGV2ZW4gd2hlbiBBcnJheS5wcm90b3R5cGUgaXMgbW9kaWZpZWQ6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Y4L3Y4L2Jsb2IvNy4wLjEvc3JjL2pzL2FycmF5LmpzI0w1OTktTDY0MlxuICAgIC8vXG4gICAgLy8gSW4gc2hvcnQsIEFycmF5IG9wZXJhdGlvbnMgYXJlIHNsb3cgaW4gcmVjZW50IHZlcnNpb25zIG9mIFY4IHdoZW4gdGhlIEFycmF5LnByb3RvdHlwZSBoYXMgYmVlbiB0YW1wZXJlZC5cbiAgICAvLyBTbywgd2hlbiBwb3NzaWJsZSwgd2UgYXJlIHVzaW5nIGZhc3RlciBvcGVuLWNvZGVkIHZlcnNpb24gdG8gYm9vc3QgdGhlIHBlcmZvcm1hbmNlLlxuXG4gICAgLy8gQXMgb2YgVjggOC40LCBkZXBlbmRpbmcgb24gdGhlIHNpemUgb2YgdGhlIGFycmF5LCB0aGlzIGlzIHVwIHRvIH4yNXggdGltZXMgZmFzdGVyIHRoYW4gQXJyYXkjc2hpZnQoKVxuICAgIC8vIEltcGxlbWVudGF0aW9uIGlzIGhlYXZpbHkgaW5zcGlyZWQgYnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2JhNjg0ODA1YjZjMGVkZWQ3NmU1Y2Q4OWVlMDAzMjhhYzdhNTkzNjUvbGliL2ludGVybmFsL3V0aWwuanMjTDM0MS1MMzQ3XG4gICAgZnVuY3Rpb24gc2hpZnROb0FyZyhsaXN0KSB7XG4gICAgICB2YXIgciA9IGxpc3RbMF07XG4gICAgICB2YXIgaW5kZXggPSAxO1xuICAgICAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGxpc3RbaW5kZXggLSAxXSA9IGxpc3RbaW5kZXhdO1xuICAgICAgfVxuICAgICAgbGlzdC5wb3AoKTtcbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvQXJyYXlTdWJjbGFzcyhvYmosIGtsYXNzKSB7XG4gICAgICBpZiAoa2xhc3MuJCRuYW1lID09PSBPcGFsLkFycmF5KSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga2xhc3MuJGFsbG9jYXRlKCkuJHJlcGxhY2UoI3tgb2JqYC50b19hfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQSBoZWxwZXIgZm9yIGtlZXBfaWYgYW5kIGRlbGV0ZV9pZiwgZmlsdGVyIGlzIGVpdGhlciBPcGFsLnRydXRoeVxuICAgIC8vIG9yIE9wYWwuZmFsc3kuXG4gICAgZnVuY3Rpb24gZmlsdGVySWYoc2VsZiwgZmlsdGVyLCBibG9jaykge1xuICAgICAgdmFyIHZhbHVlLCByYWlzZWQgPSBudWxsLCB1cGRhdGVkID0gbmV3IEFycmF5KHNlbGYubGVuZ3RoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGkyID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFyYWlzZWQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBzZWxmW2ldKVxuICAgICAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgICAgIHJhaXNlZCA9IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyYWlzZWQgfHwgZmlsdGVyKHZhbHVlKSkge1xuICAgICAgICAgIHVwZGF0ZWRbaTJdID0gc2VsZltpXVxuICAgICAgICAgIGkyICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGkyICE9PSBpKSB7XG4gICAgICAgIHNlbGYuc3BsaWNlLmFwcGx5KHNlbGYsIFswLCB1cGRhdGVkLmxlbmd0aF0uY29uY2F0KHVwZGF0ZWQpKTtcbiAgICAgICAgc2VsZi5zcGxpY2UoaTIsIHVwZGF0ZWQubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJhaXNlZCkgdGhyb3cgcmFpc2VkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnZlcnRUb0FycmF5KGFycmF5KSB7XG4gICAgICBpZiAoIWFycmF5LiQkaXNfYXJyYXkpIHtcbiAgICAgICAgYXJyYXkgPSAkY29lcmNlX3RvKGFycmF5LCAjezo6QXJyYXl9LCAndG9fYXJ5Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gI3tgYXJyYXlgLnRvX2F9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZhc3RfcHVzaChhcnIsIG9iamVjdHMpIHtcbiAgICAgIC8vIHB1c2guYXBwbHkoKSBmb3IgYXJyYXlzIGxvbmdlciB0aGFuIDMyNzY3IG1heSBjYXVzZSB2YXJpb3VzIGFyZ3VtZW50IGVycm9ycyBpbiBicm93c2Vyc1xuICAgICAgLy8gYnV0IGl0IGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIHRoYW4gYSBmb3IgbG9vcCwgd2hpY2ggcHVzaGVzIGVhY2ggZWxlbWVudCBzZXBhcmF0ZWx5XG4gICAgICAvLyBidXQgYXBwbHkoKSBoYXMgYSBvdmVyaGVhZCBieSBpdHNlbGYsIGZvciBhIHNtYWxsIG51bWJlciBvZiBlbGVtZW50c1xuICAgICAgLy8gdGhlIGZvciBsb29wIGlzIHNpZ25pZmljYW50bHkgZmFzdGVyXG4gICAgICAvLyB0aGlzIGlzIHVzaW5nIHRoZSBiZXN0IG9wdGlvbiBkZXBlbmRpbmcgb24gb2JqZWN0cy5sZW5ndGhcbiAgICAgIHZhciBsZW5ndGggPSBvYmplY3RzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPiA2ICYmIGxlbmd0aCA8IDMyNzY3KSB7XG4gICAgICAgIGFyci5wdXNoLmFwcGx5KGFyciwgb2JqZWN0cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJyLnB1c2gob2JqZWN0c1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkZWYgc2VsZi5bXSgqb2JqZWN0cylcbiAgICBgdG9BcnJheVN1YmNsYXNzKG9iamVjdHMsIHNlbGYpYFxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZShzaXplID0gbmlsLCBvYmogPSBuaWwsICZibG9jaylcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIGlmIChvYmogIT09IG5pbCAmJiBibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICN7OjpLZXJuZWwud2Fybignd2FybmluZzogYmxvY2sgc3VwZXJzZWRlcyBkZWZhdWx0IHZhbHVlIGFyZ3VtZW50Jyl9XG4gICAgICB9XG5cbiAgICAgIGlmIChzaXplID4gI3s6OkludGVnZXI6Ok1BWH0pIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdhcnJheSBzaXplIHRvbyBiaWcnfVxuICAgICAgfVxuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGZvciAwLi4yKVwifVxuICAgICAgfVxuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAoc2VsZi5sZW5ndGggPiAwKSBzZWxmLnNwbGljZSgwLCBzZWxmLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAoc2l6ZS4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgI3tyZXBsYWNlKHNpemUudG9fYSl9XG4gICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH0gZWxzZSBpZiAoI3tzaXplLnJlc3BvbmRfdG8/IDp0b19hcnl9KSB7XG4gICAgICAgICAgI3tyZXBsYWNlKHNpemUudG9fYXJ5KX1cbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzaXplID0gJGNvZXJjZV90byhzaXplLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKHNpemUgPCAwKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJyYXkgc2l6ZSd9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuc3BsaWNlKDAsIHNlbGYubGVuZ3RoKTtcbiAgICAgIHZhciBpLCB2YWx1ZTtcblxuICAgICAgaWYgKGJsb2NrID09PSBuaWwpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgIHNlbGYucHVzaChvYmopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gMCwgdmFsdWU7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICB2YWx1ZSA9IGJsb2NrKGkpO1xuICAgICAgICAgIHNlbGZbaV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLnRyeV9jb252ZXJ0KG9iailcbiAgICA6Ok9wYWwuY29lcmNlX3RvPyBvYmosIDo6QXJyYXksIDp0b19hcnlcbiAgZW5kXG5cbiAgZGVmICYob3RoZXIpXG4gICAgJXh7XG4gICAgICBvdGhlciA9IGNvbnZlcnRUb0FycmF5KG90aGVyKVxuXG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT09IDAgfHwgb3RoZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IFtdLCBoYXNoID0gI3t7fX0sIGksIGxlbmd0aCwgaXRlbTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb3RoZXIubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgJGhhc2hfcHV0KGhhc2gsIG90aGVyW2ldLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcbiAgICAgICAgaWYgKCRoYXNoX2RlbGV0ZShoYXNoLCBpdGVtKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB8KG90aGVyKVxuICAgIG90aGVyID0gYGNvbnZlcnRUb0FycmF5KG90aGVyKWBcblxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSAje3t9fSwgaSwgbGVuZ3RoLCBpdGVtO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICRoYXNoX3B1dChoYXNoLCBzZWxmW2ldLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb3RoZXIubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgJGhhc2hfcHV0KGhhc2gsIG90aGVyW2ldLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2guJGtleXMoKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiAqKG90aGVyKVxuICAgIHJldHVybiBqb2luKG90aGVyLnRvX3N0cikgaWYgb3RoZXIucmVzcG9uZF90bz8gOnRvX3N0clxuXG4gICAgb3RoZXIgPSBgJGNvZXJjZV90byhvdGhlciwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICBpZiBgb3RoZXIgPCAwYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJndW1lbnQnXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICBjb252ZXJ0ZWQgPSAje3RvX2F9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG90aGVyOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChjb252ZXJ0ZWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgb3RoZXIgPSBgY29udmVydFRvQXJyYXkob3RoZXIpYFxuXG4gICAgYHNlbGYuY29uY2F0KG90aGVyKWBcbiAgZW5kXG5cbiAgZGVmIC0ob3RoZXIpXG4gICAgb3RoZXIgPSBgY29udmVydFRvQXJyYXkob3RoZXIpYFxuXG4gICAgcmV0dXJuIFtdIGlmIGBzZWxmLmxlbmd0aCA9PT0gMGBcbiAgICByZXR1cm4gYHNlbGYuc2xpY2UoKWAgaWYgYG90aGVyLmxlbmd0aCA9PT0gMGBcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdLCBoYXNoID0gI3t7fX0sIGksIGxlbmd0aCwgaXRlbTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb3RoZXIubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgJGhhc2hfcHV0KGhhc2gsIG90aGVyW2ldLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcbiAgICAgICAgaWYgKCRoYXNoX2dldChoYXNoLCBpdGVtKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA8PChvYmplY3QpXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXG4gICAgYHNlbGYucHVzaChvYmplY3QpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgPD0+KG90aGVyKVxuICAgIGlmIDo6QXJyYXkgPT09IG90aGVyXG4gICAgICBvdGhlciA9IG90aGVyLnRvX2FcbiAgICBlbHNpZiBvdGhlci5yZXNwb25kX3RvPyA6dG9fYXJ5XG4gICAgICBvdGhlciA9IG90aGVyLnRvX2FyeS50b19hXG4gICAgZWxzZVxuICAgICAgcmV0dXJuXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmICgje3NlbGZ9ID09PSAje290aGVyfSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvdW50ID0gTWF0aC5taW4oc2VsZi5sZW5ndGgsIG90aGVyLmxlbmd0aCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICB2YXIgdG1wID0gI3tgc2VsZltpXWAgPD0+IGBvdGhlcltpXWB9O1xuXG4gICAgICAgIGlmICh0bXAgIT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje2BzZWxmLmxlbmd0aGAgPD0+IGBvdGhlci5sZW5ndGhgfTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICAleHtcbiAgICAgIHZhciByZWN1cnNlZCA9IHt9O1xuXG4gICAgICBmdW5jdGlvbiBfZXFlcShhcnJheSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIGksIGxlbmd0aCwgYSwgYjtcblxuICAgICAgICBpZiAoYXJyYXkgPT09IG90aGVyKVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIGlmICghb3RoZXIuJCRpc19hcnJheSkge1xuICAgICAgICAgIGlmICgkcmVzcG9uZF90byhvdGhlciwgJyR0b19hcnknKSkge1xuICAgICAgICAgICAgcmV0dXJuICN7YG90aGVyYCA9PSBgYXJyYXlgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcnJheS4kJGNvbnN0cnVjdG9yICE9PSBBcnJheSlcbiAgICAgICAgICBhcnJheSA9ICN7YGFycmF5YC50b19hfTtcbiAgICAgICAgaWYgKG90aGVyLiQkY29uc3RydWN0b3IgIT09IEFycmF5KVxuICAgICAgICAgIG90aGVyID0gI3tgb3RoZXJgLnRvX2F9O1xuXG4gICAgICAgIGlmIChhcnJheS5sZW5ndGggIT09IG90aGVyLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY3Vyc2VkWyN7YGFycmF5YC5vYmplY3RfaWR9XSA9IHRydWU7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhID0gYXJyYXlbaV07XG4gICAgICAgICAgYiA9IG90aGVyW2ldO1xuICAgICAgICAgIGlmIChhLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChiLiQkaXNfYXJyYXkgJiYgYi5sZW5ndGggIT09IGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVjdXJzZWQuaGFzT3duUHJvcGVydHkoI3tgYWAub2JqZWN0X2lkfSkpIHtcbiAgICAgICAgICAgICAgaWYgKCFfZXFlcShhLCBiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoISN7YGFgID09IGBiYH0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2VxZXEoc2VsZiwgb3RoZXIpO1xuICAgIH1cbiAgZW5kXG5cbiAgJXh7XG4gICAgZnVuY3Rpb24gJGFycmF5X3NsaWNlX3JhbmdlKHNlbGYsIGluZGV4KSB7XG4gICAgICB2YXIgc2l6ZSA9IHNlbGYubGVuZ3RoLFxuICAgICAgICAgIGV4Y2x1ZGUsIGZyb20sIHRvLCByZXN1bHQ7XG5cbiAgICAgIGV4Y2x1ZGUgPSBpbmRleC5leGNsO1xuICAgICAgZnJvbSAgICA9IGluZGV4LmJlZ2luID09PSBuaWwgPyAwIDogJGNvZXJjZV90byhpbmRleC5iZWdpbiwgT3BhbC5JbnRlZ2VyLCAndG9faW50Jyk7XG4gICAgICB0byAgICAgID0gaW5kZXguZW5kID09PSBuaWwgPyAtMSA6ICRjb2VyY2VfdG8oaW5kZXguZW5kLCBPcGFsLkludGVnZXIsICd0b19pbnQnKTtcblxuICAgICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgIGZyb20gKz0gc2l6ZTtcblxuICAgICAgICBpZiAoZnJvbSA8IDApIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleC5leGNsX3JldiAmJiBpbmRleC5iZWdpbiAhPT0gbmlsKSB7XG4gICAgICAgIGZyb20gKz0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZyb20gPiBzaXplKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0byA8IDApIHtcbiAgICAgICAgdG8gKz0gc2l6ZTtcblxuICAgICAgICBpZiAodG8gPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZXhjbHVkZSB8fCBpbmRleC5lbmQgPT09IG5pbCkge1xuICAgICAgICB0byArPSAxO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBzZWxmLnNsaWNlKGZyb20sIHRvKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJGFycmF5X3NsaWNlX2FyaXRobWV0aWNfc2VxKHNlbGYsIGluZGV4KSB7XG4gICAgICB2YXIgYXJyYXksIG91dCA9IFtdLCBpID0gMCwgcHNldWRvcmFuZ2U7XG5cbiAgICAgIGlmIChpbmRleC5zdGVwIDwgMCkge1xuICAgICAgICBwc2V1ZG9yYW5nZSA9IHtcbiAgICAgICAgICBiZWdpbjogaW5kZXgucmFuZ2UuZW5kLFxuICAgICAgICAgIGVuZDogaW5kZXgucmFuZ2UuYmVnaW4sXG4gICAgICAgICAgZXhjbDogZmFsc2UsXG4gICAgICAgICAgZXhjbF9yZXY6IGluZGV4LnJhbmdlLmV4Y2xcbiAgICAgICAgfTtcbiAgICAgICAgYXJyYXkgPSAkYXJyYXlfc2xpY2VfcmFuZ2Uoc2VsZiwgcHNldWRvcmFuZ2UpLiRyZXZlcnNlKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYXJyYXkgPSAkYXJyYXlfc2xpY2VfcmFuZ2Uoc2VsZiwgaW5kZXgucmFuZ2UpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoaSA8IGFycmF5Lmxlbmd0aCkge1xuICAgICAgICBvdXQucHVzaChhcnJheVtpXSk7XG4gICAgICAgIGkgKz0gTWF0aC5hYnMoaW5kZXguc3RlcCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJGFycmF5X3NsaWNlX2luZGV4X2xlbmd0aChzZWxmLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc2l6ZSA9IHNlbGYubGVuZ3RoLFxuICAgICAgICAgIGV4Y2x1ZGUsIGZyb20sIHRvLCByZXN1bHQ7XG5cbiAgICAgIGluZGV4ID0gJGNvZXJjZV90byhpbmRleCwgT3BhbC5JbnRlZ2VyLCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggKz0gc2l6ZTtcblxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGluZGV4ID49IHNpemUgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsZW5ndGggPSAkY29lcmNlX3RvKGxlbmd0aCwgT3BhbC5JbnRlZ2VyLCAndG9faW50Jyk7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDAgfHwgaW5kZXggPiBzaXplIHx8IGluZGV4IDwgMCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBzZWxmLnNsaWNlKGluZGV4LCBpbmRleCArIGxlbmd0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIGRlZiBbXShpbmRleCwgbGVuZ3RoID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGluZGV4LiQkaXNfcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuICRhcnJheV9zbGljZV9yYW5nZShzZWxmLCBpbmRleCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpbmRleC4kJGlzX2FyaXRobWV0aWNfc2VxKSB7XG4gICAgICAgIHJldHVybiAkYXJyYXlfc2xpY2VfYXJpdGhtZXRpY19zZXEoc2VsZiwgaW5kZXgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAkYXJyYXlfc2xpY2VfaW5kZXhfbGVuZ3RoKHNlbGYsIGluZGV4LCBsZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIFtdPShpbmRleCwgdmFsdWUsIGV4dHJhID0gdW5kZWZpbmVkKVxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxuXG4gICAgZGF0YSA9IG5pbFxuICAgICV4e1xuICAgICAgdmFyIGksIHNpemUgPSBzZWxmLmxlbmd0aDtcblxuICAgICAgaWYgKGluZGV4LiQkaXNfcmFuZ2UpIHtcbiAgICAgICAgaWYgKHZhbHVlLiQkaXNfYXJyYXkpXG4gICAgICAgICAgZGF0YSA9ICN7dmFsdWUudG9fYX07XG4gICAgICAgIGVsc2UgaWYgKCN7dmFsdWUucmVzcG9uZF90bz8gOnRvX2FyeX0pXG4gICAgICAgICAgZGF0YSA9ICN7dmFsdWUudG9fYXJ5LnRvX2F9O1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZGF0YSA9IFt2YWx1ZV07XG5cbiAgICAgICAgdmFyIGV4Y2x1ZGUgPSBpbmRleC5leGNsLFxuICAgICAgICAgICAgZnJvbSAgICA9IGluZGV4LmJlZ2luID09PSBuaWwgPyAwIDogJGNvZXJjZV90byhpbmRleC5iZWdpbiwgT3BhbC5JbnRlZ2VyLCAndG9faW50JyksXG4gICAgICAgICAgICB0byAgICAgID0gaW5kZXguZW5kID09PSBuaWwgPyAtMSA6ICRjb2VyY2VfdG8oaW5kZXguZW5kLCBPcGFsLkludGVnZXIsICd0b19pbnQnKTtcblxuICAgICAgICBpZiAoZnJvbSA8IDApIHtcbiAgICAgICAgICBmcm9tICs9IHNpemU7XG5cbiAgICAgICAgICBpZiAoZnJvbSA8IDApIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCBcIiN7aW5kZXguaW5zcGVjdH0gb3V0IG9mIHJhbmdlXCJ9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0byA8IDApIHtcbiAgICAgICAgICB0byArPSBzaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFleGNsdWRlIHx8IGluZGV4LmVuZCA9PT0gbmlsKSB7XG4gICAgICAgICAgdG8gKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmcm9tID4gc2l6ZSkge1xuICAgICAgICAgIGZvciAoaSA9IHNpemU7IGkgPCBmcm9tOyBpKyspIHtcbiAgICAgICAgICAgIHNlbGZbaV0gPSBuaWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvIDwgMCkge1xuICAgICAgICAgIHNlbGYuc3BsaWNlLmFwcGx5KHNlbGYsIFtmcm9tLCAwXS5jb25jYXQoZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNlbGYuc3BsaWNlLmFwcGx5KHNlbGYsIFtmcm9tLCB0byAtIGZyb21dLmNvbmNhdChkYXRhKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZXh0cmEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICN7bGVuZ3RoID0gMX1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZTtcbiAgICAgICAgICB2YWx1ZSAgPSBleHRyYTtcblxuICAgICAgICAgIGlmICh2YWx1ZS4kJGlzX2FycmF5KVxuICAgICAgICAgICAgZGF0YSA9ICN7dmFsdWUudG9fYX07XG4gICAgICAgICAgZWxzZSBpZiAoI3t2YWx1ZS5yZXNwb25kX3RvPyA6dG9fYXJ5fSlcbiAgICAgICAgICAgIGRhdGEgPSAje3ZhbHVlLnRvX2FyeS50b19hfTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkYXRhID0gW3ZhbHVlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvbGQ7XG5cbiAgICAgICAgaW5kZXggID0gJGNvZXJjZV90byhpbmRleCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgICAgIGxlbmd0aCA9ICRjb2VyY2VfdG8obGVuZ3RoLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgb2xkICAgID0gaW5kZXg7XG4gICAgICAgICAgaW5kZXggKz0gc2l6ZTtcblxuICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpJbmRleEVycm9yLCBcImluZGV4ICN7YG9sZGB9IHRvbyBzbWFsbCBmb3IgYXJyYXk7IG1pbmltdW0gI3tgLXNlbGYubGVuZ3RoYH1cIn07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6SW5kZXhFcnJvciwgXCJuZWdhdGl2ZSBsZW5ndGggKCN7bGVuZ3RofSlcIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCA+IHNpemUpIHtcbiAgICAgICAgICBmb3IgKGkgPSBzaXplOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgICAgICAgc2VsZltpXSA9IG5pbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXh0cmEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHNlbGZbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgW2luZGV4LCBsZW5ndGhdLmNvbmNhdChkYXRhKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYW55PyhwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgYGlmIChzZWxmLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlYFxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBhc3NvYyhvYmplY3QpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGl0ZW07IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXRlbSA9IHNlbGZbaV0sIGl0ZW0ubGVuZ3RoICYmICN7YGl0ZW1bMF1gID09IG9iamVjdH0pIHtcbiAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGF0KGluZGV4KVxuICAgICV4e1xuICAgICAgaW5kZXggPSAkY29lcmNlX3RvKGluZGV4LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKVxuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmW2luZGV4XTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBic2VhcmNoX2luZGV4KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmJzZWFyY2hfaW5kZXggdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgbWluID0gMCxcbiAgICAgICAgICBtYXggPSBzZWxmLmxlbmd0aCxcbiAgICAgICAgICBtaWQsXG4gICAgICAgICAgdmFsLFxuICAgICAgICAgIHJldCxcbiAgICAgICAgICBzbWFsbGVyID0gZmFsc2UsXG4gICAgICAgICAgc2F0aXNmaWVkID0gbmlsO1xuXG4gICAgICB3aGlsZSAobWluIDwgbWF4KSB7XG4gICAgICAgIG1pZCA9IG1pbiArIE1hdGguZmxvb3IoKG1heCAtIG1pbikgLyAyKTtcbiAgICAgICAgdmFsID0gc2VsZlttaWRdO1xuICAgICAgICByZXQgPSAkeWllbGQxKGJsb2NrLCB2YWwpO1xuXG4gICAgICAgIGlmIChyZXQgPT09IHRydWUpIHtcbiAgICAgICAgICBzYXRpc2ZpZWQgPSBtaWQ7XG4gICAgICAgICAgc21hbGxlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmV0ID09PSBmYWxzZSB8fCByZXQgPT09IG5pbCkge1xuICAgICAgICAgIHNtYWxsZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXQuJCRpc19udW1iZXIpIHtcbiAgICAgICAgICBpZiAocmV0ID09PSAwKSB7IHJldHVybiBtaWQ7IH1cbiAgICAgICAgICBzbWFsbGVyID0gKHJldCA8IDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje2ByZXRgLmNsYXNzfSAobXVzdCBiZSBudW1lcmljLCB0cnVlLCBmYWxzZSBvciBuaWwpXCJ9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc21hbGxlcikgeyBtYXggPSBtaWQ7IH0gZWxzZSB7IG1pbiA9IG1pZCArIDE7IH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNhdGlzZmllZDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBic2VhcmNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmJzZWFyY2ggdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgaW5kZXggPSBic2VhcmNoX2luZGV4KCZibG9jaylcblxuICAgICV4e1xuICAgICAgaWYgKGluZGV4ICE9IG51bGwgJiYgaW5kZXguJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGZbaW5kZXhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGN5Y2xlKG4gPSBuaWwsICZibG9jaylcbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOmN5Y2xlLCBuKSBkb1xuICAgICAgICBpZiBuLm5pbD9cbiAgICAgICAgICA6OkZsb2F0OjpJTkZJTklUWVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbiA9IDo6T3BhbC5jb2VyY2VfdG8hKG4sIDo6SW50ZWdlciwgOnRvX2ludClcbiAgICAgICAgICBuID4gMCA/IGVudW1lcmF0b3Jfc2l6ZSAqIG4gOiAwXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICByZXR1cm4gaWYgZW1wdHk/IHx8IG4gPT0gMFxuXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbGVuZ3RoLCB2YWx1ZTtcblxuICAgICAgaWYgKG4gPT09IG5pbCkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgc2VsZltpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbiA9ICN7OjpPcGFsLmNvZXJjZV90byEobiwgOjpJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICAgIGlmIChuIDw9IDApIHtcbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgc2VsZltpXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbi0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY2xlYXJcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcblxuICAgIGBzZWxmLnNwbGljZSgwLCBzZWxmLmxlbmd0aClgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjb3VudChvYmplY3QgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBpZiBgb2JqZWN0ICE9PSB1bmRlZmluZWRgIHx8IGJsb2NrXG4gICAgICBzdXBlclxuICAgIGVsc2VcbiAgICAgIHNpemVcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemVfY29weShvdGhlcilcbiAgICByZXBsYWNlIG90aGVyXG4gIGVuZFxuXG4gIGRlZiBjb2xsZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmNvbGxlY3QpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gJHlpZWxkMShibG9jaywgc2VsZltpXSk7XG4gICAgICAgIHJlc3VsdFtpXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbGxlY3QhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmNvbGxlY3QhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBzZWxmW2ldKTtcbiAgICAgICAgc2VsZltpXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgJXh7XG4gICAgZnVuY3Rpb24gYmlub21pYWxfY29lZmZpY2llbnQobiwgaykge1xuICAgICAgaWYgKG4gPT09IGsgfHwgayA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGsgPiAwICYmIG4gPiBrKSB7XG4gICAgICAgIHJldHVybiBiaW5vbWlhbF9jb2VmZmljaWVudChuIC0gMSwgayAtIDEpICsgYmlub21pYWxfY29lZmZpY2llbnQobiAtIDEsIGspO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cblxuICBkZWYgY29tYmluYXRpb24obilcbiAgICBudW0gPSA6Ok9wYWwuY29lcmNlX3RvISBuLCA6OkludGVnZXIsIDp0b19pbnRcbiAgICByZXR1cm4gZW51bV9mb3IoOmNvbWJpbmF0aW9uLCBudW0pIHsgYGJpbm9taWFsX2NvZWZmaWNpZW50KCN7c2VsZn0ubGVuZ3RoLCBudW0pYCB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIGksIGxlbmd0aCwgc3RhY2ssIGNob3NlbiwgbGV2LCBkb25lLCBuZXh0O1xuXG4gICAgICBpZiAobnVtID09PSAwKSB7XG4gICAgICAgICN7eWllbGQgW119XG4gICAgICB9IGVsc2UgaWYgKG51bSA9PT0gMSkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgI3t5aWVsZCBgW3NlbGZbaV1dYH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAobnVtID09PSBzZWxmLmxlbmd0aCkge1xuICAgICAgICAje3lpZWxkIGBzZWxmLnNsaWNlKClgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAobnVtID49IDAgJiYgbnVtIDwgc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgc3RhY2sgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8PSBudW0gKyAxOyBpKyspIHtcbiAgICAgICAgICBzdGFjay5wdXNoKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hvc2VuID0gW107XG4gICAgICAgIGxldiA9IDA7XG4gICAgICAgIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgc3RhY2tbMF0gPSAtMTtcblxuICAgICAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgICAgICBjaG9zZW5bbGV2XSA9IHNlbGZbc3RhY2tbbGV2KzFdXTtcbiAgICAgICAgICB3aGlsZSAobGV2IDwgbnVtIC0gMSkge1xuICAgICAgICAgICAgbGV2Kys7XG4gICAgICAgICAgICBuZXh0ID0gc3RhY2tbbGV2KzFdID0gc3RhY2tbbGV2XSArIDE7XG4gICAgICAgICAgICBjaG9zZW5bbGV2XSA9IHNlbGZbbmV4dF07XG4gICAgICAgICAgfVxuICAgICAgICAgICN7IHlpZWxkIGBjaG9zZW4uc2xpY2UoKWAgfVxuICAgICAgICAgIGxldisrO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGRvbmUgPSAobGV2ID09PSAwKTtcbiAgICAgICAgICAgIHN0YWNrW2xldl0rKztcbiAgICAgICAgICAgIGxldi0tO1xuICAgICAgICAgIH0gd2hpbGUgKCBzdGFja1tsZXYrMV0gKyBudW0gPT09IHNlbGYubGVuZ3RoICsgbGV2ICsgMSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHJlcGVhdGVkX2NvbWJpbmF0aW9uKG4pXG4gICAgbnVtID0gOjpPcGFsLmNvZXJjZV90byEgbiwgOjpJbnRlZ2VyLCA6dG9faW50XG5cbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOnJlcGVhdGVkX2NvbWJpbmF0aW9uLCBudW0pIHsgYGJpbm9taWFsX2NvZWZmaWNpZW50KHNlbGYubGVuZ3RoICsgbnVtIC0gMSwgbnVtKWAgfVxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBmdW5jdGlvbiBpdGVyYXRlKG1heCwgZnJvbSwgYnVmZmVyLCBzZWxmKSB7XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09IG1heCkge1xuICAgICAgICAgIHZhciBjb3B5ID0gYnVmZmVyLnNsaWNlKCk7XG4gICAgICAgICAgI3t5aWVsZCBgY29weWB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSBmcm9tOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKHNlbGZbaV0pO1xuICAgICAgICAgIGl0ZXJhdGUobWF4LCBpLCBidWZmZXIsIHNlbGYpO1xuICAgICAgICAgIGJ1ZmZlci5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobnVtID49IDApIHtcbiAgICAgICAgaXRlcmF0ZShudW0sIDAsIFtdLCBzZWxmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY29tcGFjdFxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGl0ZW07IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoKGl0ZW0gPSBzZWxmW2ldKSAhPT0gbmlsKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb21wYWN0IVxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgdmFyIG9yaWdpbmFsID0gc2VsZi5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxmW2ldID09PSBuaWwpIHtcbiAgICAgICAgICBzZWxmLnNwbGljZShpLCAxKTtcblxuICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5sZW5ndGggPT09IG9yaWdpbmFsID8gbmlsIDogc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb25jYXQoKm90aGVycylcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcblxuICAgIG90aGVycyA9IG90aGVycy5tYXAgZG8gfG90aGVyfFxuICAgICAgYG90aGVyID0gY29udmVydFRvQXJyYXkob3RoZXIpYFxuXG4gICAgICBpZiBvdGhlci5lcXVhbD8oc2VsZilcbiAgICAgICAgb3RoZXIgPSBvdGhlci5kdXBcbiAgICAgIGVuZFxuXG4gICAgICBvdGhlclxuICAgIGVuZFxuXG4gICAgb3RoZXJzLmVhY2ggZG8gfG90aGVyfFxuICAgICAgJXh7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvdGhlci5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHNlbGYucHVzaChvdGhlcltpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZShvYmplY3QpXG4gICAgJXh7XG4gICAgICB2YXIgb3JpZ2luYWwgPSBzZWxmLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9yaWdpbmFsOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCN7YHNlbGZbaV1gID09IG9iamVjdH0pIHtcbiAgICAgICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICAgICAgc2VsZi5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSBvcmlnaW5hbCkge1xuICAgICAgICBpZiAoI3tibG9ja19naXZlbj99KSB7XG4gICAgICAgICAgcmV0dXJuICN7eWllbGR9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZV9hdChpbmRleClcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIGluZGV4ID0gJGNvZXJjZV90byhpbmRleCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggKz0gc2VsZi5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IHNlbGZbaW5kZXhdO1xuXG4gICAgICBzZWxmLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVsZXRlX2lmKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmRlbGV0ZV9pZikgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgZmlsdGVySWYoc2VsZiwgJGZhbHN5LCBibG9jaylcbiAgICB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZGlmZmVyZW5jZSgqYXJyYXlzKVxuICAgIGFycmF5cy5yZWR1Y2UodG9fYS5kdXApIHsgfGEsIGJ8IGEgLSBiIH1cbiAgZW5kXG5cbiAgZGVmIGRpZyhpZHgsICppZHhzKVxuICAgIGl0ZW0gPSBzZWxmW2lkeF1cblxuICAgICV4e1xuICAgICAgaWYgKGl0ZW0gPT09IG5pbCB8fCBpZHhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1bmxlc3MgaXRlbS5yZXNwb25kX3RvPyg6ZGlnKVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiI3tpdGVtLmNsYXNzfSBkb2VzIG5vdCBoYXZlICNkaWcgbWV0aG9kXCJcbiAgICBlbmRcblxuICAgIGl0ZW0uZGlnKCppZHhzKVxuICBlbmRcblxuICBkZWYgZHJvcChudW1iZXIpXG4gICAgJXh7XG4gICAgICBudW1iZXIgPSAkY29lcmNlX3RvKG51bWJlciwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5zbGljZShudW1iZXIpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRjbGFzcyA9PT0gT3BhbC5BcnJheSAmJlxuICAgICAgICAgIHNlbGYuJCRjbGFzcy4kYWxsb2NhdGUuJCRwcmlzdGluZSAmJlxuICAgICAgICAgIHNlbGYuJGNvcHlfaW5zdGFuY2VfdmFyaWFibGVzLiQkcHJpc3RpbmUgJiZcbiAgICAgICAgICBzZWxmLiRpbml0aWFsaXplX2R1cC4kJHByaXN0aW5lKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnNsaWNlKDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBlYWNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2gpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICR5aWVsZDEoYmxvY2ssIHNlbGZbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVhY2hfaW5kZXgoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9pbmRleCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgJHlpZWxkMShibG9jaywgaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZW1wdHk/XG4gICAgYHNlbGYubGVuZ3RoID09PSAwYFxuICBlbmRcblxuICBkZWYgZXFsPyhvdGhlcilcbiAgICAleHtcbiAgICAgIHZhciByZWN1cnNlZCA9IHt9O1xuXG4gICAgICBmdW5jdGlvbiBfZXFsKGFycmF5LCBvdGhlcikge1xuICAgICAgICB2YXIgaSwgbGVuZ3RoLCBhLCBiO1xuXG4gICAgICAgIGlmICghb3RoZXIuJCRpc19hcnJheSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG90aGVyID0gI3tvdGhlci50b19hfTtcblxuICAgICAgICBpZiAoYXJyYXkubGVuZ3RoICE9PSBvdGhlci5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZWN1cnNlZFsje2BhcnJheWAub2JqZWN0X2lkfV0gPSB0cnVlO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYSA9IGFycmF5W2ldO1xuICAgICAgICAgIGIgPSBvdGhlcltpXTtcbiAgICAgICAgICBpZiAoYS4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgICBpZiAoYi4kJGlzX2FycmF5ICYmIGIubGVuZ3RoICE9PSBhLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlY3Vyc2VkLmhhc093blByb3BlcnR5KCN7YGFgLm9iamVjdF9pZH0pKSB7XG4gICAgICAgICAgICAgIGlmICghX2VxbChhLCBiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoISN7YGFgLmVxbD8oYGJgKX0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2VxbChzZWxmLCBvdGhlcik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZmV0Y2goaW5kZXgsIGRlZmF1bHRzID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgb3JpZ2luYWwgPSBpbmRleDtcblxuICAgICAgaW5kZXggPSAkY29lcmNlX3RvKGluZGV4LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCArPSBzZWxmLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBzZWxmLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc2VsZltpbmRleF07XG4gICAgICB9XG5cbiAgICAgIGlmIChibG9jayAhPT0gbmlsICYmIGRlZmF1bHRzICE9IG51bGwpIHtcbiAgICAgICAgI3t3YXJuKCd3YXJuaW5nOiBibG9jayBzdXBlcnNlZGVzIGRlZmF1bHQgdmFsdWUgYXJndW1lbnQnKX1cbiAgICAgIH1cblxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrKG9yaWdpbmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlZmF1bHRzICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkluZGV4RXJyb3IsIFwiaW5kZXggI3tgb3JpZ2luYWxgfSBvdXRzaWRlIG9mIGFycmF5IGJvdW5kczogMC4uLjBcIn1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6SW5kZXhFcnJvciwgXCJpbmRleCAje2BvcmlnaW5hbGB9IG91dHNpZGUgb2YgYXJyYXkgYm91bmRzOiAtI3tgc2VsZi5sZW5ndGhgfS4uLiN7YHNlbGYubGVuZ3RoYH1cIn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgZmlsbCgqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgdmFyIGksIGxlbmd0aCwgdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgYmxvY2tcbiAgICAgIGlmIGBhcmdzLmxlbmd0aCA+IDJgXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2FyZ3MubGVuZ3RofSBmb3IgMC4uMilcIlxuICAgICAgZW5kXG5cbiAgICAgIG9uZSwgdHdvID0gYXJnc1xuICAgIGVsc2VcbiAgICAgIGlmIGBhcmdzLmxlbmd0aCA9PSAwYFxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxLi4zKSdcbiAgICAgIGVsc2lmIGBhcmdzLmxlbmd0aCA+IDNgXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2FyZ3MubGVuZ3RofSBmb3IgMS4uMylcIlxuICAgICAgZW5kXG5cbiAgICAgIG9iaiwgb25lLCB0d28gPSBhcmdzXG4gICAgZW5kXG5cbiAgICBpZiA6OlJhbmdlID09PSBvbmVcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnbGVuZ3RoIGludmFsaWQgd2l0aCByYW5nZScgaWYgdHdvXG5cbiAgICAgIGxlZnQgICA9IGBvbmUuYmVnaW4gPT09IG5pbCA/IDAgOiAkY29lcmNlX3RvKG9uZS5iZWdpbiwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG4gICAgICBgbGVmdCArPSB0aGlzLmxlbmd0aGAgaWYgYGxlZnQgPCAwYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCBcIiN7b25lLmluc3BlY3R9IG91dCBvZiByYW5nZVwiIGlmIGBsZWZ0IDwgMGBcblxuICAgICAgcmlnaHQgPSBgb25lLmVuZCA9PT0gbmlsID8gLTEgOiAkY29lcmNlX3RvKG9uZS5lbmQsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgYHJpZ2h0ICs9IHRoaXMubGVuZ3RoYCBpZiBgcmlnaHQgPCAwYFxuICAgICAgYHJpZ2h0ICs9IDFgIHVubGVzcyBvbmUuZXhjbHVkZV9lbmQ/XG5cbiAgICAgIHJldHVybiBzZWxmIGlmIGByaWdodCA8PSBsZWZ0YFxuICAgIGVsc2lmIG9uZVxuICAgICAgbGVmdCAgID0gYCRjb2VyY2VfdG8ob25lLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgIGBsZWZ0ICs9IHRoaXMubGVuZ3RoYCBpZiBgbGVmdCA8IDBgXG4gICAgICBsZWZ0ICAgPSAwIGlmIGBsZWZ0IDwgMGBcblxuICAgICAgaWYgdHdvXG4gICAgICAgIHJpZ2h0ID0gYCRjb2VyY2VfdG8odHdvLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgICAgICByZXR1cm4gc2VsZiBpZiBgcmlnaHQgPT0gMGBcblxuICAgICAgICBgcmlnaHQgKz0gbGVmdGBcbiAgICAgIGVsc2VcbiAgICAgICAgcmlnaHQgPSBgdGhpcy5sZW5ndGhgXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBsZWZ0ICA9IDBcbiAgICAgIHJpZ2h0ID0gYHRoaXMubGVuZ3RoYFxuICAgIGVuZFxuXG4gICAgaWYgYGxlZnQgPiB0aGlzLmxlbmd0aGBcbiAgICAgICV4e1xuICAgICAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aDsgaSA8IHJpZ2h0OyBpKyspIHtcbiAgICAgICAgICBzZWxmW2ldID0gbmlsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBpZiBgcmlnaHQgPiB0aGlzLmxlbmd0aGBcbiAgICAgIGB0aGlzLmxlbmd0aCA9IHJpZ2h0YFxuICAgIGVuZFxuXG4gICAgaWYgYmxvY2tcbiAgICAgICV4e1xuICAgICAgICBmb3IgKGxlbmd0aCA9IHRoaXMubGVuZ3RoOyBsZWZ0IDwgcmlnaHQ7IGxlZnQrKykge1xuICAgICAgICAgIHZhbHVlID0gYmxvY2sobGVmdCk7XG4gICAgICAgICAgc2VsZltsZWZ0XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgJXh7XG4gICAgICAgIGZvciAobGVuZ3RoID0gdGhpcy5sZW5ndGg7IGxlZnQgPCByaWdodDsgbGVmdCsrKSB7XG4gICAgICAgICAgc2VsZltsZWZ0XSA9ICN7b2JqfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZmlyc3QoY291bnQgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoY291bnQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2VsZi5sZW5ndGggPT09IDAgPyBuaWwgOiBzZWxmWzBdO1xuICAgICAgfVxuXG4gICAgICBjb3VudCA9ICRjb2VyY2VfdG8oY291bnQsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAoY291bnQgPCAwKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJyYXkgc2l6ZSd9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5zbGljZSgwLCBjb3VudCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZmxhdHRlbihsZXZlbCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGZ1bmN0aW9uIF9mbGF0dGVuKGFycmF5LCBsZXZlbCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICBpLCBsZW5ndGgsXG4gICAgICAgICAgICBpdGVtLCBhcnk7XG5cbiAgICAgICAgYXJyYXkgPSAje2BhcnJheWAudG9fYX07XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpdGVtID0gYXJyYXlbaV07XG5cbiAgICAgICAgICBpZiAoISRyZXNwb25kX3RvKGl0ZW0sICckdG9fYXJ5JywgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXJ5ID0gI3tgaXRlbWAudG9fYXJ5fTtcblxuICAgICAgICAgIGlmIChhcnkgPT09IG5pbCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWFyeS4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYXJ5ID09PSBzZWxmKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvcn07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3dpdGNoIChsZXZlbCkge1xuICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChfZmxhdHRlbihhcnkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFyeSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZmFzdF9wdXNoKHJlc3VsdCwgX2ZsYXR0ZW4oYXJ5LCBsZXZlbCAtIDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgaWYgKGxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV2ZWwgPSAkY29lcmNlX3RvKGxldmVsLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9mbGF0dGVuKHNlbGYsIGxldmVsKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBmbGF0dGVuIShsZXZlbCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIHZhciBmbGF0dGVuZWQgPSAje2ZsYXR0ZW4gbGV2ZWx9O1xuXG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT0gZmxhdHRlbmVkLmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChzZWxmW2ldICE9PSBmbGF0dGVuZWRbaV0pIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpID09IGxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgI3tyZXBsYWNlIGBmbGF0dGVuZWRgfTtcbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBmcmVlemVcbiAgICByZXR1cm4gc2VsZiBpZiBmcm96ZW4/XG5cbiAgICBgJGZyZWV6ZShzZWxmKWBcbiAgZW5kXG5cbiAgYHZhciAkaGFzaF9pZHNgXG5cbiAgZGVmIGhhc2hcbiAgICAleHtcbiAgICAgIHZhciB0b3AgPSAoJGhhc2hfaWRzID09PSB1bmRlZmluZWQpLFxuICAgICAgICAgIHJlc3VsdCA9ICRvcGFsMzJfaW5pdCgpLFxuICAgICAgICAgIGhhc2hfaWQgPSBzZWxmLiRvYmplY3RfaWQoKSxcbiAgICAgICAgICBpdGVtLCBpLCBrZXk7XG5cbiAgICAgIHJlc3VsdCA9ICRvcGFsMzJfYWRkKHJlc3VsdCwgMHhBKTtcbiAgICAgIHJlc3VsdCA9ICRvcGFsMzJfYWRkKHJlc3VsdCwgc2VsZi5sZW5ndGgpO1xuXG4gICAgICBpZiAodG9wKSB7XG4gICAgICAgICRoYXNoX2lkcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gZWFybHkgZm9yIHJlY3Vyc2l2ZSBzdHJ1Y3R1cmVzXG4gICAgICBlbHNlIGlmICgkaGFzaF9pZHNbaGFzaF9pZF0pIHtcbiAgICAgICAgcmV0dXJuICRvcGFsMzJfYWRkKHJlc3VsdCwgMHgwMTAxMDEwMSk7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoa2V5IGluICRoYXNoX2lkcykge1xuICAgICAgICAgIGl0ZW0gPSAkaGFzaF9pZHNba2V5XTtcbiAgICAgICAgICBpZiAoI3tlcWw/KGBpdGVtYCl9KSB7XG4gICAgICAgICAgICByZXR1cm4gJG9wYWwzMl9hZGQocmVzdWx0LCAweDAxMDEwMTAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAkaGFzaF9pZHNbaGFzaF9pZF0gPSBzZWxmO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaXRlbSA9IHNlbGZbaV07XG4gICAgICAgICAgcmVzdWx0ID0gJG9wYWwzMl9hZGQocmVzdWx0LCBpdGVtLiRoYXNoKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAkaGFzaF9pZHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlPyhtZW1iZXIpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoI3tgc2VsZltpXWAgPT0gbWVtYmVyfSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbmRleChvYmplY3QgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBpLCBsZW5ndGgsIHZhbHVlO1xuXG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwgJiYgYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAje3dhcm4oJ3dhcm5pbmc6IGdpdmVuIGJsb2NrIG5vdCB1c2VkJyl9XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCN7YHNlbGZbaV1gID09IG9iamVjdH0pIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhbHVlID0gYmxvY2soc2VsZltpXSk7XG5cbiAgICAgICAgICBpZiAodmFsdWUgIT09IGZhbHNlICYmIHZhbHVlICE9PSBuaWwpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje2VudW1fZm9yIDppbmRleH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zZXJ0KGluZGV4LCAqb2JqZWN0cylcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIGluZGV4ID0gJGNvZXJjZV90byhpbmRleCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChvYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgIGluZGV4ICs9IHNlbGYubGVuZ3RoICsgMTtcblxuICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICN7IDo6S2VybmVsLnJhaXNlIDo6SW5kZXhFcnJvciwgXCIje2luZGV4fSBpcyBvdXQgb2YgYm91bmRzXCIgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ID4gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gc2VsZi5sZW5ndGg7IGkgPCBpbmRleDsgaSsrKSB7XG4gICAgICAgICAgICBzZWxmLnB1c2gobmlsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnNwbGljZS5hcHBseShzZWxmLCBbaW5kZXgsIDBdLmNvbmNhdChvYmplY3RzKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBgdmFyIGluc3BlY3Rfc3RhY2sgPSBbXWBcblxuICBkZWYgaW5zcGVjdFxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgaWQgPSAje19faWRfX30sXG4gICAgICBwdXNoZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGJlZ2luXG4gICAgICAleHtcbiAgICAgICAgaWYgKGluc3BlY3Rfc3RhY2suaW5kZXhPZihpZCkgIT09IC0xKSB7XG4gICAgICAgICAgcHVzaGVkID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuICdbLi4uXSc7XG4gICAgICAgIH1cbiAgICAgICAgaW5zcGVjdF9zdGFjay5wdXNoKGlkKVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSAje3NlbGZbYGlgXX07XG5cbiAgICAgICAgICByZXN1bHQucHVzaCgje09wYWwuaW5zcGVjdChgaXRlbWApfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJ1snICsgcmVzdWx0LmpvaW4oJywgJykgKyAnXSc7XG4gICAgICB9XG4gICAgICBuaWxcbiAgICBlbnN1cmVcbiAgICAgIGBpZiAocHVzaGVkKSBpbnNwZWN0X3N0YWNrLnBvcCgpYFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaW50ZXJzZWN0aW9uKCphcnJheXMpXG4gICAgJXh7XG4gICAgICBpZiAoYXJyYXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gI3t0b19hLmR1cH07XG4gICAgICB9XG4gICAgICBhcnJheXMgPSBhcnJheXMubWFwKGNvbnZlcnRUb0FycmF5KTtcbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXJyYXlzID0gYXJyYXlzLnNvcnRfYnkoJjpsZW5ndGgpXG4gICAgIyBXaGVuIHNlbGYgaXMgdGhlIHNtYWxsZXN0IGFtb25nIHRoZSBhcnJheXNcbiAgICBpZiBgc2VsZi5sZW5ndGggPCBhcnJheXNbMF0ubGVuZ3RoYFxuICAgICAgcmV0dXJuIGFycmF5cy5yZWR1Y2Uoc2VsZiwgJjomKVxuICAgIGVuZFxuXG4gICAgIyBGaXJzdCwgY2FsY3VsYXRlIGludGVyc2VjdGlvbiBvZiBhcmd1bWVudCBhcnJheXMuXG4gICAgIyBBcnJheSMmIGlzIGZhc3RlciB3aGVuIHRoZSBhcmd1bWVudCBzaXplIGlzIHNtYWxsLlxuICAgICMgU28gYGxhcmdlc3QgJiBzaG9ydGVzdCAmIHNlY29uZF9zaG9ydGVzdCAmIC4uLmAgd291bGQgYmUgdGhlIGZhc3Rlc3QuXG4gICAgbGFyZ2VzdCA9IGBhcnJheXMucG9wKClgXG4gICAgaW50ZXJzZWN0aW9uX29mX2FyZ3MgPSBhcnJheXMucmVkdWNlKGxhcmdlc3QsICY6JilcblxuICAgICMgc2VsZiBhcnJheSBtdXN0IGNvbWUgbGFzdCB0byBtYWludGFpbiB0aGUgb3JkZXJcbiAgICBzZWxmICYgaW50ZXJzZWN0aW9uX29mX2FyZ3NcbiAgZW5kXG5cbiAgZGVmIGludGVyc2VjdD8ob3RoZXIpXG4gICAgJXh7XG4gICAgICB2YXIgc21hbGwsIGxhcmdlLCBoYXNoID0gI3t7fX0sIGksIGxlbmd0aDtcbiAgICAgIGlmIChzZWxmLmxlbmd0aCA8IG90aGVyLmxlbmd0aCkge1xuICAgICAgICBzbWFsbCA9IHNlbGY7XG4gICAgICAgIGxhcmdlID0gb3RoZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbWFsbCA9IG90aGVyO1xuICAgICAgICBsYXJnZSA9IHNlbGY7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNtYWxsLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICRoYXNoX3B1dChoYXNoLCBzbWFsbFtpXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGxhcmdlLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgkaGFzaF9nZXQoaGFzaCwgbGFyZ2VbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBqb2luKHNlcCA9IG5pbClcbiAgICByZXR1cm4gJycgaWYgYHNlbGYubGVuZ3RoID09PSAwYFxuXG4gICAgaWYgYHNlcCA9PT0gbmlsYFxuICAgICAgc2VwID0gJCxcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFyIGksIGxlbmd0aCwgaXRlbSwgdG1wO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuXG4gICAgICAgIGlmICgkcmVzcG9uZF90byhpdGVtLCAnJHRvX3N0cicpKSB7XG4gICAgICAgICAgdG1wID0gI3tgaXRlbWAudG9fc3RyfTtcblxuICAgICAgICAgIGlmICh0bXAgIT09IG5pbCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goI3tgdG1wYC50b19zfSk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkcmVzcG9uZF90byhpdGVtLCAnJHRvX2FyeScpKSB7XG4gICAgICAgICAgdG1wID0gI3tgaXRlbWAudG9fYXJ5fTtcblxuICAgICAgICAgIGlmICh0bXAgPT09IHNlbGYpIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodG1wICE9PSBuaWwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCN7YHRtcGAuam9pbihzZXApfSk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkcmVzcG9uZF90byhpdGVtLCAnJHRvX3MnKSkge1xuICAgICAgICAgIHRtcCA9ICN7YGl0ZW1gLnRvX3N9O1xuXG4gICAgICAgICAgaWYgKHRtcCAhPT0gbmlsKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0bXApO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6Tm9NZXRob2RFcnJvci5uZXcoXCIje09wYWwuaW5zcGVjdChpdGVtKX0gZG9lc24ndCByZXNwb25kIHRvICN0b19zdHIsICN0b19hcnkgb3IgI3RvX3NcIiwgJ3RvX3N0cicpfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlcCA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCN7OjpPcGFsLmNvZXJjZV90byEoc2VwLCA6OlN0cmluZywgOnRvX3N0cikudG9fc30pO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGtlZXBfaWYoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6a2VlcF9pZikgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgZmlsdGVySWYoc2VsZiwgJHRydXRoeSwgYmxvY2spXG4gICAgfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGxhc3QoY291bnQgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoY291bnQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2VsZi5sZW5ndGggPT09IDAgPyBuaWwgOiBzZWxmW3NlbGYubGVuZ3RoIC0gMV07XG4gICAgICB9XG5cbiAgICAgIGNvdW50ID0gJGNvZXJjZV90byhjb3VudCwgI3s6OkludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChjb3VudCA8IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICduZWdhdGl2ZSBhcnJheSBzaXplJ307XG4gICAgICB9XG5cbiAgICAgIGlmIChjb3VudCA+IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgIGNvdW50ID0gc2VsZi5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLnNsaWNlKHNlbGYubGVuZ3RoIC0gY291bnQsIHNlbGYubGVuZ3RoKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsZW5ndGhcbiAgICBgc2VsZi5sZW5ndGhgXG4gIGVuZFxuXG4gIGRlZiBtYXgobiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGVhY2gubWF4KG4sICZibG9jaylcbiAgZW5kXG5cbiAgZGVmIG1pbigmYmxvY2spXG4gICAgZWFjaC5taW4oJmJsb2NrKVxuICBlbmRcblxuICAleHtcbiAgICAvLyBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIGZyb20sIGZyb20tMSwgLi4uLCBmcm9tIC0gaG93X21hbnkgKyAxLlxuICAgIGZ1bmN0aW9uIGRlc2NlbmRpbmdfZmFjdG9yaWFsKGZyb20sIGhvd19tYW55KSB7XG4gICAgICB2YXIgY291bnQgPSBob3dfbWFueSA+PSAwID8gMSA6IDA7XG4gICAgICB3aGlsZSAoaG93X21hbnkpIHtcbiAgICAgICAgY291bnQgKj0gZnJvbTtcbiAgICAgICAgZnJvbS0tO1xuICAgICAgICBob3dfbWFueS0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cbiAgfVxuXG4gIGRlZiBwZXJtdXRhdGlvbihudW0gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOnBlcm11dGF0aW9uLCBudW0pIGRvXG4gICAgICAgIGBkZXNjZW5kaW5nX2ZhY3RvcmlhbChzZWxmLmxlbmd0aCwgbnVtID09PSB1bmRlZmluZWQgPyBzZWxmLmxlbmd0aCA6IG51bSlgXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHBlcm11dGUsIG9mZmVuc2l2ZSwgb3V0cHV0O1xuXG4gICAgICBpZiAobnVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbnVtID0gc2VsZi5sZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbnVtID0gJGNvZXJjZV90byhudW0sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAobnVtIDwgMCB8fCBzZWxmLmxlbmd0aCA8IG51bSkge1xuICAgICAgICAvLyBubyBwZXJtdXRhdGlvbnMsIHlpZWxkIG5vdGhpbmdcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG51bSA9PT0gMCkge1xuICAgICAgICAvLyBleGFjdGx5IG9uZSBwZXJtdXRhdGlvbjogdGhlIHplcm8tbGVuZ3RoIGFycmF5XG4gICAgICAgICN7IHlpZWxkIFtdIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG51bSA9PT0gMSkge1xuICAgICAgICAvLyB0aGlzIGlzIGEgc3BlY2lhbCwgZWFzeSBjYXNlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICN7IHlpZWxkIGBbc2VsZltpXV1gIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIGdlbmVyYWwgY2FzZVxuICAgICAgICAjeyBwZXJtID0gQXJyYXkubmV3KG51bSkgfTtcbiAgICAgICAgI3sgdXNlZCA9IEFycmF5Lm5ldyhgc2VsZi5sZW5ndGhgLCBmYWxzZSkgfTtcblxuICAgICAgICBwZXJtdXRlID0gZnVuY3Rpb24obnVtLCBwZXJtLCBpbmRleCwgdXNlZCwgYmxrKSB7XG4gICAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgaWYoI3sgIXVzZWRbYGlgXSB9KSB7XG4gICAgICAgICAgICAgIHBlcm1baW5kZXhdID0gaTtcbiAgICAgICAgICAgICAgaWYoaW5kZXggPCBudW0gLSAxKSB7XG4gICAgICAgICAgICAgICAgdXNlZFtpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcGVybXV0ZS5jYWxsKHNlbGYsIG51bSwgcGVybSwgaW5kZXggKyAxLCB1c2VkLCBibGspO1xuICAgICAgICAgICAgICAgIHVzZWRbaV0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBlcm0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHNlbGZbcGVybVtqXV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkeWllbGQxKGJsaywgb3V0cHV0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgje2Jsb2NrX2dpdmVuP30pIHtcbiAgICAgICAgICAvLyBvZmZlbnNpdmUgKGJvdGggZGVmaW5pdGlvbnMpIGNvcHkuXG4gICAgICAgICAgb2ZmZW5zaXZlID0gc2VsZi5zbGljZSgpO1xuICAgICAgICAgIHBlcm11dGUuY2FsbChvZmZlbnNpdmUsIG51bSwgcGVybSwgMCwgdXNlZCwgYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHBlcm11dGUuY2FsbChzZWxmLCBudW0sIHBlcm0sIDAsIHVzZWQsIGJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHJlcGVhdGVkX3Blcm11dGF0aW9uKG4pXG4gICAgbnVtID0gOjpPcGFsLmNvZXJjZV90byEgbiwgOjpJbnRlZ2VyLCA6dG9faW50XG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZXBlYXRlZF9wZXJtdXRhdGlvbiwgbnVtKSB7IG51bSA+PSAwID8gc2l6ZSoqbnVtIDogMCB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgZnVuY3Rpb24gaXRlcmF0ZShtYXgsIGJ1ZmZlciwgc2VsZikge1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PSBtYXgpIHtcbiAgICAgICAgICB2YXIgY29weSA9IGJ1ZmZlci5zbGljZSgpO1xuICAgICAgICAgICN7eWllbGQgYGNvcHlgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBidWZmZXIucHVzaChzZWxmW2ldKTtcbiAgICAgICAgICBpdGVyYXRlKG1heCwgYnVmZmVyLCBzZWxmKTtcbiAgICAgICAgICBidWZmZXIucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaXRlcmF0ZShudW0sIFtdLCBzZWxmLnNsaWNlKCkpO1xuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHBvcChjb3VudCA9IHVuZGVmaW5lZClcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcblxuICAgIGlmIGBjb3VudCA9PT0gdW5kZWZpbmVkYFxuICAgICAgcmV0dXJuIGlmIGBzZWxmLmxlbmd0aCA9PT0gMGBcbiAgICAgIHJldHVybiBgc2VsZi5wb3AoKWBcbiAgICBlbmRcblxuICAgIGNvdW50ID0gYCRjb2VyY2VfdG8oY291bnQsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgaWYgYGNvdW50IDwgMGBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFycmF5IHNpemUnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gW10gaWYgYHNlbGYubGVuZ3RoID09PSAwYFxuXG4gICAgaWYgYGNvdW50ID09PSAxYFxuICAgICAgYFtzZWxmLnBvcCgpXWBcbiAgICBlbHNpZiBgY291bnQgPiBzZWxmLmxlbmd0aGBcbiAgICAgIGBzZWxmLnNwbGljZSgwLCBzZWxmLmxlbmd0aClgXG4gICAgZWxzZVxuICAgICAgYHNlbGYuc3BsaWNlKHNlbGYubGVuZ3RoIC0gY291bnQsIHNlbGYubGVuZ3RoKWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHByb2R1Y3QoKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSAje2Jsb2NrX2dpdmVuP30gPyBudWxsIDogW10sXG4gICAgICAgICAgbiA9IGFyZ3MubGVuZ3RoICsgMSxcbiAgICAgICAgICBjb3VudGVycyA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgICBsZW5ndGhzICA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgICBhcnJheXMgICA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgICBpLCBtLCBzdWJhcnJheSwgbGVuLCByZXN1bHRsZW4gPSAxO1xuXG4gICAgICBhcnJheXNbMF0gPSBzZWxmO1xuICAgICAgZm9yIChpID0gMTsgaSA8IG47IGkrKykge1xuICAgICAgICBhcnJheXNbaV0gPSAkY29lcmNlX3RvKGFyZ3NbaSAtIDFdLCAjezo6QXJyYXl9LCAndG9fYXJ5Jyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgbGVuID0gYXJyYXlzW2ldLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQgfHwgc2VsZjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRsZW4gKj0gbGVuO1xuICAgICAgICBpZiAocmVzdWx0bGVuID4gMjE0NzQ4MzY0Nykge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCAndG9vIGJpZyB0byBwcm9kdWN0J31cbiAgICAgICAgfVxuICAgICAgICBsZW5ndGhzW2ldID0gbGVuO1xuICAgICAgICBjb3VudGVyc1tpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIG91dGVyX2xvb3A6IGZvciAoOzspIHtcbiAgICAgICAgc3ViYXJyYXkgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIHN1YmFycmF5LnB1c2goYXJyYXlzW2ldW2NvdW50ZXJzW2ldXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHN1YmFycmF5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAje3lpZWxkIGBzdWJhcnJheWB9XG4gICAgICAgIH1cbiAgICAgICAgbSA9IG4gLSAxO1xuICAgICAgICBjb3VudGVyc1ttXSsrO1xuICAgICAgICB3aGlsZSAoY291bnRlcnNbbV0gPT09IGxlbmd0aHNbbV0pIHtcbiAgICAgICAgICBjb3VudGVyc1ttXSA9IDA7XG4gICAgICAgICAgaWYgKC0tbSA8IDApIGJyZWFrIG91dGVyX2xvb3A7XG4gICAgICAgICAgY291bnRlcnNbbV0rKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0IHx8IHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcHVzaCgqb2JqZWN0cylcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIGZhc3RfcHVzaChzZWxmLCBvYmplY3RzKTtcbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByYXNzb2Mob2JqZWN0KVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoLCBpdGVtOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHNlbGZbaV07XG5cbiAgICAgICAgaWYgKGl0ZW0ubGVuZ3RoICYmIGl0ZW1bMV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgje2BpdGVtWzFdYCA9PSBvYmplY3R9KSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZWplY3QoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cmVqZWN0KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIHZhbHVlOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IGJsb2NrKHNlbGZbaV0pO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09IG5pbCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHNlbGZbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlamVjdCEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cmVqZWN0ISkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZilgXG5cbiAgICBvcmlnaW5hbCA9IGxlbmd0aFxuICAgIGRlbGV0ZV9pZigmYmxvY2spXG5cbiAgICB1bmxlc3MgbGVuZ3RoID09IG9yaWdpbmFsXG4gICAgICBzZWxmXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiByZXBsYWNlKG90aGVyKVxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxuXG4gICAgb3RoZXIgPSBgY29udmVydFRvQXJyYXkob3RoZXIpYFxuXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi5sZW5ndGggPiAwKSBzZWxmLnNwbGljZSgwLCBzZWxmLmxlbmd0aCk7XG4gICAgICBmYXN0X3B1c2goc2VsZiwgb3RoZXIpO1xuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHJldmVyc2VcbiAgICBgc2VsZi5zbGljZSgwKS5yZXZlcnNlKClgXG4gIGVuZFxuXG4gIGRlZiByZXZlcnNlIVxuICAgIGAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpYFxuXG4gICAgYHNlbGYucmV2ZXJzZSgpYFxuICBlbmRcblxuICBkZWYgcmV2ZXJzZV9lYWNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJldmVyc2VfZWFjaCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gc2VsZi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAkeWllbGQxKGJsb2NrLCBzZWxmW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmluZGV4KG9iamVjdCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIGksIHZhbHVlO1xuXG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwgJiYgYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAje3dhcm4oJ3dhcm5pbmc6IGdpdmVuIGJsb2NrIG5vdCB1c2VkJyl9XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKGkgPSBzZWxmLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGkgPj0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoI3tgc2VsZltpXWAgPT0gYG9iamVjdGB9KSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgZm9yIChpID0gc2VsZi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChpID49IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YWx1ZSA9IGJsb2NrKHNlbGZbaV0pO1xuXG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBmYWxzZSAmJiB2YWx1ZSAhPT0gbmlsKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAje2VudW1fZm9yIDpyaW5kZXh9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJvdGF0ZShuID0gMSlcbiAgICAleHtcbiAgICAgIHZhciBhcnksIGlkeCwgZmlyc3RQYXJ0LCBsYXN0UGFydDtcblxuICAgICAgbiA9ICRjb2VyY2VfdG8obiwgI3s6OkludGVnZXJ9LCAndG9faW50JylcblxuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnNsaWNlKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBhcnkgPSBzZWxmLnNsaWNlKCk7XG4gICAgICBpZHggPSBuICUgYXJ5Lmxlbmd0aDtcblxuICAgICAgZmlyc3RQYXJ0ID0gYXJ5LnNsaWNlKGlkeCk7XG4gICAgICBsYXN0UGFydCA9IGFyeS5zbGljZSgwLCBpZHgpO1xuICAgICAgcmV0dXJuIGZpcnN0UGFydC5jb25jYXQobGFzdFBhcnQpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJvdGF0ZSEoY250ID0gMSlcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gMCB8fCBzZWxmLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICAgIGNudCA9ICRjb2VyY2VfdG8oY250LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICB9XG4gICAgYXJ5ID0gcm90YXRlKGNudClcbiAgICByZXBsYWNlIGFyeVxuICBlbmRcblxuICBjbGFzcyBzZWxmOjpTYW1wbGVSYW5kb21cbiAgICBkZWYgaW5pdGlhbGl6ZShybmcpXG4gICAgICBAcm5nID0gcm5nXG4gICAgZW5kXG5cbiAgICBkZWYgcmFuZChzaXplKVxuICAgICAgcmFuZG9tID0gYCRjb2VyY2VfdG8oI3tAcm5nLnJhbmQoc2l6ZSl9LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ3JhbmRvbSB2YWx1ZSBtdXN0IGJlID49IDAnIGlmIGByYW5kb20gPCAwYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCAncmFuZG9tIHZhbHVlIG11c3QgYmUgbGVzcyB0aGFuIEFycmF5IHNpemUnIHVubGVzcyBgcmFuZG9tIDwgc2l6ZWBcblxuICAgICAgcmFuZG9tXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzYW1wbGUoY291bnQgPSB1bmRlZmluZWQsIG9wdGlvbnMgPSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGF0IDo6S2VybmVsLnJhbmQoYHNlbGYubGVuZ3RoYCkgaWYgYGNvdW50ID09PSB1bmRlZmluZWRgXG5cbiAgICBpZiBgb3B0aW9ucyA9PT0gdW5kZWZpbmVkYFxuICAgICAgaWYgKG8gPSA6Ok9wYWwuY29lcmNlX3RvPyBjb3VudCwgOjpIYXNoLCA6dG9faGFzaClcbiAgICAgICAgb3B0aW9ucyA9IG9cbiAgICAgICAgY291bnQgPSBuaWxcbiAgICAgIGVsc2VcbiAgICAgICAgb3B0aW9ucyA9IG5pbFxuICAgICAgICBjb3VudCA9IGAkY29lcmNlX3RvKGNvdW50LCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGNvdW50ID0gYCRjb2VyY2VfdG8oY291bnQsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgb3B0aW9ucyA9IGAkY29lcmNlX3RvKG9wdGlvbnMsICN7OjpIYXNofSwgJ3RvX2hhc2gnKWBcbiAgICBlbmRcblxuICAgIGlmIGNvdW50ICYmIGBjb3VudCA8IDBgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdjb3VudCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJ1xuICAgIGVuZFxuXG4gICAgcm5nID0gb3B0aW9uc1s6cmFuZG9tXSBpZiBvcHRpb25zXG4gICAgcm5nID0gaWYgcm5nICYmIHJuZy5yZXNwb25kX3RvPyg6cmFuZClcbiAgICAgICAgICAgIFNhbXBsZVJhbmRvbS5uZXcgcm5nXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgOjpLZXJuZWxcbiAgICAgICAgICBlbmRcblxuICAgIHJldHVybiBgc2VsZlsje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfV1gIHVubGVzcyBjb3VudFxuXG4gICAgJXh7XG5cbiAgICAgIHZhciBhYmFuZG9uLCBzcGluLCByZXN1bHQsIGksIGosIGssIHRhcmdldEluZGV4LCBvbGRWYWx1ZTtcblxuICAgICAgaWYgKGNvdW50ID4gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgY291bnQgPSBzZWxmLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChjb3VudCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIFtzZWxmWyN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9XV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBpID0gI3tybmcucmFuZChgc2VsZi5sZW5ndGhgKX07XG4gICAgICAgICAgaiA9ICN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoIC0gMWApfTtcbiAgICAgICAgICBpZiAoaSA8PSBqKSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbc2VsZltpXSwgc2VsZltqXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKHNlbGYubGVuZ3RoIC8gY291bnQgPiAzKSB7XG4gICAgICAgICAgICBhYmFuZG9uID0gZmFsc2U7XG4gICAgICAgICAgICBzcGluID0gMDtcblxuICAgICAgICAgICAgcmVzdWx0ID0gI3sgQXJyYXkubmV3KGNvdW50KSB9O1xuICAgICAgICAgICAgaSA9IDE7XG5cbiAgICAgICAgICAgIHJlc3VsdFswXSA9ICN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9O1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBjb3VudCkge1xuICAgICAgICAgICAgICBrID0gI3tybmcucmFuZChgc2VsZi5sZW5ndGhgKX07XG4gICAgICAgICAgICAgIGogPSAwO1xuXG4gICAgICAgICAgICAgIHdoaWxlIChqIDwgaSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChrID09PSByZXN1bHRbal0pIHtcbiAgICAgICAgICAgICAgICAgIHNwaW4rKztcbiAgICAgICAgICAgICAgICAgIGlmIChzcGluID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFiYW5kb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGsgPSAje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFiYW5kb24pIHsgYnJlYWs7IH1cblxuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChhYmFuZG9uKSB7IGJyZWFrOyB9XG5cbiAgICAgICAgICAgICAgcmVzdWx0W2ldID0gaztcblxuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghYWJhbmRvbikge1xuICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgd2hpbGUgKGkgPCBjb3VudCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHNlbGZbcmVzdWx0W2ldXTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuc2xpY2UoKTtcblxuICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY291bnQ7IGMrKykge1xuICAgICAgICAgICAgdGFyZ2V0SW5kZXggPSAje3JuZy5yYW5kKGBzZWxmLmxlbmd0aCAtIGNgKX0gKyBjO1xuICAgICAgICAgICAgb2xkVmFsdWUgPSByZXN1bHRbY107XG4gICAgICAgICAgICByZXN1bHRbY10gPSByZXN1bHRbdGFyZ2V0SW5kZXhdO1xuICAgICAgICAgICAgcmVzdWx0W3RhcmdldEluZGV4XSA9IG9sZFZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb3VudCA9PT0gc2VsZi5sZW5ndGggPyByZXN1bHQgOiAje2ByZXN1bHRgWzAsIGNvdW50XX07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnNlbGVjdCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBpdGVtLCB2YWx1ZTsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHNlbGZbaV07XG5cbiAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBpdGVtKTtcblxuICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGVjdCEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6c2VsZWN0ISkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpXG5cbiAgICAgIHZhciBvcmlnaW5hbCA9IHNlbGYubGVuZ3RoO1xuICAgICAgI3sga2VlcF9pZigmYmxvY2spIH07XG4gICAgICByZXR1cm4gc2VsZi5sZW5ndGggPT09IG9yaWdpbmFsID8gbmlsIDogc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzaGlmdChjb3VudCA9IHVuZGVmaW5lZClcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcblxuICAgIGlmIGBjb3VudCA9PT0gdW5kZWZpbmVkYFxuICAgICAgcmV0dXJuIGlmIGBzZWxmLmxlbmd0aCA9PT0gMGBcbiAgICAgIHJldHVybiBgc2hpZnROb0FyZyhzZWxmKWBcbiAgICBlbmRcblxuICAgIGNvdW50ID0gYCRjb2VyY2VfdG8oY291bnQsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgaWYgYGNvdW50IDwgMGBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFycmF5IHNpemUnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gW10gaWYgYHNlbGYubGVuZ3RoID09PSAwYFxuXG4gICAgYHNlbGYuc3BsaWNlKDAsIGNvdW50KWBcbiAgZW5kXG5cbiAgZGVmIHNodWZmbGUocm5nID0gdW5kZWZpbmVkKVxuICAgIGR1cC50b19hLnNodWZmbGUhKHJuZylcbiAgZW5kXG5cbiAgZGVmIHNodWZmbGUhKHJuZyA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIHZhciByYW5kZ2VuLCBpID0gc2VsZi5sZW5ndGgsIGosIHRtcDtcblxuICAgICAgaWYgKHJuZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJuZyA9ICN7OjpPcGFsLmNvZXJjZV90bz8ocm5nLCA6Okhhc2gsIDp0b19oYXNoKX07XG5cbiAgICAgICAgaWYgKHJuZyAhPT0gbmlsKSB7XG4gICAgICAgICAgcm5nID0gI3tybmdbOnJhbmRvbV19O1xuXG4gICAgICAgICAgaWYgKHJuZyAhPT0gbmlsICYmICN7cm5nLnJlc3BvbmRfdG8/KDpyYW5kKX0pIHtcbiAgICAgICAgICAgIHJhbmRnZW4gPSBybmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChpKSB7XG4gICAgICAgIGlmIChyYW5kZ2VuKSB7XG4gICAgICAgICAgaiA9IHJhbmRnZW4uJHJhbmQoaSkuJHRvX2ludCgpO1xuXG4gICAgICAgICAgaWYgKGogPCAwKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgXCJyYW5kb20gbnVtYmVyIHRvbyBzbWFsbCAje2BqYH1cIn1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaiA+PSBpKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgXCJyYW5kb20gbnVtYmVyIHRvbyBiaWcgI3tgamB9XCJ9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGogPSAje3JhbmQoYGlgKX07XG4gICAgICAgIH1cblxuICAgICAgICB0bXAgPSBzZWxmWy0taV07XG4gICAgICAgIHNlbGZbaV0gPSBzZWxmW2pdO1xuICAgICAgICBzZWxmW2pdID0gdG1wO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzbGljZSEoaW5kZXgsIGxlbmd0aCA9IHVuZGVmaW5lZClcbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcblxuICAgIHJlc3VsdCA9IG5pbFxuXG4gICAgaWYgYGxlbmd0aCA9PT0gdW5kZWZpbmVkYFxuICAgICAgaWYgOjpSYW5nZSA9PT0gaW5kZXhcbiAgICAgICAgcmFuZ2UgPSBpbmRleFxuICAgICAgICByZXN1bHQgPSBzZWxmW3JhbmdlXVxuXG4gICAgICAgIHJhbmdlX3N0YXJ0ID0gYHJhbmdlLmJlZ2luID09PSBuaWwgPyAwIDogJGNvZXJjZV90byhyYW5nZS5iZWdpbiwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG4gICAgICAgIHJhbmdlX2VuZCA9IGByYW5nZS5lbmQgPT09IG5pbCA/IC0xIDogJGNvZXJjZV90byhyYW5nZS5lbmQsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgICAgICV4e1xuICAgICAgICAgIGlmIChyYW5nZV9zdGFydCA8IDApIHtcbiAgICAgICAgICAgIHJhbmdlX3N0YXJ0ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyYW5nZV9lbmQgPCAwKSB7XG4gICAgICAgICAgICByYW5nZV9lbmQgKz0gc2VsZi5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIGlmIChyYW5nZV9lbmQgPj0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJhbmdlX2VuZCA9IHNlbGYubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5leGNsKSB7XG4gICAgICAgICAgICAgIHJhbmdlX2VuZCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByYW5nZV9sZW5ndGggPSByYW5nZV9lbmQgLSByYW5nZV9zdGFydDtcbiAgICAgICAgICBpZiAocmFuZ2UuZXhjbCAmJiByYW5nZS5lbmQgIT09IG5pbCkge1xuICAgICAgICAgICAgcmFuZ2VfZW5kIC09IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlX2xlbmd0aCArPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyYW5nZV9zdGFydCA8IHNlbGYubGVuZ3RoICYmIHJhbmdlX3N0YXJ0ID49IDAgJiYgcmFuZ2VfZW5kIDwgc2VsZi5sZW5ndGggJiYgcmFuZ2VfZW5kID49IDAgJiYgcmFuZ2VfbGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc2VsZi5zcGxpY2UocmFuZ2Vfc3RhcnQsIHJhbmdlX2xlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIHN0YXJ0ID0gYCRjb2VyY2VfdG8oaW5kZXgsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgICAleHtcbiAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICBzdGFydCArPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdCA9IHNlbGZbc3RhcnRdO1xuXG4gICAgICAgICAgaWYgKHN0YXJ0ID09PSAwKSB7XG4gICAgICAgICAgICBzZWxmLnNoaWZ0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuc3BsaWNlKHN0YXJ0LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIHN0YXJ0ID0gYCRjb2VyY2VfdG8oaW5kZXgsICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgbGVuZ3RoID0gYCRjb2VyY2VfdG8obGVuZ3RoLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgICAgJXh7XG4gICAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbmQgPSBzdGFydCArIGxlbmd0aDtcblxuICAgICAgICByZXN1bHQgPSAje3NlbGZbc3RhcnQsIGxlbmd0aF19O1xuXG4gICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICBzdGFydCArPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydCArIGxlbmd0aCA+IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggLSBzdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydCA8IHNlbGYubGVuZ3RoICYmIHN0YXJ0ID49IDApIHtcbiAgICAgICAgICBzZWxmLnNwbGljZShzdGFydCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgc29ydCgmYmxvY2spXG4gICAgcmV0dXJuIHNlbGYgdW5sZXNzIGBzZWxmLmxlbmd0aCA+IDFgXG5cbiAgICAleHtcbiAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgIGJsb2NrID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgIHJldHVybiAje2BhYCA8PT4gYGJgfTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIHJldCA9IGJsb2NrKHgsIHkpO1xuXG4gICAgICAgIGlmIChyZXQgPT09IG5pbCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tgeGAuaW5zcGVjdH0gd2l0aCAje2B5YC5pbnNwZWN0fSBmYWlsZWRcIn07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gI3tgcmV0YCA+IDB9ID8gMSA6ICgje2ByZXRgIDwgMH0gPyAtMSA6IDApO1xuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc29ydCEoJmJsb2NrKVxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKVxuXG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBpZiAoI3tibG9ja19naXZlbj99KSB7XG4gICAgICAgIHJlc3VsdCA9ICN7YHNlbGYuc2xpY2UoKWAuc29ydCgmYmxvY2spfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSAje2BzZWxmLnNsaWNlKClgLnNvcnR9O1xuICAgICAgfVxuXG4gICAgICBzZWxmLmxlbmd0aCA9IDA7XG4gICAgICBmb3IodmFyIGkgPSAwLCBsZW5ndGggPSByZXN1bHQubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZi5wdXNoKHJlc3VsdFtpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNvcnRfYnkhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnNvcnRfYnkhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKWBcblxuICAgIHJlcGxhY2Ugc29ydF9ieSgmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiB0YWtlKGNvdW50KVxuICAgICV4e1xuICAgICAgaWYgKGNvdW50IDwgMCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvcn07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLnNsaWNlKDAsIGNvdW50KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0YWtlX3doaWxlKCZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGl0ZW0sIHZhbHVlOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcblxuICAgICAgICB2YWx1ZSA9IGJsb2NrKGl0ZW0pO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09IG5pbCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19hXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi4kJGNsYXNzID09PSBPcGFsLkFycmF5KSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBPcGFsLkFycmF5LiRuZXcoc2VsZik7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9fYXJ5XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdG9faCgmYmxvY2spXG4gICAgYXJyYXkgPSBzZWxmXG4gICAgYXJyYXkgPSBhcnJheS5tYXAoJmJsb2NrKSBpZiBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIGksIGxlbiA9IGFycmF5Lmxlbmd0aCwgYXJ5LCBrZXksIHZhbCwgaGFzaCA9ICN7e319O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYXJ5ID0gI3s6Ok9wYWwuY29lcmNlX3RvPyhgYXJyYXlbaV1gLCA6OkFycmF5LCA6dG9fYXJ5KX07XG4gICAgICAgIGlmICghYXJ5LiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIndyb25nIGVsZW1lbnQgdHlwZSAje2BhcnJheVtpXWAuY2xhc3N9IGF0ICN7YGlgfSAoZXhwZWN0ZWQgYXJyYXkpXCJ9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyeS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJlbGVtZW50IGhhcyB3cm9uZyBhcnJheSBsZW5ndGggYXQgI3tgaWB9IChleHBlY3RlZCAyLCB3YXMgI3tgYXJ5YC5sZW5ndGh9KVwifVxuICAgICAgICB9XG4gICAgICAgIGtleSA9IGFyeVswXTtcbiAgICAgICAgdmFsID0gYXJ5WzFdO1xuICAgICAgICAkaGFzaF9wdXQoaGFzaCwga2V5LCB2YWwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0cmFuc3Bvc2VcbiAgICByZXR1cm4gW10gaWYgZW1wdHk/XG5cbiAgICByZXN1bHQgPSBbXVxuICAgIG1heCAgICA9IG5pbFxuXG4gICAgZWFjaCBkbyB8cm93fFxuICAgICAgYHJvdyA9IGNvbnZlcnRUb0FycmF5KHJvdylgXG5cbiAgICAgIG1heCB8fD0gYHJvdy5sZW5ndGhgXG5cbiAgICAgIGlmIGByb3cubGVuZ3RoYCAhPSBtYXhcbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpJbmRleEVycm9yLCBcImVsZW1lbnQgc2l6ZSBkaWZmZXJzICgje2Byb3cubGVuZ3RoYH0gc2hvdWxkIGJlICN7bWF4fSlcIlxuICAgICAgZW5kXG5cbiAgICAgIGByb3cubGVuZ3RoYC50aW1lcyBkbyB8aXxcbiAgICAgICAgZW50cnkgPSAocmVzdWx0W2ldIHx8PSBbXSlcbiAgICAgICAgZW50cnkgPDwgcm93LmF0KGkpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgdW5pb24oKmFycmF5cylcbiAgICBhcnJheXMucmVkdWNlKHVuaXEpIHsgfGEsIGJ8IGEgfCBiIH1cbiAgZW5kXG5cbiAgZGVmIHVuaXEoJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSAje3t9fSwgaSwgbGVuZ3RoLCBpdGVtLCBrZXk7XG5cbiAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpdGVtID0gc2VsZltpXTtcbiAgICAgICAgICBpZiAoJGhhc2hfZ2V0KGhhc2gsIGl0ZW0pID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICRoYXNoX3B1dChoYXNoLCBpdGVtLCBpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuICAgICAgICAgIGtleSA9ICR5aWVsZDEoYmxvY2ssIGl0ZW0pO1xuICAgICAgICAgIGlmICgkaGFzaF9nZXQoaGFzaCwga2V5KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAkaGFzaF9wdXQoaGFzaCwga2V5LCBpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7YGhhc2hgLnZhbHVlc307XG4gICAgfVxuICBlbmRcblxuICBkZWYgdW5pcSEoJmJsb2NrKVxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgdmFyIGhhc2ggPSAje3t9fSwgaSwgaXRlbSwga2V5LCBkZWxldGVfaW5kZXhlcyA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcbiAgICAgICAga2V5ID0gKGJsb2NrID09PSBuaWwgPyBpdGVtIDogJHlpZWxkMShibG9jaywgaXRlbSkpO1xuXG4gICAgICAgIGlmICgkaGFzaF9nZXQoaGFzaCwga2V5KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgJGhhc2hfcHV0KGhhc2gsIGtleSwgaXRlbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlX2luZGV4ZXMucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSBkZWxldGVfaW5kZXhlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBzZWxmLnNwbGljZShkZWxldGVfaW5kZXhlc1tpXSwgMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZWxldGVfaW5kZXhlcy5sZW5ndGggPT09IDAgPyBuaWwgOiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHVuc2hpZnQoKm9iamVjdHMpXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICB2YXIgc2VsZkxlbmd0aCA9IHNlbGYubGVuZ3RoXG4gICAgICB2YXIgb2JqZWN0c0xlbmd0aCA9IG9iamVjdHMubGVuZ3RoXG4gICAgICBpZiAob2JqZWN0c0xlbmd0aCA9PSAwKSByZXR1cm4gc2VsZjtcbiAgICAgIHZhciBpbmRleCA9IHNlbGZMZW5ndGggLSBvYmplY3RzTGVuZ3RoXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdHNMZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLnB1c2goc2VsZltpbmRleCArIGldKVxuICAgICAgfVxuICAgICAgdmFyIGxlbiA9IHNlbGZMZW5ndGggLSAxXG4gICAgICB3aGlsZSAobGVuIC0gb2JqZWN0c0xlbmd0aCA+PSAwKSB7XG4gICAgICAgIHNlbGZbbGVuXSA9IHNlbGZbbGVuIC0gb2JqZWN0c0xlbmd0aF1cbiAgICAgICAgbGVuLS1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb2JqZWN0c0xlbmd0aDsgaisrKSB7XG4gICAgICAgIHNlbGZbal0gPSBvYmplY3RzW2pdXG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB2YWx1ZXNfYXQoKmFyZ3MpXG4gICAgb3V0ID0gW11cblxuICAgIGFyZ3MuZWFjaCBkbyB8ZWxlbXxcbiAgICAgIGlmIGVsZW0uaXNfYT8gOjpSYW5nZVxuICAgICAgICBmaW5pc2ggPSBgI3tlbGVtLmVuZH0gPT09IG5pbCA/IC0xIDogJGNvZXJjZV90bygje2VsZW0uZW5kfSwgI3s6OkludGVnZXJ9LCAndG9faW50JylgXG4gICAgICAgIHN0YXJ0ID0gYCN7ZWxlbS5iZWdpbn0gPT09IG5pbCA/IDAgOiAkY29lcmNlX3RvKCN7ZWxlbS5iZWdpbn0sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgICAgICV4e1xuICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQgKyBzZWxmLmxlbmd0aDtcbiAgICAgICAgICAgICN7bmV4dH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJXh7XG4gICAgICAgICAgaWYgKGZpbmlzaCA8IDApIHtcbiAgICAgICAgICAgIGZpbmlzaCA9IGZpbmlzaCArIHNlbGYubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoI3tlbGVtLmV4Y2x1ZGVfZW5kP30gJiYgI3tlbGVtLmVuZH0gIT09IG5pbCkge1xuICAgICAgICAgICAgZmluaXNoLS07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmaW5pc2ggPCBzdGFydCkge1xuICAgICAgICAgICAgI3tuZXh0fTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydC51cHRvKGZpbmlzaCkgeyB8aXwgb3V0IDw8IGF0KGkpIH1cbiAgICAgIGVsc2VcbiAgICAgICAgaSA9IGAkY29lcmNlX3RvKGVsZW0sICN7OjpJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgICBvdXQgPDwgYXQoaSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgb3V0XG4gIGVuZFxuXG4gIGRlZiB6aXAoKm90aGVycywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdLCBzaXplID0gc2VsZi5sZW5ndGgsIHBhcnQsIG8sIGksIGosIGpqO1xuXG4gICAgICBmb3IgKGogPSAwLCBqaiA9IG90aGVycy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgIG8gPSBvdGhlcnNbal07XG4gICAgICAgIGlmIChvLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoby4kJGlzX3JhbmdlIHx8IG8uJCRpc19lbnVtZXJhdG9yKSB7XG4gICAgICAgICAgb3RoZXJzW2pdID0gby4kdGFrZShzaXplKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBvdGhlcnNbal0gPSAjeyhcbiAgICAgICAgICA6Ok9wYWwuY29lcmNlX3RvPyhgb2AsIDo6QXJyYXksIDp0b19hcnkpIHx8XG4gICAgICAgICAgOjpPcGFsLmNvZXJjZV90byEoYG9gLCA6OkVudW1lcmF0b3IsIDp0b19lbnVtLCA6ZWFjaClcbiAgICAgICAgKS50b19hfTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICBwYXJ0ID0gW3NlbGZbaV1dO1xuXG4gICAgICAgIGZvciAoaiA9IDAsIGpqID0gb3RoZXJzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICBvID0gb3RoZXJzW2pdW2ldO1xuXG4gICAgICAgICAgaWYgKG8gPT0gbnVsbCkge1xuICAgICAgICAgICAgbyA9IG5pbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJ0W2ogKyAxXSA9IG87XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHRbaV0gPSBwYXJ0O1xuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgT3BhbC55aWVsZDEoYmxvY2ssIHJlc3VsdFtpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYuaW5oZXJpdGVkKGtsYXNzKVxuICAgICV4e1xuICAgICAga2xhc3MuJCRwcm90b3R5cGUuJHRvX2EgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2xpY2UoMCwgdGhpcy5sZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX3ZhcmlhYmxlc1xuICAgIHN1cGVyLnJlamVjdCB7IHxpdmFyfCBgL15AXFxkKyQvLnRlc3QoI3tpdmFyfSlgIHx8IGl2YXIgPT0gJ0BsZW5ndGgnIH1cbiAgZW5kXG5cbiAgZGVmIHBhY2soKmFyZ3MpXG4gICAgOjpLZXJuZWwucmFpc2UgXCJUbyB1c2UgQXJyYXkjcGFjaywgeW91IG11c3QgZmlyc3QgcmVxdWlyZSAnY29yZWxpYi9hcnJheS9wYWNrJy5cIlxuICBlbmRcblxuICBhbGlhcyBhcHBlbmQgcHVzaFxuICBhbGlhcyBmaWx0ZXIgc2VsZWN0XG4gIGFsaWFzIGZpbHRlciEgc2VsZWN0IVxuICBhbGlhcyBtYXAgY29sbGVjdFxuICBhbGlhcyBtYXAhIGNvbGxlY3QhXG4gIGFsaWFzIHByZXBlbmQgdW5zaGlmdFxuICBhbGlhcyBzaXplIGxlbmd0aFxuICBhbGlhcyBzbGljZSBbXVxuICBhbGlhcyB0b19zIGluc3BlY3RcblxuICA6Ok9wYWwucHJpc3RpbmUgc2luZ2xldG9uX2NsYXNzLCA6YWxsb2NhdGVcbiAgOjpPcGFsLnByaXN0aW5lIHNlbGYsIDpjb3B5X2luc3RhbmNlX3ZhcmlhYmxlcywgOmluaXRpYWxpemVfZHVwXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6QXJyYXk+IiwiaW5jbHVkZSIsIkVudW1lcmFibGUiLCJ0b19hIiwiQXJyYXkiLCJbXSIsImluaXRpYWxpemUiLCJzaXplIiwib2JqIiwiS2VybmVsIiwid2FybiIsIkludGVnZXI6Ok1BWCIsIkludGVnZXIiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJyZXBsYWNlIiwicmVzcG9uZF90bz8iLCJ0b19hcnkiLCJ0cnlfY29udmVydCIsIk9wYWwiLCJjb2VyY2VfdG8/IiwiJiIsIm90aGVyIiwifCIsIioiLCJqb2luIiwidG9fc3RyIiwiKyIsIi0iLCI8PCIsIm9iamVjdCIsIjw9PiIsIj09Iiwib2JqZWN0X2lkIiwiaW5kZXgiLCJsZW5ndGgiLCJbXT0iLCJ2YWx1ZSIsImV4dHJhIiwiZGF0YSIsIlJhbmdlRXJyb3IiLCJpbnNwZWN0IiwiMSIsIkluZGV4RXJyb3IiLCJhbnk/IiwicGF0dGVybiIsImFzc29jIiwiYXQiLCJic2VhcmNoX2luZGV4IiwiYmxvY2tfZ2l2ZW4/IiwiZW51bV9mb3IiLCJUeXBlRXJyb3IiLCJjbGFzcyIsImJzZWFyY2giLCJibG9jayIsInRvX3Byb2MiLCJjeWNsZSIsIm4iLCJibG9jayBpbiBjeWNsZSIsImJsb2NrICgyIGxldmVscykgaW4gY3ljbGUiLCJuaWw/IiwiRmxvYXQ6OklORklOSVRZIiwiRmxvYXQiLCJjb2VyY2VfdG8hIiwiPiIsIjAiLCJlbnVtZXJhdG9yX3NpemUiLCJlbXB0eT8iLCJjbGVhciIsImNvdW50IiwiaW5pdGlhbGl6ZV9jb3B5IiwiY29sbGVjdCIsImJsb2NrIGluIGNvbGxlY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIGNvbGxlY3QiLCJjb2xsZWN0ISIsImJsb2NrIGluIGNvbGxlY3QhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb2xsZWN0ISIsImNvbWJpbmF0aW9uIiwibnVtIiwiYmxvY2sgaW4gY29tYmluYXRpb24iLCJibG9jayAoMiBsZXZlbHMpIGluIGNvbWJpbmF0aW9uIiwicmVwZWF0ZWRfY29tYmluYXRpb24iLCJibG9jayBpbiByZXBlYXRlZF9jb21iaW5hdGlvbiIsImJsb2NrICgyIGxldmVscykgaW4gcmVwZWF0ZWRfY29tYmluYXRpb24iLCJjb21wYWN0IiwiY29tcGFjdCEiLCJjb25jYXQiLCJvdGhlcnMiLCJtYXAiLCJibG9jayBpbiBjb25jYXQiLCJibG9jayAoMiBsZXZlbHMpIGluIGNvbmNhdCIsImVxdWFsPyIsImR1cCIsImVhY2giLCJkZWxldGUiLCJkZWxldGVfYXQiLCJkZWxldGVfaWYiLCJibG9jayBpbiBkZWxldGVfaWYiLCJibG9jayAoMiBsZXZlbHMpIGluIGRlbGV0ZV9pZiIsImRpZmZlcmVuY2UiLCJyZWR1Y2UiLCJhcnJheXMiLCJibG9jayBpbiBkaWZmZXJlbmNlIiwiYSIsImIiLCJibG9jayAoMiBsZXZlbHMpIGluIGRpZmZlcmVuY2UiLCJkaWciLCJpZHgiLCJpdGVtIiwiaWR4cyIsImRyb3AiLCJudW1iZXIiLCJibG9jayBpbiBlYWNoIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoIiwiZWFjaF9pbmRleCIsImJsb2NrIGluIGVhY2hfaW5kZXgiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfaW5kZXgiLCJlcWw/IiwiZmV0Y2giLCJkZWZhdWx0cyIsImZpbGwiLCJhcmdzIiwib25lIiwidHdvIiwiUmFuZ2UiLCJsZWZ0IiwicmlnaHQiLCJleGNsdWRlX2VuZD8iLCJmaXJzdCIsImZsYXR0ZW4iLCJsZXZlbCIsImZsYXR0ZW4hIiwiZnJlZXplIiwiZnJvemVuPyIsImhhc2giLCJpbmNsdWRlPyIsIm1lbWJlciIsImluc2VydCIsIl9faWRfXyIsImludGVyc2VjdGlvbiIsInNvcnRfYnkiLCJsYXJnZXN0IiwiaW50ZXJzZWN0aW9uX29mX2FyZ3MiLCJpbnRlcnNlY3Q/Iiwic2VwIiwiJCwiLCJ0b19zIiwiTm9NZXRob2RFcnJvciIsIm5ldyIsIlN0cmluZyIsImtlZXBfaWYiLCJibG9jayBpbiBrZWVwX2lmIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBrZWVwX2lmIiwibGFzdCIsIm1heCIsIm1pbiIsInBlcm11dGF0aW9uIiwiYmxvY2sgaW4gcGVybXV0YXRpb24iLCJibG9jayAoMiBsZXZlbHMpIGluIHBlcm11dGF0aW9uIiwicGVybSIsInVzZWQiLCIhIiwicmVwZWF0ZWRfcGVybXV0YXRpb24iLCJibG9jayBpbiByZXBlYXRlZF9wZXJtdXRhdGlvbiIsImJsb2NrICgyIGxldmVscykgaW4gcmVwZWF0ZWRfcGVybXV0YXRpb24iLCI+PSIsIioqIiwicG9wIiwicHJvZHVjdCIsInB1c2giLCJyYXNzb2MiLCJyZWplY3QiLCJibG9jayBpbiByZWplY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIHJlamVjdCIsInJlamVjdCEiLCJibG9jayBpbiByZWplY3QhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZWplY3QhIiwib3JpZ2luYWwiLCJyZXZlcnNlIiwicmV2ZXJzZSEiLCJyZXZlcnNlX2VhY2giLCJibG9jayBpbiByZXZlcnNlX2VhY2giLCJibG9jayAoMiBsZXZlbHMpIGluIHJldmVyc2VfZWFjaCIsInJpbmRleCIsInJvdGF0ZSIsInJvdGF0ZSEiLCJjbnQiLCJhcnkiLCI8Y2xhc3M6c2VsZjo6U2FtcGxlUmFuZG9tPiIsInJhbmQiLCJyYW5kb20iLCJAcm5nIiwic2FtcGxlIiwib3B0aW9ucyIsIm8iLCJIYXNoIiwicm5nIiwiU2FtcGxlUmFuZG9tIiwic2VsZWN0IiwiYmxvY2sgaW4gc2VsZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzZWxlY3QiLCJzZWxlY3QhIiwiYmxvY2sgaW4gc2VsZWN0ISIsImJsb2NrICgyIGxldmVscykgaW4gc2VsZWN0ISIsInNoaWZ0Iiwic2h1ZmZsZSIsInNodWZmbGUhIiwic2xpY2UhIiwicmVzdWx0IiwicmFuZ2UiLCJyYW5nZV9zdGFydCIsInJhbmdlX2VuZCIsInN0YXJ0Iiwic29ydCIsIjwiLCJzb3J0ISIsInNvcnRfYnkhIiwiYmxvY2sgaW4gc29ydF9ieSEiLCJibG9jayAoMiBsZXZlbHMpIGluIHNvcnRfYnkhIiwidGFrZSIsInRha2Vfd2hpbGUiLCJ0b19oIiwiYXJyYXkiLCJ0cmFuc3Bvc2UiLCJibG9jayBpbiB0cmFuc3Bvc2UiLCJyb3ciLCJibG9jayAoMiBsZXZlbHMpIGluIHRyYW5zcG9zZSIsIiRyZXRfb3JfMSIsInRpbWVzIiwiaSIsImJsb2NrICgzIGxldmVscykgaW4gdHJhbnNwb3NlIiwiZW50cnkiLCJ1bmlvbiIsInVuaXEiLCJibG9jayBpbiB1bmlvbiIsImJsb2NrICgyIGxldmVscykgaW4gdW5pb24iLCJ2YWx1ZXMiLCJ1bmlxISIsInVuc2hpZnQiLCJ2YWx1ZXNfYXQiLCJvdXQiLCJibG9jayBpbiB2YWx1ZXNfYXQiLCJlbGVtIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB2YWx1ZXNfYXQiLCJpc19hPyIsImZpbmlzaCIsImVuZCIsImJlZ2luIiwidXB0byIsImJsb2NrICgzIGxldmVscykgaW4gdmFsdWVzX2F0IiwiemlwIiwiRW51bWVyYXRvciIsImluaGVyaXRlZCIsImtsYXNzIiwiaW5zdGFuY2VfdmFyaWFibGVzIiwiYmxvY2sgaW4gaW5zdGFuY2VfdmFyaWFibGVzIiwiaXZhciIsImJsb2NrICgyIGxldmVscykgaW4gaW5zdGFuY2VfdmFyaWFibGVzIiwicGFjayIsInByaXN0aW5lIiwic2luZ2xldG9uX2NsYXNzIl0sIm1hcHBpbmdzIjoiQUFBQUEsZ0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBR0FDLElBQUFDLFNBQUFBLENBQVFGLG9CQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixpQkFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOzs7SUFDRUYsSUFBQUcsU0FBQUEsQ0FBUUMsaUJBQVJEO0lBR0NEOztBQUdIQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLDBDQUE0Q0EsQ0FBQ0EsR0FBREEsQ0FBS0csTUFBQUEsQ0FBQUEsQ0FBTUg7QUFDdkRBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBLGtDQUFvQ0ksWUFBUUo7QUFDNUNB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Q0EsYUFBTSxTQUFOLEVBQWMsU0FBZDtJQUNBLGFBQU0sS0FBTixFQUFVLFNBQVY7SUFDQSxhQUFNLE1BQU4sRUFBVyxVQUFYO0lBQ0EsYUFBTSxTQUFOLEVBQWMsU0FBZDtJQUNBLGFBQU0sTUFBTixFQUFXLFFBQVg7SUFDQSxhQUFNLE9BQU4sRUFBWSxJQUFaO0lBQ0EsYUFBTSxNQUFOLEVBQVcsU0FBWDtJQUVBL08sS0FBTWdQLFVBQUFBLENBQVVyUSxJQUFBc1EsaUJBQUFBLENBQUFBLENBQWhCLEVBQWlDLFVBQTNCRDtJQUNOblEsT0FBQW1CLEtBQU1nUCxVQUFBQSxDQUFVclEsSUFBaEIsRUFBc0IseUJBQXRCLEVBQWdELGdCQUExQ3FRO0VBaGdGUm5RLEdBQU0sSUFBTkEsRUFBaUJILEtBQWpCRztBQU5BSDsifX0seyJvZmZzZXQiOnsibGluZSI6MTU5MTksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2hhc2gucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiB5aWVsZDEsIGhhc2hfY2xvbmUsIGhhc2hfZGVsZXRlLCBoYXNoX2VhY2gsIGhhc2hfZ2V0LCBoYXNoX3B1dCwgZGVueV9mcm96ZW5fYWNjZXNzLCBmcmVlemUsIG9wYWwzMl9pbml0LCBvcGFsMzJfYWRkXG4jIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcblxucmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhYmxlJ1xuXG4jIC0tLVxuIyBJbnRlcm5hbCBwcm9wZXJ0aWVzOlxuI1xuIyAtICQka2V5cyAgICAgW01hcDxrZXktYXJyYXk+XSBvcHRpb25hbCBNYXAgb2Yga2V5IGFycmF5cywgdXNlZCB3aGVuIG9iamVjdHMgYXJlIHVzZWQgYXMga2V5c1xuIyAtICQkcHJvYyAgICAgICAgW1Byb2MsbnVsbCxuaWxdIHRoZSBkZWZhdWx0IHByb2MgdXNlZCBmb3IgbWlzc2luZyBrZXlzXG4jIC0ga2V5LWFycmF5ICAgW0pTOjpNYXBdIGFuIGVsZW1lbnQgb2YgYSBhcnJheSB0aGF0IGhvbGRzIG9iamVjdHMgdXNlZCBhcyBrZXlzLCBgeyBrZXlfaGFzaCA9PiBbb2JqZWN0cy4uLl0gfWBcbmNsYXNzIDo6SGFzaCA8IGBNYXBgXG4gIGluY2x1ZGUgOjpFbnVtZXJhYmxlXG5cbiAgIyBNYXJrIGFsbCBoYXNoIGluc3RhbmNlcyBhcyB2YWxpZCBoYXNoZXMgKHVzZWQgdG8gY2hlY2sga2V5d29yZCBhcmdzLCBldGMpXG4gIGBzZWxmLiQkcHJvdG90eXBlLiQkaXNfaGFzaCA9IHRydWVgXG5cbiAgZGVmIHNlbGYuW10oKmFyZ3YpXG4gICAgJXh7XG4gICAgICB2YXIgaGFzaCwgYXJnYyA9IGFyZ3YubGVuZ3RoLCBhcmcsIGk7XG5cbiAgICAgIGlmIChhcmdjID09PSAxKSB7XG4gICAgICAgIGhhc2ggPSAjezo6T3BhbC5jb2VyY2VfdG8/KGFyZ3ZbMF0sIDo6SGFzaCwgOnRvX2hhc2gpfTtcbiAgICAgICAgaWYgKGhhc2ggIT09IG5pbCkge1xuICAgICAgICAgIHJldHVybiAje2FsbG9jYXRlLm1lcmdlIShgaGFzaGApfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFyZ3YgPSAjezo6T3BhbC5jb2VyY2VfdG8/KGFyZ3ZbMF0sIDo6QXJyYXksIDp0b19hcnkpfTtcbiAgICAgICAgaWYgKGFyZ3YgPT09IG5pbCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnb2RkIG51bWJlciBvZiBhcmd1bWVudHMgZm9yIEhhc2gnfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFyZ2MgPSBhcmd2Lmxlbmd0aDtcbiAgICAgICAgaGFzaCA9ICN7YWxsb2NhdGV9O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdjOyBpKyspIHtcbiAgICAgICAgICBhcmcgPSBhcmd2W2ldO1xuICAgICAgICAgIGlmICghYXJnLiQkaXNfYXJyYXkpXG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIGVsZW1lbnQgI3tgYXJnYC5pbnNwZWN0fSBmb3IgSGFzaFwifTtcbiAgICAgICAgICBpZiAoYXJnLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaGFzaC4kc3RvcmUoYXJnWzBdLCBuaWwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYXJnLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgaGFzaC4kc3RvcmUoYXJnWzBdLCBhcmdbMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIG51bWJlciBvZiBlbGVtZW50cyAoI3tgYXJnLmxlbmd0aGB9IGZvciAje2BhcmdgLmluc3BlY3R9KSwgbXVzdCBiZSAxLi4yXCJ9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJnYyAlIDIgIT09IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdvZGQgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgSGFzaCd9XG4gICAgICB9XG5cbiAgICAgIGhhc2ggPSAje2FsbG9jYXRlfTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ2M7IGkgKz0gMikge1xuICAgICAgICBoYXNoLiRzdG9yZShhcmd2W2ldLCBhcmd2W2kgKyAxXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYuYWxsb2NhdGVcbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gbmV3IHNlbGYuJCRjb25zdHJ1Y3RvcigpO1xuXG4gICAgICBoYXNoLiQkbm9uZSA9IG5pbDtcbiAgICAgIGhhc2guJCRwcm9jID0gbmlsO1xuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLnRyeV9jb252ZXJ0KG9iailcbiAgICA6Ok9wYWwuY29lcmNlX3RvPyhvYmosIDo6SGFzaCwgOnRvX2hhc2gpXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKGRlZmF1bHRzID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICBpZiAoZGVmYXVsdHMgIT09IHVuZGVmaW5lZCAmJiBibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMSBmb3IgMCknfVxuICAgICAgfVxuICAgICAgc2VsZi4kJG5vbmUgPSAoZGVmYXVsdHMgPT09IHVuZGVmaW5lZCA/IG5pbCA6IGRlZmF1bHRzKTtcbiAgICAgIHNlbGYuJCRwcm9jID0gYmxvY2s7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW90aGVyLiQkaXNfaGFzaCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLnNpemUgIT09IG90aGVyLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJGhhc2hfZWFjaChzZWxmLCB0cnVlLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBvdGhlcl92YWx1ZSA9ICRoYXNoX2dldChvdGhlciwga2V5KTtcbiAgICAgICAgaWYgKG90aGVyX3ZhbHVlID09PSB1bmRlZmluZWQgfHwgIXZhbHVlWyckZXFsPyddKG90aGVyX3ZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBbdHJ1ZSwgZmFsc2VdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZmFsc2UsIHRydWVdO1xuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgPj0ob3RoZXIpXG4gICAgb3RoZXIgPSA6Ok9wYWwuY29lcmNlX3RvIShvdGhlciwgOjpIYXNoLCA6dG9faGFzaClcblxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuc2l6ZSA8IG90aGVyLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VsdCA9IHRydWVcblxuICAgIG90aGVyLmVhY2ggZG8gfG90aGVyX2tleSwgb3RoZXJfdmFsfFxuICAgICAgdmFsID0gZmV0Y2gob3RoZXJfa2V5LCBgbnVsbGApXG5cbiAgICAgICV4e1xuICAgICAgICBpZiAodmFsID09IG51bGwgfHwgdmFsICE9PSBvdGhlcl92YWwpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgPihvdGhlcilcbiAgICBvdGhlciA9IDo6T3BhbC5jb2VyY2VfdG8hKG90aGVyLCA6Okhhc2gsIDp0b19oYXNoKVxuXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi5zaXplIDw9IG90aGVyLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGYgPj0gb3RoZXJcbiAgZW5kXG5cbiAgZGVmIDwob3RoZXIpXG4gICAgb3RoZXIgPSA6Ok9wYWwuY29lcmNlX3RvIShvdGhlciwgOjpIYXNoLCA6dG9faGFzaClcbiAgICBvdGhlciA+IHNlbGZcbiAgZW5kXG5cbiAgZGVmIDw9KG90aGVyKVxuICAgIG90aGVyID0gOjpPcGFsLmNvZXJjZV90byEob3RoZXIsIDo6SGFzaCwgOnRvX2hhc2gpXG4gICAgb3RoZXIgPj0gc2VsZlxuICBlbmRcblxuICBkZWYgW10oa2V5KVxuICAgICV4e1xuICAgICAgdmFyIHZhbHVlID0gJGhhc2hfZ2V0KHNlbGYsIGtleSk7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJGRlZmF1bHQoa2V5KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBbXT0oa2V5LCB2YWx1ZSlcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgICRoYXNoX3B1dChzZWxmLCBrZXksIHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBhc3NvYyhvYmplY3QpXG4gICAgJXh7XG4gICAgICByZXR1cm4gJGhhc2hfZWFjaChzZWxmLCBuaWwsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCN7YGtleWAgPT0gb2JqZWN0fSkge1xuICAgICAgICAgIHJldHVybiBbdHJ1ZSwgW2tleSwgdmFsdWVdXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2ZhbHNlLCBuaWxdO1xuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2xlYXJcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIHNlbGYuY2xlYXIoKTtcbiAgICAgIGlmIChzZWxmLiQka2V5cylcbiAgICAgICAgc2VsZi4kJGtleXMuY2xlYXIoKTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2xvbmVcbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gc2VsZi4kY2xhc3MoKS4kbmV3KCk7XG4gICAgICAkaGFzaF9jbG9uZShzZWxmLCBoYXNoKTtcbiAgICAgIHJldHVybiBzZWxmW1wiJGZyb3plbj9cIl0oKSA/IGhhc2guJGZyZWV6ZSgpIDogaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb21wYWN0XG4gICAgJXh7XG4gICAgICB2YXIgaGFzaCA9IG5ldyBNYXAoKTtcblxuICAgICAgcmV0dXJuICRoYXNoX2VhY2goc2VsZiwgaGFzaCwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT09IG5pbCkge1xuICAgICAgICAgICRoYXNoX3B1dChoYXNoLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2ZhbHNlLCBoYXNoXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbXBhY3QhXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gbmlsO1xuXG4gICAgICByZXR1cm4gJGhhc2hfZWFjaChzZWxmLCByZXN1bHQsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBuaWwpIHtcbiAgICAgICAgICAkaGFzaF9kZWxldGUoc2VsZiwga2V5KTtcbiAgICAgICAgICByZXN1bHQgPSBzZWxmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZmFsc2UsIHJlc3VsdF07XG4gICAgICB9KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb21wYXJlX2J5X2lkZW50aXR5XG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICBpZiAoIXNlbGYuJCRieV9pZGVudGl0eSkge1xuICAgICAgICBzZWxmLiQkYnlfaWRlbnRpdHkgPSB0cnVlO1xuXG4gICAgICAgIGlmIChzZWxmLnNpemUgIT09IDApXG4gICAgICAgICAgT3BhbC5oYXNoX3JlaGFzaChzZWxmKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29tcGFyZV9ieV9pZGVudGl0eT9cbiAgICBgc2VsZi4kJGJ5X2lkZW50aXR5ID09PSB0cnVlYFxuICBlbmRcblxuICBkZWYgZGVmYXVsdChrZXkgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQgJiYgc2VsZi4kJHByb2MgIT09IG5pbCAmJiBzZWxmLiQkcHJvYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkcHJvYy4kY2FsbChzZWxmLCBrZXkpO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYuJCRub25lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLiQkbm9uZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWZhdWx0PShvYmplY3QpXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICBzZWxmLiQkcHJvYyA9IG5pbDtcbiAgICAgIHNlbGYuJCRub25lID0gb2JqZWN0O1xuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlZmF1bHRfcHJvY1xuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRwcm9jICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuJCRwcm9jO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWZhdWx0X3Byb2M9KGRlZmF1bHRfcHJvYylcbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIHZhciBwcm9jID0gZGVmYXVsdF9wcm9jO1xuXG4gICAgICBpZiAocHJvYyAhPT0gbmlsKSB7XG4gICAgICAgIHByb2MgPSAjezo6T3BhbC5jb2VyY2VfdG8hKGBwcm9jYCwgOjpQcm9jLCA6dG9fcHJvYyl9O1xuXG4gICAgICAgIGlmICgje2Bwcm9jYC5sYW1iZGE/fSAmJiAje2Bwcm9jYC5hcml0eS5hYnN9ICE9PSAyKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ2RlZmF1bHRfcHJvYyB0YWtlcyB0d28gYXJndW1lbnRzJ307XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZi4kJG5vbmUgPSBuaWw7XG4gICAgICBzZWxmLiQkcHJvYyA9IHByb2M7XG5cbiAgICAgIHJldHVybiBkZWZhdWx0X3Byb2M7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVsZXRlKGtleSwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcbiAgICAgIHZhciB2YWx1ZSA9ICRoYXNoX2RlbGV0ZShzZWxmLCBrZXkpO1xuXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIHJldHVybiAje3lpZWxkIGtleX07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVsZXRlX2lmKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmRlbGV0ZV9pZikgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIHJldHVybiAkaGFzaF9lYWNoKHNlbGYsIHNlbGYsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIG9iaiA9IGJsb2NrKGtleSwgdmFsdWUpO1xuXG4gICAgICAgIGlmIChvYmogIT09IGZhbHNlICYmIG9iaiAhPT0gbmlsKSB7XG4gICAgICAgICAgJGhhc2hfZGVsZXRlKHNlbGYsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtmYWxzZSwgc2VsZl07XG4gICAgICB9KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkaWcoa2V5LCAqa2V5cylcbiAgICBpdGVtID0gc2VsZltrZXldXG5cbiAgICAleHtcbiAgICAgIGlmIChpdGVtID09PSBuaWwgfHwga2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdW5sZXNzIGl0ZW0ucmVzcG9uZF90bz8oOmRpZylcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIiN7aXRlbS5jbGFzc30gZG9lcyBub3QgaGF2ZSAjZGlnIG1ldGhvZFwiXG4gICAgZW5kXG5cbiAgICBpdGVtLmRpZygqa2V5cylcbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgIGAkaGFzaF9jbG9uZShzZWxmLCBzZWxmLiRjbGFzcygpLiRuZXcoKSlgXG4gIGVuZFxuXG4gIGRlZiBlYWNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2gpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICByZXR1cm4gJGhhc2hfZWFjaChzZWxmLCBzZWxmLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICR5aWVsZDEoYmxvY2ssIFtrZXksIHZhbHVlXSk7XG4gICAgICAgIHJldHVybiBbZmFsc2UsIHNlbGZdO1xuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaF9rZXkoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9rZXkpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICByZXR1cm4gJGhhc2hfZWFjaChzZWxmLCBzZWxmLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIGJsb2NrKGtleSk7XG4gICAgICAgIHJldHVybiBbZmFsc2UsIHNlbGZdO1xuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaF92YWx1ZSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3ZhbHVlKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgcmV0dXJuICRoYXNoX2VhY2goc2VsZiwgc2VsZiwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICBibG9jayh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBbZmFsc2UsIHNlbGZdO1xuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZW1wdHk/XG4gICAgYHNlbGYuc2l6ZSA9PT0gMGBcbiAgZW5kXG5cbiAgZGVmIGV4Y2VwdCgqa2V5cylcbiAgICBkdXAuZXhjZXB0ISgqa2V5cylcbiAgZW5kXG5cbiAgZGVmIGV4Y2VwdCEoKmtleXMpXG4gICAga2V5cy5lYWNoIHsgfGtleXwgZGVsZXRlKGtleSkgfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGZldGNoKGtleSwgZGVmYXVsdHMgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciB2YWx1ZSA9ICRoYXNoX2dldChzZWxmLCBrZXkpO1xuXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBibG9jayhrZXkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVmYXVsdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgOjpLZXJuZWwucmFpc2UgOjpLZXlFcnJvci5uZXcoXCJrZXkgbm90IGZvdW5kOiAje2tleS5pbnNwZWN0fVwiLCBrZXk6IGtleSwgcmVjZWl2ZXI6IHNlbGYpXG4gIGVuZFxuXG4gIGRlZiBmZXRjaF92YWx1ZXMoKmtleXMsICZibG9jaylcbiAgICBrZXlzLm1hcCB7IHxrZXl8IGZldGNoKGtleSwgJmJsb2NrKSB9XG4gIGVuZFxuXG4gIGRlZiBmbGF0dGVuKGxldmVsID0gMSlcbiAgICBsZXZlbCA9IDo6T3BhbC5jb2VyY2VfdG8hKGxldmVsLCA6OkludGVnZXIsIDp0b19pbnQpXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgcmV0dXJuICRoYXNoX2VhY2goc2VsZiwgcmVzdWx0LCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG5cbiAgICAgICAgaWYgKHZhbHVlLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICBpZiAobGV2ZWwgPT09IDEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBbZmFsc2UsIHJlc3VsdF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCgje2B2YWx1ZWAuZmxhdHRlbihgbGV2ZWwgLSAyYCl9KTtcbiAgICAgICAgICByZXR1cm4gW2ZhbHNlLCByZXN1bHRdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICByZXR1cm4gW2ZhbHNlLCByZXN1bHRdO1xuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZnJlZXplXG4gICAgcmV0dXJuIHNlbGYgaWYgZnJvemVuP1xuXG4gICAgYCRmcmVlemUoc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBoYXNfa2V5PyhrZXkpXG4gICAgYCRoYXNoX2dldChzZWxmLCBrZXkpICE9PSB1bmRlZmluZWRgXG4gIGVuZFxuXG4gIGRlZiBoYXNfdmFsdWU/KHZhbHVlKVxuICAgICV4e1xuICAgICAgcmV0dXJuICRoYXNoX2VhY2goc2VsZiwgZmFsc2UsIGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgICAgIGlmICgje2B2YWxgID09IHZhbHVlfSkge1xuICAgICAgICAgIHJldHVybiBbdHJ1ZSwgdHJ1ZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtmYWxzZSwgZmFsc2VdO1xuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICBgdmFyICRoYXNoX2lkc2BcblxuICBkZWYgaGFzaFxuICAgICV4e1xuICAgICAgdmFyIHRvcCA9ICgkaGFzaF9pZHMgPT09IHVuZGVmaW5lZCksXG4gICAgICAgICAgaGFzaF9pZCA9IHNlbGYuJG9iamVjdF9pZCgpLFxuICAgICAgICAgIHJlc3VsdCA9ICRvcGFsMzJfaW5pdCgpLFxuICAgICAgICAgIGtleSwgaXRlbSwgaSxcbiAgICAgICAgICBzaXplID0gc2VsZi5zaXplLCBhcnkgPSBuZXcgSW50MzJBcnJheShzaXplKTtcblxuICAgICAgcmVzdWx0ID0gJG9wYWwzMl9hZGQocmVzdWx0LCAweDQpO1xuICAgICAgcmVzdWx0ID0gJG9wYWwzMl9hZGQocmVzdWx0LCBzaXplKTtcblxuICAgICAgaWYgKHRvcCkge1xuICAgICAgICAkaGFzaF9pZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoJGhhc2hfaWRzW2hhc2hfaWRdKSB7XG4gICAgICAgIHJldHVybiAkb3BhbDMyX2FkZChyZXN1bHQsIDB4MDEwMTAxMDEpO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKGtleSBpbiAkaGFzaF9pZHMpIHtcbiAgICAgICAgICBpdGVtID0gJGhhc2hfaWRzW2tleV07XG4gICAgICAgICAgaWYgKCN7ZXFsPyhgaXRlbWApfSkge1xuICAgICAgICAgICAgcmV0dXJuICRvcGFsMzJfYWRkKHJlc3VsdCwgMHgwMTAxMDEwMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJGhhc2hfaWRzW2hhc2hfaWRdID0gc2VsZjtcbiAgICAgICAgaSA9IDBcblxuICAgICAgICAkaGFzaF9lYWNoKHNlbGYsIGZhbHNlLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgYXJ5W2ldID0gWzB4NzA0MTQ5NTIsIGtleSwgdmFsdWVdLiRoYXNoKCk7XG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIHJldHVybiBbZmFsc2UsIGZhbHNlXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXJ5ID0gYXJ5LnNvcnQoKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcmVzdWx0ID0gJG9wYWwzMl9hZGQocmVzdWx0LCBhcnlbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAkaGFzaF9pZHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbmRleChvYmplY3QpXG4gICAgJXh7XG4gICAgICByZXR1cm4gJGhhc2hfZWFjaChzZWxmLCBuaWwsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCN7YHZhbHVlYCA9PSBvYmplY3R9KSB7XG4gICAgICAgICAgcmV0dXJuIFt0cnVlLCBrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZmFsc2UsIG5pbF07XG4gICAgICB9KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbmRleGVzKCphcmdzKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXJncy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBhcmdzW2ldO1xuICAgICAgICB2YWx1ZSA9ICRoYXNoX2dldChzZWxmLCBrZXkpO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goI3tkZWZhdWx0fSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBgdmFyIGluc3BlY3RfaWRzYFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgJXh7XG4gICAgICB2YXIgdG9wID0gKGluc3BlY3RfaWRzID09PSB1bmRlZmluZWQpLFxuICAgICAgICAgIGhhc2hfaWQgPSBzZWxmLiRvYmplY3RfaWQoKSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICB9XG5cbiAgICBiZWdpblxuICAgICAgJXh7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICBpbnNwZWN0X2lkcyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluc3BlY3RfaWRzLmhhc093blByb3BlcnR5KGhhc2hfaWQpKSB7XG4gICAgICAgICAgcmV0dXJuICd7Li4ufSc7XG4gICAgICAgIH1cblxuICAgICAgICBpbnNwZWN0X2lkc1toYXNoX2lkXSA9IHRydWU7XG5cbiAgICAgICAgJGhhc2hfZWFjaChzZWxmLCBmYWxzZSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgIHZhbHVlID0gI3tPcGFsLmluc3BlY3QoYHZhbHVlYCl9XG4gICAgICAgICAga2V5ID0gI3tPcGFsLmluc3BlY3QoYGtleWApfVxuXG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5ICsgJz0+JyArIHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gW2ZhbHNlLCBmYWxzZV07XG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuICd7JyArIHJlc3VsdC5qb2luKCcsICcpICsgJ30nO1xuICAgICAgfVxuICAgICAgbmlsXG4gICAgZW5zdXJlXG4gICAgICBgaWYgKHRvcCkgaW5zcGVjdF9pZHMgPSB1bmRlZmluZWRgXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBpbnZlcnRcbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gbmV3IE1hcCgpO1xuXG4gICAgICByZXR1cm4gJGhhc2hfZWFjaChzZWxmLCBoYXNoLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICRoYXNoX3B1dChoYXNoLCB2YWx1ZSwga2V5KTtcbiAgICAgICAgcmV0dXJuIFtmYWxzZSwgaGFzaF07XG4gICAgICB9KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBrZWVwX2lmKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmtlZXBfaWYpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuXG4gICAgICByZXR1cm4gJGhhc2hfZWFjaChzZWxmLCBzZWxmLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBvYmogPSBibG9jayhrZXksIHZhbHVlKTtcblxuICAgICAgICBpZiAob2JqID09PSBmYWxzZSB8fCBvYmogPT09IG5pbCkge1xuICAgICAgICAgICRoYXNoX2RlbGV0ZShzZWxmLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZmFsc2UsIHNlbGZdO1xuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYga2V5c1xuICAgIGBBcnJheS5mcm9tKHNlbGYua2V5cygpKWBcbiAgZW5kXG5cbiAgZGVmIGxlbmd0aFxuICAgIGBzZWxmLnNpemVgXG4gIGVuZFxuXG4gIGRlZiBtZXJnZSgqb3RoZXJzLCAmYmxvY2spXG4gICAgZHVwLm1lcmdlISgqb3RoZXJzLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBtZXJnZSEoKm90aGVycywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgdmFyIGksIGosIG90aGVyO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG90aGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICBvdGhlciA9ICN7OjpPcGFsLmNvZXJjZV90byEoYG90aGVyc1tpXWAsIDo6SGFzaCwgOnRvX2hhc2gpfTtcblxuICAgICAgICBpZiAoYmxvY2sgPT09IG5pbCkge1xuICAgICAgICAgICRoYXNoX2VhY2gob3RoZXIsIGZhbHNlLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAkaGFzaF9wdXQoc2VsZiwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gW2ZhbHNlLCBmYWxzZV07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJGhhc2hfZWFjaChvdGhlciwgZmFsc2UsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSAkaGFzaF9nZXQoc2VsZiwga2V5KTtcblxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICRoYXNoX3B1dChzZWxmLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFtmYWxzZSwgZmFsc2VdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkaGFzaF9wdXQoc2VsZiwga2V5LCBibG9jayhrZXksIHZhbCwgdmFsdWUpKTtcbiAgICAgICAgICAgIHJldHVybiBbZmFsc2UsIGZhbHNlXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByYXNzb2Mob2JqZWN0KVxuICAgICV4e1xuICAgICAgcmV0dXJuICRoYXNoX2VhY2goc2VsZiwgbmlsLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICgje2B2YWx1ZWAgPT0gb2JqZWN0fSkge1xuICAgICAgICAgIHJldHVybiBbdHJ1ZSwgW2tleSwgdmFsdWVdXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2ZhbHNlLCBuaWxdO1xuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVoYXNoXG4gICAgJXh7XG4gICAgICAkZGVueV9mcm96ZW5fYWNjZXNzKHNlbGYpO1xuICAgICAgcmV0dXJuIE9wYWwuaGFzaF9yZWhhc2goc2VsZik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVqZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlamVjdCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gbmV3IE1hcCgpO1xuXG4gICAgICByZXR1cm4gJGhhc2hfZWFjaChzZWxmLCBoYXNoLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBvYmogPSBibG9jayhrZXksIHZhbHVlKTtcblxuICAgICAgICBpZiAob2JqID09PSBmYWxzZSB8fCBvYmogPT09IG5pbCkge1xuICAgICAgICAgICRoYXNoX3B1dChoYXNoLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2ZhbHNlLCBoYXNoXVxuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVqZWN0ISgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZWplY3QhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IG5pbDtcblxuICAgICAgcmV0dXJuICRoYXNoX2VhY2goc2VsZiwgcmVzdWx0LCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBvYmogPSBibG9jayhrZXksIHZhbHVlKTtcblxuICAgICAgICBpZiAob2JqICE9PSBmYWxzZSAmJiBvYmogIT09IG5pbCkge1xuICAgICAgICAgICRoYXNoX2RlbGV0ZShzZWxmLCBrZXkpO1xuICAgICAgICAgIHJlc3VsdCA9IHNlbGY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtmYWxzZSwgcmVzdWx0XTtcbiAgICAgIH0pO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlcGxhY2Uob3RoZXIpXG4gICAgYCRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7YFxuXG4gICAgb3RoZXIgPSA6Ok9wYWwuY29lcmNlX3RvIShvdGhlciwgOjpIYXNoLCA6dG9faGFzaClcblxuICAgICV4e1xuICAgICAgc2VsZi4kY2xlYXIoKTtcblxuICAgICAgJGhhc2hfZWFjaChvdGhlciwgZmFsc2UsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgJGhhc2hfcHV0KHNlbGYsIGtleSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gW2ZhbHNlLCBmYWxzZV07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiBvdGhlci5kZWZhdWx0X3Byb2NcbiAgICAgIHNlbGYuZGVmYXVsdF9wcm9jID0gb3RoZXIuZGVmYXVsdF9wcm9jXG4gICAgZWxzZVxuICAgICAgc2VsZi5kZWZhdWx0ID0gb3RoZXIuZGVmYXVsdFxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgc2VsZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnNlbGVjdCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gbmV3IE1hcCgpO1xuXG4gICAgICByZXR1cm4gJGhhc2hfZWFjaChzZWxmLCBoYXNoLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBvYmogPSBibG9jayhrZXksIHZhbHVlKTtcblxuICAgICAgICBpZiAob2JqICE9PSBmYWxzZSAmJiBvYmogIT09IG5pbCkge1xuICAgICAgICAgICRoYXNoX3B1dChoYXNoLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2ZhbHNlLCBoYXNoXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGVjdCEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6c2VsZWN0ISkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIHZhciByZXN1bHQgPSBuaWw7XG5cbiAgICAgIHJldHVybiAkaGFzaF9lYWNoKHNlbGYsIHJlc3VsdCwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgb2JqID0gYmxvY2soa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKG9iaiA9PT0gZmFsc2UgfHwgb2JqID09PSBuaWwpIHtcbiAgICAgICAgICAkaGFzaF9kZWxldGUoc2VsZiwga2V5KTtcbiAgICAgICAgICByZXN1bHQgPSBzZWxmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZmFsc2UsIHJlc3VsdF07XG4gICAgICB9KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzaGlmdFxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgcmV0dXJuICRoYXNoX2VhY2goc2VsZiwgbmlsLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBbdHJ1ZSwgW2tleSwgJGhhc2hfZGVsZXRlKHNlbGYsIGtleSldXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNsaWNlKCprZXlzKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBNYXAoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV0sIHZhbHVlID0gJGhhc2hfZ2V0KHNlbGYsIGtleSk7XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAkaGFzaF9wdXQocmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRvX2FcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgcmV0dXJuICRoYXNoX2VhY2goc2VsZiwgcmVzdWx0LCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICAgIHJldHVybiBbZmFsc2UsIHJlc3VsdF07XG4gICAgICB9KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19oKCZibG9jaylcbiAgICByZXR1cm4gbWFwKCZibG9jaykudG9faCBpZiBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRjbGFzcyA9PT0gT3BhbC5IYXNoKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGFzaCA9IG5ldyBNYXAoKTtcblxuICAgICAgJGhhc2hfY2xvbmUoc2VsZiwgaGFzaCk7XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRvX2hhc2hcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0b19wcm9jXG4gICAgcHJvYyBkbyB8a2V5ID0gdW5kZWZpbmVkfFxuICAgICAgJXh7XG4gICAgICAgIGlmIChrZXkgPT0gbnVsbCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbm8ga2V5IGdpdmVuJ31cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmW2tleV1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHRyYW5zZm9ybV9rZXlzKGtleXNfaGFzaCA9IG5pbCwgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6dHJhbnNmb3JtX2tleXMpIHsgc2l6ZSB9IGlmICFibG9jayAmJiAha2V5c19oYXNoXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgTWFwKCk7XG5cbiAgICAgIHJldHVybiAkaGFzaF9lYWNoKHNlbGYsIHJlc3VsdCwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgbmV3X2tleTtcbiAgICAgICAgaWYgKGtleXNfaGFzaCAhPT0gbmlsKVxuICAgICAgICAgIG5ld19rZXkgPSAkaGFzaF9nZXQoa2V5c19oYXNoLCBrZXkpO1xuICAgICAgICBpZiAobmV3X2tleSA9PT0gdW5kZWZpbmVkICYmIGJsb2NrICYmIGJsb2NrICE9PSBuaWwpXG4gICAgICAgICAgbmV3X2tleSA9IGJsb2NrKGtleSk7XG4gICAgICAgIGlmIChuZXdfa2V5ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgbmV3X2tleSA9IGtleSAvLyBrZXkgbm90IG1vZGlmaWVkXG4gICAgICAgICRoYXNoX3B1dChyZXN1bHQsIG5ld19rZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIFtmYWxzZSwgcmVzdWx0XTtcbiAgICAgIH0pO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRyYW5zZm9ybV9rZXlzIShrZXlzX2hhc2ggPSBuaWwsICZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnRyYW5zZm9ybV9rZXlzISkgeyBzaXplIH0gaWYgIWJsb2NrICYmICFrZXlzX2hhc2hcblxuICAgICV4e1xuICAgICAgJGRlbnlfZnJvemVuX2FjY2VzcyhzZWxmKTtcblxuICAgICAgdmFyIG1vZGlmaWVkX2tleXMgPSBuZXcgTWFwKCk7XG5cbiAgICAgIHJldHVybiAkaGFzaF9lYWNoKHNlbGYsIHNlbGYsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIG5ld19rZXk7XG4gICAgICAgIGlmIChrZXlzX2hhc2ggIT09IG5pbClcbiAgICAgICAgICBuZXdfa2V5ID0gJGhhc2hfZ2V0KGtleXNfaGFzaCwga2V5KTtcbiAgICAgICAgaWYgKG5ld19rZXkgPT09IHVuZGVmaW5lZCAmJiBibG9jayAmJiBibG9jayAhPT0gbmlsKVxuICAgICAgICAgIG5ld19rZXkgPSBibG9jayhrZXkpO1xuICAgICAgICBpZiAobmV3X2tleSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHJldHVybiBbZmFsc2UsIHNlbGZdOyAvLyBrZXkgbm90IG1vZGlmaWVkXG4gICAgICAgIGlmICghJGhhc2hfZ2V0KG1vZGlmaWVkX2tleXMsIGtleSkpXG4gICAgICAgICAgJGhhc2hfZGVsZXRlKHNlbGYsIGtleSk7XG4gICAgICAgICRoYXNoX3B1dChzZWxmLCBuZXdfa2V5LCB2YWx1ZSk7XG4gICAgICAgICRoYXNoX3B1dChtb2RpZmllZF9rZXlzLCBuZXdfa2V5LCB0cnVlKVxuICAgICAgICByZXR1cm4gW2ZhbHNlLCBzZWxmXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRyYW5zZm9ybV92YWx1ZXMoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6dHJhbnNmb3JtX3ZhbHVlcykgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgTWFwKCk7XG5cbiAgICAgIHJldHVybiAkaGFzaF9lYWNoKHNlbGYsIHJlc3VsdCwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAkaGFzaF9wdXQocmVzdWx0LCBrZXksIGJsb2NrKHZhbHVlKSk7XG4gICAgICAgIHJldHVybiBbZmFsc2UsIHJlc3VsdF07XG4gICAgICB9KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0cmFuc2Zvcm1fdmFsdWVzISgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDp0cmFuc2Zvcm1fdmFsdWVzISkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG5cbiAgICAgIHJldHVybiAkaGFzaF9lYWNoKHNlbGYsIHNlbGYsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgJGhhc2hfcHV0KHNlbGYsIGtleSwgYmxvY2sodmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIFtmYWxzZSwgc2VsZl07XG4gICAgICB9KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB2YWx1ZXNcbiAgICBgQXJyYXkuZnJvbShzZWxmLnZhbHVlcygpKWBcbiAgZW5kXG5cbiAgYWxpYXMgZWFjaF9wYWlyIGVhY2hcbiAgYWxpYXMgZXFsPyA9PVxuICBhbGlhcyBmaWx0ZXIgc2VsZWN0XG4gIGFsaWFzIGZpbHRlciEgc2VsZWN0IVxuICBhbGlhcyBpbmNsdWRlPyBoYXNfa2V5P1xuICBhbGlhcyBpbmRpY2VzIGluZGV4ZXNcbiAgYWxpYXMga2V5IGluZGV4XG4gIGFsaWFzIGtleT8gaGFzX2tleT9cbiAgYWxpYXMgbWVtYmVyPyBoYXNfa2V5P1xuICBhbGlhcyBzaXplIGxlbmd0aFxuICBhbGlhcyBzdG9yZSBbXT1cbiAgYWxpYXMgdG9fcyBpbnNwZWN0XG4gIGFsaWFzIHVwZGF0ZSBtZXJnZSFcbiAgYWxpYXMgdmFsdWU/IGhhc192YWx1ZT9cbiAgYWxpYXMgdmFsdWVzX2F0IGluZGV4ZXNcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpIYXNoPiIsImluY2x1ZGUiLCJFbnVtZXJhYmxlIiwiW10iLCJPcGFsIiwiY29lcmNlX3RvPyIsImFyZ3YiLCIwIiwiSGFzaCIsImFsbG9jYXRlIiwibWVyZ2UhIiwiQXJyYXkiLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJpbnNwZWN0IiwidHJ5X2NvbnZlcnQiLCJvYmoiLCJpbml0aWFsaXplIiwiZGVmYXVsdHMiLCI9PSIsIm90aGVyIiwiPj0iLCJjb2VyY2VfdG8hIiwicmVzdWx0IiwiZWFjaCIsImJsb2NrIGluID49Iiwib3RoZXJfa2V5Iiwib3RoZXJfdmFsIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA+PSIsInZhbCIsImZldGNoIiwiPiIsIjwiLCI8PSIsImtleSIsIltdPSIsInZhbHVlIiwiYXNzb2MiLCJvYmplY3QiLCJjbGVhciIsImNsb25lIiwiY29tcGFjdCIsImNvbXBhY3QhIiwiY29tcGFyZV9ieV9pZGVudGl0eSIsImNvbXBhcmVfYnlfaWRlbnRpdHk/IiwiZGVmYXVsdCIsImRlZmF1bHQ9IiwiZGVmYXVsdF9wcm9jIiwiZGVmYXVsdF9wcm9jPSIsIlByb2MiLCJsYW1iZGE/IiwiYXJpdHkiLCJhYnMiLCJUeXBlRXJyb3IiLCJkZWxldGUiLCJkZWxldGVfaWYiLCJibG9jayIsImVudW1fZm9yIiwiYmxvY2sgaW4gZGVsZXRlX2lmIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkZWxldGVfaWYiLCJzaXplIiwiZGlnIiwiaXRlbSIsInJlc3BvbmRfdG8/IiwiY2xhc3MiLCJrZXlzIiwiZHVwIiwiYmxvY2sgaW4gZWFjaCIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaCIsImVhY2hfa2V5IiwiYmxvY2sgaW4gZWFjaF9rZXkiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfa2V5IiwiZWFjaF92YWx1ZSIsImJsb2NrIGluIGVhY2hfdmFsdWUiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfdmFsdWUiLCJlbXB0eT8iLCJleGNlcHQiLCJleGNlcHQhIiwiYmxvY2sgaW4gZXhjZXB0ISIsImJsb2NrICgyIGxldmVscykgaW4gZXhjZXB0ISIsIktleUVycm9yIiwibmV3IiwiZmV0Y2hfdmFsdWVzIiwibWFwIiwiYmxvY2sgaW4gZmV0Y2hfdmFsdWVzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBmZXRjaF92YWx1ZXMiLCJ0b19wcm9jIiwiZmxhdHRlbiIsImxldmVsIiwiMSIsIkludGVnZXIiLCJmcmVlemUiLCJmcm96ZW4/IiwiaGFzX2tleT8iLCJoYXNfdmFsdWU/IiwiaGFzaCIsImVxbD8iLCJpbmRleCIsImluZGV4ZXMiLCJpbnZlcnQiLCJrZWVwX2lmIiwiYmxvY2sgaW4ga2VlcF9pZiIsImJsb2NrICgyIGxldmVscykgaW4ga2VlcF9pZiIsImxlbmd0aCIsIm1lcmdlIiwib3RoZXJzIiwicmFzc29jIiwicmVoYXNoIiwicmVqZWN0IiwiYmxvY2sgaW4gcmVqZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZWplY3QiLCJyZWplY3QhIiwiYmxvY2sgaW4gcmVqZWN0ISIsImJsb2NrICgyIGxldmVscykgaW4gcmVqZWN0ISIsInJlcGxhY2UiLCJzZWxlY3QiLCJibG9jayBpbiBzZWxlY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIHNlbGVjdCIsInNlbGVjdCEiLCJibG9jayBpbiBzZWxlY3QhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzZWxlY3QhIiwic2hpZnQiLCJzbGljZSIsInRvX2EiLCJ0b19oIiwiYmxvY2tfZ2l2ZW4/IiwidG9faGFzaCIsInByb2MiLCJibG9jayBpbiB0b19wcm9jIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0b19wcm9jIiwidHJhbnNmb3JtX2tleXMiLCJrZXlzX2hhc2giLCJibG9jayBpbiB0cmFuc2Zvcm1fa2V5cyIsImJsb2NrICgyIGxldmVscykgaW4gdHJhbnNmb3JtX2tleXMiLCJ0cmFuc2Zvcm1fa2V5cyEiLCJibG9jayBpbiB0cmFuc2Zvcm1fa2V5cyEiLCJibG9jayAoMiBsZXZlbHMpIGluIHRyYW5zZm9ybV9rZXlzISIsInRyYW5zZm9ybV92YWx1ZXMiLCJibG9jayBpbiB0cmFuc2Zvcm1fdmFsdWVzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0cmFuc2Zvcm1fdmFsdWVzIiwidHJhbnNmb3JtX3ZhbHVlcyEiLCJibG9jayBpbiB0cmFuc2Zvcm1fdmFsdWVzISIsImJsb2NrICgyIGxldmVscykgaW4gdHJhbnNmb3JtX3ZhbHVlcyEiLCJ2YWx1ZXMiXSwibWFwcGluZ3MiOiJBQUFBQSwrQkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFHQUMsSUFBQUMsU0FBQUEsQ0FBUUYsb0JBQVJFO0VBUUFGLE9BQUFHO0VBQUFBOztJQUFBQTs7O0lBQ0VGLElBQUFHLFNBQUFBLENBQVFDLGlCQUFSRDtJQUdDRDtJQUVERyxNQUFJTCxJQUFKSyxTQUFBQSxvQkFqQkYsRUFpQkVBO0FBQUFBLE1BQUFBOzs7TUFqQkY7TUFpQmM7O0FBRWRBOztBQUVBQTtBQUNBQSxlQUFpQkMsS0FBTUMsZUFBQUEsQ0FBWUMsSUFBSUgsT0FBQUEsQ0FBQ0ksQ0FBREosQ0FBdEIsRUFBMkJLLFdBQTNCLEVBQW1DLFNBQTdCSCxDQUF1Q0Y7QUFDOURBO0FBQ0FBLGlCQUFtQkwsSUFBQVcsVUFBQUEsQ0FBQUEsQ0FBUUMsV0FBQUEsQ0FBU1AsSUFBVE8sQ0FBZ0JQO0FBQzNDQTs7QUFFQUEsZUFBaUJDLEtBQU1DLGVBQUFBLENBQVlDLElBQUlILE9BQUFBLENBQUNJLENBQURKLENBQXRCLEVBQTJCUSxZQUEzQixFQUFvQyxRQUE5Qk4sQ0FBdUNGO0FBQzlEQTtBQUNBQSxVQUFZUyxPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixFQUFnQ1gsa0NBQXhCVSxDQUEyRFY7QUFDL0VBOztBQUVBQTtBQUNBQSxlQUFp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OjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvbnVtYmVyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxuIyB1c2Vfc3RyaWN0OiB0cnVlXG5cbnJlcXVpcmUgJ2NvcmVsaWIvbnVtZXJpYydcblxuY2xhc3MgOjpOdW1iZXIgPCA6Ok51bWVyaWNcbiAgOjpPcGFsLmJyaWRnZShgTnVtYmVyYCwgc2VsZilcbiAgYE9wYWwucHJvcChzZWxmLiQkcHJvdG90eXBlLCAnJCRpc19udW1iZXInLCB0cnVlKWBcbiAgYHNlbGYuJCRpc19udW1iZXJfY2xhc3MgPSB0cnVlYFxuICBgdmFyIG51bWJlcl9pZF9tYXAgPSBuZXcgTWFwKClgXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhbGxvY2F0ZVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiYWxsb2NhdG9yIHVuZGVmaW5lZCBmb3IgI3tuYW1lfVwiXG4gICAgZW5kXG5cbiAgICB1bmRlZiA6bmV3XG4gIGVuZFxuXG4gIGRlZiBjb2VyY2Uob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIgPT09IG5pbCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3tvdGhlci5jbGFzc30gaW50byBGbG9hdFwifTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG90aGVyLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBbI3s6Oktlcm5lbC5GbG9hdChvdGhlcil9LCBzZWxmXTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCN7b3RoZXIucmVzcG9uZF90bz8oOnRvX2YpfSkge1xuICAgICAgICByZXR1cm4gWyN7OjpPcGFsLmNvZXJjZV90byEob3RoZXIsIDo6RmxvYXQsIDp0b19mKX0sIHNlbGZdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIFtvdGhlciwgc2VsZl07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7b3RoZXIuY2xhc3N9IGludG8gRmxvYXRcIn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgX19pZF9fXG4gICAgJXh7XG4gICAgICAvLyBCaW5hcnktc2FmZSBpbnRlZ2Vyc1xuICAgICAgaWYgKHNlbGZ8MCA9PT0gc2VsZikge1xuICAgICAgICByZXR1cm4gKHNlbGYgKiAyKSArIDE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKG51bWJlcl9pZF9tYXAuaGFzKHNlbGYpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bWJlcl9pZF9tYXAuZ2V0KHNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpZCA9IE9wYWwudWlkKCk7XG4gICAgICAgIG51bWJlcl9pZF9tYXAuc2V0KHNlbGYsIGlkKTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICAleHtcbiAgICAgIC8vIEJpbmFyeS1zYWZlIGludGVnZXJzXG4gICAgICBpZiAoc2VsZnwwID09PSBzZWxmKSB7XG4gICAgICAgIHJldHVybiAje19faWRfX31cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZi50b1N0cmluZygpLiRoYXNoKCk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgKyhvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiArIG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDorLCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgLShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiAtIG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDotLCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgKihvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiAqIG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDoqLCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgLyhvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiAvIG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDovLCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgJShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICBpZiAob3RoZXIgPT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG90aGVyID09IDApIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6WmVyb0RpdmlzaW9uRXJyb3IsICdkaXZpZGVkIGJ5IDAnfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdGhlciA8IDAgfHwgc2VsZiA8IDApIHtcbiAgICAgICAgICByZXR1cm4gKHNlbGYgJSBvdGhlciArIG90aGVyKSAlIG90aGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzZWxmICUgb3RoZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6JSwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmICYob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgJiBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Jiwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHwob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgfCBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6fCwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIF4ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgXiBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Xiwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIDwob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgPCBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6PCwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIDw9KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmIDw9IG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDo8PSwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmID4ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgPiBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Piwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmID49KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmID49IG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDo+PSwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgIyBDb21wdXRlIHRoZSByZXN1bHQgb2YgdGhlIHNwYWNlc2hpcCBvcGVyYXRvciBpbnNpZGUgaXRzIG93biBmdW5jdGlvbiBzbyBpdFxuICAjIGNhbiBiZSBvcHRpbWl6ZWQgZGVzcGl0ZSBhIHRyeS9maW5hbGx5IGNvbnN0cnVjdC5cbiAgJXh7XG4gICAgdmFyIHNwYWNlc2hpcF9vcGVyYXRvciA9IGZ1bmN0aW9uKHNlbGYsIG90aGVyKSB7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKGlzTmFOKHNlbGYpIHx8IGlzTmFOKG90aGVyKSkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZiA+IG90aGVyKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZiA8IG90aGVyKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOjw9PiwgYG90aGVyYH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICBgc3BhY2VzaGlwX29wZXJhdG9yKHNlbGYsIG90aGVyKWBcbiAgcmVzY3VlIDo6QXJndW1lbnRFcnJvclxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgPDwoY291bnQpXG4gICAgY291bnQgPSA6Ok9wYWwuY29lcmNlX3RvISBjb3VudCwgOjpJbnRlZ2VyLCA6dG9faW50XG5cbiAgICBgI3tjb3VudH0gPiAwID8gc2VsZiA8PCAje2NvdW50fSA6IHNlbGYgPj4gLSN7Y291bnR9YFxuICBlbmRcblxuICBkZWYgPj4oY291bnQpXG4gICAgY291bnQgPSA6Ok9wYWwuY29lcmNlX3RvISBjb3VudCwgOjpJbnRlZ2VyLCA6dG9faW50XG5cbiAgICBgI3tjb3VudH0gPiAwID8gc2VsZiA+PiAje2NvdW50fSA6IHNlbGYgPDwgLSN7Y291bnR9YFxuICBlbmRcblxuICBkZWYgW10oYml0KVxuICAgIGJpdCA9IDo6T3BhbC5jb2VyY2VfdG8hIGJpdCwgOjpJbnRlZ2VyLCA6dG9faW50XG5cbiAgICAleHtcbiAgICAgIGlmICgje2JpdH0gPCAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgaWYgKCN7Yml0fSA+PSAzMikge1xuICAgICAgICByZXR1cm4gI3sgc2VsZiB9IDwgMCA/IDEgOiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChzZWxmID4+ICN7Yml0fSkgJiAxO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmICtAXG4gICAgYCtzZWxmYFxuICBlbmRcblxuICBkZWYgLUBcbiAgICBgLXNlbGZgXG4gIGVuZFxuXG4gIGRlZiB+XG4gICAgYH5zZWxmYFxuICBlbmRcblxuICBkZWYgKioob3RoZXIpXG4gICAgaWYgOjpJbnRlZ2VyID09PSBvdGhlclxuICAgICAgaWYgISg6OkludGVnZXIgPT09IHNlbGYpIHx8IG90aGVyID4gMFxuICAgICAgICBgTWF0aC5wb3coc2VsZiwgb3RoZXIpYFxuICAgICAgZWxzZVxuICAgICAgICA6OlJhdGlvbmFsLm5ldyhzZWxmLCAxKSoqb3RoZXJcbiAgICAgIGVuZFxuICAgIGVsc2lmIHNlbGYgPCAwICYmICg6OkZsb2F0ID09PSBvdGhlciB8fCA6OlJhdGlvbmFsID09PSBvdGhlcilcbiAgICAgIDo6Q29tcGxleC5uZXcoc2VsZiwgMCkqKm90aGVyLnRvX2ZcbiAgICBlbHNpZiBgb3RoZXIuJCRpc19udW1iZXIgIT0gbnVsbGBcbiAgICAgIGBNYXRoLnBvdyhzZWxmLCBvdGhlcilgXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOioqLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYudmFsdWVPZigpID09PSBvdGhlci52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgje290aGVyLnJlc3BvbmRfdG8/IDo9PX0pIHtcbiAgICAgICAgcmV0dXJuICN7b3RoZXIgPT0gc2VsZn07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgPT09ID09XG5cbiAgZGVmIGFic1xuICAgIGBNYXRoLmFicyhzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIGFiczJcbiAgICBgTWF0aC5hYnMoc2VsZiAqIHNlbGYpYFxuICBlbmRcblxuICBkZWYgYWxsYml0cz8obWFzaylcbiAgICBtYXNrID0gOjpPcGFsLmNvZXJjZV90byEgbWFzaywgOjpJbnRlZ2VyLCA6dG9faW50XG4gICAgYChzZWxmICYgbWFzaykgPT0gbWFza2BcbiAgZW5kXG5cbiAgZGVmIGFueWJpdHM/KG1hc2spXG4gICAgbWFzayA9IDo6T3BhbC5jb2VyY2VfdG8hIG1hc2ssIDo6SW50ZWdlciwgOnRvX2ludFxuICAgIGAoc2VsZiAmIG1hc2spICE9PSAwYFxuICBlbmRcblxuICBkZWYgYW5nbGVcbiAgICByZXR1cm4gc2VsZiBpZiBuYW4/XG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09IDApIHtcbiAgICAgICAgaWYgKDEgLyBzZWxmID4gMCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzZWxmIDwgMCkge1xuICAgICAgICByZXR1cm4gTWF0aC5QSTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBiaXRfbGVuZ3RoXG4gICAgdW5sZXNzIDo6SW50ZWdlciA9PT0gc2VsZlxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpOb01ldGhvZEVycm9yLm5ldyhcInVuZGVmaW5lZCBtZXRob2QgYGJpdF9sZW5ndGhgIGZvciAje3NlbGZ9OkZsb2F0XCIsICdiaXRfbGVuZ3RoJylcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKHNlbGYgPT09IDAgfHwgc2VsZiA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSAwLFxuICAgICAgICAgIHZhbHVlICA9IHNlbGYgPCAwID8gfnNlbGYgOiBzZWxmO1xuXG4gICAgICB3aGlsZSAodmFsdWUgIT0gMCkge1xuICAgICAgICByZXN1bHQgICArPSAxO1xuICAgICAgICB2YWx1ZSAgPj4+PSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNlaWwobmRpZ2l0cyA9IDApXG4gICAgJXh7XG4gICAgICB2YXIgZiA9ICN7dG9fZn07XG5cbiAgICAgIGlmIChmICUgMSA9PT0gMCAmJiBuZGlnaXRzID49IDApIHtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBmYWN0b3IgPSBNYXRoLnBvdygxMCwgbmRpZ2l0cyksXG4gICAgICAgICAgcmVzdWx0ID0gTWF0aC5jZWlsKGYgKiBmYWN0b3IpIC8gZmFjdG9yO1xuXG4gICAgICBpZiAoZiAlIDEgPT09IDApIHtcbiAgICAgICAgcmVzdWx0ID0gTWF0aC5yb3VuZChyZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNocihlbmNvZGluZyA9IHVuZGVmaW5lZClcbiAgICBgT3BhbC5lbmMoU3RyaW5nLmZyb21DaGFyQ29kZShzZWxmKSwgZW5jb2RpbmcgfHwgXCJCSU5BUllcIilgXG4gIGVuZFxuXG4gIGRlZiBkZW5vbWluYXRvclxuICAgIGlmIG5hbj8gfHwgaW5maW5pdGU/XG4gICAgICAxXG4gICAgZWxzZVxuICAgICAgc3VwZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGRvd250byhzdG9wLCAmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIGVudW1fZm9yKDpkb3dudG8sIHN0b3ApIGRvXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7c2VsZi5jbGFzc30gd2l0aCAje3N0b3AuY2xhc3N9IGZhaWxlZFwiIHVubGVzcyA6Ok51bWVyaWMgPT09IHN0b3BcbiAgICAgICAgc3RvcCA+IHNlbGYgPyAwIDogc2VsZiAtIHN0b3AgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKCFzdG9wLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tzZWxmLmNsYXNzfSB3aXRoICN7c3RvcC5jbGFzc30gZmFpbGVkXCJ9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gc2VsZjsgaSA+PSBzdG9wOyBpLS0pIHtcbiAgICAgICAgYmxvY2soaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZXF1YWw/KG90aGVyKVxuICAgIHNlbGYgPT0gb3RoZXIgfHwgYGlzTmFOKHNlbGYpICYmIGlzTmFOKG90aGVyKWBcbiAgZW5kXG5cbiAgZGVmIGV2ZW4/XG4gICAgYHNlbGYgJSAyID09PSAwYFxuICBlbmRcblxuICBkZWYgZmxvb3IobmRpZ2l0cyA9IDApXG4gICAgJXh7XG4gICAgICB2YXIgZiA9ICN7dG9fZn07XG5cbiAgICAgIGlmIChmICUgMSA9PT0gMCAmJiBuZGlnaXRzID49IDApIHtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBmYWN0b3IgPSBNYXRoLnBvdygxMCwgbmRpZ2l0cyksXG4gICAgICAgICAgcmVzdWx0ID0gTWF0aC5mbG9vcihmICogZmFjdG9yKSAvIGZhY3RvcjtcblxuICAgICAgaWYgKGYgJSAxID09PSAwKSB7XG4gICAgICAgIHJlc3VsdCA9IE1hdGgucm91bmQocmVzdWx0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBnY2Qob3RoZXIpXG4gICAgdW5sZXNzIDo6SW50ZWdlciA9PT0gb3RoZXJcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnbm90IGFuIGludGVnZXInXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBtaW4gPSBNYXRoLmFicyhzZWxmKSxcbiAgICAgICAgICBtYXggPSBNYXRoLmFicyhvdGhlcik7XG5cbiAgICAgIHdoaWxlIChtaW4gPiAwKSB7XG4gICAgICAgIHZhciB0bXAgPSBtaW47XG5cbiAgICAgICAgbWluID0gbWF4ICUgbWluO1xuICAgICAgICBtYXggPSB0bXA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXg7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZ2NkbGNtKG90aGVyKVxuICAgIFtnY2Qob3RoZXIpLCBsY20ob3RoZXIpXVxuICBlbmRcblxuICBkZWYgaW50ZWdlcj9cbiAgICBgc2VsZiAlIDEgPT09IDBgXG4gIGVuZFxuXG4gIGRlZiBpc19hPyhrbGFzcylcbiAgICByZXR1cm4gdHJ1ZSBpZiBrbGFzcyA9PSA6OkludGVnZXIgJiYgOjpJbnRlZ2VyID09PSBzZWxmXG4gICAgcmV0dXJuIHRydWUgaWYga2xhc3MgPT0gOjpJbnRlZ2VyICYmIDo6SW50ZWdlciA9PT0gc2VsZlxuICAgIHJldHVybiB0cnVlIGlmIGtsYXNzID09IDo6RmxvYXQgJiYgOjpGbG9hdCA9PT0gc2VsZlxuXG4gICAgc3VwZXJcbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX29mPyhrbGFzcylcbiAgICByZXR1cm4gdHJ1ZSBpZiBrbGFzcyA9PSA6OkludGVnZXIgJiYgOjpJbnRlZ2VyID09PSBzZWxmXG4gICAgcmV0dXJuIHRydWUgaWYga2xhc3MgPT0gOjpJbnRlZ2VyICYmIDo6SW50ZWdlciA9PT0gc2VsZlxuICAgIHJldHVybiB0cnVlIGlmIGtsYXNzID09IDo6RmxvYXQgJiYgOjpGbG9hdCA9PT0gc2VsZlxuXG4gICAgc3VwZXJcbiAgZW5kXG5cbiAgZGVmIGxjbShvdGhlcilcbiAgICB1bmxlc3MgOjpJbnRlZ2VyID09PSBvdGhlclxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdub3QgYW4gaW50ZWdlcidcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKHNlbGYgPT0gMCB8fCBvdGhlciA9PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhzZWxmICogb3RoZXIgLyAje2djZChvdGhlcil9KTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBuZXh0XG4gICAgYHNlbGYgKyAxYFxuICBlbmRcblxuICBkZWYgbm9iaXRzPyhtYXNrKVxuICAgIG1hc2sgPSA6Ok9wYWwuY29lcmNlX3RvISBtYXNrLCA6OkludGVnZXIsIDp0b19pbnRcbiAgICBgKHNlbGYgJiBtYXNrKSA9PSAwYFxuICBlbmRcblxuICBkZWYgbm9uemVybz9cbiAgICBgc2VsZiA9PSAwID8gbmlsIDogc2VsZmBcbiAgZW5kXG5cbiAgZGVmIG51bWVyYXRvclxuICAgIGlmIG5hbj8gfHwgaW5maW5pdGU/XG4gICAgICBzZWxmXG4gICAgZWxzZVxuICAgICAgc3VwZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIG9kZD9cbiAgICBgc2VsZiAlIDIgIT09IDBgXG4gIGVuZFxuXG4gIGRlZiBvcmRcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBwb3coYiwgbSA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09IDApIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6Olplcm9EaXZpc2lvbkVycm9yLCAnZGl2aWRlZCBieSAwJ31cbiAgICAgIH1cblxuICAgICAgaWYgKG0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gI3tzZWxmKipifTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghKCN7OjpJbnRlZ2VyID09PSBifSkpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnSW50ZWdlciNwb3coKSAybmQgYXJndW1lbnQgbm90IGFsbG93ZWQgdW5sZXNzIGEgMXN0IGFyZ3VtZW50IGlzIGludGVnZXInfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGIgPCAwKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ0ludGVnZXIjcG93KCkgMXN0IGFyZ3VtZW50IGNhbm5vdCBiZSBuZWdhdGl2ZSB3aGVuIDJuZCBhcmd1bWVudCBzcGVjaWZpZWQnfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEoI3s6OkludGVnZXIgPT09IG19KSkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdJbnRlZ2VyI3BvdygpIDJuZCBhcmd1bWVudCBub3QgYWxsb3dlZCB1bmxlc3MgYWxsIGFyZ3VtZW50cyBhcmUgaW50ZWdlcnMnfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG0gPT09IDApIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6WmVyb0RpdmlzaW9uRXJyb3IsICdkaXZpZGVkIGJ5IDAnfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICN7KHNlbGYqKmIpICUgbX1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBwcmVkXG4gICAgYHNlbGYgLSAxYFxuICBlbmRcblxuICBkZWYgcXVvKG90aGVyKVxuICAgIGlmIDo6SW50ZWdlciA9PT0gc2VsZlxuICAgICAgc3VwZXJcbiAgICBlbHNlXG4gICAgICBzZWxmIC8gb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHJhdGlvbmFsaXplKGVwcyA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2Bhcmd1bWVudHMubGVuZ3RoYH0gZm9yIDAuLjEpXCJ9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIDo6SW50ZWdlciA9PT0gc2VsZlxuICAgICAgOjpSYXRpb25hbC5uZXcoc2VsZiwgMSlcbiAgICBlbHNpZiBpbmZpbml0ZT9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6RmxvYXREb21haW5FcnJvciwgJ0luZmluaXR5J1xuICAgIGVsc2lmIG5hbj9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6RmxvYXREb21haW5FcnJvciwgJ05hTidcbiAgICBlbHNpZiBgZXBzID09IG51bGxgXG4gICAgICBmLCBuICA9IDo6TWF0aC5mcmV4cCBzZWxmXG4gICAgICBmICAgICA9IDo6TWF0aC5sZGV4cChmLCA6OkZsb2F0OjpNQU5UX0RJRykudG9faVxuICAgICAgbiAgICAtPSA6OkZsb2F0OjpNQU5UX0RJR1xuXG4gICAgICA6OlJhdGlvbmFsLm5ldygyICogZiwgMSA8PCAoMSAtIG4pKS5yYXRpb25hbGl6ZSg6OlJhdGlvbmFsLm5ldygxLCAxIDw8ICgxIC0gbikpKVxuICAgIGVsc2VcbiAgICAgIHRvX3IucmF0aW9uYWxpemUoZXBzKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgcmVtYWluZGVyKHkpXG4gICAgc2VsZiAtIHkgKiAoc2VsZiAvIHkpLnRydW5jYXRlXG4gIGVuZFxuXG4gIGRlZiByb3VuZChuZGlnaXRzID0gdW5kZWZpbmVkKVxuICAgIGlmIDo6SW50ZWdlciA9PT0gc2VsZlxuICAgICAgaWYgYG5kaWdpdHMgPT0gbnVsbGBcbiAgICAgICAgcmV0dXJuIHNlbGZcbiAgICAgIGVuZFxuXG4gICAgICBpZiA6OkZsb2F0ID09PSBuZGlnaXRzICYmIG5kaWdpdHMuaW5maW5pdGU/XG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ0luZmluaXR5J1xuICAgICAgZW5kXG5cbiAgICAgIG5kaWdpdHMgPSA6Ok9wYWwuY29lcmNlX3RvIShuZGlnaXRzLCA6OkludGVnZXIsIDp0b19pbnQpXG5cbiAgICAgIGlmIG5kaWdpdHMgPCA6OkludGVnZXI6Ok1JTlxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsICdvdXQgb2YgYm91bmRzJ1xuICAgICAgZW5kXG5cbiAgICAgIGlmIGBuZGlnaXRzID49IDBgXG4gICAgICAgIHJldHVybiBzZWxmXG4gICAgICBlbmRcblxuICAgICAgbmRpZ2l0cyA9IC1uZGlnaXRzXG5cbiAgICAgICV4e1xuICAgICAgICBpZiAoMC40MTUyNDEgKiBuZGlnaXRzIC0gMC4xMjUgPiAje3NpemV9KSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZiA9IE1hdGgucG93KDEwLCBuZGlnaXRzKSxcbiAgICAgICAgICAgIHggPSBNYXRoLmZsb29yKChNYXRoLmFicyhzZWxmKSArIGYgLyAyKSAvIGYpICogZjtcblxuICAgICAgICByZXR1cm4gc2VsZiA8IDAgPyAteCA6IHg7XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgaWYgbmFuPyAmJiBgbmRpZ2l0cyA9PSBudWxsYFxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkZsb2F0RG9tYWluRXJyb3IsICdOYU4nXG4gICAgICBlbmRcblxuICAgICAgbmRpZ2l0cyA9IDo6T3BhbC5jb2VyY2VfdG8hKGBuZGlnaXRzIHx8IDBgLCA6OkludGVnZXIsIDp0b19pbnQpXG5cbiAgICAgIGlmIG5kaWdpdHMgPD0gMFxuICAgICAgICBpZiBuYW4/XG4gICAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCAnTmFOJ1xuICAgICAgICBlbHNpZiBpbmZpbml0ZT9cbiAgICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkZsb2F0RG9tYWluRXJyb3IsICdJbmZpbml0eSdcbiAgICAgICAgZW5kXG4gICAgICBlbHNpZiBuZGlnaXRzID09IDBcbiAgICAgICAgcmV0dXJuIGBNYXRoLnJvdW5kKHNlbGYpYFxuICAgICAgZWxzaWYgbmFuPyB8fCBpbmZpbml0ZT9cbiAgICAgICAgcmV0dXJuIHNlbGZcbiAgICAgIGVuZFxuXG4gICAgICBfLCBleHAgPSA6Ok1hdGguZnJleHAoc2VsZilcblxuICAgICAgaWYgbmRpZ2l0cyA+PSAoOjpGbG9hdDo6RElHICsgMikgLSAoZXhwID4gMCA/IGV4cCAvIDQgOiBleHAgLyAzIC0gMSlcbiAgICAgICAgcmV0dXJuIHNlbGZcbiAgICAgIGVuZFxuXG4gICAgICBpZiBuZGlnaXRzIDwgLShleHAgPiAwID8gZXhwIC8gMyArIDEgOiBleHAgLyA0KVxuICAgICAgICByZXR1cm4gMFxuICAgICAgZW5kXG5cbiAgICAgIGBNYXRoLnJvdW5kKHNlbGYgKiBNYXRoLnBvdygxMCwgbmRpZ2l0cykpIC8gTWF0aC5wb3coMTAsIG5kaWdpdHMpYFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgdGltZXMoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6dGltZXMpIHsgc2VsZiB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGY7IGkrKykge1xuICAgICAgICBibG9jayhpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0b19mXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdG9faVxuICAgIGBzZWxmIDwgMCA/IE1hdGguY2VpbChzZWxmKSA6IE1hdGguZmxvb3Ioc2VsZilgXG4gIGVuZFxuXG4gIGRlZiB0b19yXG4gICAgaWYgOjpJbnRlZ2VyID09PSBzZWxmXG4gICAgICA6OlJhdGlvbmFsLm5ldyhzZWxmLCAxKVxuICAgIGVsc2VcbiAgICAgIGYsIGUgID0gOjpNYXRoLmZyZXhwKHNlbGYpXG4gICAgICBmICAgICA9IDo6TWF0aC5sZGV4cChmLCA6OkZsb2F0OjpNQU5UX0RJRykudG9faVxuICAgICAgZSAgICAtPSA6OkZsb2F0OjpNQU5UX0RJR1xuXG4gICAgICAoZiAqICg6OkZsb2F0OjpSQURJWCoqZSkpLnRvX3JcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHRvX3MoYmFzZSA9IDEwKVxuICAgIGJhc2UgPSA6Ok9wYWwuY29lcmNlX3RvISBiYXNlLCA6OkludGVnZXIsIDp0b19pbnRcblxuICAgIGlmIGJhc2UgPCAyIHx8IGJhc2UgPiAzNlxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFkaXggI3tiYXNlfVwiXG4gICAgZW5kXG5cbiAgICAjIERvbid0IGxvc2UgdGhlIG5lZ2F0aXZlIHplcm9cbiAgICBpZiBzZWxmID09IDAgJiYgYDEvc2VsZiA9PT0gLUluZmluaXR5YFxuICAgICAgcmV0dXJuICctMC4wJ1xuICAgIGVuZFxuXG4gICAgYHNlbGYudG9TdHJpbmcoYmFzZSlgXG4gIGVuZFxuXG4gIGRlZiB0cnVuY2F0ZShuZGlnaXRzID0gMClcbiAgICAleHtcbiAgICAgIHZhciBmID0gI3t0b19mfTtcblxuICAgICAgaWYgKGYgJSAxID09PSAwICYmIG5kaWdpdHMgPj0gMCkge1xuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGZhY3RvciA9IE1hdGgucG93KDEwLCBuZGlnaXRzKSxcbiAgICAgICAgICByZXN1bHQgPSBwYXJzZUludChmICogZmFjdG9yLCAxMCkgLyBmYWN0b3I7XG5cbiAgICAgIGlmIChmICUgMSA9PT0gMCkge1xuICAgICAgICByZXN1bHQgPSBNYXRoLnJvdW5kKHJlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGlnaXRzKGJhc2UgPSAxMClcbiAgICBpZiBzZWxmIDwgMFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpNYXRoOjpEb21haW5FcnJvciwgJ291dCBvZiBkb21haW4nXG4gICAgZW5kXG5cbiAgICBiYXNlID0gOjpPcGFsLmNvZXJjZV90byEgYmFzZSwgOjpJbnRlZ2VyLCA6dG9faW50XG5cbiAgICBpZiBiYXNlIDwgMlxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFkaXggI3tiYXNlfVwiXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmICE9IHBhcnNlSW50KHNlbGYpKSAjezo6S2VybmVsLnJhaXNlIDo6Tm9NZXRob2RFcnJvciwgXCJ1bmRlZmluZWQgbWV0aG9kIGBkaWdpdHMnIGZvciAje2luc3BlY3R9XCJ9XG5cbiAgICAgIHZhciB2YWx1ZSA9IHNlbGYsIHJlc3VsdCA9IFtdO1xuXG4gICAgICBpZiAoc2VsZiA9PSAwKSB7XG4gICAgICAgIHJldHVybiBbMF07XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh2YWx1ZSAhPSAwKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlICUgYmFzZSk7XG4gICAgICAgIHZhbHVlID0gcGFyc2VJbnQodmFsdWUgLyBiYXNlLCAxMCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGl2bW9kKG90aGVyKVxuICAgIGlmIG5hbj8gfHwgb3RoZXIubmFuP1xuICAgICAgOjpLZXJuZWwucmFpc2UgOjpGbG9hdERvbWFpbkVycm9yLCAnTmFOJ1xuICAgIGVsc2lmIGluZmluaXRlP1xuICAgICAgOjpLZXJuZWwucmFpc2UgOjpGbG9hdERvbWFpbkVycm9yLCAnSW5maW5pdHknXG4gICAgZWxzZVxuICAgICAgc3VwZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHVwdG8oc3RvcCwgJmJsb2NrKVxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6dXB0bywgc3RvcCkgZG9cbiAgICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tzZWxmLmNsYXNzfSB3aXRoICN7c3RvcC5jbGFzc30gZmFpbGVkXCIgdW5sZXNzIDo6TnVtZXJpYyA9PT0gc3RvcFxuICAgICAgICBzdG9wIDwgc2VsZiA/IDAgOiBzdG9wIC0gc2VsZiArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoIXN0b3AuJCRpc19udW1iZXIpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje3NlbGYuY2xhc3N9IHdpdGggI3tzdG9wLmNsYXNzfSBmYWlsZWRcIn1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSBzZWxmOyBpIDw9IHN0b3A7IGkrKykge1xuICAgICAgICBibG9jayhpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB6ZXJvP1xuICAgIGBzZWxmID09IDBgXG4gIGVuZFxuXG4gICMgU2luY2UgYml0d2lzZSBvcGVyYXRpb25zIGFyZSAzMiBiaXQsIGRlY2xhcmUgaXQgdG8gYmUgc28uXG4gIGRlZiBzaXplXG4gICAgNFxuICBlbmRcblxuICBkZWYgbmFuP1xuICAgIGBpc05hTihzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIGZpbml0ZT9cbiAgICBgc2VsZiAhPSBJbmZpbml0eSAmJiBzZWxmICE9IC1JbmZpbml0eSAmJiAhaXNOYU4oc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBpbmZpbml0ZT9cbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09IEluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiArMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNlbGYgPT0gLUluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHBvc2l0aXZlP1xuICAgIGBzZWxmICE9IDAgJiYgKHNlbGYgPT0gSW5maW5pdHkgfHwgMSAvIHNlbGYgPiAwKWBcbiAgZW5kXG5cbiAgZGVmIG5lZ2F0aXZlP1xuICAgIGBzZWxmID09IC1JbmZpbml0eSB8fCAxIC8gc2VsZiA8IDBgXG4gIGVuZFxuXG4gICV4e1xuICAgIGZ1bmN0aW9uIG51bWJlclRvVWludDhBcnJheShudW0pIHtcbiAgICAgIHZhciB1aW50OGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gICAgICBuZXcgRGF0YVZpZXcodWludDhhcnJheS5idWZmZXIpLnNldEZsb2F0NjQoMCwgbnVtLCB0cnVlKTtcbiAgICAgIHJldHVybiB1aW50OGFycmF5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVpbnQ4QXJyYXlUb051bWJlcihhcnIpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlcikuZ2V0RmxvYXQ2NCgwLCB0cnVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbmNyZW1lbnROdW1iZXJCaXQobnVtKSB7XG4gICAgICB2YXIgYXJyID0gbnVtYmVyVG9VaW50OEFycmF5KG51bSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXJyW2ldID09PSAweGZmKSB7XG4gICAgICAgICAgYXJyW2ldID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcnJbaV0rKztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb051bWJlcihhcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlY3JlbWVudE51bWJlckJpdChudW0pIHtcbiAgICAgIHZhciBhcnIgPSBudW1iZXJUb1VpbnQ4QXJyYXkobnVtKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhcnJbaV0gPT09IDApIHtcbiAgICAgICAgICBhcnJbaV0gPSAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFycltpXS0tO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdWludDhBcnJheVRvTnVtYmVyKGFycik7XG4gICAgfVxuICB9XG5cbiAgZGVmIG5leHRfZmxvYXRcbiAgICByZXR1cm4gOjpGbG9hdDo6SU5GSU5JVFkgaWYgc2VsZiA9PSA6OkZsb2F0OjpJTkZJTklUWVxuICAgIHJldHVybiA6OkZsb2F0OjpOQU4gaWYgbmFuP1xuXG4gICAgaWYgc2VsZiA+PSAwXG4gICAgICAjIE1hdGguYWJzKCkgaXMgbmVlZGVkIHRvIGhhbmRsZSAtMC4wXG4gICAgICBgaW5jcmVtZW50TnVtYmVyQml0KE1hdGguYWJzKHNlbGYpKWBcbiAgICBlbHNlXG4gICAgICBgZGVjcmVtZW50TnVtYmVyQml0KHNlbGYpYFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgcHJldl9mbG9hdFxuICAgIHJldHVybiAtOjpGbG9hdDo6SU5GSU5JVFkgaWYgc2VsZiA9PSAtOjpGbG9hdDo6SU5GSU5JVFlcbiAgICByZXR1cm4gOjpGbG9hdDo6TkFOIGlmIG5hbj9cblxuICAgIGlmIHNlbGYgPiAwXG4gICAgICBgZGVjcmVtZW50TnVtYmVyQml0KHNlbGYpYFxuICAgIGVsc2VcbiAgICAgIGAtaW5jcmVtZW50TnVtYmVyQml0KE1hdGguYWJzKHNlbGYpKWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXMgYXJnIGFuZ2xlXG4gIGFsaWFzIGVxbD8gPT1cbiAgYWxpYXMgZmRpdiAvXG4gIGFsaWFzIGluc3BlY3QgdG9fc1xuICBhbGlhcyBraW5kX29mPyBpc19hP1xuICBhbGlhcyBtYWduaXR1ZGUgYWJzXG4gIGFsaWFzIG1vZHVsbyAlXG4gIGFsaWFzIG9iamVjdF9pZCBfX2lkX19cbiAgYWxpYXMgcGhhc2UgYW5nbGVcbiAgYWxpYXMgc3VjYyBuZXh0XG4gIGFsaWFzIHRvX2ludCB0b19pXG5lbmRcblxuOjpGaXhudW0gPSA6Ok51bWJlclxuXG5jbGFzcyA6OkludGVnZXIgPCA6Ok51bWVyaWNcbiAgYHNlbGYuJCRpc19udW1iZXJfY2xhc3MgPSB0cnVlYFxuICBgc2VsZi4kJGlzX2ludGVnZXJfY2xhc3MgPSB0cnVlYFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgYWxsb2NhdGVcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImFsbG9jYXRvciB1bmRlZmluZWQgZm9yICN7bmFtZX1cIlxuICAgIGVuZFxuXG4gICAgdW5kZWYgOm5ld1xuXG4gICAgZGVmIHNxcnQobilcbiAgICAgIG4gPSA6Ok9wYWwuY29lcmNlX3RvIShuLCA6OkludGVnZXIsIDp0b19pbnQpXG4gICAgICAleHtcbiAgICAgICAgaWYgKG4gPCAwKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6Ok1hdGg6OkRvbWFpbkVycm9yLCAnTnVtZXJpY2FsIGFyZ3VtZW50IGlzIG91dCBvZiBkb21haW4gLSBcImlzcXJ0XCInfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KE1hdGguc3FydChuKSwgMTApO1xuICAgICAgfVxuICAgIGVuZFxuXG4gICAgZGVmIHRyeV9jb252ZXJ0KG9iamVjdClcbiAgICAgIE9wYWwuY29lcmNlX3RvPyhvYmplY3QsIHNlbGYsIDp0b19pbnQpXG4gICAgZW5kXG4gIGVuZFxuXG4gIHNlbGY6Ok1BWCA9IGBNYXRoLnBvdygyLCAzMCkgLSAxYFxuICBzZWxmOjpNSU4gPSBgLU1hdGgucG93KDIsIDMwKWBcbmVuZFxuXG5jbGFzcyA6OkZsb2F0IDwgOjpOdW1lcmljXG4gIGBzZWxmLiQkaXNfbnVtYmVyX2NsYXNzID0gdHJ1ZWBcblxuICBjbGFzcyA8PCBzZWxmXG4gICAgZGVmIGFsbG9jYXRlXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJhbGxvY2F0b3IgdW5kZWZpbmVkIGZvciAje25hbWV9XCJcbiAgICBlbmRcblxuICAgIHVuZGVmIDpuZXdcblxuICAgIGRlZiA9PT0ob3RoZXIpXG4gICAgICBgISFvdGhlci4kJGlzX251bWJlcmBcbiAgICBlbmRcbiAgZW5kXG5cbiAgc2VsZjo6SU5GSU5JVFkgPSBgSW5maW5pdHlgXG4gIHNlbGY6Ok1BWCAgICAgID0gYE51bWJlci5NQVhfVkFMVUVgXG4gIHNlbGY6Ok1JTiAgICAgID0gYE51bWJlci5NSU5fVkFMVUVgXG4gIHNlbGY6Ok5BTiAgICAgID0gYE5hTmBcblxuICBzZWxmOjpESUcgICAgICA9IDE1XG4gIHNlbGY6Ok1BTlRfRElHID0gNTNcbiAgc2VsZjo6UkFESVggICAgPSAyXG5cbiAgc2VsZjo6RVBTSUxPTiA9IGBOdW1iZXIuRVBTSUxPTiB8fCAyLjIyMDQ0NjA0OTI1MDMxMzA4MDg0NzI2MzMzNjE4MTZFLTE2YFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOk51bWJlcj4iLCJPcGFsIiwiYnJpZGdlIiwiYWxsb2NhdGUiLCJLZXJuZWwiLCJyYWlzZSIsIlR5cGVFcnJvciIsIm5hbWUiLCJjb2VyY2UiLCJvdGhlciIsImNsYXNzIiwiRmxvYXQiLCJyZXNwb25kX3RvPyIsImNvZXJjZV90byEiLCJfX2lkX18iLCJoYXNoIiwiKyIsIl9fY29lcmNlZF9fIiwiLSIsIioiLCIvIiwiJSIsIlplcm9EaXZpc2lvbkVycm9yIiwiJiIsInwiLCJeIiwiPCIsIjw9IiwiPiIsIj49IiwiPD0+IiwiQXJndW1lbnRFcnJvciIsIjw8IiwiY291bnQiLCJJbnRlZ2VyIiwiPj4iLCJbXSIsImJpdCIsIitAIiwiLUAiLCJ+IiwiKioiLCI9PT0iLCIwIiwiUmF0aW9uYWwiLCJuZXciLCIxIiwiQ29tcGxleCIsInRvX2YiLCI9PSIsImFicyIsImFiczIiLCJhbGxiaXRzPyIsIm1hc2siLCJhbnliaXRzPyIsImFuZ2xlIiwibmFuPyIsImJpdF9sZW5ndGgiLCJOb01ldGhvZEVycm9yIiwiY2VpbCIsIm5kaWdpdHMiLCJjaHIiLCJlbmNvZGluZyIsImRlbm9taW5hdG9yIiwiaW5maW5pdGU/IiwiZG93bnRvIiwic3RvcCIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwiYmxvY2sgaW4gZG93bnRvIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkb3dudG8iLCJOdW1lcmljIiwiZXF1YWw/IiwiJHJldF9vcl8xIiwiZXZlbj8iLCJmbG9vciIsImdjZCIsImdjZGxjbSIsImxjbSIsImludGVnZXI/IiwiaXNfYT8iLCJrbGFzcyIsImluc3RhbmNlX29mPyIsIm5leHQiLCJub2JpdHM/Iiwibm9uemVybz8iLCJudW1lcmF0b3IiLCJvZGQ/Iiwib3JkIiwicG93IiwiYiIsIm0iLCJwcmVkIiwicXVvIiwicmF0aW9uYWxpemUiLCJlcHMiLCJGbG9hdERvbWFpbkVycm9yIiwiTWF0aCIsImZyZXhwIiwiZiIsIm4iLCJsZGV4cCIsIkZsb2F0OjpNQU5UX0RJRyIsInRvX2kiLCIyIiwidG9fciIsInJlbWFpbmRlciIsInkiLCJ0cnVuY2F0ZSIsInJvdW5kIiwiUmFuZ2VFcnJvciIsIkludGVnZXI6Ok1JTiIsInNpemUiLCJfIiwiZXhwIiwiRmxvYXQ6OkRJRyIsIjQiLCIzIiwidGltZXMiLCJibG9jayIsImJsb2NrIGluIHRpbWVzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0aW1lcyIsImUiLCJGbG9hdDo6UkFESVgiLCJ0b19zIiwiYmFzZSIsIjEwIiwiMzYiLCJkaWdpdHMiLCJNYXRoOjpEb21haW5FcnJvciIsImluc3BlY3QiLCJkaXZtb2QiLCJ1cHRvIiwiYmxvY2sgaW4gdXB0byIsImJsb2NrICgyIGxldmVscykgaW4gdXB0byIsInplcm8/IiwiZmluaXRlPyIsInBvc2l0aXZlPyIsIm5lZ2F0aXZlPyIsIm5leHRfZmxvYXQiLCJGbG9hdDo6SU5GSU5JVFkiLCJGbG9hdDo6TkFOIiwicHJldl9mbG9hdCIsIk51bWJlciIsIjxjbGFzczpJbnRlZ2VyPiIsInNxcnQiLCJ0cnlfY29udmVydCIsIm9iamVjdCIsImNvZXJjZV90bz8iLCI8Y2xhc3M6RmxvYXQ+IiwiMTUiLCI1MyJdLCJtYXBwaW5ncyI6IkFBQUFBLGlDQUFBQSxnQkFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBOztFQUdBQyxJQUFBQyxTQUFBQSxDQUFRRixpQkFBUkU7RUFFQUM7RUFBQUE7O0lBQUFBOzs7SUFDRUMsS0FBTUMsUUFBQUEsQ0FBU0YsTUFBZixFQUF3QkYsSUFBbEJJO0lBQ0xGO0lBQ0FBO0lBQ0FBO0lBRUQ7Ozs7QUFDRUcsTUFBQUEsd0JBQUFBLG9CQUFBQTtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBQUMsT0FBUUMsT0FBQUEsQ0FBT0MsZ0JBQWYsRUFBNkJILDBCQUFELEdBQUEsQ0FBMkJMLElBQUFTLE1BQUFBLENBQUFBLENBQTNCLENBQXBCRjtNQURWRixDQUFBQTs7O01BSUEsc0JBQU0sS0FBTjtNQWhCSixPQUFBO0lBV0UsNEJBQVNMLElBQVQ7O0FBUUFVLElBQUFBLHNCQUFBQSxrQkFBV0MsS0FBWEQ7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQSxRQUFVSixPQUFRQyxPQUFBQSxDQUFPQyxn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QUFBQTtJQVBGLDRCQUFTNUMsSUFBVDtJQVlBLFdBQUFBLElBQUEsY0FBa0J1SixRQUFsQjtJQUNBLFdBQUF2SixJQUFBLFNBQWtCdUosZ0JBQWxCO0lBQ0EsV0FBQXZKLElBQUEsU0FBa0J1SixnQkFBbEI7SUFDQSxXQUFBdkosSUFBQSxTQUFrQnVKLEdBQWxCO0lBRUEsV0FBQXZKLElBQUEsU0FBaUJ3SixFQUFqQjtJQUNBLFdBQUF4SixJQUFBLGNBQWlCeUosRUFBakI7SUFDQSxXQUFBekosSUFBQSxXQUFpQjBHLENBQWpCO0lBRUE2QyxPQUFBLFdBQUF2SixJQUFBLGFBQWlCdUosdURBQWpCO0VBeEJGQSxHQUFNLElBQU5BLEVBQWdCOUUsY0FBaEI4RTtBQS82QkF4SjsifX0seyJvZmZzZXQiOnsibGluZSI6MTgzMTksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3JhbmdlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxuXG5yZXF1aXJlICdjb3JlbGliL2VudW1lcmFibGUnXG5cbmNsYXNzIDo6UmFuZ2VcbiAgaW5jbHVkZSA6OkVudW1lcmFibGVcblxuICBgc2VsZi4kJHByb3RvdHlwZS4kJGlzX3JhbmdlID0gdHJ1ZWBcblxuICBhdHRyX3JlYWRlciA6YmVnaW4sIDplbmRcblxuICBkZWYgaW5pdGlhbGl6ZShmaXJzdCwgbGFzdCwgZXhjbHVkZSA9IGZhbHNlKVxuICAgIDo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLCBcIidpbml0aWFsaXplJyBjYWxsZWQgdHdpY2VcIiBpZiBAYmVnaW5cbiAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdiYWQgdmFsdWUgZm9yIHJhbmdlJyB1bmxlc3MgZmlyc3QgPD0+IGxhc3QgfHwgZmlyc3QubmlsPyB8fCBsYXN0Lm5pbD9cblxuICAgIEBiZWdpbiA9IGZpcnN0XG4gICAgQGVuZCAgID0gbGFzdFxuICAgIEBleGNsICA9IGV4Y2x1ZGVcbiAgZW5kXG5cbiAgZGVmID09PSh2YWx1ZSlcbiAgICByZXR1cm4gZmFsc2UgaWYgYHZhbHVlLiQkaXNfcmFuZ2VgXG4gICAgY292ZXI/IHZhbHVlXG4gIGVuZFxuXG4gICV4e1xuICAgIGZ1bmN0aW9uIGlzX2luZmluaXRlKHNlbGYpIHtcbiAgICAgIGlmIChzZWxmLmJlZ2luID09PSBuaWwgfHwgc2VsZi5lbmQgPT09IG5pbCB8fFxuICAgICAgICAgIHNlbGYuYmVnaW4gPT09IC1JbmZpbml0eSB8fCBzZWxmLmVuZCA9PT0gSW5maW5pdHkgfHxcbiAgICAgICAgICBzZWxmLmJlZ2luID09PSBJbmZpbml0eSB8fCBzZWxmLmVuZCA9PT0gLUluZmluaXR5KSByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBkZWYgY291bnQoJmJsb2NrKVxuICAgIGlmICFibG9ja19naXZlbj8gJiYgYGlzX2luZmluaXRlKHNlbGYpYFxuICAgICAgcmV0dXJuIDo6RmxvYXQ6OklORklOSVRZXG4gICAgZW5kXG4gICAgc3VwZXJcbiAgZW5kXG5cbiAgZGVmIHRvX2FcbiAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ2Nhbm5vdCBjb252ZXJ0IGVuZGxlc3MgcmFuZ2UgdG8gYW4gYXJyYXknIGlmIGBpc19pbmZpbml0ZShzZWxmKWBcbiAgICBzdXBlclxuICBlbmRcblxuICBkZWYgY292ZXI/KHZhbHVlKVxuICAgIGNvbXBhcmUgPSAtPihhLCBiKSB7XG4gICAgICBhIDw9PiBiIHx8IDFcbiAgICB9XG5cbiAgICBpZiBgdmFsdWUuJCRpc19yYW5nZWBcbiAgICAgIHZhbF9iZWdpbiA9IHZhbHVlLmJlZ2luXG4gICAgICB2YWxfZW5kID0gdmFsdWUuZW5kXG4gICAgICB2YWxfZXhjbCA9IHZhbHVlLmV4Y2x1ZGVfZW5kP1xuICAgICAgaWYgKEBiZWdpbiAmJiB2YWxfYmVnaW4ubmlsPykgfHxcbiAgICAgICAgIChAZW5kICYmIHZhbF9lbmQubmlsPykgfHxcbiAgICAgICAgICh2YWxfYmVnaW4gJiYgdmFsX2VuZCAmJiBjb21wYXJlLmNhbGwodmFsX2JlZ2luLCB2YWxfZW5kKS50aGVuIHsgfGN8IHZhbF9leGNsID8gYyA+PSAwIDogYyA+IDAgfSkgfHxcbiAgICAgICAgICh2YWxfYmVnaW4gJiYgIWNvdmVyPyh2YWxfYmVnaW4pKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIGVuZFxuXG4gICAgICBjbXAgPSBjb21wYXJlLmNhbGwoQGVuZCwgdmFsX2VuZClcbiAgICAgIHJldHVybiBjbXAgPj0gMCBpZiBAZXhjbCA9PSB2YWxfZXhjbFxuICAgICAgcmV0dXJuIGNtcCA+IDAgaWYgQGV4Y2xcbiAgICAgIHJldHVybiB0cnVlIGlmIGNtcCA+PSAwXG5cbiAgICAgIHZhbF9tYXggPSB2YWx1ZS5tYXhcbiAgICAgIHJldHVybiAhdmFsX21heC5uaWw/ICYmIGNvbXBhcmUuY2FsbCh2YWxfbWF4LCBAZW5kKSA8PSAwXG4gICAgZW5kXG5cbiAgICByZXR1cm4gZmFsc2UgaWYgQGJlZ2luICYmIGNvbXBhcmUuY2FsbChAYmVnaW4sIHZhbHVlKSA+IDBcbiAgICByZXR1cm4gdHJ1ZSBpZiBAZW5kLm5pbD9cbiAgICBlbmRfY21wID0gY29tcGFyZS5jYWxsKHZhbHVlLCBAZW5kKVxuICAgIEBleGNsID8gZW5kX2NtcCA8IDAgOiBlbmRfY21wIDw9IDBcbiAgZW5kXG5cbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbGltaXQ7XG5cbiAgICAgIGlmICgje0BiZWdpbn0uJCRpc19udW1iZXIgJiYgI3tAZW5kfS4kJGlzX251bWJlcikge1xuICAgICAgICBpZiAoI3tAYmVnaW59ICUgMSAhPT0gMCB8fCAje0BlbmR9ICUgMSAhPT0gMCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiY2FuJ3QgaXRlcmF0ZSBmcm9tIEZsb2F0XCJ9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAje0BiZWdpbn0sIGxpbWl0ID0gI3tAZW5kfSArICN7QGV4Y2wgPyAwIDogMX07IGkgPCBsaW1pdDsgaSsrKSB7XG4gICAgICAgICAgYmxvY2soaSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgaWYgKCN7QGJlZ2lufS4kJGlzX3N0cmluZyAmJiAje0BlbmR9LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICN7QGJlZ2luLnVwdG8oQGVuZCwgQGV4Y2wsICZibG9jayl9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN1cnJlbnQgPSBAYmVnaW5cbiAgICBsYXN0ICAgID0gQGVuZFxuXG4gICAgdW5sZXNzIGN1cnJlbnQucmVzcG9uZF90bz8oOnN1Y2MpXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJjYW4ndCBpdGVyYXRlIGZyb20gI3tjdXJyZW50LmNsYXNzfVwiXG4gICAgZW5kXG5cbiAgICB3aGlsZSBAZW5kLm5pbD8gfHwgKGN1cnJlbnQgPD0+IGxhc3QpIDwgMFxuICAgICAgeWllbGQgY3VycmVudFxuXG4gICAgICBjdXJyZW50ID0gY3VycmVudC5zdWNjXG4gICAgZW5kXG5cbiAgICB5aWVsZCBjdXJyZW50IGlmICFAZXhjbCAmJiBjdXJyZW50ID09IGxhc3RcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVxbD8ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyA6OlJhbmdlID09PSBvdGhlclxuXG4gICAgQGV4Y2wgPT09IG90aGVyLmV4Y2x1ZGVfZW5kPyAmJlxuICAgICAgQGJlZ2luLmVxbD8ob3RoZXIuYmVnaW4pICYmXG4gICAgICBAZW5kLmVxbD8ob3RoZXIuZW5kKVxuICBlbmRcblxuICBkZWYgZXhjbHVkZV9lbmQ/XG4gICAgQGV4Y2xcbiAgZW5kXG5cbiAgZGVmIGZpcnN0KG4gPSB1bmRlZmluZWQpXG4gICAgOjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCAnY2Fubm90IGdldCB0aGUgbWluaW11bSBvZiBiZWdpbmxlc3MgcmFuZ2UnIGlmIEBiZWdpbi5uaWw/XG4gICAgcmV0dXJuIEBiZWdpbiBpZiBgbiA9PSBudWxsYFxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlPyh2YWwpXG4gICAgaWYgYHNlbGYuYmVnaW4uJCRpc19udW1iZXIgfHwgc2VsZi5lbmQuJCRpc19udW1iZXJgIHx8XG4gICAgICAgQGJlZ2luLmlzX2E/KDo6VGltZSkgfHwgQGVuZC5pc19hPyg6OlRpbWUpIHx8XG4gICAgICAgOjpJbnRlZ2VyLnRyeV9jb252ZXJ0KEBiZWdpbikgfHwgOjpJbnRlZ2VyLnRyeV9jb252ZXJ0KEBlbmQpXG4gICAgICByZXR1cm4gY292ZXI/KHZhbClcbiAgICBlbmRcblxuICAgIGlmIGBzZWxmLmJlZ2luLiQkaXNfc3RyaW5nIHx8IHNlbGYuZW5kLiQkaXNfc3RyaW5nYFxuICAgICAgaWYgYHNlbGYuYmVnaW4uJCRpc19zdHJpbmcgJiYgc2VsZi5lbmQuJCRpc19zdHJpbmdgXG4gICAgICAgIHJldHVybiBAYmVnaW4udXB0byhAZW5kLCBAZXhjbCkuYW55PyB7IHxzfCBzID09IHZhbCB9XG4gICAgICBlbHNpZiBAYmVnaW4ubmlsP1xuICAgICAgICBjbXAgPSB2YWwgPD0+IEBlbmRcbiAgICAgICAgcmV0dXJuICFjbXAubmlsPyAmJiAoQGV4Y2wgPyBjbXAgPCAwIDogY21wIDw9IDApXG4gICAgICBlbHNpZiBAZW5kLm5pbD9cbiAgICAgICAgY21wID0gQGJlZ2luIDw9PiB2YWxcbiAgICAgICAgcmV0dXJuICFjbXAubmlsPyAmJiBjbXAgPD0gMFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAjIGludm9rZSBFbnVtZXJhYmxlI2luY2x1ZGU/XG4gICAgc3VwZXJcbiAgZW5kXG5cbiAgZGVmIGxhc3QobiA9IHVuZGVmaW5lZClcbiAgICA6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsICdjYW5ub3QgZ2V0IHRoZSBtYXhpbXVtIG9mIGVuZGxlc3MgcmFuZ2UnIGlmIEBlbmQubmlsP1xuICAgIHJldHVybiBAZW5kIGlmIGBuID09IG51bGxgXG4gICAgdG9fYS5sYXN0KG4pXG4gIGVuZFxuXG4gICMgRklYTUU6IGN1cnJlbnRseSBoYXJkY29kZWQgdG8gYXNzdW1lIHJhbmdlIGhvbGRzIG51bWVyaWNzXG4gIGRlZiBtYXhcbiAgICBpZiBAZW5kLm5pbD9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgJ2Nhbm5vdCBnZXQgdGhlIG1heGltdW0gb2YgZW5kbGVzcyByYW5nZSdcbiAgICBlbHNpZiBibG9ja19naXZlbj9cbiAgICAgIHN1cGVyXG4gICAgZWxzaWYgIUBiZWdpbi5uaWw/ICYmIChAYmVnaW4gPiBAZW5kIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBAZXhjbCAmJiBAYmVnaW4gPT0gQGVuZClcbiAgICAgIG5pbFxuICAgIGVsc2VcbiAgICAgIGAje0BleGNsfSA/ICN7QGVuZH0gLSAxIDogI3tAZW5kfWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIG1pblxuICAgIGlmIEBiZWdpbi5uaWw/XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsICdjYW5ub3QgZ2V0IHRoZSBtaW5pbXVtIG9mIGJlZ2lubGVzcyByYW5nZSdcbiAgICBlbHNpZiBibG9ja19naXZlbj9cbiAgICAgIHN1cGVyXG4gICAgZWxzaWYgIUBlbmQubmlsPyAmJiAoQGJlZ2luID4gQGVuZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIEBleGNsICYmIEBiZWdpbiA9PSBAZW5kKVxuICAgICAgbmlsXG4gICAgZWxzZVxuICAgICAgQGJlZ2luXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzaXplXG4gICAgJXh7XG4gICAgICB2YXIgYiA9IHRoaXMuYmVnaW4sIGUgPSB0aGlzLmVuZDtcblxuICAgICAgLy8gSWYgYmVnaW4gaXMgTnVtZXJpY1xuICAgICAgaWYgKCN7OjpOdW1lcmljID09PSBgYmB9KSB7XG4gICAgICAgIC8vIElmIGVuZCBpcyBOdW1lcmljXG4gICAgICAgIGlmICgjezo6TnVtZXJpYyA9PT0gYGVgfSkge1xuICAgICAgICAgIC8vIENhbGN1bGF0aW5nIHNpemUgYmFzZWQgb24gd2hldGhlciByYW5nZSBpcyBleGNsdXNpdmUgb3IgaW5jbHVzaXZlXG4gICAgICAgICAgdmFyIHNpemUgPSAje2BlYCAtIGBiYH07XG4gICAgICAgICAgaWYgKHNpemUgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLmV4Y2wpIHtcbiAgICAgICAgICAgIHNpemUgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICgjezo6RmxvYXQgPT09IGBiYH0gfHwgI3s6OkZsb2F0ID09PSBgZWB9KSA/IE1hdGguZmxvb3Ioc2l6ZSkgOiBzaXplO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGVuZCBpcyBuaWxcbiAgICAgICAgZWxzZSBpZiAoZSA9PT0gbmlsKSB7XG4gICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBJZiBiZWdpbiBpcyBuaWxcbiAgICAgIGVsc2UgaWYgKGIgPT09IG5pbCkge1xuICAgICAgICAvLyBJZiBlbmQgaXMgTnVtZXJpY1xuICAgICAgICBpZiAoI3s6Ok51bWVyaWMgPT09IGBlYH0pIHtcbiAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgbmVpdGhlciBiZWdpbiBub3IgZW5kIGlzIE51bWVyaWNcbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3RlcChuID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgZnVuY3Rpb24gY29lcmNlU3RlcFNpemUoKSB7XG4gICAgICAgIGlmIChuID09IG51bGwpIHtcbiAgICAgICAgICBuID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghbi4kJGlzX251bWJlcikge1xuICAgICAgICAgIG4gPSAjezo6T3BhbC5jb2VyY2VfdG8hKG4sIDo6SW50ZWdlciwgOnRvX2ludCl9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobiA8IDApIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJzdGVwIGNhbid0IGJlIG5lZ2F0aXZlXCJ9XG4gICAgICAgIH0gZWxzZSBpZiAobiA9PT0gMCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcInN0ZXAgY2FuJ3QgYmUgMFwifVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGVudW1lcmF0b3JTaXplKCkge1xuICAgICAgICBpZiAoISN7QGJlZ2luLnJlc3BvbmRfdG8/KDpzdWNjKX0pIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCN7QGJlZ2lufS4kJGlzX3N0cmluZyAmJiAje0BlbmR9LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuICUgMSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiAjeyhzaXplIC8gbikuY2VpbH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbiBpcyBhIGZsb2F0XG4gICAgICAgICAgdmFyIGJlZ2luID0gc2VsZi5iZWdpbiwgZW5kID0gc2VsZi5lbmQsXG4gICAgICAgICAgICAgIGFicyA9IE1hdGguYWJzLCBmbG9vciA9IE1hdGguZmxvb3IsXG4gICAgICAgICAgICAgIGVyciA9IChhYnMoYmVnaW4pICsgYWJzKGVuZCkgKyBhYnMoZW5kIC0gYmVnaW4pKSAvIGFicyhuKSAqICN7OjpGbG9hdDo6RVBTSUxPTn0sXG4gICAgICAgICAgICAgIHNpemU7XG5cbiAgICAgICAgICBpZiAoZXJyID4gMC41KSB7XG4gICAgICAgICAgICBlcnIgPSAwLjU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlbGYuZXhjbCkge1xuICAgICAgICAgICAgc2l6ZSA9IGZsb29yKChlbmQgLSBiZWdpbikgLyBuIC0gZXJyKTtcbiAgICAgICAgICAgIGlmIChzaXplICogbiArIGJlZ2luIDwgZW5kKSB7XG4gICAgICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2l6ZSA9IGZsb29yKChlbmQgLSBiZWdpbikgLyBuICsgZXJyKSArIDFcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIGlmIChAYmVnaW4uaXNfYT8oTnVtZXJpYykgfHwgQGJlZ2luLm5pbD8pICYmXG4gICAgICAgICAoQGVuZC5pc19hPyhOdW1lcmljKSB8fCBAZW5kLm5pbD8pICYmXG4gICAgICAgICAhKEBiZWdpbi5uaWw/ICYmIEBlbmQubmlsPylcblxuICAgICAgICByZXR1cm4gOjpFbnVtZXJhdG9yOjpBcml0aG1ldGljU2VxdWVuY2UubmV3KHNlbGYsIG4sIDpzdGVwKVxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gZW51bV9mb3IoOnN0ZXAsIG4pIGRvXG4gICAgICAgICAgJXh7XG4gICAgICAgICAgICBjb2VyY2VTdGVwU2l6ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGVudW1lcmF0b3JTaXplKCk7XG4gICAgICAgICAgfVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgYGNvZXJjZVN0ZXBTaXplKClgXG5cbiAgICBpZiBgc2VsZi5iZWdpbi4kJGlzX251bWJlciAmJiBzZWxmLmVuZC4kJGlzX251bWJlcmBcbiAgICAgIGkgPSAwXG4gICAgICBsb29wIGRvXG4gICAgICAgIGN1cnJlbnQgPSBAYmVnaW4gKyBpICogblxuICAgICAgICBpZiBAZXhjbFxuICAgICAgICAgIGJyZWFrIGlmIGN1cnJlbnQgPj0gQGVuZFxuICAgICAgICBlbHNpZiBjdXJyZW50ID4gQGVuZFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGVuZFxuICAgICAgICB5aWVsZChjdXJyZW50KVxuICAgICAgICBpICs9IDFcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgICV4e1xuICAgICAgICBpZiAoI3tAYmVnaW59LiQkaXNfc3RyaW5nICYmICN7QGVuZH0uJCRpc19zdHJpbmcgJiYgbiAlIDEgIT09IDApIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnbm8gaW1wbGljaXQgY29udmVyc2lvbiB0byBmbG9hdCBmcm9tIHN0cmluZyd9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVhY2hfd2l0aF9pbmRleCBkbyB8dmFsdWUsIGlkeHxcbiAgICAgICAgeWllbGQodmFsdWUpIGlmIGlkeCAlIG4gPT0gMFxuICAgICAgZW5kXG4gICAgZW5kXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgJShuKVxuICAgIGlmIEBiZWdpbi5pc19hPyhOdW1lcmljKSAmJiBAZW5kLmlzX2E/KE51bWVyaWMpXG4gICAgICA6OkVudW1lcmF0b3I6OkFyaXRobWV0aWNTZXF1ZW5jZS5uZXcoc2VsZiwgbiwgOiUpXG4gICAgZWxzZVxuICAgICAgc3RlcChuKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgYnNlYXJjaCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpic2VhcmNoKSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBpZiBgaXNfaW5maW5pdGUoc2VsZikgJiYgKHNlbGYuYmVnaW4uJCRpc19udW1iZXIgfHwgc2VsZi5lbmQuJCRpc19udW1iZXIpYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpOb3RJbXBsZW1lbnRlZEVycm9yLCBcIkNhbid0ICNic2VhcmNoIGFuIGluZmluaXRlIHJhbmdlXCJcbiAgICBlbmRcblxuICAgIHVubGVzcyBgc2VsZi5iZWdpbi4kJGlzX251bWJlciAmJiBzZWxmLmVuZC4kJGlzX251bWJlcmBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcImNhbid0IGRvIGJpbmFyeSBzZWFyY2ggZm9yICN7QGJlZ2luLmNsYXNzfVwiXG4gICAgZW5kXG5cbiAgICB0b19hLmJzZWFyY2goJmJsb2NrKVxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIFwiI3tAYmVnaW4gfHwgJyd9I3tAZXhjbCA/ICcuLi4nIDogJy4uJ30je0BlbmQgfHwgJyd9XCJcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBcIiN7QGJlZ2luICYmIEBiZWdpbi5pbnNwZWN0fSN7QGV4Y2wgPyAnLi4uJyA6ICcuLid9I3tAZW5kICYmIEBlbmQuaW5zcGVjdH1cIlxuICBlbmRcblxuICBkZWYgbWFyc2hhbF9sb2FkKGFyZ3MpXG4gICAgQGJlZ2luID0gYXJnc1s6YmVnaW5dXG4gICAgQGVuZCA9IGFyZ3NbOmVuZF1cbiAgICBAZXhjbCA9IGFyZ3NbOmV4Y2xdXG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgWzo6UmFuZ2UsIEBiZWdpbiwgQGVuZCwgQGV4Y2xdLmhhc2hcbiAgZW5kXG5cbiAgYWxpYXMgPT0gZXFsP1xuICBhbGlhcyBtZW1iZXI/IGluY2x1ZGU/XG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6UmFuZ2U+IiwiaW5jbHVkZSIsIkVudW1lcmFibGUiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJmaXJzdCIsImxhc3QiLCJleGNsdWRlIiwiQGJlZ2luIiwiS2VybmVsIiwicmFpc2UiLCJOYW1lRXJyb3IiLCI8PT4iLCJuaWw/IiwiQXJndW1lbnRFcnJvciIsIkBlbmQiLCJAZXhjbCIsIj09PSIsInZhbHVlIiwiY292ZXI/IiwiY291bnQiLCJibG9ja19naXZlbj8iLCJGbG9hdDo6SU5GSU5JVFkiLCJGbG9hdCIsInRvX2EiLCJUeXBlRXJyb3IiLCJjb21wYXJlIiwiYmxvY2sgaW4gY292ZXI/IiwiYSIsImIiLCJibG9jayAoMiBsZXZlbHMpIGluIGNvdmVyPyIsIiRyZXRfb3JfMSIsIjEiLCJ2YWxfYmVnaW4iLCJiZWdpbiIsInZhbF9lbmQiLCJlbmQiLCJ2YWxfZXhjbCIsImV4Y2x1ZGVfZW5kPyIsInRoZW4iLCJjYWxsIiwiYyIsIj49IiwiMCIsIj4iLCJjbXAiLCJ2YWxfbWF4IiwibWF4IiwiISIsIjw9IiwiZW5kX2NtcCIsIjwiLCJlYWNoIiwiZW51bV9mb3IiLCJibG9jayBpbiBlYWNoIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoIiwic2l6ZSIsInVwdG8iLCJibG9jayIsInRvX3Byb2MiLCJjdXJyZW50IiwicmVzcG9uZF90bz8iLCJjbGFzcyIsInN1Y2MiLCJlcWw/Iiwib3RoZXIiLCJSYW5nZSIsIiRyZXRfb3JfMiIsIm4iLCJSYW5nZUVycm9yIiwiaW5jbHVkZT8iLCJ2YWwiLCJpc19hPyIsIlRpbWUiLCJJbnRlZ2VyIiwidHJ5X2NvbnZlcnQiLCJhbnk/IiwiYmxvY2sgaW4gaW5jbHVkZT8iLCJzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbmNsdWRlPyIsIj09IiwibWluIiwiTnVtZXJpYyIsIi0iLCJzdGVwIiwiT3BhbCIsImNvZXJjZV90byEiLCIvIiwiY2VpbCIsIkZsb2F0OjpFUFNJTE9OIiwiRW51bWVyYXRvcjo6QXJpdGhtZXRpY1NlcXVlbmNlIiwiRW51bWVyYXRvciIsIm5ldyIsImJsb2NrIGluIHN0ZXAiLCJibG9jayAoMiBsZXZlbHMpIGluIHN0ZXAiLCJpIiwibG9vcCIsIisiLCIqIiwiZWFjaF93aXRoX2luZGV4IiwiaWR4IiwiJSIsImJzZWFyY2giLCJOb3RJbXBsZW1lbnRlZEVycm9yIiwidG9fcyIsImluc3BlY3QiLCJtYXJzaGFsX2xvYWQiLCJhcmdzIiwiW10iLCJoYXNoIl0sIm1hcHBpbmdz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Q0FBOUIsQ0FBQSxHQUFBLENBQXFELENBQUEsUUFBQTFFLENBQUFBLFlBQUFoQixRQUFBZ0IsQ0FBQSxDQUFBLEdBQUEsQ0FBUWhCLFFBQUkwRixTQUFBQSxDQUFBQSxDQUFaLElBQUEsQ0FBQSxTQUFBLENBQUEsQ0FBckQ7SUFERkEsQ0FBQUE7O0FBSUFDLElBQUFBLDRCQUFBQSx3QkFBaUJDLElBQWpCRDtBQUFBQSxNQUFBQTs7O01BQ0VsRyxhQUFTbUcsSUFBSUMsT0FBQUEsQ0FBQyxPQUFEQTtNQUNiN0YsV0FBTzRGLElBQUlDLE9BQUFBLENBQUMsS0FBREE7TUFDWEYsT0FBQTFGLENBQUFBLFlBQVEyRixJQUFJQyxPQUFBQSxDQUFDLE1BQURBLENBQVo1RjtJQUhGMEYsQ0FBQUE7O0FBTUFHLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUEsQ0FBQzNDLFlBQUQsRUFBVTFELFVBQVYsRUFBa0JPLFFBQWxCLEVBQXdCQyxTQUF4QixDQUE4QjZGLE1BQUFBLENBQUFBO0lBRGhDQSxDQUFBQTtJQUlBLGFBQU0sSUFBTixFQUFTLE1BQVQ7SUFDQTdHLE9BQUEsYUFBTSxTQUFOLEVBQWMsVUFBZDtFQTFXRkEsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQUpBSDsifX0seyJvZmZzZXQiOnsibGluZSI6MTg4MDUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3Byb2MucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBzbGljZSwgZWFjaF9pdmFyXG4jIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcblxuY2xhc3MgOjpQcm9jIDwgYEZ1bmN0aW9uYFxuICBgT3BhbC5wcm9wKHNlbGYuJCRwcm90b3R5cGUsICckJGlzX3Byb2MnLCB0cnVlKWBcbiAgYE9wYWwucHJvcChzZWxmLiQkcHJvdG90eXBlLCAnJCRpc19sYW1iZGEnLCBmYWxzZSlgXG5cbiAgZGVmIHNlbGYubmV3KCZibG9jaylcbiAgICB1bmxlc3MgYmxvY2tcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNyZWF0ZSBhIFByb2Mgb2JqZWN0IHdpdGhvdXQgYSBibG9jaydcbiAgICBlbmRcblxuICAgIGJsb2NrXG4gIGVuZFxuXG4gICV4e1xuICAgIGZ1bmN0aW9uICRjYWxsX2xhbWJkYShzZWxmLCBhcmdzKSB7XG4gICAgICBpZiAoc2VsZi4kJHJldCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBzZWxmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyID09PSBzZWxmLiQkcmV0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyLiR2O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkY2FsbF9wcm9jKHNlbGYsIGFyZ3MpIHtcbiAgICAgIGlmIChzZWxmLiQkYnJrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIE9wYWwueWllbGRYKHNlbGYsIGFyZ3MpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyID09PSBzZWxmLiQkYnJrKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyLiR2O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3BhbC55aWVsZFgoc2VsZiwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGVmIGNhbGwoKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSBzZWxmLiQkcCA9IGJsb2NrO1xuICAgICAgaWYgKHNlbGYuJCRpc19sYW1iZGEpIHJldHVybiAkY2FsbF9sYW1iZGEoc2VsZiwgYXJncyk7XG4gICAgICByZXR1cm4gJGNhbGxfcHJvYyhzZWxmLCBhcmdzKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA+PihvdGhlcilcbiAgICA6Oktlcm5lbC5wcm9jIGRvIHwqYXJncywgJmJsb2NrfFxuICAgICAgb3V0ID0gY2FsbCgqYXJncywgJmJsb2NrKVxuICAgICAgb3RoZXIuY2FsbChvdXQpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiA8PChvdGhlcilcbiAgICA6Oktlcm5lbC5wcm9jIGRvIHwqYXJncywgJmJsb2NrfFxuICAgICAgb3V0ID0gb3RoZXIuY2FsbCgqYXJncywgJmJsb2NrKVxuICAgICAgY2FsbChvdXQpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB0b19wcm9jXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgbGFtYmRhP1xuICAgICMgVGhpcyBtZXRob2Qgc2hvdWxkIHRlbGwgdGhlIHVzZXIgaWYgdGhlIHByb2MgdHJpY2tzIGFyZSB1bmF2YWlsYWJsZSxcbiAgICAjIChzZWUgUHJvYyNsYW1iZGE/IG9uIHJ1YnkgZG9jcyB0byBmaW5kIG91dCBtb3JlKS5cbiAgICBgISFzZWxmLiQkaXNfbGFtYmRhYFxuICBlbmRcblxuICBkZWYgYXJpdHlcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkaXNfY3VycmllZCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2UgaWYgKHNlbGYuJCRhcml0eSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkYXJpdHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZi5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc291cmNlX2xvY2F0aW9uXG4gICAgYGlmIChzZWxmLiQkaXNfY3VycmllZCkgeyByZXR1cm4gbmlsOyB9YFxuICAgIGBzZWxmLiQkc291cmNlX2xvY2F0aW9uYCB8fCBuaWxcbiAgZW5kXG5cbiAgZGVmIGJpbmRpbmdcbiAgICBgaWYgKHNlbGYuJCRpc19jdXJyaWVkKSB7ICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIkNhbid0IGNyZWF0ZSBCaW5kaW5nXCJ9IH1gXG5cbiAgICBpZiBkZWZpbmVkPyA6OkJpbmRpbmdcbiAgICAgIDo6QmluZGluZy5uZXcobmlsLCBbXSwgYHNlbGYuJCRzYCwgc291cmNlX2xvY2F0aW9uKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgcGFyYW1ldGVycyhsYW1iZGE6IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkaXNfY3VycmllZCkge1xuICAgICAgICByZXR1cm4gI3tbWzpyZXN0XV19O1xuICAgICAgfSBlbHNlIGlmIChzZWxmLiQkcGFyYW1ldGVycykge1xuICAgICAgICBpZiAobGFtYmRhID09IG51bGwgPyBzZWxmLiQkaXNfbGFtYmRhIDogbGFtYmRhKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuJCRwYXJhbWV0ZXJzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBbXSwgaSwgbGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi4kJHBhcmFtZXRlcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJhbWV0ZXIgPSBzZWxmLiQkcGFyYW1ldGVyc1tpXTtcblxuICAgICAgICAgICAgaWYgKHBhcmFtZXRlclswXSA9PT0gJ3JlcScpIHtcbiAgICAgICAgICAgICAgLy8gcmVxdWlyZWQgYXJndW1lbnRzIGFsd2F5cyBoYXZlIG5hbWVcbiAgICAgICAgICAgICAgcGFyYW1ldGVyID0gWydvcHQnLCBwYXJhbWV0ZXJbMV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJhbWV0ZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjdXJyeShhcml0eSA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChhcml0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFyaXR5ID0gc2VsZi5sZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYXJpdHkgPSAjezo6T3BhbC5jb2VyY2VfdG8hKGFyaXR5LCA6OkludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgICAgaWYgKHNlbGYuJCRpc19sYW1iZGEgJiYgYXJpdHkgIT09IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJpdHlgfSBmb3IgI3tgc2VsZi5sZW5ndGhgfSlcIn1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjdXJyaWVkICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSAkc2xpY2UoYXJndW1lbnRzKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgICAgcmVzdWx0O1xuXG4gICAgICAgIGlmIChsZW5ndGggPiBhcml0eSAmJiBzZWxmLiQkaXNfbGFtYmRhICYmICFzZWxmLiQkaXNfY3VycmllZCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGxlbmd0aGB9IGZvciAje2Bhcml0eWB9KVwifVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+PSBhcml0eSkge1xuICAgICAgICAgIHJldHVybiBzZWxmLiRjYWxsLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjdXJyaWVkLmFwcGx5KG51bGwsXG4gICAgICAgICAgICBhcmdzLmNvbmNhdCgkc2xpY2UoYXJndW1lbnRzKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC4kJGlzX2xhbWJkYSA9IHNlbGYuJCRpc19sYW1iZGE7XG4gICAgICAgIHJlc3VsdC4kJGlzX2N1cnJpZWQgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuXG4gICAgICBjdXJyaWVkLiQkaXNfbGFtYmRhID0gc2VsZi4kJGlzX2xhbWJkYTtcbiAgICAgIGN1cnJpZWQuJCRpc19jdXJyaWVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBjdXJyaWVkO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgICV4e1xuICAgICAgdmFyIG9yaWdpbmFsX3Byb2MgPSBzZWxmLiQkb3JpZ2luYWxfcHJvYyB8fCBzZWxmLFxuICAgICAgICAgIHByb2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxfcHJvYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG5cbiAgICAgICRlYWNoX2l2YXIoc2VsZiwgZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICBwcm9jW3Byb3BdID0gc2VsZltwcm9wXTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcHJvYztcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzID09PSBjYWxsXG4gIGFsaWFzIGNsb25lIGR1cFxuICBhbGlhcyB5aWVsZCBjYWxsXG4gIGFsaWFzIFtdIGNhbGxcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6UHJvYz4iLCJuZXciLCJzZWxmIiwiYmxvY2siLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJjYWxsIiwiPj4iLCJvdGhlciIsInByb2MiLCJibG9jayBpbiA+PiIsImJsb2NrICgyIGxldmVscykgaW4gPj4iLCJvdXQiLCJhcmdzIiwidG9fcHJvYyIsIjw8IiwiYmxvY2sgaW4gPDwiLCJibG9jayAoMiBsZXZlbHMpIGluIDw8IiwibGFtYmRhPyIsImFyaXR5Iiwic291cmNlX2xvY2F0aW9uIiwiJHJldF9vcl8xIiwiYmluZGluZyIsIkJpbmRpbmciLCJwYXJhbWV0ZXJzIiwiJGt3YXJncyIsImN1cnJ5IiwiT3BhbCIsImNvZXJjZV90byEiLCJJbnRlZ2VyIiwiZHVwIl0sIm1hcHBpbmdzIjoiQUFBQUEsK0JBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFHQUEsT0FBQUM7RUFBQUE7Ozs7SUFDR0E7SUFDQUE7SUFFREMsTUFBSUMsSUFBSkQsVUFBQUEscUJBQUFBO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQ0UsS0FBQSxRQUFPRSxLQUFQLENBQUE7UUFDRUMsT0FBUUMsT0FBQUEsQ0FBT0Msb0JBQWYsRUFBZ0NMLCtDQUF4Qkk7TUFEVjtNQUlBSixPQUFBRTtJQUxGRixDQUFBQTs7QUFTRkQ7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVFTyxJQUFBQSxvQkFBQUEsZ0JBakRGLEVBaURFQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQWpERjtNQWlEVzs7QUFFWEE7QUFDQUE7QUFDQUE7QUFDQUE7SUFMRUEsQ0FBQUEsSUFBQUE7O0FBUUFDLElBQUFBLGtCQUFBQSx3QkFBT0MsS0FBUEQ7QUFBQUEsTUFBQUE7O01BQUFBO01BQ0VBLE9BQVFFLE1BQVJOLE9BQVFNLFFBQUFBLEVBQUFBLEVBQUFBLEVBQVJDLGFBMURKLEVBMERJQSxFQUFBQzs7UUFBQUE7OztR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QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUF0Q0VBLENBQUFBLElBQUFBOztBQXlDQUksSUFBQUEsbUJBQUFBLGVBQUFBO0FBQUFBLE1BQUFBOzs7QUFFRkE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtJQVpFQSxDQUFBQTtJQWVBLGFBQU0sS0FBTixFQUFVLE1BQVY7SUFDQSxhQUFNLE9BQU4sRUFBWSxLQUFaO0lBQ0EsYUFBTSxPQUFOLEVBQVksTUFBWjtJQUNBL0IsT0FBQSxhQUFNLElBQU4sRUFBUyxNQUFUO0VBL0xGQSxHQUFNLElBQU5BLEVBQWdCRCxRQUFoQkM7QUFIQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE5MDU1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9tZXRob2QucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXG5cbmNsYXNzIDo6TWV0aG9kXG4gIGF0dHJfcmVhZGVyIDpvd25lciwgOnJlY2VpdmVyLCA6bmFtZVxuXG4gIGRlZiBpbml0aWFsaXplKHJlY2VpdmVyLCBvd25lciwgbWV0aG9kLCBuYW1lKVxuICAgIEByZWNlaXZlciA9IHJlY2VpdmVyXG4gICAgQG93bmVyICAgID0gb3duZXJcbiAgICBAbmFtZSAgICAgPSBuYW1lXG4gICAgQG1ldGhvZCAgID0gbWV0aG9kXG4gIGVuZFxuXG4gIGRlZiBhcml0eVxuICAgIEBtZXRob2QuYXJpdHlcbiAgZW5kXG5cbiAgZGVmIHBhcmFtZXRlcnNcbiAgICBgI3tAbWV0aG9kfS4kJHBhcmFtZXRlcnNgXG4gIGVuZFxuXG4gIGRlZiBzb3VyY2VfbG9jYXRpb25cbiAgICBgI3tAbWV0aG9kfS4kJHNvdXJjZV9sb2NhdGlvbmAgfHwgWycoZXZhbCknLCAwXVxuICBlbmRcblxuICBkZWYgY29tbWVudHNcbiAgICBgI3tAbWV0aG9kfS4kJGNvbW1lbnRzYCB8fCBbXVxuICBlbmRcblxuICBkZWYgY2FsbCgqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgI3tAbWV0aG9kfS4kJHAgPSBibG9jaztcblxuICAgICAgcmV0dXJuICN7QG1ldGhvZH0uYXBwbHkoI3tAcmVjZWl2ZXJ9LCBhcmdzKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjdXJyeShhcml0eSA9IHVuZGVmaW5lZClcbiAgICBAbWV0aG9kLmN1cnJ5KGFyaXR5KVxuICBlbmRcblxuICBkZWYgPj4ob3RoZXIpXG4gICAgQG1ldGhvZCA+PiBvdGhlclxuICBlbmRcblxuICBkZWYgPDwob3RoZXIpXG4gICAgQG1ldGhvZCA8PCBvdGhlclxuICBlbmRcblxuICBkZWYgdW5iaW5kXG4gICAgOjpVbmJvdW5kTWV0aG9kLm5ldyhAcmVjZWl2ZXIuY2xhc3MsIEBvd25lciwgQG1ldGhvZCwgQG5hbWUpXG4gIGVuZFxuXG4gIGRlZiB0b19wcm9jXG4gICAgJXh7XG4gICAgICB2YXIgcHJvYyA9IHNlbGYuJGNhbGwuYmluZChzZWxmKTtcbiAgICAgIHByb2MuJCR1bmJvdW5kID0gI3tAbWV0aG9kfTtcbiAgICAgIHByb2MuJCRpc19sYW1iZGEgPSB0cnVlO1xuICAgICAgcHJvYy4kJGFyaXR5ID0gI3tAbWV0aG9kfS4kJGFyaXR5ID09IG51bGwgPyAje0BtZXRob2R9Lmxlbmd0aCA6ICN7QG1ldGhvZH0uJCRhcml0eTtcbiAgICAgIHByb2MuJCRwYXJhbWV0ZXJzID0gI3tAbWV0aG9kfS4kJHBhcmFtZXRlcnM7XG4gICAgICByZXR1cm4gcHJvYztcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIjPCN7c2VsZi5jbGFzc306ICN7QHJlY2VpdmVyLmNsYXNzfSMje0BuYW1lfSAoZGVmaW5lZCBpbiAje0Bvd25lcn0gaW4gI3tzb3VyY2VfbG9jYXRpb24uam9pbignOicpfSk+XCJcbiAgZW5kXG5cbiAgYWxpYXMgW10gY2FsbFxuICBhbGlhcyA9PT0gY2FsbFxuZW5kXG5cbmNsYXNzIDo6VW5ib3VuZE1ldGhvZFxuICBhdHRyX3JlYWRlciA6c291cmNlLCA6b3duZXIsIDpuYW1lXG5cbiAgZGVmIGluaXRpYWxpemUoc291cmNlLCBvd25lciwgbWV0aG9kLCBuYW1lKVxuICAgIEBzb3VyY2UgPSBzb3VyY2VcbiAgICBAb3duZXIgID0gb3duZXJcbiAgICBAbWV0aG9kID0gbWV0aG9kXG4gICAgQG5hbWUgICA9IG5hbWVcbiAgICBgc2VsZi4kJG1ldGhvZCA9IG1ldGhvZGBcbiAgZW5kXG5cbiAgZGVmIGFyaXR5XG4gICAgQG1ldGhvZC5hcml0eVxuICBlbmRcblxuICBkZWYgcGFyYW1ldGVyc1xuICAgIGAje0BtZXRob2R9LiQkcGFyYW1ldGVyc2BcbiAgZW5kXG5cbiAgZGVmIHNvdXJjZV9sb2NhdGlvblxuICAgIGAje0BtZXRob2R9LiQkc291cmNlX2xvY2F0aW9uYCB8fCBbJyhldmFsKScsIDBdXG4gIGVuZFxuXG4gIGRlZiBjb21tZW50c1xuICAgIGAje0BtZXRob2R9LiQkY29tbWVudHNgIHx8IFtdXG4gIGVuZFxuXG4gIGRlZiBiaW5kKG9iamVjdClcbiAgICAleHtcbiAgICAgIGlmICgje0Bvd25lcn0uJCRpc19tb2R1bGUgfHwgT3BhbC5pc19hKCN7b2JqZWN0fSwgI3tAb3duZXJ9KSkge1xuICAgICAgICByZXR1cm4gI3s6Ok1ldGhvZC5uZXcob2JqZWN0LCBAb3duZXIsIEBtZXRob2QsIEBuYW1lKX07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCJjYW4ndCBiaW5kIHNpbmdsZXRvbiBtZXRob2QgdG8gYSBkaWZmZXJlbnQgY2xhc3MgKGV4cGVjdGVkICN7b2JqZWN0fS5raW5kX29mPygje0Bvd25lcn0gdG8gYmUgdHJ1ZSlcIn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYmluZF9jYWxsKG9iamVjdCwgKmFyZ3MsICZibG9jaylcbiAgICBiaW5kKG9iamVjdCkuY2FsbCgqYXJncywgJmJsb2NrKVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIFwiIzwje3NlbGYuY2xhc3N9OiAje0Bzb3VyY2V9IyN7QG5hbWV9IChkZWZpbmVkIGluICN7QG93bmVyfSBpbiAje3NvdXJjZV9sb2NhdGlvbi5qb2luKCc6Jyl9KT5cIlxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6TWV0aG9kPiIsInNlbGYiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJyZWNlaXZlciIsIm93bmVyIiwibWV0aG9kIiwibmFtZSIsIkByZWNlaXZlciIsIkBvd25lciIsIkBuYW1lIiwiQG1ldGhvZCIsImFyaXR5IiwicGFyYW1ldGVycyIsInNvdXJjZV9sb2NhdGlvbiIsIiRyZXRfb3JfMSIsIjAiLCJjb21tZW50cyIsImNhbGwiLCJjdXJyeSIsIj4+Iiwib3RoZXIiLCI8PCIsInVuYmluZCIsIlVuYm91bmRNZXRob2QiLCJuZXciLCJjbGFzcyIsInRvX3Byb2MiLCJpbnNwZWN0Iiwiam9pbiIsIjxjbGFzczpVbmJvdW5kTWV0aG9kPiIsInNvdXJjZSIsIkBzb3VyY2UiLCJiaW5kIiwib2JqZWN0IiwiTWV0aG9kIiwiS2VybmVsIiwicmFpc2UiLCJUeXBlRXJyb3IiLCJiaW5kX2NhbGwiLCJhcmdzIiwiYmxvY2siXSwibWFwcGluZ3MiOiJBQUFBQSxpQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFFQUM7RUFBQUE7O0lBQUFBOztBQUFBQTs7SUFDRUMsSUFBQUMsYUFBQUEsQ0FBWSxPQUFaLEVBQW9CLFVBQXBCLEVBQStCLE1BQS9CQTs7QUFFQUMsSUFBQUEsMEJBQUFBLHNCQUFlQyxRQUFELEVBQVdDLEtBQVgsRUFBa0JDLE1BQWxCLEVBQTBCQyxJQUF4Q0o7QUFBQUEsTUFBQUE7OztNQUNFSyxnQkFBWUo7TUFDWkssYUFBWUo7TUFDWkssWUFBWUg7TUFDWkos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O0lBUkVBLENBQUFBOztBQVdBTSxJQUFBQSx5QkFBQUEscUJBQWNMLE1BQUQsRUE3R2YsRUE2R0VLO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BN0dGO01BNkd3QjtNQUNwQkEsT0FBWXJCLE1BQVpqQixJQUFBZ0MsTUFBQUEsQ0FBS0MsTUFBTEQsQ0FBWWYsUUFBQUEsRUFBTSxNQUFDc0IsSUFBRCxDQUFOdEIsRUFBY3VCLEtBQURkLFNBQUFBLENBQUFBLENBQWJUO0lBRGRxQixDQUFBQSxJQUFBQTtJQUlBVCxPQUFBRix1QkFBQUEsbUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSxJQUFELEdBQUEsQ0FBSzNCLElBQUl5QixPQUFBQSxDQUFBQSxDQUFULENBQUEsR0FBZ0JFLElBQWhCLEdBQUEsQ0FBb0JJLFdBQXBCLENBQUEsR0FBNEJKLEdBQTVCLEdBQUEsQ0FBK0JsQixTQUEvQixDQUFBLEdBQXFDa0IsZUFBckMsR0FBQSxDQUFvRG5CLFVBQXBELENBQUEsR0FBMkRtQixNQUEzRCxHQUFBLENBQWlFM0IsSUFBQWEsaUJBQUFBLENBQUFBLENBQWVlLE1BQUFBLENBQU1ELEdBQU5DLENBQWhGLENBQUEsR0FBMkZEO0lBRDdGQSxDQUFBQTtFQTFDRkUsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQXZFQS9COyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxOTI1NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvdmFyaWFibGVzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxuXG4jIHJlZ2V4cCBtYXRjaGVzXG4leHskZ3ZhcnNbJyYnXSA9ICRndmFyc1snfiddID0gJGd2YXJzWydgJ10gPSAkZ3ZhcnNbXCInXCJdID0gbmlsfVxuXG4jIHJlcXVpcmVzXG4kTE9BREVEX0ZFQVRVUkVTID0gJFwiID0gYE9wYWwubG9hZGVkX2ZlYXR1cmVzYFxuJExPQURfUEFUSCAgICAgICA9ICQ6ID0gW11cblxuIyBzcGxpdCBsaW5lc1xuJC8gPSBcIlxcblwiXG4kLCA9IG5pbFxuXG46OkFSR1YgPSBbXVxuOjpBUkdGID0gOjpPYmplY3QubmV3XG46OkVOViAgPSB7fVxuXG4kVkVSQk9TRSA9IGZhbHNlXG4kREVCVUcgICA9IGZhbHNlXG4kU0FGRSAgICA9IDBcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiJExPQURFRF9GRUFUVVJFUyIsIiRcIiIsIiRMT0FEX1BBVEgiLCIkOiIsIiQvIiwiJCwiLCJPYmplY3QiLCJuZXciLCIkVkVSQk9TRSIsIiRERUJVRyIsIiRTQUZFIiwiMCJdLCJtYXBwaW5ncyI6IkFBQUFBLG9DQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUdHQTtFQUdIQyx5QkFBbUJDLENBQUFBLGVBQU1GLG9CQUFORTtFQUNuQkMsbUJBQW1CQyxDQUFBQSxjQUFLLEVBQUxBO0VBR25CQyxjQUFLTDtFQUNMTSxjQUFLO0VBRUwsV0FBQSxJQUFBLFVBQVMsRUFBVDtFQUNBLFdBQUEsSUFBQSxVQUFTQyxPQUFRQyxLQUFBQSxDQUFBQSxDQUFqQjtFQUNBLFdBQUEsSUFBQSxTQUFTLFdBQVQ7RUFFQUMsaUJBQVc7RUFDWEMsZUFBVztFQUNYVixPQUFBVyxDQUFBQSxjQUFXQyxDQUFYRDtBQW5CQVg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE5Mjc0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9pby5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcblxuY2xhc3MgOjpJT1xuICBzZWxmOjpTRUVLX1NFVCA9IDBcbiAgc2VsZjo6U0VFS19DVVIgPSAxXG4gIHNlbGY6OlNFRUtfRU5EID0gMlxuICBzZWxmOjpTRUVLX0RBVEEgPSAzXG4gIHNlbGY6OlNFRUtfSE9MRSA9IDRcblxuICBzZWxmOjpSRUFEQUJMRSA9IDFcbiAgc2VsZjo6V1JJVEFCTEUgPSA0XG5cbiAgYXR0cl9yZWFkZXIgOmVvZlxuXG4gIGF0dHJfYWNjZXNzb3IgOnJlYWRfcHJvYywgIDpzeW5jLCA6dHR5LCA6d3JpdGVfcHJvY1xuXG4gIGRlZiBpbml0aWFsaXplKGZkLCBmbGFncyA9ICdyJylcbiAgICBAZmQgPSBmZFxuICAgIEBmbGFncyA9IGZsYWdzXG4gICAgQGVvZiA9IGZhbHNlXG5cbiAgICBpZiBmbGFncy5pbmNsdWRlPygncicpICYmICFmbGFncy5tYXRjaD8oL1t3YStdLylcbiAgICAgIEBjbG9zZWQgPSA6d3JpdGVcbiAgICBlbHNpZiBmbGFncy5tYXRjaD8oL1t3YV0vKSAmJiAhZmxhZ3MubWF0Y2g/KC9bcitdLylcbiAgICAgIEBjbG9zZWQgPSA6cmVhZFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgZmlsZW5vXG4gICAgQGZkXG4gIGVuZFxuXG4gIGRlZiB0dHk/XG4gICAgYHNlbGYudHR5ID09IHRydWVgXG4gIGVuZFxuXG4gIGRlZiB3cml0ZShzdHJpbmcpXG4gICAgYHNlbGYud3JpdGVfcHJvYyhzdHJpbmcpYFxuICAgIHN0cmluZy5zaXplXG4gIGVuZFxuXG4gIGRlZiBmbHVzaFxuICAgICMgbm9vcFxuICBlbmRcblxuICBkZWYgPDwoc3RyaW5nKVxuICAgIHdyaXRlKHN0cmluZylcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBwcmludCgqYXJncylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGFyZ3MubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBhcmdzW2ldID0gI3s6Oktlcm5lbC5TdHJpbmcoYGFyZ3NbaV1gKX1cbiAgICAgIH1cbiAgICAgIHNlbGYuJHdyaXRlKGFyZ3Muam9pbigjeyQsfSkpO1xuICAgIH1cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIHB1dHMoKmFyZ3MpXG4gICAgJXh7XG4gICAgICB2YXIgbGluZVxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICN7d3JpdGUgXCJcXG5cIn07XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhcmdzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICBpZiAoYXJnc1tpXS4kJGlzX2FycmF5KXtcbiAgICAgICAgICAgIHZhciBhcnkgPSAje2BhcmdzW2ldYC5mbGF0dGVufVxuICAgICAgICAgICAgaWYgKGFyeS5sZW5ndGggPiAwKSAje3B1dHMoKmBhcnlgKX1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGFyZ3NbaV0uJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAgICAgbGluZSA9IGFyZ3NbaV0udmFsdWVPZigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbGluZSA9ICN7OjpLZXJuZWwuU3RyaW5nKGBhcmdzW2ldYCl9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFsaW5lLmVuZHNXaXRoKFwiXFxuXCIpKSBsaW5lICs9IFwiXFxuXCJcbiAgICAgICAgICAgICN7d3JpdGUgYGxpbmVgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBuaWxcbiAgZW5kXG5cbiAgIyBSZWFkaW5nXG5cbiAgZGVmIGdldGNcbiAgICBAcmVhZF9idWZmZXIgfHw9ICcnXG4gICAgcGFydHMgPSAnJ1xuXG4gICAgIyBXaWxsIGV4ZWN1cmUgYXQgbW9zdCB0d2ljZSAtIG9uZSB0aW1lIHJlYWRpbmcgZnJvbSBhIGJ1ZmZlclxuICAgICMgc2Vjb25kIHRpbWUgZXhlY3V0aW5nIHJlYWQgcHJvY1xuICAgIGJlZ2luXG4gICAgICBAcmVhZF9idWZmZXIgKz0gcGFydHNcbiAgICAgIGlmIEByZWFkX2J1ZmZlciAhPSAnJ1xuICAgICAgICByZXQgPSBAcmVhZF9idWZmZXJbMF1cbiAgICAgICAgQHJlYWRfYnVmZmVyID0gQHJlYWRfYnVmZmVyWzEuLi0xXVxuICAgICAgICByZXR1cm4gcmV0XG4gICAgICBlbmRcbiAgICBlbmQgd2hpbGUgcGFydHMgPSBzeXNyZWFkX25vcmFpc2UoMSlcblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgZ2V0Ynl0ZVxuICAgIGdldGMmLm9yZFxuICBlbmRcblxuICBkZWYgcmVhZGJ5dGVcbiAgICByZWFkY2hhci5vcmRcbiAgZW5kXG5cbiAgZGVmIHJlYWRjaGFyXG4gICAgZ2V0YyB8fCA6Oktlcm5lbC5yYWlzZSg6OkVPRkVycm9yLCAnZW5kIG9mIGZpbGUgcmVhY2hlZCcpXG4gIGVuZFxuXG4gIGRlZiByZWFkbGluZSgqYXJncylcbiAgICBnZXRzKCphcmdzKSB8fCA6Oktlcm5lbC5yYWlzZSg6OkVPRkVycm9yLCAnZW5kIG9mIGZpbGUgcmVhY2hlZCcpXG4gIGVuZFxuXG4gIGRlZiBnZXRzKHNlcCA9IGZhbHNlLCBsaW1pdCA9IG5pbCwgb3B0cyA9IHt9KVxuICAgIGlmIGBzZXAuJCRpc19udW1iZXJgICYmICFsaW1pdFxuICAgICAgc2VwLCBsaW1pdCwgb3B0cyA9IGZhbHNlLCBzZXAsIGxpbWl0XG4gICAgZW5kXG4gICAgaWYgYHNlcC4kJGlzX2hhc2hgICYmICFsaW1pdCAmJiBvcHRzID09IHt9XG4gICAgICBzZXAsIGxpbWl0LCBvcHRzID0gZmFsc2UsIG5pbCwgc2VwXG4gICAgZWxzaWYgYGxpbWl0LiQkaXNfaGFzaGAgJiYgb3B0cyA9PSB7fVxuICAgICAgc2VwLCBsaW1pdCwgb3B0cyA9IHNlcCwgbmlsLCBsaW1pdFxuICAgIGVuZFxuXG4gICAgb3JpZ19zZXAgPSBzZXBcblxuICAgIHNlcCA9ICQvIGlmIHNlcCA9PSBmYWxzZVxuICAgIHNlcCA9IC9cXHI/XFxuXFxyP1xcbi8gaWYgc2VwID09ICcnXG4gICAgc2VwIHx8PSAnJ1xuICAgIHNlcCA9IHNlcC50b19zdHIgdW5sZXNzIG9yaWdfc2VwID09ICcnXG5cbiAgICAjIFRyeSB0byBkZWR1Y2UgbGVuZ3RoIG9mIGEgcmVnZXhwXG4gICAgc2VwbGVuID0gb3JpZ19zZXAgPT0gJycgPyAyIDogc2VwLmxlbmd0aFxuXG4gICAgc2VwID0gLyAvIGlmIHNlcCA9PSAnICcgIyBXVEYgaXMgdGhpcywgU3RyaW5nI3NwbGl0KFwiIFwiKSBtYXRjaGVzIGFsbCB3aGl0ZXNwYWNlcz8/P1xuXG4gICAgQHJlYWRfYnVmZmVyIHx8PSAnJ1xuICAgIGRhdGEgPSAnJ1xuICAgIHJldCA9IG5pbFxuXG4gICAgYmVnaW5cbiAgICAgIEByZWFkX2J1ZmZlciArPSBkYXRhXG4gICAgICBpZiBzZXAgIT0gJycgJiYgKGBzZXAuJCRpc19yZWdleHBgID8gQHJlYWRfYnVmZmVyLm1hdGNoPyhzZXApIDogQHJlYWRfYnVmZmVyLmluY2x1ZGU/KHNlcCkpXG4gICAgICAgIG9yaWdfYnVmZmVyID0gQHJlYWRfYnVmZmVyXG4gICAgICAgIHJldCwgQHJlYWRfYnVmZmVyID0gQHJlYWRfYnVmZmVyLnNwbGl0KHNlcCwgMilcbiAgICAgICAgcmV0ICs9IG9yaWdfYnVmZmVyW3JldC5sZW5ndGgsIHNlcGxlbl0gaWYgcmV0ICE9IG9yaWdfYnVmZmVyXG4gICAgICAgIGJyZWFrXG4gICAgICBlbmRcbiAgICBlbmQgd2hpbGUgZGF0YSA9IHN5c3JlYWRfbm9yYWlzZShzZXAgPT0gJycgPyA2NV81MzYgOiAxKVxuXG4gICAgdW5sZXNzIHJldFxuICAgICAgcmV0LCBAcmVhZF9idWZmZXIgPSAoQHJlYWRfYnVmZmVyIHx8ICcnKSwgJydcbiAgICAgIHJldCA9IG5pbCBpZiByZXQgPT0gJydcbiAgICBlbmRcblxuICAgIGlmIHJldFxuICAgICAgaWYgbGltaXRcbiAgICAgICAgcmV0ID0gcmV0WzAuLi5saW1pdF1cbiAgICAgICAgQHJlYWRfYnVmZmVyID0gcmV0W2xpbWl0Li4tMV0gKyBAcmVhZF9idWZmZXJcbiAgICAgIGVuZFxuICAgICAgcmV0ID0gcmV0LnN1YigvXFxyP1xcblxcei8sICcnKSBpZiBvcHRzWzpjaG9tcF1cbiAgICAgIHJldCA9IHJldC5zdWIoL1xcQVtcXHJcXG5dKy8sICcnKSBpZiBvcmlnX3NlcCA9PSAnJ1xuICAgIGVuZFxuXG4gICAgJF8gPSByZXQgaWYgb3JpZ19zZXAgPT0gZmFsc2VcbiAgICByZXRcbiAgZW5kXG5cbiAgIyBUaGlzIG1ldGhvZCBpcyB0byBiZSBvdmVybG9hZGVkLCBvciByZWFkX3Byb2MgY2FuIGJlIGNoYW5nZWRcbiAgZGVmIHN5c3JlYWQoaW50ZWdlcilcbiAgICBgc2VsZi5yZWFkX3Byb2MoaW50ZWdlcilgIHx8IGJlZ2luXG4gICAgICBAZW9mID0gdHJ1ZVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpFT0ZFcnJvciwgJ2VuZCBvZiBmaWxlIHJlYWNoZWQnXG4gICAgZW5kXG4gIGVuZFxuXG4gICMgQHByaXZhdGVcbiAgZGVmIHN5c3JlYWRfbm9yYWlzZShpbnRlZ2VyKVxuICAgIHN5c3JlYWQoaW50ZWdlcilcbiAgcmVzY3VlIDo6RU9GRXJyb3JcbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIHJlYWRwYXJ0aWFsKGludGVnZXIpXG4gICAgQHJlYWRfYnVmZmVyIHx8PSAnJ1xuICAgIHBhcnQgPSBzeXNyZWFkKGludGVnZXIpXG4gICAgcmV0LCBAcmVhZF9idWZmZXIgPSBAcmVhZF9idWZmZXIgKyAocGFydCB8fCAnJyksICcnXG4gICAgcmV0ID0gbmlsIGlmIHJldCA9PSAnJ1xuICAgIHJldFxuICBlbmRcblxuICBkZWYgcmVhZChpbnRlZ2VyID0gbmlsKVxuICAgIEByZWFkX2J1ZmZlciB8fD0gJydcbiAgICBwYXJ0cyA9ICcnXG4gICAgcmV0ID0gbmlsXG5cbiAgICBiZWdpblxuICAgICAgQHJlYWRfYnVmZmVyICs9IHBhcnRzXG4gICAgICBpZiBpbnRlZ2VyICYmIEByZWFkX2J1ZmZlci5sZW5ndGggPiBpbnRlZ2VyXG4gICAgICAgIHJldCwgQHJlYWRfYnVmZmVyID0gQHJlYWRfYnVmZmVyWzAuLi5pbnRlZ2VyXSwgQHJlYWRfYnVmZmVyW2ludGVnZXIuLi0xXVxuICAgICAgICByZXR1cm4gcmV0XG4gICAgICBlbmRcbiAgICBlbmQgd2hpbGUgcGFydHMgPSBzeXNyZWFkX25vcmFpc2UoaW50ZWdlciB8fCA2NV81MzYpXG5cbiAgICByZXQsIEByZWFkX2J1ZmZlciA9IEByZWFkX2J1ZmZlciwgJydcbiAgICByZXRcbiAgZW5kXG5cbiAgIyBFYWNoZXNcblxuICBkZWYgcmVhZGxpbmVzKHNlcGFyYXRvciA9ICQvKVxuICAgIGVhY2hfbGluZShzZXBhcmF0b3IpLnRvX2FcbiAgZW5kXG5cbiAgZGVmIGVhY2goc2VwID0gJC8sICphcmdzLCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDplYWNoLCBzZXAsICphcmdzIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHdoaWxlIChzID0gZ2V0cyhzZXAsICphcmdzKSlcbiAgICAgIHlpZWxkKHMpXG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBlYWNoX2J5dGUoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaF9ieXRlIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHdoaWxlIChzID0gZ2V0Ynl0ZSlcbiAgICAgIHlpZWxkKHMpXG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBlYWNoX2NoYXIoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaF9jaGFyIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHdoaWxlIChzID0gZ2V0YylcbiAgICAgIHlpZWxkKHMpXG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gICMgQ2xvc2VkbmVzc1xuXG4gIGRlZiBjbG9zZVxuICAgIEBjbG9zZWQgPSA6Ym90aFxuICBlbmRcblxuICBkZWYgY2xvc2VfcmVhZFxuICAgIGlmIEBjbG9zZWQgPT0gOndyaXRlXG4gICAgICBAY2xvc2VkID0gOmJvdGhcbiAgICBlbHNlXG4gICAgICBAY2xvc2VkID0gOnJlYWRcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGNsb3NlX3dyaXRlXG4gICAgaWYgQGNsb3NlZCA9PSA6cmVhZFxuICAgICAgQGNsb3NlZCA9IDpib3RoXG4gICAgZWxzZVxuICAgICAgQGNsb3NlZCA9IDp3cml0ZVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgY2xvc2VkP1xuICAgIEBjbG9zZWQgPT0gOmJvdGhcbiAgZW5kXG5cbiAgZGVmIGNsb3NlZF9yZWFkP1xuICAgIEBjbG9zZWQgPT0gOnJlYWQgfHwgQGNsb3NlZCA9PSA6Ym90aFxuICBlbmRcblxuICBkZWYgY2xvc2VkX3dyaXRlP1xuICAgIEBjbG9zZWQgPT0gOndyaXRlIHx8IEBjbG9zZWQgPT0gOmJvdGhcbiAgZW5kXG5cbiAgIyBAcHJpdmF0ZVxuICBkZWYgY2hlY2tfd3JpdGFibGVcbiAgICBpZiBjbG9zZWRfd3JpdGU/XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OklPRXJyb3IsICdub3Qgb3BlbmVkIGZvciB3cml0aW5nJ1xuICAgIGVuZFxuICBlbmRcblxuICAjIEBwcml2YXRlXG4gIGRlZiBjaGVja19yZWFkYWJsZVxuICAgIGlmIGNsb3NlZF9yZWFkP1xuICAgICAgOjpLZXJuZWwucmFpc2UgOjpJT0Vycm9yLCAnbm90IG9wZW5lZCBmb3IgcmVhZGluZydcbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXMgZWFjaF9saW5lIGVhY2hcbiAgYWxpYXMgZW9mPyBlb2ZcbmVuZFxuXG46OlNURElOICA9ICRzdGRpbiAgPSA6OklPLm5ldygwLCAncicpXG46OlNURE9VVCA9ICRzdGRvdXQgPSA6OklPLm5ldygxLCAndycpXG46OlNUREVSUiA9ICRzdGRlcnIgPSA6OklPLm5ldygyLCAndycpXG5cbmB2YXIgY29uc29sZSA9IE9wYWwuZ2xvYmFsLmNvbnNvbGVgXG46OlNURE9VVC53cml0ZV9wcm9jID0gYHR5cGVvZihwcm9jZXNzKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mKHByb2Nlc3Muc3Rkb3V0KSA9PT0gJ29iamVjdCcgPyBmdW5jdGlvbihzKXtwcm9jZXNzLnN0ZG91dC53cml0ZShzKX0gOiBmdW5jdGlvbihzKXtjb25zb2xlLmxvZyhzKX1gXG46OlNUREVSUi53cml0ZV9wcm9jID0gYHR5cGVvZihwcm9jZXNzKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mKHByb2Nlc3Muc3RkZXJyKSA9PT0gJ29iamVjdCcgPyBmdW5jdGlvbihzKXtwcm9jZXNzLnN0ZGVyci53cml0ZShzKX0gOiBmdW5jdGlvbihzKXtjb25zb2xlLndhcm4ocyl9YFxuXG46OlNURElOLnJlYWRfcHJvYyA9IGBmdW5jdGlvbihzKSB7IHZhciBwID0gcHJvbXB0KCk7IGlmIChwICE9PSBudWxsKSByZXR1cm4gcCArIFwiXFxuXCI7IHJldHVybiBuaWw7IH1gXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpJTz4iLCJzZWxmIiwiMCIsIjEiLCIyIiwiMyIsIjQiLCJhdHRyX3JlYWRlciIsImF0dHJfYWNjZXNzb3IiLCJpbml0aWFsaXplIiwiZmQiLCJmbGFncyIsIkBmZCIsIkBmbGFncyIsIkBlb2YiLCJpbmNsdWRlPyIsIm1hdGNoPyIsIkBjbG9zZWQiLCJmaWxlbm8iLCJ0dHk/Iiwid3JpdGUiLCJzdHJpbmciLCJzaXplIiwiZmx1c2giLCI8PCIsInByaW50IiwiS2VybmVsIiwiU3RyaW5nIiwiJCwiLCJwdXRzIiwiZmxhdHRlbiIsImdldGMiLCJAcmVhZF9idWZmZXIiLCIkcmV0X29yXzEiLCJwYXJ0cyIsIisiLCJyZXQiLCJbXSIsIi0xIiwic3lzcmVhZF9ub3JhaXNlIiwiZ2V0Ynl0ZSIsInJlYWRieXRlIiwicmVhZGNoYXIiLCJvcmQiLCJyYWlzZSIsIkVPRkVycm9yIiwicmVhZGxpbmUiLCJnZXRzIiwiYXJncyIsInNlcCIsImxpbWl0Iiwib3B0cyIsIm9yaWdfc2VwIiwiJC8iLCJ0b19zdHIiLCJzZXBsZW4iLCJsZW5ndGgiLCJkYXRhIiwib3JpZ19idWZmZXIiLCJzcGxpdCIsIjY1NTM2Iiwic3ViIiwiJF8iLCJzeXNyZWFkIiwiaW50ZWdlciIsInJlYWRwYXJ0aWFsIiwicGFydCIsInJlYWQiLCI+IiwicmVhZGxpbmVzIiwic2VwYXJhdG9yIiwiZWFjaF9saW5lIiwidG9fYSIsImVhY2giLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsInMiLCJlYWNoX2J5dGUiLCJlYWNoX2NoYXIiLCJjbG9zZSIsImNsb3NlX3JlYWQiLCJjbG9zZV93cml0ZSIsImNsb3NlZD8iLCI9PSIsImNsb3NlZF9yZWFkPyIsImNsb3NlZF93cml0ZT8iLCJjaGVja193cml0YWJsZSIsIklPRXJyb3IiLCJjaGVja19yZWFkYWJsZSIsIiRzdGRpbiIsIklPIiwibmV3IiwiJHN0ZG91dCIsIiRzdGRlcnIiLCJTVERPVVQiLCJ3cml0ZV9wcm9jPSIsIlNUREVSUiIsInJlYWRfcHJvYz0iLCJTVERJTiJdLCJtYXBwaW5ncyI6IkFBQUFBLDZCQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQztFQUFBQTs7SUFBQUE7O0FBQUFBOztJQUNFLFdBQUFDLElBQUEsY0FBaUJDLENBQWpCO0lBQ0EsV0FBQUQsSUFBQSxjQUFpQkUsQ0FBakI7SUFDQSxXQUFBRixJQUFBLGNBQWlCRyxDQUFqQjtJQUNBLFdBQUFILElBQUEsZUFBa0JJLENBQWxCO0lBQ0EsV0FBQUosSUFBQSxlQUFrQkssQ0FBbEI7SUFFQSxXQUFBTCxJQUFBLGNBQWlCRSxDQUFqQjtJQUNBLFdBQUFGLElBQUEsY0FBaUJLLENBQWpCO0lBRUFMLElBQUFNLGFBQUFBLENBQVksS0FBWkE7SUFFQU4sSUFBQU8sZUFBQUEsQ0FBYyxXQUFkLEVBQTJCLE1BQTNCLEVBQWtDLEtBQWxDLEVBQXdDLFlBQXhDQTs7QUFFQUMsSUFBQUEsMEJBQUFBLHNCQUFlQyxFQUFELEVBQUtDLEtBQW5CRjtBQUFBQSxNQUFBQTs7O01BQW1CLDJCQUFRQTtNQUN6QkcsVUFBTUY7TUFDTkcsYUFBU0Y7TUFDVEcsV0FBTztNQUVQLElBQUcsQ0FBQSxRQUFBSCxLQUFLSSxhQUFBQSxDQUFVTixHQUFWTSxDQUFMLENBQUEsSUFBQSxDQUFBLEtBQXdCSixLQUFLSyxXQUFBQSxDQUFRLE9BQVJBLENBQTdCLENBQUEsQ0FBQSxDQUFIO1FBQ0VQLE9BQUFRLENBQUFBLGNBQVUsT0FBVkE7TUFERixP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QUFBQSxJQUFBQTtFQThTQSxXQUFBLElBQUEsV0FBV3lGLENBQUFBLGVBQVVDLFNBQUlDLEtBQUFBLENBQUt6RixDQUFULEVBQVlILEdBQVI0RixDQUFkRixDQUFYO0VBQ0EsV0FBQSxJQUFBLFlBQVdHLENBQUFBLGdCQUFVRixTQUFJQyxLQUFBQSxDQUFLeEYsQ0FBVCxFQUFZSixHQUFSNEYsQ0FBZEMsQ0FBWDtFQUNBLFdBQUEsSUFBQSxZQUFXQyxDQUFBQSxnQkFBVUgsU0FBSUMsS0FBQUEsQ0FBS3ZGLENBQVQsRUFBWUwsR0FBUjRGLENBQWRFLENBQVg7RUFFQzlGO0VBQ0QrRixhQUFRQyxnQkFBQUEsQ0FBZWhHLHdJQUFmZ0c7RUFDUkMsYUFBUUQsZ0JBQUFBLENBQWVoRyx5SUFBZmdHO0VBRVJoRyxPQUFPa0csTUFBQUEsQ0FBY2xHLDhFQUFka0csQ0FBQUEsRUFBQUEsTUFBUEMsWUFBT0QsY0FBQUEsRUFBQUEsRUFBQUEsQ0FBQUEsRUFBQUE7QUF4VFBsRzsifX0seyJvZmZzZXQiOnsibGluZSI6MTk3MTIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJvcGFsL3JlZ2V4cF9hbmNob3JzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgZnJvemVuX3N0cmluZ19saXRlcmFsOiB0cnVlXG5cbm1vZHVsZSBPcGFsXG4gIHNlbGY6OlJFR0VYUF9TVEFSVCA9IFJVQllfRU5HSU5FID09ICdvcGFsJyA/ICdeJyA6ICdcXEEnXG4gIHNlbGY6OlJFR0VYUF9FTkQgPSBSVUJZX0VOR0lORSA9PSAnb3BhbCcgPyAnJCcgOiAnXFx6J1xuXG4gICMgVW5pY29kZSBjaGFyYWN0ZXJzIGluIHJhbmdlc1xuICAjIFxcdTAwMDEgLSBcXHUwMDJGIChibGFuayB1bmljb2RlIGNoYXJhY3RlcnMgKyBzcGFjZSArICFcIiMkJSYnKCkqKywtLi8gY2hhcnMpXG4gICMgXFx1MDAzQSAtIFxcdTAwNDAgKDo7PD0+P0AgY2hhcnMpXG4gICMgXFx1MDA1QiAtIFxcdTAwNUUgKFtcXF1eIGNoYXJzKVxuICAjIFxcdTAwNjAgICAgICAgICAgKGAgY2hhcilcbiAgIyBcXHUwMDdCIC0gXFx1MDA3RiAoe3x9fiBjaGFyc30pXG4gICMgYXJlIG5vdCBhbGxvd2VkIHRvIGJlIHVzZWQgaW4gaWRlbnRpZmllciBpbiB0aGUgYmVnZ2luaW5nIG9yIG1pZGRsZSBvZiBpdHMgbmFtZVxuICBzZWxmOjpGT1JCSURERU5fU1RBUlRJTkdfSURFTlRJRklFUl9DSEFSUyA9ICdcXHUwMDAxLVxcdTAwMkZcXHUwMDNBLVxcdTAwNDBcXHUwMDVCLVxcdTAwNUVcXHUwMDYwXFx1MDA3Qi1cXHUwMDdGJ1xuXG4gICMgVW5pY29kZSBjaGFyYWN0ZXJzIGluIHJhbmdlc1xuICAjIFxcdTAwMDEgLSBcXHUwMDIwIChibGFuayB1bmljb2RlIGNoYXJhY3RlcnMgKyBzcGFjZSlcbiAgIyBcXHUwMDIyIC0gXFx1MDAyRiAoXCIjJCUmJygpKissLS4vIGNoYXJzKVxuICAjIFxcdTAwM0EgLSBcXHUwMDNFICg6Ozw9PiBjaGFycylcbiAgIyBcXHUwMDQwICAgICAgICAgIChAIGNoYXIpXG4gICMgXFx1MDA1QiAtIFxcdTAwNUUgKFtcXF1eIGNoYXJzKVxuICAjIFxcdTAwNjAgICAgICAgICAgKGAgY2hhcilcbiAgIyBcXHUwMDdCIC0gXFx1MDA3RiAoe3x9fiBjaGFyc30pXG4gICMgYXJlIG5vdCBhbGxvd2VkIHRvIGJlIHVzZWQgaW4gaWRlbnRpZmllciBpbiB0aGUgZW5kIG9mIGl0cyBuYW1lXG4gICMgSW4gZmFjdCwgRk9SQklEREVOX1NUQVJUSU5HX0lERU5USUZJRVJfQ0hBUlMgPSBGT1JCSURERU5fRU5ESU5HX0lERU5USUZJRVJfQ0hBUlMgKyBcXHUwMDIxICgnPycpICsgXFx1MDAzRiAoJyEnKVxuICBzZWxmOjpGT1JCSURERU5fRU5ESU5HX0lERU5USUZJRVJfQ0hBUlMgICA9ICdcXHUwMDAxLVxcdTAwMjBcXHUwMDIyLVxcdTAwMkZcXHUwMDNBLVxcdTAwM0VcXHUwMDQwXFx1MDA1Qi1cXHUwMDVFXFx1MDA2MFxcdTAwN0ItXFx1MDA3RidcbiAgc2VsZjo6SU5MSU5FX0lERU5USUZJRVJfUkVHRVhQID0gUmVnZXhwLm5ldyhcIlteI3tzZWxmOjpGT1JCSURERU5fU1RBUlRJTkdfSURFTlRJRklFUl9DSEFSU31dKlteI3tzZWxmOjpGT1JCSURERU5fRU5ESU5HX0lERU5USUZJRVJfQ0hBUlN9XVwiKVxuXG4gICMgRm9yIGNvbnN0YW50cyBydWxlcyBhcmUgcHJldHR5IG11Y2ggdGhlIHNhbWUsIGJ1dCAnOicgaXMgYWxsb3dlZCBhbmQgJz8hJyBhcmUgbm90LlxuICAjIFBsdXMgaXQgbWF5IHN0YXJ0IHdpdGggYSAnOjonIHdoaWNoIGluZGljYXRlcyB0aGF0IHRoZSBjb25zdGFudCBjb21lcyBmcm9tIHRvcGxldmVsLlxuICBzZWxmOjpGT1JCSURERU5fQ09OU1RfTkFNRV9DSEFSUyA9ICdcXHUwMDAxLVxcdTAwMjBcXHUwMDIxLVxcdTAwMkZcXHUwMDNCLVxcdTAwM0ZcXHUwMDQwXFx1MDA1Qi1cXHUwMDVFXFx1MDA2MFxcdTAwN0ItXFx1MDA3RidcbiAgc2VsZjo6Q09OU1RfTkFNRV9SRUdFWFAgPSBSZWdleHAubmV3KFwiI3tzZWxmOjpSRUdFWFBfU1RBUlR9KDo6KT9bQS1aXVteI3tzZWxmOjpGT1JCSURERU5fQ09OU1RfTkFNRV9DSEFSU31dKiN7c2VsZjo6UkVHRVhQX0VORH1cIilcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOk9wYWw+Iiwic2VsZiIsIlJlZ2V4cCIsIm5ldyIsInNlbGY6OkZPUkJJRERFTl9TVEFSVElOR19JREVOVElGSUVSX0NIQVJTIiwic2VsZjo6Rk9SQklEREVOX0VORElOR19JREVOVElGSUVSX0NIQVJTIiwic2VsZjo6UkVHRVhQX1NUQVJUIiwic2VsZjo6Rk9SQklEREVOX0NPTlNUX05BTUVfQ0hBUlMiLCJzZWxmOjpSRUdFWFBfRU5EIl0sIm1hcHBpbmdzIjoiQUFBQUEsc0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7SUFDRSxXQUFBQyxJQUFBLGtCQUE2Q0QsR0FBN0M7SUFDQSxXQUFBQyxJQUFBLGdCQUEyQ0QsR0FBM0M7SUFTQSxXQUFBQyxJQUFBLHlDQUE0Q0QscUVBQTVDO0lBWUEsV0FBQUMsSUFBQSx1Q0FBNENELDJGQUE1QztJQUNBLFdBQUFDLElBQUEsOEJBQWlDQyxZQUFNQyxLQUFBQSxDQUFNSCxJQUFELEdBQUEsQ0FBS0ksSUFBQUgsSUFBQUcsd0NBQUwsQ0FBQSxHQUErQ0osTUFBL0MsR0FBQSxDQUFxREssSUFBQUosSUFBQUksc0NBQXJELENBQUEsR0FBNkZMLEdBQWxHRyxDQUF2QztJQUlBLFdBQUFGLElBQUEsZ0NBQW1DRCwyRkFBbkM7SUFDQUEsT0FBQSxXQUFBQyxJQUFBLHVCQUEwQkMsWUFBTUMsS0FBQUEsQ0FBSyxFQUFBLEdBQUEsQ0FBR0csSUFBQUwsSUFBQUssaUJBQUgsQ0FBQSxHQUFzQk4sY0FBdEIsR0FBQSxDQUFvQ08sSUFBQU4sSUFBQU0sK0JBQXBDLENBQUEsR0FBcUVQLElBQXJFLEdBQUEsQ0FBeUVRLElBQUFQLElBQUFPLGVBQXpFLENBQUxMLENBQWhDO0VBN0JGSCxHQUFBQSxXQUFBQTtBQUZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MTk3MzIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJvcGFsL21pbmkucmIiXSwic291cmNlc0NvbnRlbnQiOlsiOjpPYmplY3QucmVxdWlyZSAnb3BhbC9iYXNlJ1xuXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL25pbCdcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvYm9vbGVhbidcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvc3RyaW5nJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9jb21wYXJhYmxlJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhYmxlJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhdG9yJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9hcnJheSdcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvaGFzaCdcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvbnVtYmVyJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9yYW5nZSdcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvcHJvYydcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvbWV0aG9kJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9yZWdleHAnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3ZhcmlhYmxlcydcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvaW8nXG46Ok9iamVjdC5yZXF1aXJlICdvcGFsL3JlZ2V4cF9hbmNob3JzJ1xuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJPYmplY3QiLCJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiQUFBQUEsNEJBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLE9BQVFDLFNBQUFBLENBQVNGLFdBQVRFO0VBRVJELE9BQVFDLFNBQUFBLENBQVNGLGFBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGlCQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixnQkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0Ysb0JBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLG9CQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixvQkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsZUFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsY0FBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsZ0JBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGVBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGNBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLGdCQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixnQkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsbUJBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLFlBQVRFO0VBQ1JGLE9BQUFDLE9BQVFDLFNBQUFBLENBQVNGLHFCQUFURTtBQWpCUkY7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE5NzU2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9rZXJuZWwvZm9ybWF0LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogY29lcmNlX3RvXG4jIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcblxubW9kdWxlIDo6S2VybmVsXG4gIGRlZiBmb3JtYXQoZm9ybWF0X3N0cmluZywgKmFyZ3MpXG4gICAgaWYgYXJncy5sZW5ndGggPT0gMSAmJiBhcmdzWzBdLnJlc3BvbmRfdG8/KDp0b19hcnkpXG4gICAgICBhcnkgPSA6Ok9wYWwuY29lcmNlX3RvPyhhcmdzWzBdLCA6OkFycmF5LCA6dG9fYXJ5KVxuICAgICAgYXJncyA9IGFyeS50b19hIHVubGVzcyBhcnkubmlsP1xuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICAgICAgLy91c2VkIGZvciBzbGljaW5nOlxuICAgICAgICAgIGJlZ2luX3NsaWNlID0gMCxcbiAgICAgICAgICBlbmRfc2xpY2UsXG4gICAgICAgICAgLy91c2VkIGZvciBpdGVyYXRpbmcgb3ZlciB0aGUgZm9ybWF0IHN0cmluZzpcbiAgICAgICAgICBpLFxuICAgICAgICAgIGxlbiA9IGZvcm1hdF9zdHJpbmcubGVuZ3RoLFxuICAgICAgICAgIC8vdXNlZCBmb3IgcHJvY2Vzc2luZyBmaWVsZCB2YWx1ZXM6XG4gICAgICAgICAgYXJnLFxuICAgICAgICAgIHN0cixcbiAgICAgICAgICAvL3VzZWQgZm9yIHByb2Nlc3NpbmcgJWcgYW5kICVHIGZpZWxkczpcbiAgICAgICAgICBleHBvbmVudCxcbiAgICAgICAgICAvL3VzZWQgZm9yIGtlZXBpbmcgdHJhY2sgb2Ygd2lkdGggYW5kIHByZWNpc2lvbjpcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBwcmVjaXNpb24sXG4gICAgICAgICAgLy91c2VkIGZvciBob2xkaW5nIHRlbXBvcmFyeSB2YWx1ZXM6XG4gICAgICAgICAgdG1wX251bSxcbiAgICAgICAgICAvL3VzZWQgZm9yIHByb2Nlc3NpbmcgJXt9IGFuZCAlPD4gZmlsZWRzOlxuICAgICAgICAgIGhhc2hfcGFyYW1ldGVyX2tleSxcbiAgICAgICAgICBjbG9zaW5nX2JyYWNlX2NoYXIsXG4gICAgICAgICAgLy91c2VkIGZvciBwcm9jZXNzaW5nICViLCAlQiwgJW8sICV4LCBhbmQgJVggZmllbGRzOlxuICAgICAgICAgIGJhc2VfbnVtYmVyLFxuICAgICAgICAgIGJhc2VfcHJlZml4LFxuICAgICAgICAgIGJhc2VfbmVnX3plcm9fcmVnZXgsXG4gICAgICAgICAgYmFzZV9uZWdfemVyb19kaWdpdCxcbiAgICAgICAgICAvL3VzZWQgZm9yIHByb2Nlc3NpbmcgYXJndW1lbnRzOlxuICAgICAgICAgIG5leHRfYXJnLFxuICAgICAgICAgIHNlcV9hcmdfbnVtID0gMSxcbiAgICAgICAgICBwb3NfYXJnX251bSA9IDAsXG4gICAgICAgICAgLy91c2VkIGZvciBrZWVwaW5nIHRyYWNrIG9mIGZsYWdzOlxuICAgICAgICAgIGZsYWdzLFxuICAgICAgICAgIEZOT05FICA9IDAsXG4gICAgICAgICAgRlNIQVJQID0gMSxcbiAgICAgICAgICBGTUlOVVMgPSAyLFxuICAgICAgICAgIEZQTFVTICA9IDQsXG4gICAgICAgICAgRlpFUk8gID0gOCxcbiAgICAgICAgICBGU1BBQ0UgPSAxNixcbiAgICAgICAgICBGV0lEVEggPSAzMixcbiAgICAgICAgICBGUFJFQyAgPSA2NCxcbiAgICAgICAgICBGUFJFQzAgPSAxMjg7XG5cbiAgICAgIGZ1bmN0aW9uIENIRUNLX0ZPUl9GTEFHUygpIHtcbiAgICAgICAgaWYgKGZsYWdzJkZXSURUSCkgeyAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ2ZsYWcgYWZ0ZXIgd2lkdGgnfSB9XG4gICAgICAgIGlmIChmbGFncyZGUFJFQzApIHsgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdmbGFnIGFmdGVyIHByZWNpc2lvbid9IH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gQ0hFQ0tfRk9SX1dJRFRIKCkge1xuICAgICAgICBpZiAoZmxhZ3MmRldJRFRIKSB7ICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnd2lkdGggZ2l2ZW4gdHdpY2UnfSB9XG4gICAgICAgIGlmIChmbGFncyZGUFJFQzApIHsgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd3aWR0aCBhZnRlciBwcmVjaXNpb24nfSB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIEdFVF9OVEhfQVJHKG51bSkge1xuICAgICAgICBpZiAobnVtID49IGFyZ3MubGVuZ3RoKSB7ICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAndG9vIGZldyBhcmd1bWVudHMnfSB9XG4gICAgICAgIHJldHVybiBhcmdzW251bV07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIEdFVF9ORVhUX0FSRygpIHtcbiAgICAgICAgc3dpdGNoIChwb3NfYXJnX251bSkge1xuICAgICAgICBjYXNlIC0xOiAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ1bm51bWJlcmVkKCN7YHNlcV9hcmdfbnVtYH0pIG1peGVkIHdpdGggbnVtYmVyZWRcIn0gLy8gcmFpc2VcbiAgICAgICAgY2FzZSAtMjogI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwidW5udW1iZXJlZCgje2BzZXFfYXJnX251bWB9KSBtaXhlZCB3aXRoIG5hbWVkXCJ9IC8vIHJhaXNlXG4gICAgICAgIH1cbiAgICAgICAgcG9zX2FyZ19udW0gPSBzZXFfYXJnX251bSsrO1xuICAgICAgICByZXR1cm4gR0VUX05USF9BUkcocG9zX2FyZ19udW0gLSAxKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gR0VUX1BPU19BUkcobnVtKSB7XG4gICAgICAgIGlmIChwb3NfYXJnX251bSA+IDApIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJudW1iZXJlZCgje2BudW1gfSkgYWZ0ZXIgdW5udW1iZXJlZCgje2Bwb3NfYXJnX251bWB9KVwifVxuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NfYXJnX251bSA9PT0gLTIpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJudW1iZXJlZCgje2BudW1gfSkgYWZ0ZXIgbmFtZWRcIn1cbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtIDwgMSkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgaW5kZXggLSAje2BudW1gfSRcIn1cbiAgICAgICAgfVxuICAgICAgICBwb3NfYXJnX251bSA9IC0xO1xuICAgICAgICByZXR1cm4gR0VUX05USF9BUkcobnVtIC0gMSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIEdFVF9BUkcoKSB7XG4gICAgICAgIHJldHVybiAobmV4dF9hcmcgPT09IHVuZGVmaW5lZCA/IEdFVF9ORVhUX0FSRygpIDogbmV4dF9hcmcpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBSRUFEX05VTShsYWJlbCkge1xuICAgICAgICB2YXIgbnVtLCBzdHIgPSAnJztcbiAgICAgICAgZm9yICg7OyBpKyspIHtcbiAgICAgICAgICBpZiAoaSA9PT0gbGVuKSB7XG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ21hbGZvcm1lZCBmb3JtYXQgc3RyaW5nIC0gJSpbMC05XSd9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmb3JtYXRfc3RyaW5nLmNoYXJDb2RlQXQoaSkgPCA0OCB8fCBmb3JtYXRfc3RyaW5nLmNoYXJDb2RlQXQoaSkgPiA1Nykge1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgbnVtID0gcGFyc2VJbnQoc3RyLCAxMCkgfHwgMDtcbiAgICAgICAgICAgIGlmIChudW0gPiAyMTQ3NDgzNjQ3KSB7XG4gICAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIiN7YGxhYmVsYH0gdG9vIGJpZ1wifVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyICs9IGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIFJFQURfTlVNX0FGVEVSX0FTVEVSKGxhYmVsKSB7XG4gICAgICAgIHZhciBhcmcsIG51bSA9IFJFQURfTlVNKGxhYmVsKTtcbiAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkgKyAxKSA9PT0gJyQnKSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIGFyZyA9IEdFVF9QT1NfQVJHKG51bSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJnID0gR0VUX05FWFRfQVJHKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICN7YGFyZ2AudG9faW50fTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gZm9ybWF0X3N0cmluZy5pbmRleE9mKCclJyk7IGkgIT09IC0xOyBpID0gZm9ybWF0X3N0cmluZy5pbmRleE9mKCclJywgaSkpIHtcbiAgICAgICAgc3RyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGZsYWdzID0gRk5PTkU7XG4gICAgICAgIHdpZHRoID0gLTE7XG4gICAgICAgIHByZWNpc2lvbiA9IC0xO1xuICAgICAgICBuZXh0X2FyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgICBlbmRfc2xpY2UgPSBpO1xuXG4gICAgICAgIGkrKztcblxuICAgICAgICBzd2l0Y2ggKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpKSB7XG4gICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgIGJlZ2luX3NsaWNlID0gaTtcbiAgICAgICAgICAvLyBuby1icmVha1xuICAgICAgICBjYXNlICcnOlxuICAgICAgICBjYXNlICdcXG4nOlxuICAgICAgICBjYXNlICdcXDAnOlxuICAgICAgICAgIGkrKztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdF9zZXF1ZW5jZTogZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHN3aXRjaCAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkpIHtcblxuICAgICAgICAgIGNhc2UgJyAnOlxuICAgICAgICAgICAgQ0hFQ0tfRk9SX0ZMQUdTKCk7XG4gICAgICAgICAgICBmbGFncyB8PSBGU1BBQ0U7XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgIENIRUNLX0ZPUl9GTEFHUygpO1xuICAgICAgICAgICAgZmxhZ3MgfD0gRlNIQVJQO1xuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICBDSEVDS19GT1JfRkxBR1MoKTtcbiAgICAgICAgICAgIGZsYWdzIHw9IEZQTFVTO1xuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICBDSEVDS19GT1JfRkxBR1MoKTtcbiAgICAgICAgICAgIGZsYWdzIHw9IEZNSU5VUztcbiAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJzAnOlxuICAgICAgICAgICAgQ0hFQ0tfRk9SX0ZMQUdTKCk7XG4gICAgICAgICAgICBmbGFncyB8PSBGWkVSTztcbiAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJzEnOlxuICAgICAgICAgIGNhc2UgJzInOlxuICAgICAgICAgIGNhc2UgJzMnOlxuICAgICAgICAgIGNhc2UgJzQnOlxuICAgICAgICAgIGNhc2UgJzUnOlxuICAgICAgICAgIGNhc2UgJzYnOlxuICAgICAgICAgIGNhc2UgJzcnOlxuICAgICAgICAgIGNhc2UgJzgnOlxuICAgICAgICAgIGNhc2UgJzknOlxuICAgICAgICAgICAgdG1wX251bSA9IFJFQURfTlVNKCd3aWR0aCcpO1xuICAgICAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkgKyAxKSA9PT0gJyQnKSB7XG4gICAgICAgICAgICAgIGlmIChpICsgMiA9PT0gbGVuKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gJyUnO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBicmVhayBmb3JtYXRfc2VxdWVuY2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG5leHRfYXJnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ2YWx1ZSBnaXZlbiB0d2ljZSAtICUje2B0bXBfbnVtYH0kXCJ9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbmV4dF9hcmcgPSBHRVRfUE9TX0FSRyh0bXBfbnVtKTtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgQ0hFQ0tfRk9SX1dJRFRIKCk7XG4gICAgICAgICAgICAgIGZsYWdzIHw9IEZXSURUSDtcbiAgICAgICAgICAgICAgd2lkdGggPSB0bXBfbnVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgY2FzZSAnXFx7JzpcbiAgICAgICAgICAgIGNsb3NpbmdfYnJhY2VfY2hhciA9IChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSA9PT0gJzwnID8gJz4nIDogJ1xcfScpO1xuICAgICAgICAgICAgaGFzaF9wYXJhbWV0ZXJfa2V5ID0gJyc7XG5cbiAgICAgICAgICAgIGkrKztcblxuICAgICAgICAgICAgZm9yICg7OyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGkgPT09IGxlbikge1xuICAgICAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbWFsZm9ybWVkIG5hbWUgLSB1bm1hdGNoZWQgcGFyZW50aGVzaXMnfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSA9PT0gY2xvc2luZ19icmFjZV9jaGFyKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocG9zX2FyZ19udW0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJuYW1lZCAje2BoYXNoX3BhcmFtZXRlcl9rZXlgfSBhZnRlciB1bm51bWJlcmVkKCN7YHBvc19hcmdfbnVtYH0pXCJ9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3NfYXJnX251bSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIm5hbWVkICN7YGhhc2hfcGFyYW1ldGVyX2tleWB9IGFmdGVyIG51bWJlcmVkXCJ9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvc19hcmdfbnVtID0gLTI7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJnc1swXSA9PT0gdW5kZWZpbmVkIHx8ICFhcmdzWzBdLiQkaXNfaGFzaCkge1xuICAgICAgICAgICAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdvbmUgaGFzaCByZXF1aXJlZCd9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbmV4dF9hcmcgPSAje2BhcmdzWzBdYC5mZXRjaChgaGFzaF9wYXJhbWV0ZXJfa2V5YCl9O1xuXG4gICAgICAgICAgICAgICAgaWYgKGNsb3NpbmdfYnJhY2VfY2hhciA9PT0gJz4nKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHN0ciA9IG5leHRfYXJnLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICBpZiAocHJlY2lzaW9uICE9PSAtMSkgeyBzdHIgPSBzdHIuc2xpY2UoMCwgcHJlY2lzaW9uKTsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaGFzaF9wYXJhbWV0ZXJfa2V5ICs9IGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmFpc2VcblxuICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgQ0hFQ0tfRk9SX1dJRFRIKCk7XG4gICAgICAgICAgICBmbGFncyB8PSBGV0lEVEg7XG4gICAgICAgICAgICB3aWR0aCA9IFJFQURfTlVNX0FGVEVSX0FTVEVSKCd3aWR0aCcpO1xuICAgICAgICAgICAgaWYgKHdpZHRoIDwgMCkge1xuICAgICAgICAgICAgICBmbGFncyB8PSBGTUlOVVM7XG4gICAgICAgICAgICAgIHdpZHRoID0gLXdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgICBpZiAoZmxhZ3MmRlBSRUMwKSB7XG4gICAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAncHJlY2lzaW9uIGdpdmVuIHR3aWNlJ31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZsYWdzIHw9IEZQUkVDfEZQUkVDMDtcbiAgICAgICAgICAgIHByZWNpc2lvbiA9IDA7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBpZiAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkgPT09ICcqJykge1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIHByZWNpc2lvbiA9IFJFQURfTlVNX0FGVEVSX0FTVEVSKCdwcmVjaXNpb24nKTtcbiAgICAgICAgICAgICAgaWYgKHByZWNpc2lvbiA8IDApIHtcbiAgICAgICAgICAgICAgICBmbGFncyAmPSB+RlBSRUM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlY2lzaW9uID0gUkVBRF9OVU0oJ3ByZWNpc2lvbicpO1xuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICBhcmcgPSAjezo6S2VybmVsLkludGVnZXIoYEdFVF9BUkcoKWApfTtcbiAgICAgICAgICAgIGlmIChhcmcgPj0gMCkge1xuICAgICAgICAgICAgICBzdHIgPSBhcmcudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCBwcmVjaXNpb24pIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGWkVSTyAmJiBwcmVjaXNpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gKChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpID8gMSA6IDApKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0ciA9ICgtYXJnKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHByZWNpc2lvbikgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGWkVSTyAmJiBwcmVjaXNpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gMSkgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgIGNhc2UgJ0InOlxuICAgICAgICAgIGNhc2UgJ28nOlxuICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgIGNhc2UgJ1gnOlxuICAgICAgICAgICAgc3dpdGNoIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSkge1xuICAgICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICBjYXNlICdCJzpcbiAgICAgICAgICAgICAgYmFzZV9udW1iZXIgPSAyO1xuICAgICAgICAgICAgICBiYXNlX3ByZWZpeCA9ICcwYic7XG4gICAgICAgICAgICAgIGJhc2VfbmVnX3plcm9fcmVnZXggPSAvXjErLztcbiAgICAgICAgICAgICAgYmFzZV9uZWdfemVyb19kaWdpdCA9ICcxJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdvJzpcbiAgICAgICAgICAgICAgYmFzZV9udW1iZXIgPSA4O1xuICAgICAgICAgICAgICBiYXNlX3ByZWZpeCA9ICcwJztcbiAgICAgICAgICAgICAgYmFzZV9uZWdfemVyb19yZWdleCA9IC9eMz83Ky87XG4gICAgICAgICAgICAgIGJhc2VfbmVnX3plcm9fZGlnaXQgPSAnNyc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICBjYXNlICdYJzpcbiAgICAgICAgICAgICAgYmFzZV9udW1iZXIgPSAxNjtcbiAgICAgICAgICAgICAgYmFzZV9wcmVmaXggPSAnMHgnO1xuICAgICAgICAgICAgICBiYXNlX25lZ196ZXJvX3JlZ2V4ID0gL15mKy87XG4gICAgICAgICAgICAgIGJhc2VfbmVnX3plcm9fZGlnaXQgPSAnZic7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJnID0gI3s6Oktlcm5lbC5JbnRlZ2VyKGBHRVRfQVJHKClgKX07XG4gICAgICAgICAgICBpZiAoYXJnID49IDApIHtcbiAgICAgICAgICAgICAgc3RyID0gYXJnLnRvU3RyaW5nKGJhc2VfbnVtYmVyKTtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCBwcmVjaXNpb24pIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQICYmIGFyZyAhPT0gMCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIHByZWNpc2lvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAoKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgPyAxIDogMCkgLSAoKGZsYWdzJkZTSEFSUCAmJiBhcmcgIT09IDApID8gYmFzZV9wcmVmaXgubGVuZ3RoIDogMCkpIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQICYmIGFyZyAhPT0gMCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlAgJiYgYXJnICE9PSAwKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gKC1hcmcpLnRvU3RyaW5nKGJhc2VfbnVtYmVyKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHByZWNpc2lvbikgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlpFUk8gJiYgcHJlY2lzaW9uID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gMSAtIChmbGFncyZGU0hBUlAgPyAyIDogMCkpIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlApIHsgc3RyID0gYmFzZV9wcmVmaXggKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0ciA9IChhcmcgPj4+IDApLnRvU3RyaW5nKGJhc2VfbnVtYmVyKS5yZXBsYWNlKGJhc2VfbmVnX3plcm9fcmVnZXgsIGJhc2VfbmVnX3plcm9fZGlnaXQpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgcHJlY2lzaW9uIC0gMikgeyBzdHIgPSBiYXNlX25lZ196ZXJvX2RpZ2l0ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgICAgc3RyID0gJy4uJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlApIHsgc3RyID0gYmFzZV9wcmVmaXggKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGWkVSTyAmJiBwcmVjaXNpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAyIC0gKGZsYWdzJkZTSEFSUCA/IGJhc2VfcHJlZml4Lmxlbmd0aCA6IDApKSB7IHN0ciA9IGJhc2VfbmVnX3plcm9fZGlnaXQgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgICAgc3RyID0gJy4uJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gJy4uJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpID09PSBmb3JtYXRfc3RyaW5nLmNoYXJBdChpKS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgIHN0ciA9IHN0ci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgY2FzZSAnRyc6XG4gICAgICAgICAgICBhcmcgPSAjezo6S2VybmVsLkZsb2F0KGBHRVRfQVJHKClgKX07XG4gICAgICAgICAgICBpZiAoYXJnID49IDAgfHwgaXNOYU4oYXJnKSkge1xuICAgICAgICAgICAgICBpZiAoYXJnID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgIHN0ciA9ICdJbmYnO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgICAgIHN0ciA9IGFyZy50b0ZpeGVkKHByZWNpc2lvbiA9PT0gLTEgPyA2IDogcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2UnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICAgICAgICAgICAgc3RyID0gYXJnLnRvRXhwb25lbnRpYWwocHJlY2lzaW9uID09PSAtMSA/IDYgOiBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnRyc6XG4gICAgICAgICAgICAgICAgICBzdHIgPSBhcmcudG9FeHBvbmVudGlhbCgpO1xuICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSBwYXJzZUludChzdHIuc3BsaXQoJ2UnKVsxXSwgMTApO1xuICAgICAgICAgICAgICAgICAgaWYgKCEoZXhwb25lbnQgPCAtNCB8fCBleHBvbmVudCA+PSAocHJlY2lzaW9uID09PSAtMSA/IDYgOiBwcmVjaXNpb24pKSkge1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSBhcmcudG9QcmVjaXNpb24ocHJlY2lzaW9uID09PSAtMSA/IChmbGFncyZGU0hBUlAgPyA2IDogdW5kZWZpbmVkKSA6IHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIGFyZyAhPT0gSW5maW5pdHkgJiYgIWlzTmFOKGFyZykpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAoKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgPyAxIDogMCkpIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGFyZyA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgc3RyID0gJ0luZic7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgICAgc3RyID0gKC1hcmcpLnRvRml4ZWQocHJlY2lzaW9uID09PSAtMSA/IDYgOiBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICAgICAgICBzdHIgPSAoLWFyZykudG9FeHBvbmVudGlhbChwcmVjaXNpb24gPT09IC0xID8gNiA6IHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICAgICAgICBjYXNlICdHJzpcbiAgICAgICAgICAgICAgICAgIHN0ciA9ICgtYXJnKS50b0V4cG9uZW50aWFsKCk7XG4gICAgICAgICAgICAgICAgICBleHBvbmVudCA9IHBhcnNlSW50KHN0ci5zcGxpdCgnZScpWzFdLCAxMCk7XG4gICAgICAgICAgICAgICAgICBpZiAoIShleHBvbmVudCA8IC00IHx8IGV4cG9uZW50ID49IChwcmVjaXNpb24gPT09IC0xID8gNiA6IHByZWNpc2lvbikpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9ICgtYXJnKS50b1ByZWNpc2lvbihwcmVjaXNpb24gPT09IC0xID8gKGZsYWdzJkZTSEFSUCA/IDYgOiB1bmRlZmluZWQpIDogcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIGFyZyAhPT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gMSkgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSA9PT0gZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkudG9VcHBlckNhc2UoKSAmJiBhcmcgIT09IEluZmluaXR5ICYmIGFyZyAhPT0gLUluZmluaXR5ICYmICFpc05hTihhcmcpKSB7XG4gICAgICAgICAgICAgIHN0ciA9IHN0ci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoLyhbZUVdWy0rXT8pKFswLTldKSQvLCAnJDEwJDInKTtcbiAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgLy8gTm90IGltcGxlbWVudGVkIGJlY2F1c2UgdGhlcmUgYXJlIG5vIHNwZWNzIGZvciB0aGlzIGZpZWxkIHR5cGUuXG4gICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6Tm90SW1wbGVtZW50ZWRFcnJvciwgJ2BBYCBhbmQgYGFgIGZvcm1hdCBmaWVsZCB0eXBlcyBhcmUgbm90IGltcGxlbWVudGVkIGluIE9wYWwgeWV0J31cbiAgICAgICAgICAgIC8vIHJhaXNlXG5cbiAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgIGFyZyA9IEdFVF9BUkcoKTtcbiAgICAgICAgICAgIGlmICgje2BhcmdgLnJlc3BvbmRfdG8/KDp0b19hcnkpfSkgeyBhcmcgPSAje2BhcmdgLnRvX2FyeX1bMF07IH1cbiAgICAgICAgICAgIGlmICgje2BhcmdgLnJlc3BvbmRfdG8/KDp0b19zdHIpfSkge1xuICAgICAgICAgICAgICBzdHIgPSAje2BhcmdgLnRvX3N0cn07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCRjb2VyY2VfdG8oYXJnLCAjezo6SW50ZWdlcn0sICd0b19pbnQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJyVjIHJlcXVpcmVzIGEgY2hhcmFjdGVyJ31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhayBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICdwJzpcbiAgICAgICAgICAgIHN0ciA9ICN7YEdFVF9BUkcoKWAuaW5zcGVjdH07XG4gICAgICAgICAgICBpZiAocHJlY2lzaW9uICE9PSAtMSkgeyBzdHIgPSBzdHIuc2xpY2UoMCwgcHJlY2lzaW9uKTsgfVxuICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgc3RyID0gI3tgR0VUX0FSRygpYC50b19zfTtcbiAgICAgICAgICAgIGlmIChwcmVjaXNpb24gIT09IC0xKSB7IHN0ciA9IHN0ci5zbGljZSgwLCBwcmVjaXNpb24pOyB9XG4gICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIm1hbGZvcm1lZCBmb3JtYXQgc3RyaW5nIC0gJSN7YGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpYH1cIn1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ21hbGZvcm1lZCBmb3JtYXQgc3RyaW5nIC0gJSd9XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgKz0gZm9ybWF0X3N0cmluZy5zbGljZShiZWdpbl9zbGljZSwgZW5kX3NsaWNlKSArIHN0cjtcbiAgICAgICAgYmVnaW5fc2xpY2UgPSBpICsgMTtcbiAgICAgIH1cblxuICAgICAgaWYgKCN7JERFQlVHfSAmJiBwb3NfYXJnX251bSA+PSAwICYmIHNlcV9hcmdfbnVtIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd0b28gbWFueSBhcmd1bWVudHMgZm9yIGZvcm1hdCBzdHJpbmcnfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0ICsgZm9ybWF0X3N0cmluZy5zbGljZShiZWdpbl9zbGljZSk7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBzcHJpbnRmIGZvcm1hdFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6S2VybmVsPiIsImZvcm1hdCIsImZvcm1hdF9zdHJpbmciLCJhcmdzIiwibGVuZ3RoIiwiMSIsIltdIiwiMCIsInJlc3BvbmRfdG8/IiwiYXJ5IiwiT3BhbCIsImNvZXJjZV90bz8iLCJBcnJheSIsIm5pbD8iLCJ0b19hIiwiS2VybmVsIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwidG9faW50IiwiZmV0Y2giLCJJbnRlZ2VyIiwiRmxvYXQiLCJOb3RJbXBsZW1l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QUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsa0JBQW9CYyxPQUFRSyxTQUFBQSxDQUFVbkIsU0FBVm1CLENBQXNCbkI7QUFDbERBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSxrQkFBb0JjLE9BQVFNLE9BQUFBLENBQVFwQixTQUFSb0IsQ0FBb0JwQjtBQUNoREE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBLFlBQWNjLE9BQVFDLE9BQUFBLENBQU9NLDBCQUFmLEVBQXNDckIsZ0VBQTlCZTtBQUN0QmY7O0FBRUFBO0FBQ0FBO0FBQ0FBLGdCQUFrQkEsQ0FBQ0EsR0FBREEsQ0FBS08sZ0JBQUFBLENBQWEsUUFBYkEsQ0FBc0JQLFVBQVlBLENBQUNBLEdBQURBLENBQUtzQixRQUFBQSxDQUFBQSxDQUFRdEI7QUFDdEVBLGdCQUFrQkEsQ0FBQ0EsR0FBREEsQ0FBS08sZ0JBQUFBLENBQWEsUUFBYkEsQ0FBc0JQO0FBQzdDQSxvQkFBc0JBLENBQUNBLEdBQURBLENBQUt1QixRQUFBQSxDQUFBQSxDQUFRdkI7QUFDbkNBO0FBQ0FBLHdEQUEwRG1CLGNBQVVuQjtBQUNwRUE7QUFDQUE7QUFDQUEsY0FBZ0JjLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWdDaEIseUJBQXhCZTtBQUN4QmY7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBLGtCQUFvQkEsQ0FBQ0EsU0FBREEsQ0FBV3dCLFNBQUFBLENBQUFBLENBQVN4QjtBQUN4Q0E7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBLGtCQUFvQkEsQ0FBQ0EsU0FBREEsQ0FBV3lCLE1BQUFBLENBQUFBLENBQU16QjtBQUNyQ0E7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBLFlBQWNjLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWlDaEIsNkJBQUQsR0FBQSxDQUErQkEsdUJBQS9CLENBQXhCZTtBQUN0QmY7QUFDQUE7O0FBRUFBO0FBQ0FBLFVBQVljLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWdDaEIsNkJBQXhCZTtBQUNwQmY7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQSxVQUFZMEIsWUFBTzFCO0FBQ25CQSxRQUFVYyxPQUFRQyxPQUFBQSxDQUFPQyxvQkFBZixFQUFnQ2hCLHNDQUF4QmU7QUFDbEJmOztBQUVBQTtBQUNBQTtJQTdoQkVBLENBQUFBLElBQUFBO0lBZ2lCQUQsT0FBQSxhQUFNLFNBQU4sRUFBYyxRQUFkO0VBamlCRkEsR0FBTyxJQUFQQTtBQUhBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MjAzMjEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3N0cmluZy9lbmNvZGluZy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcblxucmVxdWlyZSAnY29yZWxpYi9zdHJpbmcnXG5cbmNsYXNzIDo6RW5jb2RpbmdcbiAgZGVmIHNlbGYucmVnaXN0ZXIobmFtZSwgb3B0aW9ucyA9IHt9LCAmYmxvY2spXG4gICAgbmFtZXMgPSBbbmFtZV0gKyAob3B0aW9uc1s6YWxpYXNlc10gfHwgW10pXG4gICAgYXNjaWkgPSBvcHRpb25zWzphc2NpaV0gfHwgZmFsc2VcbiAgICBkdW1teSA9IG9wdGlvbnNbOmR1bW15XSB8fCBmYWxzZVxuXG4gICAgaWYgb3B0aW9uc1s6aW5oZXJpdHNdXG4gICAgICBlbmNvZGluZyA9IG9wdGlvbnNbOmluaGVyaXRzXS5jbG9uZVxuICAgICAgZW5jb2RpbmcuaW5pdGlhbGl6ZShuYW1lLCBuYW1lcywgYXNjaWksIGR1bW15KVxuICAgIGVsc2VcbiAgICAgIGVuY29kaW5nID0gbmV3KG5hbWUsIG5hbWVzLCBhc2NpaSwgZHVtbXkpXG4gICAgZW5kXG4gICAgZW5jb2RpbmcuaW5zdGFuY2VfZXZhbCgmYmxvY2spIGlmIGJsb2NrX2dpdmVuP1xuXG4gICAgcmVnaXN0ZXIgPSBgT3BhbC5lbmNvZGluZ3NgXG4gICAgbmFtZXMuZWFjaCBkbyB8ZW5jb2RpbmdfbmFtZXxcbiAgICAgIGNvbnN0X3NldCBlbmNvZGluZ19uYW1lLnRyKCctJywgJ18nKSwgZW5jb2RpbmdcbiAgICAgIHJlZ2lzdGVyLkpTW2VuY29kaW5nX25hbWVdID0gZW5jb2RpbmdcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNlbGYuZmluZChuYW1lKVxuICAgIHJldHVybiBkZWZhdWx0X2V4dGVybmFsIGlmIG5hbWUgPT0gOmRlZmF1bHRfZXh0ZXJuYWxcbiAgICBgcmV0dXJuIE9wYWwuZmluZF9lbmNvZGluZyhuYW1lKWBcbiAgZW5kXG5cbiAgc2luZ2xldG9uX2NsYXNzLmF0dHJfYWNjZXNzb3IgOmRlZmF1bHRfZXh0ZXJuYWxcblxuICBhdHRyX3JlYWRlciA6bmFtZSwgOm5hbWVzXG5cbiAgZGVmIGluaXRpYWxpemUobmFtZSwgbmFtZXMsIGFzY2lpLCBkdW1teSlcbiAgICBAbmFtZSAgPSBuYW1lXG4gICAgQG5hbWVzID0gbmFtZXNcbiAgICBAYXNjaWkgPSBhc2NpaVxuICAgIEBkdW1teSA9IGR1bW15XG4gIGVuZFxuXG4gIGRlZiBhc2NpaV9jb21wYXRpYmxlP1xuICAgIEBhc2NpaVxuICBlbmRcblxuICBkZWYgZHVtbXk/XG4gICAgQGR1bW15XG4gIGVuZFxuXG4gIGRlZiBiaW5hcnk/XG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBAbmFtZVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIFwiIzxFbmNvZGluZzoje0BuYW1lfSN7JyAoZHVtbXkpJyBpZiBAZHVtbXl9PlwiXG4gIGVuZFxuXG4gICMgbWV0aG9kcyB0byBpbXBsZW1lbnQgcGVyIGVuY29kaW5nXG4gIGRlZiBjaGFyc2l6ZShzdHJpbmcpXG4gICAgJXh7XG4gICAgICB2YXIgbGVuID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoYXJjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmICghKGNoYXJjb2RlID49IDB4RDgwMCAmJiBjaGFyY29kZSA8PSAweERCRkYpKSB7XG4gICAgICAgICAgbGVuKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBsZW47XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaF9jaGFyKHN0cmluZywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIGxvd19zdXJyb2dhdGUgPSBcIlwiO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hhcmNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdmFyIGNociA9IHN0cmluZy5jaGFyQXQoaSk7XG4gICAgICAgIGlmIChjaGFyY29kZSA+PSAweERDMDAgJiYgY2hhcmNvZGUgPD0gMHhERkZGKSB7XG4gICAgICAgICAgbG93X3N1cnJvZ2F0ZSA9IGNocjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFyY29kZSA+PSAweEQ4MDAgJiYgY2hhcmNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICAgICAgY2hyID0gbG93X3N1cnJvZ2F0ZSArIGNocjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyaW5nLmVuY29kaW5nLm5hbWUgIT0gXCJVVEYtOFwiKSB7XG4gICAgICAgICAgY2hyID0gbmV3IFN0cmluZyhjaHIpO1xuICAgICAgICAgIGNoci5lbmNvZGluZyA9IHN0cmluZy5lbmNvZGluZztcbiAgICAgICAgfVxuICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgY2hyKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlYWNoX2J5dGUoKilcbiAgICA6Oktlcm5lbC5yYWlzZSA6Ok5vdEltcGxlbWVudGVkRXJyb3JcbiAgZW5kXG5cbiAgZGVmIGJ5dGVzaXplKCopXG4gICAgOjpLZXJuZWwucmFpc2UgOjpOb3RJbXBsZW1lbnRlZEVycm9yXG4gIGVuZFxuXG4gIGNsYXNzIDo6RW5jb2RpbmdFcnJvciA8IDo6U3RhbmRhcmRFcnJvcjsgZW5kXG4gIGNsYXNzIDo6Q29tcGF0aWJpbGl0eUVycm9yIDwgOjpFbmNvZGluZ0Vycm9yOyBlbmRcbiAgY2xhc3MgVW5kZWZpbmVkQ29udmVyc2lvbkVycm9yIDwgOjpFbmNvZGluZ0Vycm9yOyBlbmRcbmVuZFxuXG46OkVuY29kaW5nLnJlZ2lzdGVyICdVVEYtOCcsIGFsaWFzZXM6IFsnQ1A2NTAwMSddLCBhc2NpaTogdHJ1ZSBkb1xuICBkZWYgZWFjaF9ieXRlKHN0cmluZywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgLy8gVGFrZW4gZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi9mNTJkZmZkOWRmMDQ0NWI5M2MwYzkwNjVjMmY4ZjBmNDZiMmM3MjlhL2luZGV4LmpzI0wxOTU0LUwyMDMyXG4gICAgICB2YXIgdW5pdHMgPSBJbmZpbml0eTtcbiAgICAgIHZhciBjb2RlUG9pbnQ7XG4gICAgICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgICAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgI3t5aWVsZCBgMHhFRmB9O1xuICAgICAgICAgICAgICAgICN7eWllbGQgYDB4QkZgfTtcbiAgICAgICAgICAgICAgICAje3lpZWxkIGAweEJEYH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAje3lpZWxkIGAweEVGYH07XG4gICAgICAgICAgICAgICAgI3t5aWVsZCBgMHhCRmB9O1xuICAgICAgICAgICAgICAgICN7eWllbGQgYDB4QkRgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkge1xuICAgICAgICAgICAgICAje3lpZWxkIGAweEVGYH07XG4gICAgICAgICAgICAgICN7eWllbGQgYDB4QkZgfTtcbiAgICAgICAgICAgICAgI3t5aWVsZCBgMHhCRGB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMDtcbiAgICAgICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkge1xuICAgICAgICAgICAgI3t5aWVsZCBgMHhFRmB9O1xuICAgICAgICAgICAgI3t5aWVsZCBgMHhCRmB9O1xuICAgICAgICAgICAgI3t5aWVsZCBgMHhCRGB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsO1xuXG4gICAgICAgIC8vIGVuY29kZSB1dGY4XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrO1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludGB9O1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrO1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludCA+PiAweDYgfCAweEMwYH07XG4gICAgICAgICAgI3t5aWVsZCBgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBgfTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrO1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludCA+PiAweEMgfCAweEUwYH07XG4gICAgICAgICAgI3t5aWVsZCBgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwYH07XG4gICAgICAgICAgI3t5aWVsZCBgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBgfTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVhaztcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MGB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEludmFsaWQgY29kZSBwb2ludFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYnl0ZXNpemUoc3RyaW5nKVxuICAgIHN0cmluZy5ieXRlcy5sZW5ndGhcbiAgZW5kXG5lbmRcblxuOjpFbmNvZGluZy5yZWdpc3RlciAnVVRGLTE2TEUnIGRvXG4gIGRlZiBlYWNoX2J5dGUoc3RyaW5nLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgI3t5aWVsZCBgY29kZSAmIDB4ZmZgfTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSA+PiA4YH07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYnl0ZXNpemUoc3RyaW5nKVxuICAgIGBzdHJpbmcubGVuZ3RoICogMmBcbiAgZW5kXG5lbmRcblxuOjpFbmNvZGluZy5yZWdpc3RlciAnVVRGLTE2QkUnLCBpbmhlcml0czogOjpFbmNvZGluZzo6VVRGXzE2TEUgZG9cbiAgZGVmIGVhY2hfYnl0ZShzdHJpbmcsICZibG9jaylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgICAgICAje3lpZWxkIGBjb2RlID4+IDhgfTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSAmIDB4ZmZgfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuZW5kXG5cbjo6RW5jb2RpbmcucmVnaXN0ZXIgJ1VURi0zMkxFJyBkb1xuICBkZWYgZWFjaF9ieXRlKHN0cmluZywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgICN7eWllbGQgYGNvZGUgJiAweGZmYH07XG4gICAgICAgICN7eWllbGQgYGNvZGUgPj4gOGB9O1xuICAgICAgICAje3lpZWxkIDB9O1xuICAgICAgICAje3lpZWxkIDB9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGJ5dGVzaXplKHN0cmluZylcbiAgICBgc3RyaW5nLmxlbmd0aCAqIDRgXG4gIGVuZFxuZW5kXG5cbjo6RW5jb2RpbmcucmVnaXN0ZXIgJ1VURi0zMkJFJywgaW5oZXJpdHM6IDo6RW5jb2Rpbmc6OlVURl8zMkxFIGRvXG4gIGRlZiBlYWNoX2J5dGUoc3RyaW5nLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgI3t5aWVsZCAwfTtcbiAgICAgICAgI3t5aWVsZCAwfTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSA+PiA4YH07XG4gICAgICAgICN7eWllbGQgYGNvZGUgJiAweGZmYH07XG4gICAgICB9XG4gICAgfVxuICBlbmRcbmVuZFxuXG46OkVuY29kaW5nLnJlZ2lzdGVyICdBU0NJSS04QklUJywgYWxpYXNlczogWydCSU5BUlknXSwgYXNjaWk6IHRydWUgZG9cbiAgZGVmIGVhY2hfY2hhcihzdHJpbmcsICZibG9jaylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNociA9IG5ldyBTdHJpbmcoc3RyaW5nLmNoYXJBdChpKSk7XG4gICAgICAgIGNoci5lbmNvZGluZyA9IHN0cmluZy5lbmNvZGluZztcbiAgICAgICAgI3t5aWVsZCBgY2hyYH07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2hhcnNpemUoc3RyaW5nKVxuICAgIGBzdHJpbmcubGVuZ3RoYFxuICBlbmRcblxuICBkZWYgZWFjaF9ieXRlKHN0cmluZywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAje3lpZWxkIGBjb2RlICYgMHhmZmB9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGJ5dGVzaXplKHN0cmluZylcbiAgICBgc3RyaW5nLmxlbmd0aGBcbiAgZW5kXG5cbiAgZGVmIGJpbmFyeT9cbiAgICB0cnVlXG4gIGVuZFxuZW5kXG5cbjo6RW5jb2RpbmcucmVnaXN0ZXIgJ0lTTy04ODU5LTEnLCBhbGlhc2VzOiBbJ0lTTzg4NTktMSddLCBhc2NpaTogdHJ1ZSwgaW5oZXJpdHM6IDo6RW5jb2Rpbmc6OkFTQ0lJXzhCSVRcbjo6RW5jb2RpbmcucmVnaXN0ZXIgJ1VTLUFTQ0lJJywgYWxpYXNlczogWydBU0NJSSddLCBhc2NpaTogdHJ1ZSwgaW5oZXJpdHM6IDo6RW5jb2Rpbmc6OkFTQ0lJXzhCSVRcblxuY2xhc3MgOjpTdHJpbmdcbiAgYXR0cl9yZWFkZXIgOmVuY29kaW5nXG4gIGF0dHJfcmVhZGVyIDppbnRlcm5hbF9lbmNvZGluZ1xuICBgT3BhbC5wcm9wKFN0cmluZy5wcm90b3R5cGUsICdieXRlcycsIG5pbClgXG4gIGBPcGFsLnByb3AoU3RyaW5nLnByb3RvdHlwZSwgJ2VuY29kaW5nJywgI3s6OkVuY29kaW5nOjpVVEZfOH0pYFxuICBgT3BhbC5wcm9wKFN0cmluZy5wcm90b3R5cGUsICdpbnRlcm5hbF9lbmNvZGluZycsICN7OjpFbmNvZGluZzo6VVRGXzh9KWBcblxuICBkZWYgYlxuICAgIGR1cC5mb3JjZV9lbmNvZGluZygnYmluYXJ5JylcbiAgZW5kXG5cbiAgZGVmIGJ5dGVzaXplXG4gICAgQGludGVybmFsX2VuY29kaW5nLmJ5dGVzaXplKHNlbGYpXG4gIGVuZFxuXG4gIGRlZiBlYWNoX2J5dGUoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9ieXRlKSB7IGJ5dGVzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgQGludGVybmFsX2VuY29kaW5nLmVhY2hfYnl0ZShzZWxmLCAmYmxvY2spXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBieXRlc1xuICAgICMgUkVNSU5EOiByZXF1aXJlZCB3aGVuIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIG90aGVyd2lzZSB0aGUgZm9sbG93aW5nIGVycm9yIHdpbGwgYmUgdGhyb3duOlxuICAgICMgQ2Fubm90IGNyZWF0ZSBwcm9wZXJ0eSAnYnl0ZXMnIG9uIHN0cmluZyAnYWJjJ1xuICAgICV4e1xuICAgICAgaWYgKHR5cGVvZiBzZWxmID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gI3tgbmV3IFN0cmluZyhzZWxmKWAuZWFjaF9ieXRlLnRvX2F9O1xuICAgICAgfVxuICAgIH1cblxuICAgIEBieXRlcyB8fD0gZWFjaF9ieXRlLnRvX2FcbiAgICBAYnl0ZXMuZHVwXG4gIGVuZFxuXG4gIGRlZiBlYWNoX2NoYXIoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9jaGFyKSB7IGxlbmd0aCB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIEBlbmNvZGluZy5lYWNoX2NoYXIoc2VsZiwgJmJsb2NrKVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY2hhcnMoJmJsb2NrKVxuICAgIHJldHVybiBlYWNoX2NoYXIudG9fYSB1bmxlc3MgYmxvY2tcblxuICAgIGVhY2hfY2hhcigmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBlYWNoX2NvZGVwb2ludCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDplYWNoX2NvZGVwb2ludCB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAje3lpZWxkIGBzZWxmLmNvZGVQb2ludEF0KGkpYH07XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGNvZGVwb2ludHMoJmJsb2NrKVxuICAgICMgSWYgYSBibG9jayBpcyBnaXZlbiwgd2hpY2ggaXMgYSBkZXByZWNhdGVkIGZvcm0sIHdvcmtzIHRoZSBzYW1lIGFzIGVhY2hfY29kZXBvaW50LlxuICAgIHJldHVybiBlYWNoX2NvZGVwb2ludCgmYmxvY2spIGlmIGJsb2NrX2dpdmVuP1xuICAgIGVhY2hfY29kZXBvaW50LnRvX2FcbiAgZW5kXG5cbiAgZGVmIGVuY29kZShlbmNvZGluZylcbiAgICBgT3BhbC5lbmMoc2VsZiwgZW5jb2RpbmcpYFxuICBlbmRcblxuICBkZWYgZm9yY2VfZW5jb2RpbmcoZW5jb2RpbmcpXG4gICAgJXh7XG4gICAgICB2YXIgc3RyID0gc2VsZjtcblxuICAgICAgaWYgKGVuY29kaW5nID09PSBzdHIuZW5jb2RpbmcpIHsgcmV0dXJuIHN0cjsgfVxuXG4gICAgICBlbmNvZGluZyA9ICN7OjpPcGFsLmNvZXJjZV90byEoZW5jb2RpbmcsIDo6U3RyaW5nLCA6dG9fcyl9O1xuICAgICAgZW5jb2RpbmcgPSAjezo6RW5jb2RpbmcuZmluZChlbmNvZGluZyl9O1xuXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHN0ci5lbmNvZGluZykgeyByZXR1cm4gc3RyOyB9XG5cbiAgICAgIHN0ciA9IE9wYWwuc2V0X2VuY29kaW5nKHN0ciwgZW5jb2RpbmcpO1xuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGdldGJ5dGUoaWR4KVxuICAgIHN0cmluZ19ieXRlcyA9IGJ5dGVzXG4gICAgaWR4ID0gOjpPcGFsLmNvZXJjZV90byEoaWR4LCA6OkludGVnZXIsIDp0b19pbnQpXG4gICAgcmV0dXJuIGlmIHN0cmluZ19ieXRlcy5sZW5ndGggPCBpZHhcblxuICAgIHN0cmluZ19ieXRlc1tpZHhdXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2NvcHkob3RoZXIpXG4gICAgJXtcbiAgICAgIHNlbGYuZW5jb2RpbmcgPSBvdGhlci5lbmNvZGluZztcbiAgICAgIHNlbGYuaW50ZXJuYWxfZW5jb2RpbmcgPSBvdGhlci5pbnRlcm5hbF9lbmNvZGluZztcbiAgICB9XG4gIGVuZFxuXG4gICMgc3R1YlxuICBkZWYgdmFsaWRfZW5jb2Rpbmc/XG4gICAgdHJ1ZVxuICBlbmRcbmVuZFxuXG46OkVuY29kaW5nLmRlZmF1bHRfZXh0ZXJuYWwgPSBfX0VOQ09ESU5HX19cbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6RW5jb2Rpbmc+IiwicmVnaXN0ZXIiLCJuYW1lIiwib3B0aW9ucyIsIm5hbWVzIiwiKyIsIiRyZXRfb3JfMSIsIltdIiwiYXNjaWkiLCJkdW1teSIsImVuY29kaW5nIiwiY2xvbmUiLCJpbml0aWFsaXplIiwibmV3IiwiYmxvY2tfZ2l2ZW4/IiwiaW5zdGFuY2VfZXZhbCIsImJsb2NrIiwidG9fcHJvYyIsImVhY2giLCJibG9jayBpbiByZWdpc3RlciIsImVuY29kaW5nX25hbWUiLCJibG9jayAoMiBsZXZlbHMpIGluIHJlZ2lzdGVyIiwiY29uc3Rfc2V0IiwidHIiLCJmaW5kIiwiZGVmYXVsdF9leHRlcm5hbCIsInNpbmdsZXRvbl9jbGFzcyIsImF0dHJfYWNjZXNzb3IiLCJhdHRyX3JlYWRlciIsIkBuYW1lIiwiQG5hbWVzIiwiQGFzY2lpIiwiQGR1bW15IiwiYXNjaWlfY29tcGF0aWJsZT8iLCJkdW1teT8iLCJiaW5hcnk/IiwidG9fcyIsImluc3BlY3QiLCJjaGFyc2l6ZSIsInN0cmluZyIsImVhY2hfY2hhciIsImVhY2hfYnl0ZSIsIktlcm5lbCIsInJhaXNlIiwiTm90SW1wbGVtZW50ZWRFcnJvciIsImJ5dGVzaXplIiwiPGNsYXNzOkVuY29kaW5nRXJyb3I+IiwiU3RhbmRhcmRFcnJvciIsIjxjbGFzczpDb21wYXRpYmlsaXR5RXJyb3I+IiwiRW5jb2RpbmdFcnJvciIsIjxjbGFzczpVbmRlZmluZWRDb252ZXJzaW9uRXJyb3I+IiwiRW5jb2RpbmciLCJibG9jayBpbiA8dG9wIChyZXF1aXJlZCk+IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8dG9wIChyZXF1aXJlZCk+IiwiYnl0ZXMiLCJsZW5ndGgiLCJFbmNvZGluZzo6VVRGXzE2TEUiLCIwIiwiRW5jb2Rpbmc6OlVURl8zMkxFIiwiRW5jb2Rpbmc6OkFTQ0lJXzhCSVQiLCI8Y2xhc3M6U3RyaW5nPiIsIkVuY29kaW5nOjpVVEZfOCIsImIiLCJkdXAiLCJmb3JjZV9lbmNvZGluZyIsIkBpbnRlcm5hbF9lbmNvZGluZyIsImVudW1fZm9yIiwiYmxvY2sgaW4gZWFjaF9ieXRlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX2J5dGUiLCJ0b19hIiwiQGJ5dGVzIiwiYmxvY2sgaW4gZWFjaF9jaGFyIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX2NoYXIiLCJAZW5jb2RpbmciLCJjaGFycyIsImVhY2hfY29kZXBvaW50IiwiY29kZXBvaW50cyIsImVuY29kZSIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiU3RyaW5nIiwiZ2V0Ynl0ZSIsImlkeCIsInN0cmluZ19ieXRlcyIsIkludGVnZXIiLCI8IiwiaW5pdGlhbGl6ZV9jb3B5Iiwib3RoZXIiLCJ2YWxpZF9lbmNvZGluZz8iLCJkZWZhdWx0X2V4dGVybmFsPSJdLCJtYXBwaW5ncyI6IkFBQUFBLDBDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQyxJQUFBQyxTQUFBQSxDQUFRRixnQkFBUkU7RUFFQUM7RUFBQUE7O0lBQUFBOztBQUFBQTs7SUFDRUMsTUFBSUgsSUFBSkcsZUFBQUEsb0JBQWtCQyxJQUFELEVBQU9DLE9BQXhCRjtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUF3QiwrQkFBVTtNQUNoQ0csUUFBZUMsU0FBUCxDQUFDSCxJQUFELENBQU9HLEVBQUcsQ0FBQSxRQUFBQyxDQUFBQSxZQUFBSCxPQUFPSSxPQUFBQSxDQUFDLFNBQURBLENBQVBELENBQUEsQ0FBQSxHQUFBLENBQUEsU0FBQSxJQUFBLENBQXFCLEVBQXJCLENBQUEsQ0FBSEQ7TUFDZkcsUUFBUSxDQUFBLFFBQUFGLENBQUFBLFlBQUFILE9BQU9JLE9BQUFBLENBQUMsT0FBREEsQ0FBUEQsQ0FBQSxDQUFBLElBQUEsQ0FBQSxTQUFBLENBQUE7TUFDUkcsUUFBUSxDQUFBLFFBQUFILENBQUFBLFlBQUFILE9BQU9JLE9BQUFBLENBQUMsT0FBREEsQ0FBUEQsQ0FBQSxDQUFBLElBQUEsQ0FBQSxTQUFBLENBQUE7TUFFUixJQUFBLFFBQUdILE9BQU9JLE9BQUFBLENBQUMsVUFBREEsQ0FBVixDQUFBOztRQUNFRyxXQUFXUCxPQUFPSSxPQUFBQSxDQUFDLFVBQURBLENBQVdJLE9BQUFBLENBQUFBO1FBQzdCRCxRQUFRRSxZQUFBQSxDQUFZVixJQUFwQixFQUEwQkUsS0FBMUIsRUFBaUNJLEtBQWpDLEVBQXdDQyxLQUFoQ0c7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T0FBRUEsSUFBRixHQUNKQSx5Q0FESSxHQUVKQSwyREFGSSxHQUdKQTtJQUpFQSxDQUFBQTtJQVFBMUIsT0FBQTRCLCtCQUFBQSxZQUNFLElBREZBLENBQUFBO0VBdkdGNUIsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtFQTRHQS9ELE9BQVU0RixNQUFBQSxDQUFvQjVCLElBOVo5QlYsY0E4WjhCVSxVQUFwQjRCLENBQUFBLEVBQUFBLE1BQVZ0QyxlQUFVc0MscUJBQUFBLEVBQUFBLEVBQUFBLENBQUFBLEVBQUFBO0FBOVpWNUY7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIwODQ2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9tYXRoLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHlwZV9lcnJvclxuIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXG5cbm1vZHVsZSA6Ok1hdGhcbiAgc2VsZjo6RSAgPSBgTWF0aC5FYFxuICBzZWxmOjpQSSA9IGBNYXRoLlBJYFxuXG4gIHNlbGY6OkRvbWFpbkVycm9yID0gOjpDbGFzcy5uZXcoOjpTdGFuZGFyZEVycm9yKVxuXG4gIGRlZiBzZWxmLmNoZWNrZWQobWV0aG9kLCAqYXJncylcbiAgICAleHtcbiAgICAgIGlmIChpc05hTihhcmdzWzBdKSB8fCAoYXJncy5sZW5ndGggPT0gMiAmJiBpc05hTihhcmdzWzFdKSkpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IE1hdGhbbWV0aG9kXS5hcHBseShudWxsLCBhcmdzKTtcblxuICAgICAgaWYgKGlzTmFOKHJlc3VsdCkpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSBEb21haW5FcnJvciwgXCJOdW1lcmljYWwgYXJndW1lbnQgaXMgb3V0IG9mIGRvbWFpbiAtIFxcXCIje21ldGhvZH1cXFwiXCJ9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYuZmxvYXQhKHZhbHVlKVxuICAgIDo6S2VybmVsLkZsb2F0KHZhbHVlKVxuICByZXNjdWUgOjpBcmd1bWVudEVycm9yXG4gICAgOjpLZXJuZWwucmFpc2UgYCR0eXBlX2Vycm9yKHZhbHVlLCAjezo6RmxvYXR9KWBcbiAgZW5kXG5cbiAgZGVmIHNlbGYuaW50ZWdlciEodmFsdWUpXG4gICAgOjpLZXJuZWwuSW50ZWdlcih2YWx1ZSlcbiAgcmVzY3VlIDo6QXJndW1lbnRFcnJvclxuICAgIDo6S2VybmVsLnJhaXNlIGAkdHlwZV9lcnJvcih2YWx1ZSwgI3s6OkludGVnZXJ9KWBcbiAgZW5kXG5cbiAgbW9kdWxlX2Z1bmN0aW9uXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLmVyZmApXG4gICAgJXh7XG4gICAgICBPcGFsLnByb3AoTWF0aCwgJ2VyZicsIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdmFyIEExID0gIDAuMjU0ODI5NTkyLFxuICAgICAgICAgICAgQTIgPSAtMC4yODQ0OTY3MzYsXG4gICAgICAgICAgICBBMyA9ICAxLjQyMTQxMzc0MSxcbiAgICAgICAgICAgIEE0ID0gLTEuNDUzMTUyMDI3LFxuICAgICAgICAgICAgQTUgPSAgMS4wNjE0MDU0MjksXG4gICAgICAgICAgICBQICA9ICAwLjMyNzU5MTE7XG5cbiAgICAgICAgdmFyIHNpZ24gPSAxO1xuXG4gICAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICAgICAgc2lnbiA9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgeCA9IE1hdGguYWJzKHgpO1xuXG4gICAgICAgIHZhciB0ID0gMS4wIC8gKDEuMCArIFAgKiB4KTtcbiAgICAgICAgdmFyIHkgPSAxLjAgLSAoKCgoKEE1ICogdCArIEE0KSAqIHQpICsgQTMpICogdCArIEEyKSAqIHQgKyBBMSkgKiB0ICogTWF0aC5leHAoLXggKiB4KTtcblxuICAgICAgICByZXR1cm4gc2lnbiAqIHk7XG4gICAgICB9KTtcbiAgICB9XG4gIGVuZFxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC5lcmZjYClcbiAgICAleHtcbiAgICAgIE9wYWwucHJvcChNYXRoLCAnZXJmYycsIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdmFyIHogPSBNYXRoLmFicyh4KSxcbiAgICAgICAgICAgIHQgPSAxLjAgLyAoMC41ICogeiArIDEuMCk7XG5cbiAgICAgICAgdmFyIEExID0gdCAqIDAuMTcwODcyNzcgKyAtMC44MjIxNTIyMyxcbiAgICAgICAgICAgIEEyID0gdCAqIEExICsgMS40ODg1MTU4NyxcbiAgICAgICAgICAgIEEzID0gdCAqIEEyICsgLTEuMTM1MjAzOTgsXG4gICAgICAgICAgICBBNCA9IHQgKiBBMyArIDAuMjc4ODY4MDcsXG4gICAgICAgICAgICBBNSA9IHQgKiBBNCArIC0wLjE4NjI4ODA2LFxuICAgICAgICAgICAgQTYgPSB0ICogQTUgKyAwLjA5Njc4NDE4LFxuICAgICAgICAgICAgQTcgPSB0ICogQTYgKyAwLjM3NDA5MTk2LFxuICAgICAgICAgICAgQTggPSB0ICogQTcgKyAxLjAwMDAyMzY4LFxuICAgICAgICAgICAgQTkgPSB0ICogQTgsXG4gICAgICAgICAgICBBMTAgPSAteiAqIHogLSAxLjI2NTUxMjIzICsgQTk7XG5cbiAgICAgICAgdmFyIGEgPSB0ICogTWF0aC5leHAoQTEwKTtcblxuICAgICAgICBpZiAoeCA8IDAuMCkge1xuICAgICAgICAgIHJldHVybiAyLjAgLSBhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIGVuZFxuXG4gICMgU2luZ2xlIGFyZ3VtZW50IGVxdWl2YWxlbnQgZnVuY3Rpb25zXG4gICVpW1xuICAgIGFjb3MgYWNvc2ggYXNpbiBhc2luaCBhdGFuIGF0YW5oIGNicnRcbiAgICBjb3MgY29zaCBlcmYgZXJmYyBleHAgc2luIHNpbmggc3FydCB0YW5oXG4gIF0uZWFjaCBkbyB8bWV0aG9kfFxuICAgIGRlZmluZV9tZXRob2QgbWV0aG9kIGRvIHx4fFxuICAgICAgOjpNYXRoLmNoZWNrZWQgbWV0aG9kLCA6Ok1hdGguZmxvYXQhKHgpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBhdGFuMih5LCB4KVxuICAgIDo6TWF0aC5jaGVja2VkIDphdGFuMiwgOjpNYXRoLmZsb2F0ISh5KSwgOjpNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICBkZWYgaHlwb3QoeCwgeSlcbiAgICA6Ok1hdGguY2hlY2tlZCA6aHlwb3QsIDo6TWF0aC5mbG9hdCEoeCksIDo6TWF0aC5mbG9hdCEoeSlcbiAgZW5kXG5cbiAgZGVmIGZyZXhwKHgpXG4gICAgeCA9IE1hdGguZmxvYXQhKHgpXG5cbiAgICAleHtcbiAgICAgIGlmIChpc05hTih4KSkge1xuICAgICAgICByZXR1cm4gW05hTiwgMF07XG4gICAgICB9XG5cbiAgICAgIHZhciBleCAgID0gTWF0aC5mbG9vcihNYXRoLmxvZyhNYXRoLmFicyh4KSkgLyBNYXRoLmxvZygyKSkgKyAxLFxuICAgICAgICAgIGZyYWMgPSB4IC8gTWF0aC5wb3coMiwgZXgpO1xuXG4gICAgICByZXR1cm4gW2ZyYWMsIGV4XTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBnYW1tYShuKVxuICAgIG4gPSBNYXRoLmZsb2F0IShuKVxuXG4gICAgJXh7XG4gICAgICB2YXIgaSwgdCwgeCwgdmFsdWUsIHJlc3VsdCwgdHdvTiwgdGhyZWVOLCBmb3VyTiwgZml2ZU47XG5cbiAgICAgIHZhciBHID0gNC43NDIxODc1O1xuXG4gICAgICB2YXIgUCA9IFtcbiAgICAgICAgIDAuOTk5OTk5OTk5OTk5OTk3MDkxODIsXG4gICAgICAgICA1Ny4xNTYyMzU2NjU4NjI5MjM1MTcsXG4gICAgICAgIC01OS41OTc5NjAzNTU0NzU0OTEyNDgsXG4gICAgICAgICAxNC4xMzYwOTc5NzQ3NDE3NDcxNzQsXG4gICAgICAgIC0wLjQ5MTkxMzgxNjA5NzYyMDE5OTc4LFxuICAgICAgICAgMC4zMzk5NDY0OTk4NDgxMTg4ODY5OWUtNCxcbiAgICAgICAgIDAuNDY1MjM2Mjg5MjcwNDg1NzU2NjVlLTQsXG4gICAgICAgIC0wLjk4Mzc0NDc1MzA0ODc5NTY0Njc3ZS00LFxuICAgICAgICAgMC4xNTgwODg3MDMyMjQ5MTI0ODg4NGUtMyxcbiAgICAgICAgLTAuMjEwMjY0NDQxNzI0MTA0ODgzMTllLTMsXG4gICAgICAgICAwLjIxNzQzOTYxODExNTIxMjY0MzIwZS0zLFxuICAgICAgICAtMC4xNjQzMTgxMDY1MzY3NjM4OTAyMmUtMyxcbiAgICAgICAgIDAuODQ0MTgyMjM5ODM4NTI3NDMyOTNlLTQsXG4gICAgICAgIC0wLjI2MTkwODM4NDAxNTgxNDA4NjcwZS00LFxuICAgICAgICAgMC4zNjg5OTE4MjY1OTUzMTYyMjcwNGUtNVxuICAgICAgXTtcblxuXG4gICAgICBpZiAoaXNOYU4obikpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPT09IDAgJiYgMSAvIG4gPCAwKSB7XG4gICAgICAgIHJldHVybiAtSW5maW5pdHk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuID09PSAtMSB8fCBuID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSBEb21haW5FcnJvciwgJ051bWVyaWNhbCBhcmd1bWVudCBpcyBvdXQgb2YgZG9tYWluIC0gXCJnYW1tYVwiJ307XG4gICAgICB9XG5cbiAgICAgIGlmICgje0ludGVnZXIgPT09IG59KSB7XG4gICAgICAgIGlmIChuIDw9IDApIHtcbiAgICAgICAgICByZXR1cm4gaXNGaW5pdGUobikgPyBJbmZpbml0eSA6IE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuID4gMTcxKSB7XG4gICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgID0gbiAtIDI7XG4gICAgICAgIHJlc3VsdCA9IG4gLSAxO1xuXG4gICAgICAgIHdoaWxlICh2YWx1ZSA+IDEpIHtcbiAgICAgICAgICByZXN1bHQgKj0gdmFsdWU7XG4gICAgICAgICAgdmFsdWUtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQgPT0gMCkge1xuICAgICAgICAgIHJlc3VsdCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpZiAobiA8IDAuNSkge1xuICAgICAgICByZXR1cm4gTWF0aC5QSSAvIChNYXRoLnNpbihNYXRoLlBJICogbikgKiAjezo6TWF0aC5nYW1tYSgxIC0gbil9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPj0gMTcxLjM1KSB7XG4gICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPiA4NS4wKSB7XG4gICAgICAgIHR3b04gICA9IG4gKiBuO1xuICAgICAgICB0aHJlZU4gPSB0d29OICogbjtcbiAgICAgICAgZm91ck4gID0gdGhyZWVOICogbjtcbiAgICAgICAgZml2ZU4gID0gZm91ck4gKiBuO1xuXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoMiAqIE1hdGguUEkgLyBuKSAqIE1hdGgucG93KChuIC8gTWF0aC5FKSwgbikgKlxuICAgICAgICAgICgxICsgMSAvICgxMiAqIG4pICsgMSAvICgyODggKiB0d29OKSAtIDEzOSAvICg1MTg0MCAqIHRocmVlTikgLVxuICAgICAgICAgIDU3MSAvICgyNDg4MzIwICogZm91ck4pICsgMTYzODc5IC8gKDIwOTAxODg4MCAqIGZpdmVOKSArXG4gICAgICAgICAgNTI0NjgxOSAvICg3NTI0Njc5NjgwMCAqIGZpdmVOICogbikpO1xuICAgICAgfVxuXG4gICAgICBuIC09IDE7XG4gICAgICB4ICA9IFBbMF07XG5cbiAgICAgIGZvciAoaSA9IDE7IGkgPCBQLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHggKz0gUFtpXSAvIChuICsgaSk7XG4gICAgICB9XG5cbiAgICAgIHQgPSBuICsgRyArIDAuNTtcblxuICAgICAgcmV0dXJuIE1hdGguc3FydCgyICogTWF0aC5QSSkgKiBNYXRoLnBvdyh0LCBuICsgMC41KSAqIE1hdGguZXhwKC10KSAqIHg7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbGRleHAobWFudGlzc2EsIGV4cG9uZW50KVxuICAgIG1hbnRpc3NhID0gTWF0aC5mbG9hdCEobWFudGlzc2EpXG4gICAgZXhwb25lbnQgPSBNYXRoLmludGVnZXIhKGV4cG9uZW50KVxuXG4gICAgJXh7XG4gICAgICBpZiAoaXNOYU4oZXhwb25lbnQpKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpSYW5nZUVycm9yLCAnZmxvYXQgTmFOIG91dCBvZiByYW5nZSBvZiBpbnRlZ2VyJ307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYW50aXNzYSAqIE1hdGgucG93KDIsIGV4cG9uZW50KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsZ2FtbWEobilcbiAgICAleHtcbiAgICAgIGlmIChuID09IC0xKSB7XG4gICAgICAgIHJldHVybiBbSW5maW5pdHksIDFdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbTWF0aC5sb2coTWF0aC5hYnMoI3s6Ok1hdGguZ2FtbWEobil9KSksICN7OjpNYXRoLmdhbW1hKG4pfSA8IDAgPyAtMSA6IDFdO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxvZyh4LCBiYXNlID0gdW5kZWZpbmVkKVxuICAgIGlmIDo6U3RyaW5nID09PSB4XG4gICAgICA6Oktlcm5lbC5yYWlzZSBgJHR5cGVfZXJyb3IoeCwgI3s6OkZsb2F0fSlgXG4gICAgZW5kXG5cbiAgICBpZiBgYmFzZSA9PSBudWxsYFxuICAgICAgOjpNYXRoLmNoZWNrZWQgOmxvZywgOjpNYXRoLmZsb2F0ISh4KVxuICAgIGVsc2VcbiAgICAgIGlmIDo6U3RyaW5nID09PSBiYXNlXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIGAkdHlwZV9lcnJvcihiYXNlLCAjezo6RmxvYXR9KWBcbiAgICAgIGVuZFxuXG4gICAgICA6Ok1hdGguY2hlY2tlZCg6bG9nLCA6Ok1hdGguZmxvYXQhKHgpKSAvIDo6TWF0aC5jaGVja2VkKDpsb2csIDo6TWF0aC5mbG9hdCEoYmFzZSkpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBsb2cxMCh4KVxuICAgIGlmIDo6U3RyaW5nID09PSB4XG4gICAgICA6Oktlcm5lbC5yYWlzZSBgJHR5cGVfZXJyb3IoeCwgI3s6OkZsb2F0fSlgXG4gICAgZW5kXG5cbiAgICA6Ok1hdGguY2hlY2tlZCA6bG9nMTAsIDo6TWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIGxvZzIoeClcbiAgICBpZiA6OlN0cmluZyA9PT0geFxuICAgICAgOjpLZXJuZWwucmFpc2UgYCR0eXBlX2Vycm9yKHgsICN7OjpGbG9hdH0pYFxuICAgIGVuZFxuXG4gICAgOjpNYXRoLmNoZWNrZWQgOmxvZzIsIDo6TWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIHRhbih4KVxuICAgIHggPSA6Ok1hdGguZmxvYXQhKHgpXG5cbiAgICBpZiB4LmluZmluaXRlP1xuICAgICAgcmV0dXJuIDo6RmxvYXQ6Ok5BTlxuICAgIGVuZFxuXG4gICAgOjpNYXRoLmNoZWNrZWQgOnRhbiwgOjpNYXRoLmZsb2F0ISh4KVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOk1hdGg+Iiwic2VsZiIsIkNsYXNzIiwibmV3IiwiU3RhbmRhcmRFcnJvciIsImNoZWNrZWQiLCJtZXRob2QiLCJLZXJuZWwiLCJyYWlzZSIsIkRvbWFpbkVycm9yIiwiZmxvYXQhIiwidmFsdWUiLCJGbG9hdCIsIkFyZ3VtZW50RXJyb3IiLCJpbnRlZ2VyISIsIkludGVnZXIiLCJtb2R1bGVfZnVuY3Rpb24iLCJlYWNoIiwiYmxvY2sgaW4gPG1vZHVsZTpNYXRoPiIsImJsb2NrICgyIGxldmVscykgaW4gPG1vZHVsZTpNYXRoPiIsImRlZmluZV9tZXRob2QiLCJ4IiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiA8bW9kdWxlOk1hdGg+IiwiTWF0aCIsImF0YW4yIiwieSIsImh5cG90IiwiZnJleHAiLCJnYW1tYSIsIm4iLCI9PT0iLCItIiwiMSIsImxkZXhwIiwibWFudGlzc2EiLCJleHBvbmVudCIsIlJhbmdlRXJyb3IiLCJsZ2FtbWEiLCJsb2ciLCJiYXNlIiwiU3RyaW5nIiwiLyIsImxvZzEwIiwibG9nMiIsInRhbiIsImluZmluaXRlPyIsIkZsb2F0OjpOQU4iXSwibWFwcGluZ3MiOiJBQUFBQSwrQkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUdBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNFLFdBQUFDLElBQUEsT0FBWUQsTUFBWjtJQUNBLFdBQUFDLElBQUEsUUFBWUQsT0FBWjtJQUVBLFdBQUFDLElBQUEsaUJBQW9CQyxNQUFPQyxLQUFBQSxDQUFLQyxvQkFBTEQsQ0FBM0I7SUFFQUUsTUFBSUosSUFBSkksY0FBQUEsbUJBQWlCQyxNQUFELEVBVGxCLEVBU0VEO0FBQUFBLE1BQUFBOzs7TUFURjtNQVMyQjs7QUFFM0JBO0FBQ0FBO0FBQ0FBOztBQUVBQTs7QUFFQUE7QUFDQUEsUUFBVUUsT0FBUUMsT0FBQUEsQ0FBT0MsaUJBQWYsRUFBNkJKLDBDQUFELEdBQUEsQ0FBMkNDLE1BQTNDLENBQUEsR0FBa0RELElBQXRFRyxDQUEwRUg7QUFDNUZBOztBQUVBQTtBQUNBQTtJQWJFQSxDQUFBQSxJQUFBQTtJQWdCQUssTUFBSVQsSUFBSlMsYUFBQUEsNEJBQWdCQyxLQUFoQkQ7QUFBQUE7TUFDRTtRQUFBQSxPQUFBSCxPQUFRSyxPQUFBQSxDQUFPRCxLQUFQQztNQUFSO1FBQ0Ysc0JBQU8sQ0FBQUMsb0JBQUEsQ0FBUDtVQUFBO1lBQ0VILE9BQUFILE9BQVFDLE9BQUFBLENBQVFFLG1CQUFxQkUsWUFBUUYsQ0FBckNGO1VBRFY7UUFBQSxDQURFO01BQUE7SUFERkUsQ0FBQUE7SUFNQUksTUFBSWIsSUFBSmEsZUFBQUEsOEJBQWtCSCxLQUFsQkc7QUFBQUE7TUFDRTtRQUFBQSxPQUFBUCxPQUFRUSxTQUFBQSxDQUFTSixLQUFUSTtNQUFSO1FBQ0Ysc0JBQU8s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UUFDRSxPQUFPQyxJQUFBbEMsWUFBQWtDO01BRFQ7TUFJQUYsT0FBQXJCLFdBQU1sQixTQUFBQSxDQUFTLEtBQWYsRUFBcUJrQixXQUFNYixXQUFBQSxDQUFRVyxDQUFSWCxDQUFyQkw7SUFQUnVDLENBQUFBO0VBcFJGNUMsR0FBTyxJQUFQQTtBQUhBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MjExNjIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2NvbXBsZXgvYmFzZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgOjpLZXJuZWxcbiAgZGVmIENvbXBsZXgocmVhbCwgaW1hZyA9IG5pbClcbiAgICBpZiBpbWFnXG4gICAgICBDb21wbGV4Lm5ldyhyZWFsLCBpbWFnKVxuICAgIGVsc2VcbiAgICAgIENvbXBsZXgubmV3KHJlYWwsIDApXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmNsYXNzIDo6U3RyaW5nXG4gIGRlZiB0b19jXG4gICAgQ29tcGxleC5mcm9tX3N0cmluZyhzZWxmKVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOktlcm5lbD4iLCJDb21wbGV4IiwicmVhbCIsImltYWciLCJuZXciLCIwIiwiPGNsYXNzOlN0cmluZz4iLCJ0b19jIiwiZnJvbV9zdHJpbmciLCJzZWxmIl0sIm1hcHBpbmdzIjoiQUFBQUEsdUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUMsdUJBQUFBLG1CQUFZQyxJQUFELEVBQU9DLElBQWxCRjtBQUFBQTs7TUFBa0IseUJBQU87TUFDdkIsSUFBQSxRQUFHRSxJQUFILENBQUE7UUFDRUYsT0FBQUEsYUFBT0csS0FBQUEsQ0FBS0YsSUFBWixFQUFrQkMsSUFBWEM7TUFEVDtRQUdFSCxPQUFBQSxhQUFPRyxLQUFBQSxDQUFLRixJQUFaLEVBQWtCRyxDQUFYRDtNQUhUO0lBREZILENBQUFBLElBQUFBO0VBREZELEdBQU8sSUFBUEE7RUFVQUQsT0FBQU87RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBQyxvQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBTixhQUFPTyxhQUFBQSxDQUFhQyxJQUFiRDtJQURURCxDQUFBQTtFQURGRCxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBVkFQOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMTE5NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvY29tcGxleC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcblxucmVxdWlyZSAnY29yZWxpYi9udW1lcmljJ1xucmVxdWlyZSAnY29yZWxpYi9jb21wbGV4L2Jhc2UnXG5cbmNsYXNzIDo6Q29tcGxleCA8IDo6TnVtZXJpY1xuICBkZWYgc2VsZi5yZWN0KHJlYWwsIGltYWcgPSAwKVxuICAgIHVubGVzcyA6Ok51bWVyaWMgPT09IHJlYWwgJiYgcmVhbC5yZWFsPyAmJiA6Ok51bWVyaWMgPT09IGltYWcgJiYgaW1hZy5yZWFsP1xuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdub3QgYSByZWFsJ1xuICAgIGVuZFxuXG4gICAgbmV3KHJlYWwsIGltYWcpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnBvbGFyKHIsIHRoZXRhID0gMClcbiAgICB1bmxlc3MgOjpOdW1lcmljID09PSByICYmIHIucmVhbD8gJiYgOjpOdW1lcmljID09PSB0aGV0YSAmJiB0aGV0YS5yZWFsP1xuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdub3QgYSByZWFsJ1xuICAgIGVuZFxuXG4gICAgbmV3KHIgKiA6Ok1hdGguY29zKHRoZXRhKSwgciAqIDo6TWF0aC5zaW4odGhldGEpKVxuICBlbmRcblxuICBhdHRyX3JlYWRlciA6cmVhbCwgOmltYWdcblxuICBkZWYgaW5pdGlhbGl6ZShyZWFsLCBpbWFnID0gMClcbiAgICBAcmVhbCA9IHJlYWxcbiAgICBAaW1hZyA9IGltYWdcbiAgICBmcmVlemVcbiAgZW5kXG5cbiAgZGVmIGNvZXJjZShvdGhlcilcbiAgICBpZiA6OkNvbXBsZXggPT09IG90aGVyXG4gICAgICBbb3RoZXIsIHNlbGZdXG4gICAgZWxzaWYgOjpOdW1lcmljID09PSBvdGhlciAmJiBvdGhlci5yZWFsP1xuICAgICAgWzo6Q29tcGxleC5uZXcob3RoZXIsIDApLCBzZWxmXVxuICAgIGVsc2VcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCBcIiN7b3RoZXIuY2xhc3N9IGNhbid0IGJlIGNvZXJjZWQgaW50byBDb21wbGV4XCJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIGlmIDo6Q29tcGxleCA9PT0gb3RoZXJcbiAgICAgIEByZWFsID09IG90aGVyLnJlYWwgJiYgQGltYWcgPT0gb3RoZXIuaW1hZ1xuICAgIGVsc2lmIDo6TnVtZXJpYyA9PT0gb3RoZXIgJiYgb3RoZXIucmVhbD9cbiAgICAgIEByZWFsID09IG90aGVyICYmIEBpbWFnID09IDBcbiAgICBlbHNlXG4gICAgICBvdGhlciA9PSBzZWxmXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAtQFxuICAgIDo6S2VybmVsLkNvbXBsZXgoLUByZWFsLCAtQGltYWcpXG4gIGVuZFxuXG4gIGRlZiArKG90aGVyKVxuICAgIGlmIDo6Q29tcGxleCA9PT0gb3RoZXJcbiAgICAgIDo6S2VybmVsLkNvbXBsZXgoQHJlYWwgKyBvdGhlci5yZWFsLCBAaW1hZyArIG90aGVyLmltYWcpXG4gICAgZWxzaWYgOjpOdW1lcmljID09PSBvdGhlciAmJiBvdGhlci5yZWFsP1xuICAgICAgOjpLZXJuZWwuQ29tcGxleChAcmVhbCArIG90aGVyLCBAaW1hZylcbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6Kywgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIC0ob3RoZXIpXG4gICAgaWYgOjpDb21wbGV4ID09PSBvdGhlclxuICAgICAgOjpLZXJuZWwuQ29tcGxleChAcmVhbCAtIG90aGVyLnJlYWwsIEBpbWFnIC0gb3RoZXIuaW1hZylcbiAgICBlbHNpZiA6Ok51bWVyaWMgPT09IG90aGVyICYmIG90aGVyLnJlYWw/XG4gICAgICA6Oktlcm5lbC5Db21wbGV4KEByZWFsIC0gb3RoZXIsIEBpbWFnKVxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDotLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgKihvdGhlcilcbiAgICBpZiA6OkNvbXBsZXggPT09IG90aGVyXG4gICAgICA6Oktlcm5lbC5Db21wbGV4KEByZWFsICogb3RoZXIucmVhbCAtIEBpbWFnICogb3RoZXIuaW1hZyxcbiAgICAgICAgQHJlYWwgKiBvdGhlci5pbWFnICsgQGltYWcgKiBvdGhlci5yZWFsLFxuICAgICAgKVxuICAgIGVsc2lmIDo6TnVtZXJpYyA9PT0gb3RoZXIgJiYgb3RoZXIucmVhbD9cbiAgICAgIDo6S2VybmVsLkNvbXBsZXgoQHJlYWwgKiBvdGhlciwgQGltYWcgKiBvdGhlcilcbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6Kiwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIC8ob3RoZXIpXG4gICAgaWYgOjpDb21wbGV4ID09PSBvdGhlclxuICAgICAgaWYgKDo6TnVtYmVyID09PSBAcmVhbCAmJiBAcmVhbC5uYW4/KSB8fCAoOjpOdW1iZXIgPT09IEBpbWFnICYmIEBpbWFnLm5hbj8pIHx8XG4gICAgICAgICAoOjpOdW1iZXIgPT09IG90aGVyLnJlYWwgJiYgb3RoZXIucmVhbC5uYW4/KSB8fCAoOjpOdW1iZXIgPT09IG90aGVyLmltYWcgJiYgb3RoZXIuaW1hZy5uYW4/KVxuICAgICAgICA6OkNvbXBsZXgubmV3KDo6RmxvYXQ6Ok5BTiwgOjpGbG9hdDo6TkFOKVxuICAgICAgZWxzZVxuICAgICAgICBzZWxmICogb3RoZXIuY29uaiAvIG90aGVyLmFiczJcbiAgICAgIGVuZFxuICAgIGVsc2lmIDo6TnVtZXJpYyA9PT0gb3RoZXIgJiYgb3RoZXIucmVhbD9cbiAgICAgIDo6S2VybmVsLkNvbXBsZXgoQHJlYWwucXVvKG90aGVyKSwgQGltYWcucXVvKG90aGVyKSlcbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6Lywgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmICoqKG90aGVyKVxuICAgIGlmIG90aGVyID09IDBcbiAgICAgIHJldHVybiA6OkNvbXBsZXgubmV3KDEsIDApXG4gICAgZW5kXG5cbiAgICBpZiA6OkNvbXBsZXggPT09IG90aGVyXG4gICAgICByLCB0aGV0YSA9IHBvbGFyXG4gICAgICBvcmUgICAgICA9IG90aGVyLnJlYWxcbiAgICAgIG9pbSAgICAgID0gb3RoZXIuaW1hZ1xuICAgICAgbnIgICAgICAgPSA6Ok1hdGguZXhwKG9yZSAqIDo6TWF0aC5sb2cocikgLSBvaW0gKiB0aGV0YSlcbiAgICAgIG50aGV0YSAgID0gdGhldGEgKiBvcmUgKyBvaW0gKiA6Ok1hdGgubG9nKHIpXG5cbiAgICAgIDo6Q29tcGxleC5wb2xhcihuciwgbnRoZXRhKVxuICAgIGVsc2lmIDo6SW50ZWdlciA9PT0gb3RoZXJcbiAgICAgIGlmIG90aGVyID4gMFxuICAgICAgICB4ID0gc2VsZlxuICAgICAgICB6ID0geFxuICAgICAgICBuID0gb3RoZXIgLSAxXG5cbiAgICAgICAgd2hpbGUgbiAhPSAwXG4gICAgICAgICAgZGl2LCBtb2QgPSBuLmRpdm1vZCgyKVxuICAgICAgICAgIHdoaWxlIG1vZCA9PSAwXG4gICAgICAgICAgICB4ID0gOjpLZXJuZWwuQ29tcGxleCh4LnJlYWwgKiB4LnJlYWwgLSB4LmltYWcgKiB4LmltYWcsIDIgKiB4LnJlYWwgKiB4LmltYWcpXG4gICAgICAgICAgICBuID0gZGl2XG4gICAgICAgICAgICBkaXYsIG1vZCA9IG4uZGl2bW9kKDIpXG4gICAgICAgICAgZW5kXG5cbiAgICAgICAgICB6ICo9IHhcbiAgICAgICAgICBuIC09IDFcbiAgICAgICAgZW5kXG5cbiAgICAgICAgelxuICAgICAgZWxzZVxuICAgICAgICAoOjpSYXRpb25hbC5uZXcoMSwgMSkgLyBzZWxmKSoqLW90aGVyXG4gICAgICBlbmRcbiAgICBlbHNpZiA6OkZsb2F0ID09PSBvdGhlciB8fCA6OlJhdGlvbmFsID09PSBvdGhlclxuICAgICAgciwgdGhldGEgPSBwb2xhclxuXG4gICAgICA6OkNvbXBsZXgucG9sYXIocioqb3RoZXIsIHRoZXRhICogb3RoZXIpXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOioqLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgYWJzXG4gICAgOjpNYXRoLmh5cG90KEByZWFsLCBAaW1hZylcbiAgZW5kXG5cbiAgZGVmIGFiczJcbiAgICBAcmVhbCAqIEByZWFsICsgQGltYWcgKiBAaW1hZ1xuICBlbmRcblxuICBkZWYgYW5nbGVcbiAgICA6Ok1hdGguYXRhbjIoQGltYWcsIEByZWFsKVxuICBlbmRcblxuICBkZWYgY29ualxuICAgIDo6S2VybmVsLkNvbXBsZXgoQHJlYWwsIC1AaW1hZylcbiAgZW5kXG5cbiAgZGVmIGRlbm9taW5hdG9yXG4gICAgQHJlYWwuZGVub21pbmF0b3IubGNtKEBpbWFnLmRlbm9taW5hdG9yKVxuICBlbmRcblxuICBkZWYgZXFsPyhvdGhlcilcbiAgICBDb21wbGV4ID09PSBvdGhlciAmJiBAcmVhbC5jbGFzcyA9PSBAaW1hZy5jbGFzcyAmJiBzZWxmID09IG90aGVyXG4gIGVuZFxuXG4gIGRlZiBmZGl2KG90aGVyKVxuICAgIHVubGVzcyA6Ok51bWVyaWMgPT09IG90aGVyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCIje290aGVyLmNsYXNzfSBjYW4ndCBiZSBjb2VyY2VkIGludG8gQ29tcGxleFwiXG4gICAgZW5kXG5cbiAgICBzZWxmIC8gb3RoZXJcbiAgZW5kXG5cbiAgZGVmIGZpbml0ZT9cbiAgICBAcmVhbC5maW5pdGU/ICYmIEBpbWFnLmZpbml0ZT9cbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICBbOjpDb21wbGV4LCBAcmVhbCwgQGltYWddLmhhc2hcbiAgZW5kXG5cbiAgZGVmIGluZmluaXRlP1xuICAgIEByZWFsLmluZmluaXRlPyB8fCBAaW1hZy5pbmZpbml0ZT9cbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBcIigje3NlbGZ9KVwiXG4gIGVuZFxuXG4gIGRlZiBudW1lcmF0b3JcbiAgICBkID0gZGVub21pbmF0b3JcblxuICAgIDo6S2VybmVsLkNvbXBsZXgoQHJlYWwubnVtZXJhdG9yICogKGQgLyBAcmVhbC5kZW5vbWluYXRvciksXG4gICAgICBAaW1hZy5udW1lcmF0b3IgKiAoZCAvIEBpbWFnLmRlbm9taW5hdG9yKSxcbiAgICApXG4gIGVuZFxuXG4gIGRlZiBwb2xhclxuICAgIFthYnMsIGFyZ11cbiAgZW5kXG5cbiAgZGVmIHJhdGlvbmFsaXplKGVwcyA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2Bhcmd1bWVudHMubGVuZ3RoYH0gZm9yIDAuLjEpXCJ9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIEBpbWFnICE9IDBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7c2VsZn0gaW50byBSYXRpb25hbFwiXG4gICAgZW5kXG5cbiAgICByZWFsLnJhdGlvbmFsaXplKGVwcylcbiAgZW5kXG5cbiAgZGVmIHJlYWw/XG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIHJlY3RcbiAgICBbQHJlYWwsIEBpbWFnXVxuICBlbmRcblxuICBkZWYgdG9fZlxuICAgIHVubGVzcyBAaW1hZyA9PSAwXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsIFwiY2FuJ3QgY29udmVydCAje3NlbGZ9IGludG8gRmxvYXRcIlxuICAgIGVuZFxuXG4gICAgQHJlYWwudG9fZlxuICBlbmRcblxuICBkZWYgdG9faVxuICAgIHVubGVzcyBAaW1hZyA9PSAwXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlJhbmdlRXJyb3IsIFwiY2FuJ3QgY29udmVydCAje3NlbGZ9IGludG8gSW50ZWdlclwiXG4gICAgZW5kXG5cbiAgICBAcmVhbC50b19pXG4gIGVuZFxuXG4gIGRlZiB0b19yXG4gICAgdW5sZXNzIEBpbWFnID09IDBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6UmFuZ2VFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7c2VsZn0gaW50byBSYXRpb25hbFwiXG4gICAgZW5kXG5cbiAgICBAcmVhbC50b19yXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgcmVzdWx0ID0gQHJlYWwuaW5zcGVjdFxuXG4gICAgcmVzdWx0ICs9XG4gICAgICBpZiAoOjpOdW1iZXIgPT09IEBpbWFnICYmIEBpbWFnLm5hbj8pIHx8IEBpbWFnLnBvc2l0aXZlPyB8fCBAaW1hZy56ZXJvP1xuICAgICAgICAnKydcbiAgICAgIGVsc2VcbiAgICAgICAgJy0nXG4gICAgICBlbmRcblxuICAgIHJlc3VsdCArPSBAaW1hZy5hYnMuaW5zcGVjdFxuXG4gICAgaWYgOjpOdW1iZXIgPT09IEBpbWFnICYmIChAaW1hZy5uYW4/IHx8IEBpbWFnLmluZmluaXRlPylcbiAgICAgIHJlc3VsdCArPSAnKidcbiAgICBlbmRcblxuICAgIHJlc3VsdCArICdpJ1xuICBlbmRcblxuICBJID0gbmV3KDAsIDEpXG5cbiAgZGVmIHNlbGYuZnJvbV9zdHJpbmcoc3RyKVxuICAgICV4e1xuICAgICAgdmFyIHJlID0gL1srLV0/W1xcZF9dKyhcXC5bXFxkX10rKT8oZVxcZCspPy8sXG4gICAgICAgICAgbWF0Y2ggPSBzdHIubWF0Y2gocmUpLFxuICAgICAgICAgIHJlYWwsIGltYWcsIGRlbm9taW5hdG9yO1xuXG4gICAgICBmdW5jdGlvbiBpc0Zsb2F0KCkge1xuICAgICAgICByZXR1cm4gcmUudGVzdChzdHIpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjdXRGbG9hdCgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKHJlKTtcbiAgICAgICAgdmFyIG51bWJlciA9IG1hdGNoWzBdO1xuICAgICAgICBzdHIgPSBzdHIuc2xpY2UobnVtYmVyLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBudW1iZXIucmVwbGFjZSgvXy9nLCAnJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGhhbmRsZXMgYm90aCBmbG9hdHMgYW5kIHJhdGlvbmFsc1xuICAgICAgZnVuY3Rpb24gY3V0TnVtYmVyKCkge1xuICAgICAgICBpZiAoaXNGbG9hdCgpKSB7XG4gICAgICAgICAgdmFyIG51bWVyYXRvciA9IHBhcnNlRmxvYXQoY3V0RmxvYXQoKSk7XG5cbiAgICAgICAgICBpZiAoc3RyWzBdID09PSAnLycpIHtcbiAgICAgICAgICAgIC8vIHJhdGlvbmFsIHJlYWwgcGFydFxuICAgICAgICAgICAgc3RyID0gc3RyLnNsaWNlKDEpO1xuXG4gICAgICAgICAgICBpZiAoaXNGbG9hdCgpKSB7XG4gICAgICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IHBhcnNlRmxvYXQoY3V0RmxvYXQoKSk7XG4gICAgICAgICAgICAgIHJldHVybiAjezo6S2VybmVsLlJhdGlvbmFsKGBudW1lcmF0b3JgLCBgZGVub21pbmF0b3JgKX07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyByZXZlcnRpbmcgJy8nXG4gICAgICAgICAgICAgIHN0ciA9ICcvJyArIHN0cjtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bWVyYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZmxvYXQgcmVhbCBwYXJ0LCBubyBkZW5vbWluYXRvclxuICAgICAgICAgICAgcmV0dXJuIG51bWVyYXRvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVhbCA9IGN1dE51bWJlcigpO1xuXG4gICAgICBpZiAoIXJlYWwpIHtcbiAgICAgICAgaWYgKHN0clswXSA9PT0gJ2knKSB7XG4gICAgICAgICAgLy8gaSA9PiBDb21wbGV4KDAsIDEpXG4gICAgICAgICAgcmV0dXJuICN7OjpLZXJuZWwuQ29tcGxleCgwLCAxKX07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0clswXSA9PT0gJy0nICYmIHN0clsxXSA9PT0gJ2knKSB7XG4gICAgICAgICAgLy8gLWkgPT4gQ29tcGxleCgwLCAtMSlcbiAgICAgICAgICByZXR1cm4gI3s6Oktlcm5lbC5Db21wbGV4KDAsIC0xKX07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0clswXSA9PT0gJysnICYmIHN0clsxXSA9PT0gJ2knKSB7XG4gICAgICAgICAgLy8gK2kgPT4gQ29tcGxleCgwLCAxKVxuICAgICAgICAgIHJldHVybiAjezo6S2VybmVsLkNvbXBsZXgoMCwgMSl9O1xuICAgICAgICB9XG4gICAgICAgIC8vIGFueXRoaW5nID0+IENvbXBsZXgoMCwgMClcbiAgICAgICAgcmV0dXJuICN7OjpLZXJuZWwuQ29tcGxleCgwLCAwKX07XG4gICAgICB9XG5cbiAgICAgIGltYWcgPSBjdXROdW1iZXIoKTtcbiAgICAgIGlmICghaW1hZykge1xuICAgICAgICBpZiAoc3RyWzBdID09PSAnaScpIHtcbiAgICAgICAgICAvLyAzaSA9PiBDb21wbGV4KDAsIDMpXG4gICAgICAgICAgcmV0dXJuICN7OjpLZXJuZWwuQ29tcGxleCgwLCBgcmVhbGApfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAzID0+IENvbXBsZXgoMywgMClcbiAgICAgICAgICByZXR1cm4gI3s6Oktlcm5lbC5Db21wbGV4KGByZWFsYCwgMCl9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAzKzJpID0+IENvbXBsZXgoMywgMilcbiAgICAgICAgcmV0dXJuICN7OjpLZXJuZWwuQ29tcGxleChgcmVhbGAsIGBpbWFnYCl9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGFsaWFzIHJlY3Rhbmd1bGFyIHJlY3RcbiAgZW5kXG5cbiAgYWxpYXMgYXJnIGFuZ2xlXG4gIGFsaWFzIGNvbmp1Z2F0ZSBjb25qXG4gIGFsaWFzIGRpdmlkZSAvXG4gIGFsaWFzIGltYWdpbmFyeSBpbWFnXG4gIGFsaWFzIG1hZ25pdHVkZSBhYnNcbiAgYWxpYXMgcGhhc2UgYXJnXG4gIGFsaWFzIHF1byAvXG4gIGFsaWFzIHJlY3Rhbmd1bGFyIHJlY3RcblxuICB1bmRlZiBuZWdhdGl2ZT9cbiAgdW5kZWYgcG9zaXRpdmU/XG4gIHVuZGVmIHN0ZXBcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpDb21wbGV4PiIsInJlY3QiLCJyZWFsIiwiaW1hZyIsIjAiLCJOdW1lcmljIiwicmVhbD8iLCJLZXJuZWwiLCJyYWlzZSIsIlR5cGVFcnJvciIsIm5ldyIsInBvbGFyIiwiciIsInRoZXRhIiwiKiIsIk1hdGgiLCJjb3MiLCJzaW4iLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJAcmVhbCIsIkBpbWFnIiwiZnJlZXplIiwiY29lcmNlIiwib3RoZXIiLCJDb21wbGV4IiwiY2xhc3MiLCI9PSIsIiRyZXRfb3JfMSIsIi1AIiwiKyIsIl9fY29lcmNlZF9fIiwiLSIsIi8iLCJOdW1iZXIiLCJuYW4/IiwiRmxvYXQ6Ok5BTiIsIkZsb2F0IiwiY29uaiIsImFiczIiLCJxdW8iLCIqKiIsIjEiLCJvcmUiLCJvaW0iLCJuciIsImV4cCIsImxvZyIsIm50aGV0YSIsIkludGVnZXIiLCI+IiwieCIsInoiLCJuIiwiZGl2bW9kIiwiMiIsImRpdiIsIm1vZCIsIlJhdGlvbmFsIiwiYWJzIiwiaHlwb3QiLCJhbmdsZSIsImF0YW4yIiwiZGVub21pbmF0b3IiLCJsY20iLCJlcWw/IiwiJHJldF9vcl8yIiwiPT09IiwiZmRpdiIsImZpbml0ZT8iLCJoYXNoIiwiaW5maW5pdGU/IiwiaW5zcGVjdCIsIm51bWVyYXRvciIsImQiLCJhcmciLCJyYXRpb25hbGl6ZSIsImVwcyIsIkFyZ3VtZW50RXJyb3IiLCJSYW5nZUVycm9yIiwidG9fZiIsInRvX2kiLCJ0b19yIiwidG9fcyIsInJlc3VsdCIsInBvc2l0aXZlPyIsInplcm8/IiwiZnJvbV9zdHJpbmciLCJzdHIiLCItMSJdLCJtYXBwaW5ncyI6IkFBQUFBLGtDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQyxJQUFBQyxTQUFBQSxDQUFRRixpQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsc0JBQVJFO0VBRUFGLE9BQUFHO0VBQUFBOztJQUFBQTs7QUFBQUE7O0lBQ0VDLE1BQUlILElBQUpHLFdBQUFBLGdCQUFjQyxJQUFELEVBQU9DLElBQXBCRjtBQUFBQSxNQUFBQTs7O01BQW9CLHlCQUFPRztNQUN6QixLQUFPLENBQUEsQ0FBQSxDQUFBLFFBQUFDLGNBQUEsRUFBY0gsSUFBZCxDQUFBLElBQUEsQ0FBQSxRQUFzQkEsSUFBSUksVUFBQUEsQ0FBQUEsQ0FBMUIsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQUFBLFFBQW9DRCxjQUFwQyxFQUFrREYsSUFBbEQsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQUFBLFFBQTBEQSxJQUFJRyxVQUFBQSxDQUFBQSxDQUE5RCxDQUFBLENBQUEsQ0FBUDtRQUNFQyxPQUFRQyxPQUFBQSxDQUFPQyxnQkFBZixFQUE0QlIsWUFBcEJPO01BRFY7TUFJQVAsT0FBQUgsSUFBQVksS0FBQUEsQ0FBSVIsSUFBSixFQUFVQyxJQUFWTztJQUxGVCxDQUFBQSxJQUFBQTtJQVFBVSxNQUFJYixJQUFKYSxZQUFBQSxpQkFBZUMsQ0FBRCxFQUFJQyxLQUFsQkY7QUFBQUEsTUFBQUE7OztNQUFrQiwyQkFBUVA7TUFDeEIsS0FBTyxDQUFBLENBQUEsQ0FBQSxRQUFBQyxjQUFBLEVBQWNPLENBQWQsQ0FBQSxJQUFBLENBQUEsUUFBbUJBLENBQUNOLFVBQUFBLENBQUFBLENBQXBCLENBQUEsQ0FBQSxDQUFBLElBQUEsQ0FBQSxRQUE4QkQsY0FBOUIsRUFBNENRLEtBQTVDLENBQUEsQ0FBQSxDQUFBLElBQUEsQ0FBQSxRQUFxREEsS0FBS1AsVUFBQUEsQ0FBQUEsQ0FBMUQsQ0FBQSxDQUFBLENBQVA7UUFDRUMsT0FBUUMsT0FBQUEsQ0FBT0MsZ0JBQWYsRUFBNEJFLFlBQXBCSDtNQURWO01BSUFHLE9BQUFiLElBQUFZLEtBQUFBLENBQU1JLFVBQUZGLENBQUVFLEVBQUVDLFdBQU1DLEtBQUFBLENBQUtILEtBQUxHLENBQVJGLENBQU4sRUFBNkJBLFVBQUZGLENBQUVFLEVBQUVDLFdBQU1FLEtBQUFBLENBQUtKLEtBQUxJLENBQVJILENBQTdCSjtJQUxGQyxDQUFBQSxJQUFBQTtJQVFBYixJQUFBb0IsYUFBQUEsQ0FBWSxNQUFaLEVBQW1CLE1BQW5CQTs7QUFFQUMsSUFBQUEsMEJBQUFBLHNCQUFlakIsSUFBRCxFQUFPQyxJQUFyQmdCO0FBQUFBLE1BQUFBOzs7TUFBcUIseUJBQU9mO01BQzFCZ0IsWUFBUWxCO01BQ1JtQixZQUFRbEI7TUFDUmdCLE9BQUFyQixJQUFBd0IsUUFBQUEsQ0FBQUE7SUFIRkgsQ0FBQUEsSUFBQUE7O0FBTUFJLElBQUFBLHNCQUFBQSxrQkFBV0MsS0FBWEQ7QUFBQUEsTUFBQUE7O01BQ0UsSUFBQSxRQUFHRSxjQUFILEVBQWlCRCxLQUFqQixDQUFBO1FBQ0VELE9BQUEsQ0FBQ0MsS0FBRCxFQUFRMUIsSUFBUjtNQURGLE9BRUEsSUFBTSxDQUFBLFFBQUFPLGNBQUEsRUFBY21CLEtBQWQsQ0FBQSxJQUFBLENBQUEsUUFBdUJBLEtBQUtsQixVQUFBQSxDQUFBQSxDQUE1QixDQUFBLENBQUEsQ0FBTjtRQUNFaUIsT0FBQSxDQUFDRSxjQUFTZixLQUFBQSxDQUFLYyxLQUFkLEVBQXFCcEIsQ0FBWk0sQ0FBVixFQUEwQlosSUFBMUI7TUFERjtRQUdFeUIsT0FBQWhCLE9BQVFDLE9BQUFBLENBQU9DLGdCQUFmLEVBQTRCLEVBQUEsR0FBQSxDQUFHZSxLQUFLRSxPQUFBQSxDQUFBQSxDQUFSLENBQUEsR0FBZUgsZ0NBQW5DZjtNQUhWO0lBSEZlLENBQUFBOztBQVVBSSxJQUFBQSxrQkFBQUEsMkJBQU9ILEtBQVBHO0FBQUFBLE1BQUFBOztNQUNFLElBQUEsUUFBR0YsY0FBSCxFQUFpQkQsS0FBakIsQ0FBQTtRQUNFLElBQUEsUUFBQUksQ0FBQUEsWUFBQVIsU0FBTU8sT0FBQUEsQ0FBR0gsS0FBS3RCLE1BQUFBLENBQUFBLENBQVJ5QixDQUFOQyxDQUFBLENBQUE7VUFBdUJELE9BQUFOLFNBQU1NLE9BQUFBLENBQUdILEtBQUtyQixNQUFBQSxDQUFBQSxDQUFSd0I7UUFBN0I7VUFBQUEsT0FBQTtRQUFBO01BREYsT0FFQSxJQUFNLENBQUEsUUFBQXRCLGNBQUEsRUFBY21CLEtBQWQsQ0FBQSxJQUFBLENBQUEsUUFBdUJBLEtBQUtsQixVQUFBQSxDQUFBQSxDQUE1QixDQUFBLENBQUEsQ0FBTjtRQUNFLElBQUEsUUFBQXNCLENBQUFBLFlBQUFSLFNBQU1PLE9BQUFBLENBQUdILEtBQUhHLENBQU5DLENBQUEsQ0FBQTtVQUFrQkQsT0FBQU4sU0FBTU0sT0FBQUEsQ0FBR3ZCLENBQUh1QjtRQUF4QjtVQUFBQSxPQUFBO1FBQUE7TUFERjtRQUdFQSxPQUFBSCxLQUFNRyxPQUFBQSxDQUFHN0IsSUFBSDZCO01BSFI7SUFIRkEsQ0FBQUE7O0FBVUFFLElBQUFBLGtCQUFBQSw0QkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUF0QixPQUFRa0IsU0FBQUEsQ0FBVUwsU0FBRFMsT0FBQUEsQ0FBQUEsQ0FBakIsRUFBMEJSLFNBQURRLE9BQUFBLENBQUFBLENBQWpCSjtJQURWSSxDQUFBQTs7QUFJQUMsSUFBQUEsaUJBQUFBLDBCQUFNTixLQUFOTTtBQUFBQSxNQUFBQTs7TUFDRSxJQUFBLFFBQUdMLGNBQUgsRUFBaUJELEtBQWpCLENBQUE7UUFDRU0sT0FBQXZCLE9BQVFrQixTQUFBQSxDQUFlSyxTQUFOVixTQUFNVSxFQUFFTixLQUFLdEIsTUFBQUEsQ0FBQUEsQ0FBUDRCLENBQXZCLEVBQTJDQSxTQUFOVCxTQUFNUyxFQUFFTixLQUFLckIsTUFBQUEsQ0FBQUEsQ0FBUDJCLENBQW5DTDtNQURWLE9BRUEsSUFBTSxDQUFBLFFBQUFwQixjQUFBLEVBQWNtQixLQUFkLENBQUEsSUFBQSxDQUFBLFFBQXVCQSxLQUFLbEIsVUFBQUEsQ0FBQUEsQ0FBNUIsQ0FBQSxDQUFBLENBQU47UUFDRXdCLE9BQUF2QixPQUFRa0IsU0FBQUEsQ0FBZUssU0FBTlYsU0FBTVUsRUFBRU4sS0FBRk0sQ0FBdkIsRUFBZ0NULFNBQXhCSTtNQURWO1FBR0VLLE9BQUFoQyxJQUFBaUMsYUFBQUEsQ0FBWSxHQUFaLEVBQWdCUCxLQUFoQk87TUFIRjtJQUhGRCxDQUFBQTs7QUFVQUUsSUFBQUEsaUJBQUFBLDJCQUFNUixLQUFOUTtBQUFBQSxNQUFBQTs7TUFDRSxJQUFBLFFBQUdQLGNBQUgsRUFBaUJELEtBQWpCLENBQUE7UUFDRVEsT0FBQXpCLE9BQVFrQixTQUFBQSxDQUFlTyxVQUFOWixTQUFNWSxFQUFFUixLQUFLdEIsTUFBQUEsQ0FBQUEsQ0FBUDhCLENBQXZCLEVBQTJDQSxVQUFOWCxTQUFNVyxFQUFFUixLQUFLckIsTUFBQUEsQ0FBQUEsQ0FBUDZCLENBQW5DUDtNQURWLE9BRUEsSUFBTSxDQUFBLFFBQUFwQixjQUFBLEVBQWNtQixLQUFkLENBQUEsSUFBQSxDQUFBLFFBQXVCQSxLQUFLbEIsVUFBQUEsQ0FBQUEsQ0FBNUIsQ0FBQSxDQUFBLENBQU47UUFDRTBCLE9BQUF6QixPQUFRa0IsU0FBQUEsQ0FBZU8sVUFBTlosU0FBTVksRUFBRVIsS0FBRlEsQ0FBdkIsRUFBZ0NYLFNBQXhCSTtNQURWO1FBR0VPLE9BQUFsQyxJQUFBaUMsYUFBQUEsQ0FBWSxHQUFaLEVBQWdCUCxLQUFoQk87TUFIRjtJQUhGQyxDQUFBQTs7QUFVQWxCLElBQUFBLGlCQUFBQSxzQkFBTVUsS0FBTlY7QUFBQUEsTUFBQUE7O01BQ0UsSUFBQSxRQUFHVyxjQUFILEVBQWlCRCxLQUFqQixDQUFBO1FBQ0VWLE9BQUFQLE9BQVFrQixTQUFBQSxDQUE0Qk8sVUFBYmxCLFVBQU5NLFNBQU1OLEVBQUVVLEtBQUt0QixNQUFBQSxDQUFBQSxDQUFQWSxDQUFha0IsRUFBUWxCLFVBQU5PLFNBQU1QLEVBQUVVLEtBQUtyQixNQUFBQSxDQUFBQSxDQUFQVyxDQUFSa0IsQ0FBcEMsRUFDcUJGLFNBQWJoQixVQUFOTSxTQUFNTixFQUFFVSxLQUFLckIsTUFBQUEsQ0FBQUEsQ0FBUFcsQ0FBYWdCLEVBQVFoQixVQUFOTyxTQUFNUCxFQUFFVSxLQUFLdEIsTUFBQUEsQ0FBQUEsQ0FBUFksQ0FBUmdCLENBRGJMO01BRFYsT0FJQSxJQUFNLENBQUEsUUFBQXBCLGNBQUEsRUFBY21CLEtBQWQsQ0FBQSxJQUFBLENBQUEsUUFBdUJBLEtBQUtsQixVQUFBQSxDQUFBQSxDQUE1QixDQUFBLENBQUEsQ0FBTjtRQUNFUSxPQUFBUCxPQUFRa0IsU0FBQUEsQ0FBZVgsVUFBTk0sU0FBTU4sRUFBRVUsS0FBRlYsQ0FBdkIsRUFBc0NBLFVBQU5PLFNBQU1QLEVBQUVVLEtBQUZWLENBQTlCVztNQURWO1FBR0VYLE9BQUFoQixJQUFBaUMsYUFBQUEsQ0FBWSxHQUFaLEVBQWdCUCxLQUFoQk87TUFIRjtJQUxGakIsQ0FBQUE7O0FBWUFtQixJQUFBQSxpQkFBQUEsMkJBQU1ULEtBQU5TO0FBQUFBLE1BQUFBOztNQUNFLElBQUEsUUFBR1IsY0FBSCxFQUFpQkQsS0FBakIsQ0FBQTtRQUNFLElBQUcsQ0FBQSxDQUFBLENBQUMsQ0FBQSxRQUFBVSxhQUFBLEVBQWFkLFNBQWIsQ0FBQSxJQUFBLENBQUEsUUFBc0JBLFNBQUtlLFNBQUFBLENBQUFBLENBQTNCLENBQUEsQ0FBQSxDQUFELElBQUEsQ0FBdUMsQ0FBQSxRQUFBRCxhQUFBLEVBQWFiLFNBQWIsQ0FBQSxJQUFBLENBQUEsUUFBc0JBLFNBQUtjLFNBQUFBLENBQUFBLENBQTNCLENBQUEsQ0FBQSxDQUF2QyxDQUFBLENBQUEsSUFBQSxDQUNDLENBQUEsUUFBQUQsYUFBQSxFQUFhVixLQUFLdEIsTUFBQUEsQ0FBQUEsQ0FBbEIsQ0FBQSxJQUFBLENBQUEsUUFBMkJzQixLQUFLdEIsTUFBQUEsQ0FBQUEsQ0FBS2lDLFNBQUFBLENBQUFBLENBQXJDLENBQUEsQ0FBQSxDQURELENBQUEsQ0FBQSxJQUFBLENBQ2lELENBQUEsUUFBQUQsYUFBQSxFQUFhVixLQUFLckIsTUFBQUEsQ0FBQUEsQ0FBbEIsQ0FBQSxJQUFBLENBQUEsUUFBMkJxQixLQUFLckIsTUFBQUEsQ0FBQUEsQ0FBS2dDLFNBQUFBLENBQUFBLENBQXJDLENBQUEsQ0FBQSxDQURqRCxDQUFBLENBQUg7VUFFRUYsT0FBQVIsY0FBU2YsS0FBQUEsQ0FBSzBCLElBQUFDLFlBQUFELFFBQWQsRUFBNEJBLElBQUFDLFlBQUFELFFBQW5CMUI7UUFGWDtVQUlFdUIsT0FBa0JBLFdBQWJuQixVQUFMaEIsSUFBS2dCLEVBQUVVLEtBQUtjLE1BQUFBLENBQUFBLENBQVB4QixDQUFhbUIsRUFBRVQsS0FBS2UsTUFBQUEsQ0FBQUEsQ0FBUE47UUFKcEI7TUFERixPQU9BLElBQU0sQ0FBQSxRQUFBNUIsY0FBQSxFQUFjbUIsS0FBZCxDQUFBLElBQUEsQ0FBQSxRQUF1QkEsS0FBS2xCLFVBQUFBLENBQUFBLENBQTVCLENBQUEsQ0FBQSxDQUFOO1FBQ0UyQixPQUFBMUIsT0FBUWtCLFNBQUFBLENBQVNMLFNBQUtvQixLQUFBQSxDQUFLaEIsS0FBTGdCLENBQXRCLEVBQW1DbkIsU0FBS21CLEtBQUFBLENBQUtoQixLQUFMZ0IsQ0FBaENmO01BRFY7UUFHRVEsT0FBQW5DLElBQUFpQyxhQUFBQSxDQUFZLEdBQVosRUFBZ0JQLEtBQWhCTztNQUhGO0lBUkZFLENBQUFBOztBQWVBUSxJQUFBQSxrQkFBQUEsdUJBQU9qQixLQUFQaUI7QUFBQUEsTUFBQUE7OztNQUNFLElBQUEsTUFBR2pCLEtBQUgsRUFBWXBCLENBQVosQ0FBQTtRQUNFLE9BQU9xQixjQUFTZixLQUFBQSxDQUFLZ0MsQ0FBZCxFQUFpQnRDLENBQVJNO01BRGxCO01BSUEsSUFBQSxRQUFHZSxjQUFILEVBQWlCRCxLQUFqQixDQUFBOztRQUNFLEtBQVcxQixJQUFBYSxPQUFBQSxDQUFBQSxDQUFYLGtCQUFBLEVBQUFDLENBQUFBLElBQUEsNkJBQUFBLENBQUEsRUFBR0MsQ0FBQUEsUUFBSCw2QkFBR0EsQ0FBSDtRQUNBOEIsTUFBV25CLEtBQUt0QixNQUFBQSxDQUFBQTtRQUNoQjBDLE1BQVdwQixLQUFLckIsTUFBQUEsQ0FBQUE7UUFDaEIwQyxLQUFXOUIsV0FBTStCLEtBQUFBLENBQXlCZCxVQUFoQmxCLFVBQUo2QixHQUFJN0IsRUFBRUMsV0FBTWdDLEtBQUFBLENBQUtuQyxDQUFMbUMsQ0FBUmpDLENBQWdCa0IsRUFBTWxCLFVBQUo4QixHQUFJOUIsRUFBRUQsS0FBRkMsQ0FBTmtCLENBQXpCYztRQUNqQkUsU0FBdUJsQixTQUFOaEIsVUFBTkQsS0FBTUMsRUFBRTZCLEdBQUY3QixDQUFNZ0IsRUFBTWhCLFVBQUo4QixHQUFJOUIsRUFBRUMsV0FBTWdDLEtBQUFBLENBQUtuQyxDQUFMbUMsQ0FBUmpDLENBQU5nQjtRQUV2QlcsT0FBQWhCLGNBQVNkLE9BQUFBLENBQU9rQyxFQUFoQixFQUFvQkcsTUFBWHJDO01BUFgsT0FRQSxJQUFBLFFBQU1zQyxjQUFOLEVBQW9CekIsS0FBcEIsQ0FBQTtRQUNFLElBQUEsUUFBUzBCLE9BQU4xQixLQUFNMEIsRUFBRTlDLENBQUY4QyxDQUFULENBQUE7O1VBQ0VDLElBQUlyRDtVQUNKc0QsSUFBSUQ7VUFDSkUsSUFBVXJCLFVBQU5SLEtBQU1RLEVBQUVVLENBQUZWO1VBRVYsT0FBQSxPQUFNcUIsQ0FBTixFQUFXakQsQ0FBWCxDQUFBOztZQUNFLEtBQVdpRCxDQUFDQyxRQUFBQSxDQUFRQyxDQUFSRCxDQUFaLGtCQUFBLEVBQUFFLENBQUFBLE1BQUEsNkJBQUFBLENBQUEsRUFBS0MsQ0FBQUEsTUFBTCw2QkFBS0EsQ0FBTDtZQUNBLE9BQUEsTUFBTUEsR0FBTixFQUFhckQsQ0FBYixDQUFBOztjQUNFK0MsSUFBSTVDLE9BQVFrQixTQUFBQSxDQUF5Qk8sVUFBVGxCLFVBQVBxQyxDQUFDakQsTUFBQUEsQ0FBQUEsQ0FBTVksRUFBRXFDLENBQUNqRCxNQUFBQSxDQUFBQSxDQUFIWSxDQUFTa0IsRUFBU2xCLFVBQVBxQyxDQUFDaEQsTUFBQUEsQ0FBQUEsQ0FBTVcsRUFBRXFDLENBQUNoRCxNQUFBQSxDQUFBQSxDQUFIVyxDQUFUa0IsQ0FBakMsRUFBK0RsQixVQUFUQSxVQUFGeUMsQ0FBRXpDLEVBQUVxQyxDQUFDakQsTUFBQUEsQ0FBQUEsQ0FBSFksQ0FBU0EsRUFBRXFDLENBQUNoRCxNQUFBQSxDQUFBQSxDQUFIVyxDQUF2RFc7Y0FDWjRCLElBQUlHO2NBQ0osS0FBV0gsQ0FBQ0MsUUFBQUEsQ0FBUUMsQ0FBUkQsQ0FBWixrQkFBQSxFQUFBRSxDQUFBQSxNQUFBLDZCQUFBQSxDQUFBLEVBQUtDLENBQUFBLE1BQUwsNkJBQUtBLENBQUw7WUFIRjtZQU1BTCxJQUFFdEMsVUFBRnNDLENBQUV0QyxFQUFHcUMsQ0FBSHJDO1lBQ0Z1QyxJQUFFckIsVUFBRnFCLENBQUVyQixFQUFHVSxDQUFIVjtVQVRKO1VBWUFTLE9BQUFXO1FBakJGO1VBbUJFWCxPQUFzQlIsV0FBckJ5QixlQUFVaEQsS0FBQUEsQ0FBS2dDLENBQWYsRUFBa0JBLENBQVJoQyxDQUFXdUIsRUFBRW5DLElBQUZtQyxDQUFPUSxPQUFBQSxDQUFHakIsS0FBREssT0FBQUEsQ0FBQUEsQ0FBRlk7UUFuQi9CO01BREYsT0FzQkEsSUFBTSxDQUFBLFFBQUFKLFlBQUEsRUFBWWIsS0FBWixDQUFBLElBQUEsQ0FBQSxRQUFxQmtDLGVBQXJCLEVBQW9DbEMsS0FBcEMsQ0FBQSxDQUFBLENBQU47O1FBQ0UsS0FBVzFCLElBQUFhLE9BQUFBLENBQUFBLENBQVgsa0JBQUEsRUFBQUMsQ0FBQUEsSUFBQSw2QkFBQUEsQ0FBQSxFQUFHQyxDQUFBQSxRQUFILDZCQUFHQSxDQUFIO1FBRUE0QixPQUFBaEIsY0FBU2QsT0FBQUEsQ0FBT0MsQ0FBQzZCLE9BQUFBLENBQUVqQixLQUFGaUIsQ0FBakIsRUFBZ0MzQixVQUFORCxLQUFNQyxFQUFFVSxLQUFGVixDQUF2Qkg7TUFIWDtRQUtFOEIsT0FBQTNDLElBQUFpQyxhQUFBQSxDQUFZLElBQVosRUFBaUJQLEtBQWpCTztNQUxGO0lBbkNGVSxDQUFBQTs7QUE0Q0FrQixJQUFBQSxtQkFBQUEsZUFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUE1QyxXQUFNNkMsT0FBQUEsQ0FBT3hDLFNBQWIsRUFBb0JDLFNBQWR1QztJQURSRCxDQUFBQTs7QUFJQXBCLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQWNULFNBQVJoQixVQUFOTSxTQUFNTixFQUFFTSxTQUFGTixDQUFRZ0IsRUFBUWhCLFVBQU5PLFNBQU1QLEVBQUVPLFNBQUZQLENBQVJnQjtJQURoQlMsQ0FBQUE7O0FBSUFzQixJQUFBQSxxQkFBQUEsaUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBOUMsV0FBTStDLE9BQUFBLENBQU96QyxTQUFiLEVBQW9CRCxTQUFkMEM7SUFEUkQsQ0FBQUE7O0FBSUF2QixJQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBL0IsT0FBUWtCLFNBQUFBLENBQVNMLFNBQWpCLEVBQXlCQyxTQUFEUSxPQUFBQSxDQUFBQSxDQUFoQko7SUFEVmEsQ0FBQUE7O0FBSUF5QixJQUFBQSwyQkFBQUEsdUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBM0MsU0FBSzJDLGFBQUFBLENBQUFBLENBQVlDLEtBQUFBLENBQUszQyxTQUFLMEMsYUFBQUEsQ0FBQUEsQ0FBVkM7SUFEbkJELENBQUFBOztBQUlBRSxJQUFBQSxvQkFBQUEsNkJBQVN6QyxLQUFUeUM7QUFBQUEsTUFBQUE7O01BQ0UsSUFBQSxRQUFBckMsQ0FBQUEsWUFBQSxDQUFBLFFBQUFzQyxDQUFBQSxZQUFBekMsYUFBUTBDLFFBQUFBLENBQUkzQyxLQUFKMkMsQ0FBUkQsQ0FBQSxDQUFBLEdBQUEsQ0FBcUI5QyxTQUFLTSxPQUFBQSxDQUFBQSxDQUFPQyxPQUFBQSxDQUFHTixTQUFLSyxPQUFBQSxDQUFBQSxDQUFSQyxDQUFqQyxJQUFBLENBQUEsU0FBQSxDQUFBLENBQUFDLENBQUEsQ0FBQTtRQUFtRHFDLE9BQUFuRSxJQUFLNkIsT0FBQUEsQ0FBR0gsS0FBSEc7TUFBeEQ7UUFBQXNDLE9BQUE7TUFBQTtJQURGQSxDQUFBQTs7QUFJQUcsSUFBQUEsb0JBQUFBLGdCQUFTNUMsS0FBVDRDO0FBQUFBLE1BQUFBOzs7TUFDRSxLQUFBLFFBQU8vRCxjQUFQLEVBQXFCbUIsS0FBckIsQ0FBQTtRQUNFakIsT0FBUUMsT0FBQUEsQ0FBT0MsZ0JBQWYsRUFBNEIsRUFBQSxHQUFBLENBQUdlLEtBQUtFLE9BQUFBLENBQUFBLENBQVIsQ0FBQSxHQUFlMEMsZ0NBQW5DNUQ7TUFEVjtNQUlBNEQsT0FBS25DLFdBQUxuQyxJQUFLbUMsRUFBRVQsS0FBRlM7SUFMUG1DLENBQUFBOztBQVFBQyxJQUFBQSx1QkFBQUEsZ0NBQUFBO0FBQUFBLE1BQUFBOztNQUNFLElBQUEsUUFBQXpDLENBQUFBLFlBQUFSLFNBQUtpRCxZQUFBQSxDQUFBQSxDQUFMekMsQ0FBQSxDQUFBO1FBQWlCeUMsT0FBQWhELFNBQUtnRCxZQUFBQSxDQUFBQTtNQUF0QjtRQUFBQSxPQUFBO01BQUE7SUFERkEsQ0FBQUE7O0FBSUFDLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUEsQ0FBQzdDLGNBQUQsRUFBWUwsU0FBWixFQUFtQkMsU0FBbkIsQ0FBeUJpRCxNQUFBQSxDQUFBQTtJQUQzQkEsQ0FBQUE7O0FBSUFDLElBQUFBLHlCQUFBQSxtQ0FBQUE7QUFBQUEsTUFBQUE7O01BQ0UsSUFBQSxRQUFBM0MsQ0FBQUEsWUFBQVIsU0FBS21ELGNBQUFBLENBQUFBLENBQUwzQyxDQUFBLENBQUE7UUFBQTJDLE9BQUE7TUFBQTtRQUFtQkEsT0FBQWxELFNBQUtrRCxjQUFBQSxDQUFBQTtNQUF4QjtJQURGQSxDQUFBQTs7QUFJQUMsSUFBQUEsdUJBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0EsR0FBRCxHQUFBLENBQUkxRSxJQUFKLENBQUEsR0FBUzBFO0lBRFhBLENBQUFBOztBQUlBQyxJQUFBQSx5QkFBQUEscUJBQUFBO0FBQUFBLE1BQUFBOzs7TUFDRUMsSUFBSTVFLElBQUFpRSxhQUFBQSxDQUFBQTtNQUVKVSxPQUFBbEUsT0FBUWtCLFNBQUFBLENBQXlCWCxVQUFoQk0sU0FBS3FELFdBQUFBLENBQUFBLENBQVczRCxFQUFLbUIsV0FBRnlDLENBQUV6QyxFQUFFYixTQUFLMkMsYUFBQUEsQ0FBQUEsQ0FBUDlCLENBQUxuQixDQUFqQyxFQUNrQkEsVUFBaEJPLFNBQUtvRCxXQUFBQSxDQUFBQSxDQUFXM0QsRUFBS21CLFdBQUZ5QyxDQUFFekMsRUFBRVosU0FBSzBDLGFBQUFBLENBQUFBLENBQVA5QixDQUFMbkIsQ0FEVlc7SUFIVmdELENBQUFBOztBQVFBOUQsSUFBQUEscUJBQUFBLGlCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQSxDQUFDYixJQUFBNkQsS0FBQUEsQ0FBQUEsQ0FBRCxFQUFNN0QsSUFBQTZFLEtBQUFBLENBQUFBLENBQU47SUFERmhFLENBQUFBOztBQUlBaUUsSUFBQUEsMkJBQUFBLHVCQUFnQkMsR0FBaEJEO0FBQUFBLE1BQUFBOzs7OztBQUVGQTtBQUNBQSxRQUFVckUsT0FBUUMsT0FBQUEsQ0FBT3NFLG9CQUFmLEVBQWlDRiw2QkFBRCxHQUFBLENBQStCQSxnQkFBL0IsQ0FBQSxHQUFpREEsWUFBekVwRSxDQUFxRm9FO0FBQ3ZHQTtBQUNBQTtNQUVJLElBQUEsT0FBR3ZELFNBQUgsRUFBWWpCLENBQVosQ0FBQTtRQUNFRyxPQUFRQyxPQUFBQSxDQUFPdUUsaUJBQWYsRUFBOEJILGdCQUFELEdBQUEsQ0FBaUI5RSxJQUFqQixDQUFBLEdBQXNCOEUsZ0JBQTNDcEU7TUFEVjtNQUlBb0UsT0FBQTlFLElBQUFJLE1BQUFBLENBQUFBLENBQUkwRSxhQUFBQSxDQUFhQyxHQUFiRDtJQVhOQSxDQUFBQSxJQUFBQTs7QUFjQXRFLElBQUFBLHFCQUFBQSxZQUNFLEtBREZBLENBQUFBOztBQUlBTCxJQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBLENBQUNtQixTQUFELEVBQVFDLFNBQVI7SUFERnBCLENBQUFBOztBQUlBK0UsSUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7O01BQ0UsS0FBQSxNQUFPM0QsU0FBUCxFQUFnQmpCLENBQWhCLENBQUE7UUFDRUcsT0FBUUMsT0FBQUEsQ0FBT3VFLGlCQUFmLEVBQThCQyxnQkFBRCxHQUFBLENBQWlCbEYsSUFBakIsQ0FBQSxHQUFzQmtGLGFBQTNDeEU7TUFEVjtNQUlBd0UsT0FBQTVELFNBQUs0RCxNQUFBQSxDQUFBQTtJQUxQQSxDQUFBQTs7QUFRQUMsSUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7O01BQ0UsS0FBQSxNQUFPNUQsU0FBUCxFQUFnQmpCLENBQWhCLENBQUE7UUFDRUcsT0FBUUMsT0FBQUEsQ0FBT3VFLGlCQUFmLEVBQThCRSxnQkFBRCxHQUFBLENBQWlCbkYsSUFBakIsQ0FBQSxHQUFzQm1GLGVBQTNDekU7TUFEVjtNQUlBeUUsT0FBQTdELFNBQUs2RCxNQUFBQSxDQUFBQTtJQUxQQSxDQUFBQTs7QUFRQUMsSUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7O01BQ0UsS0FBQSxNQUFPN0QsU0FBUCxFQUFnQmpCLENBQWhCLENBQUE7UUFDRUcsT0FBUUMsT0FBQUEsQ0FBT3VFLGlCQUFmLEVBQThCRyxnQkFBRCxHQUFBLENBQWlCcEYsSUFBakIsQ0FBQSxHQUFzQm9GLGdCQUEzQzFFO01BRFY7TUFJQTBFLE9BQUE5RCxTQUFLOEQsTUFBQUEsQ0FBQUE7SUFMUEEsQ0FBQUE7O0FBUUFDLElBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7OztNQUNFQyxTQUFTaEUsU0FBS29ELFNBQUFBLENBQUFBO01BRWRZLFNBQU90RCxTQUFQc0QsTUFBT3RELEVBQ0wsQ0FBRyxDQUFBLENBQUMsQ0FBQSxRQUFBSSxhQUFBLEVBQWFiLFNBQWIsQ0FBQSxJQUFBLENBQUEsUUFBc0JBLFNBQUtjLFNBQUFBLENBQUFBLENBQTNCLENBQUEsQ0FBQSxDQUFELElBQUEsQ0FBQSxRQUFzQ2QsU0FBS2dFLGNBQUFBLENBQUFBLENBQTNDLENBQUEsQ0FBQSxDQUFBLElBQUEsQ0FBQSxRQUF5RGhFLFNBQUtpRSxVQUFBQSxDQUFBQSxDQUE5RCxDQUFBLENBQUEsQ0FBSCxHQUFBLENBQ0VILEdBREYsSUFBQSxDQUdFQSxHQUhGLENBQUEsQ0FES3JEO01BT1BzRCxTQUFPdEQsU0FBUHNELE1BQU90RCxFQUFHVCxTQUFLc0MsS0FBQUEsQ0FBQUEsQ0FBSWEsU0FBQUEsQ0FBQUEsQ0FBWjFDO01BRVAsSUFBRyxDQUFBLFFBQUFJLGFBQUEsRUFBYWIsU0FBYixDQUFBLElBQUEsQ0FBdUIsQ0FBQSxRQUFBQSxTQUFLYyxTQUFBQSxDQUFBQSxDQUFMLENBQUEsSUFBQSxDQUFBLFFBQWNkLFNBQUtrRCxjQUFBQSxDQUFBQSxDQUFuQixDQUFBLENBQUEsQ0FBdkIsQ0FBQSxDQUFIO1FBQ0VhLFNBQU90RCxTQUFQc0QsTUFBT3RELEVBQUdxRCxHQUFIckQ7TUFEVDtNQUlBcUQsT0FBT3JELFNBQVBzRCxNQUFPdEQsRUFBRXFELEdBQUZyRDtJQWhCVHFELENBQUFBO0lBbUJBLDZCQUFJckYsSUFBQVksS0FBQUEsQ0FBSU4sQ0FBSixFQUFPc0MsQ0FBUGhDLENBQUo7SUFFQTZFLE1BQUl6RixJQUFKeUYsa0JBQUFBLHVCQUFxQkMsR0FBckJEO0FBQUFBOztBQUVGQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBLHFCQUF1QmhGLE9BQVFtRCxVQUFBQSxDQUFXNkIsU0FBbkIsRUFBZ0NBLFdBQXhCN0IsQ0FBc0M2QjtBQUNyRUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQSxpQkFBbUJoRixPQUFRa0IsU0FBQUEsQ0FBU3JCLENBQWpCLEVBQW9Cc0MsQ0FBWmpCLENBQWU4RDtBQUMxQ0E7QUFDQUE7QUFDQUE7QUFDQUEsaUJBQW1CaEYsT0FBUWtCLFNBQUFBLENBQVNyQixDQUFqQixFQUFvQnFGLEVBQVpoRSxDQUFnQjhEO0FBQzNDQTtBQUNBQTtBQUNBQTtBQUNBQSxpQkFBbUJoRixPQUFRa0IsU0FBQUEsQ0FBU3JCLENBQWpCLEVBQW9Cc0MsQ0FBWmpCLENBQWU4RDtBQUMxQ0E7QUFDQUE7QUFDQUEsZUFBaUJoRixPQUFRa0IsU0FBQUEsQ0FBU3JCLENBQWpCLEVBQW9CQSxDQUFacUIsQ0FBZThEO0FBQ3hDQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsaUJBQW1CaEYsT0FBUWtCLFNBQUFBLENBQVNyQixDQUFqQixFQUFxQm1GLElBQWI5RCxDQUFvQjhEO0FBQy9DQTtBQUNBQTtBQUNBQSxpQkFBbUJoRixPQUFRa0IsU0FBQUEsQ0FBVThELElBQWxCLEVBQXlCbkYsQ0FBakJxQixDQUFvQjhEO0FBQy9DQTtBQUNBQTtBQUNBQTtBQUNBQSxlQUFpQmhGLE9BQVFrQixTQUFBQSxDQUFVOEQsSUFBbEIsRUFBMEJBLElBQWxCOUQsQ0FBeUI4RDtBQUNsREE7QUFDQUE7SUEzRUVBLENBQUFBO0lBOEVBOztNQUNFLE9BQUEsYUFBTSxhQUFOLEVBQWtCLE1BQWxCO0lBREYsNEJBQVN6RixJQUFUO0lBSUEsYUFBTSxLQUFOLEVBQVUsT0FBVjtJQUNBLGFBQU0sV0FBTixFQUFnQixNQUFoQjtJQUNBLGFBQU0sUUFBTixFQUFhLEdBQWI7SUFDQSxhQUFNLFdBQU4sRUFBZ0IsTUFBaEI7SUFDQSxhQUFNLFdBQU4sRUFBZ0IsS0FBaEI7SUFDQSxhQUFNLE9BQU4sRUFBWSxLQUFaO0lBQ0EsYUFBTSxLQUFOLEVBQVUsR0FBVjtJQUNBLGFBQU0sYUFBTixFQUFrQixNQUFsQjs7SUFFQSxzQkFBTSxXQUFOOztJQUNBLHNCQUFNLFdBQU47OztJQUNBLHNCQUFNLE1BQU47SUE3V0ZFLE9BQUE7RUFLQUEsR0FBTSxJQUFOQSxFQUFrQkssY0FBbEJMO0FBTEFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMTY0MiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmF0aW9uYWwvYmFzZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgOjpLZXJuZWxcbiAgZGVmIFJhdGlvbmFsKG51bWVyYXRvciwgZGVub21pbmF0b3IgPSAxKVxuICAgIDo6UmF0aW9uYWwuY29udmVydChudW1lcmF0b3IsIGRlbm9taW5hdG9yKVxuICBlbmRcbmVuZFxuXG5jbGFzcyA6OlN0cmluZ1xuICBkZWYgdG9fclxuICAgIDo6UmF0aW9uYWwuZnJvbV9zdHJpbmcoc2VsZilcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpLZXJuZWw+IiwiUmF0aW9uYWwiLCJudW1lcmF0b3IiLCJkZW5vbWluYXRvciIsIjEiLCJjb252ZXJ0IiwiPGNsYXNzOlN0cmluZz4iLCJ0b19yIiwiZnJvbV9zdHJpbmciLCJzZWxmIl0sIm1hcHBpbmdzIjoiQUFBQUEsd0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDO0VBQUFBOzs7SUFDRUEsT0FBQUMsd0JBQUFBLG9CQUFhQyxTQUFELEVBQVlDLFdBQXhCRjtBQUFBQTs7TUFBd0IsdUNBQWNHO01BQ3BDSCxPQUFBQSxlQUFVSSxTQUFBQSxDQUFTSCxTQUFuQixFQUE4QkMsV0FBcEJFO0lBRFpKLENBQUFBLElBQUFBO0VBREZELEdBQU8sSUFBUEE7RUFNQUQsT0FBQU87RUFBQUE7OztJQUNFQSxPQUFBQyxvQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBTixlQUFVTyxhQUFBQSxDQUFhQyxJQUFiRDtJQURaRCxDQUFBQTtFQURGRCxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBTkFQOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMTY3MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmF0aW9uYWwucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXG5cbnJlcXVpcmUgJ2NvcmVsaWIvbnVtZXJpYydcbnJlcXVpcmUgJ2NvcmVsaWIvcmF0aW9uYWwvYmFzZSdcblxuY2xhc3MgOjpSYXRpb25hbCA8IDo6TnVtZXJpY1xuICBkZWYgc2VsZi5yZWR1Y2UobnVtLCBkZW4pXG4gICAgbnVtID0gbnVtLnRvX2lcbiAgICBkZW4gPSBkZW4udG9faVxuXG4gICAgaWYgZGVuID09IDBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6WmVyb0RpdmlzaW9uRXJyb3IsICdkaXZpZGVkIGJ5IDAnXG4gICAgZWxzaWYgZGVuIDwgMFxuICAgICAgbnVtID0gLW51bVxuICAgICAgZGVuID0gLWRlblxuICAgIGVsc2lmIGRlbiA9PSAxXG4gICAgICByZXR1cm4gbmV3KG51bSwgZGVuKVxuICAgIGVuZFxuXG4gICAgZ2NkID0gbnVtLmdjZChkZW4pXG5cbiAgICBuZXcobnVtIC8gZ2NkLCBkZW4gLyBnY2QpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvbnZlcnQobnVtLCBkZW4pXG4gICAgaWYgbnVtLm5pbD8gfHwgZGVuLm5pbD9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6VHlwZUVycm9yLCAnY2Fubm90IGNvbnZlcnQgbmlsIGludG8gUmF0aW9uYWwnXG4gICAgZW5kXG5cbiAgICBpZiA6OkludGVnZXIgPT09IG51bSAmJiA6OkludGVnZXIgPT09IGRlblxuICAgICAgcmV0dXJuIHJlZHVjZShudW0sIGRlbilcbiAgICBlbmRcblxuICAgIGlmIDo6RmxvYXQgPT09IG51bSB8fCA6OlN0cmluZyA9PT0gbnVtIHx8IDo6Q29tcGxleCA9PT0gbnVtXG4gICAgICBudW0gPSBudW0udG9fclxuICAgIGVuZFxuXG4gICAgaWYgOjpGbG9hdCA9PT0gZGVuIHx8IDo6U3RyaW5nID09PSBkZW4gfHwgOjpDb21wbGV4ID09PSBkZW5cbiAgICAgIGRlbiA9IGRlbi50b19yXG4gICAgZW5kXG5cbiAgICBpZiBkZW4uZXF1YWw/KDEpICYmICEoOjpJbnRlZ2VyID09PSBudW0pXG4gICAgICA6Ok9wYWwuY29lcmNlX3RvIShudW0sIDo6UmF0aW9uYWwsIDp0b19yKVxuICAgIGVsc2lmIDo6TnVtZXJpYyA9PT0gbnVtICYmIDo6TnVtZXJpYyA9PT0gZGVuXG4gICAgICBudW0gLyBkZW5cbiAgICBlbHNlXG4gICAgICByZWR1Y2UobnVtLCBkZW4pXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKG51bSwgZGVuKVxuICAgIEBudW0gPSBudW1cbiAgICBAZGVuID0gZGVuXG4gICAgZnJlZXplXG4gIGVuZFxuXG4gIGRlZiBudW1lcmF0b3JcbiAgICBAbnVtXG4gIGVuZFxuXG4gIGRlZiBkZW5vbWluYXRvclxuICAgIEBkZW5cbiAgZW5kXG5cbiAgZGVmIGNvZXJjZShvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiA6OlJhdGlvbmFsXG4gICAgICBbb3RoZXIsIHNlbGZdXG5cbiAgICB3aGVuIDo6SW50ZWdlclxuICAgICAgW290aGVyLnRvX3IsIHNlbGZdXG5cbiAgICB3aGVuIDo6RmxvYXRcbiAgICAgIFtvdGhlciwgdG9fZl1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIDo6UmF0aW9uYWxcbiAgICAgIEBudW0gPT0gb3RoZXIubnVtZXJhdG9yICYmIEBkZW4gPT0gb3RoZXIuZGVub21pbmF0b3JcblxuICAgIHdoZW4gOjpJbnRlZ2VyXG4gICAgICBAbnVtID09IG90aGVyICYmIEBkZW4gPT0gMVxuXG4gICAgd2hlbiA6OkZsb2F0XG4gICAgICB0b19mID09IG90aGVyXG5cbiAgICBlbHNlXG4gICAgICBvdGhlciA9PSBzZWxmXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gOjpSYXRpb25hbFxuICAgICAgQG51bSAqIG90aGVyLmRlbm9taW5hdG9yIC0gQGRlbiAqIG90aGVyLm51bWVyYXRvciA8PT4gMFxuXG4gICAgd2hlbiA6OkludGVnZXJcbiAgICAgIEBudW0gLSBAZGVuICogb3RoZXIgPD0+IDBcblxuICAgIHdoZW4gOjpGbG9hdFxuICAgICAgdG9fZiA8PT4gb3RoZXJcblxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDo8PT4sIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiArKG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIDo6UmF0aW9uYWxcbiAgICAgIG51bSA9IEBudW0gKiBvdGhlci5kZW5vbWluYXRvciArIEBkZW4gKiBvdGhlci5udW1lcmF0b3JcbiAgICAgIGRlbiA9IEBkZW4gKiBvdGhlci5kZW5vbWluYXRvclxuXG4gICAgICA6Oktlcm5lbC5SYXRpb25hbChudW0sIGRlbilcblxuICAgIHdoZW4gOjpJbnRlZ2VyXG4gICAgICA6Oktlcm5lbC5SYXRpb25hbChAbnVtICsgb3RoZXIgKiBAZGVuLCBAZGVuKVxuXG4gICAgd2hlbiA6OkZsb2F0XG4gICAgICB0b19mICsgb3RoZXJcblxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDorLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgLShvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiA6OlJhdGlvbmFsXG4gICAgICBudW0gPSBAbnVtICogb3RoZXIuZGVub21pbmF0b3IgLSBAZGVuICogb3RoZXIubnVtZXJhdG9yXG4gICAgICBkZW4gPSBAZGVuICogb3RoZXIuZGVub21pbmF0b3JcblxuICAgICAgOjpLZXJuZWwuUmF0aW9uYWwobnVtLCBkZW4pXG5cbiAgICB3aGVuIDo6SW50ZWdlclxuICAgICAgOjpLZXJuZWwuUmF0aW9uYWwoQG51bSAtIG90aGVyICogQGRlbiwgQGRlbilcblxuICAgIHdoZW4gOjpGbG9hdFxuICAgICAgdG9fZiAtIG90aGVyXG5cbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6LSwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmICoob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gOjpSYXRpb25hbFxuICAgICAgbnVtID0gQG51bSAqIG90aGVyLm51bWVyYXRvclxuICAgICAgZGVuID0gQGRlbiAqIG90aGVyLmRlbm9taW5hdG9yXG5cbiAgICAgIDo6S2VybmVsLlJhdGlvbmFsKG51bSwgZGVuKVxuXG4gICAgd2hlbiA6OkludGVnZXJcbiAgICAgIDo6S2VybmVsLlJhdGlvbmFsKEBudW0gKiBvdGhlciwgQGRlbilcblxuICAgIHdoZW4gOjpGbG9hdFxuICAgICAgdG9fZiAqIG90aGVyXG5cbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6Kiwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIC8ob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gOjpSYXRpb25hbFxuICAgICAgbnVtID0gQG51bSAqIG90aGVyLmRlbm9taW5hdG9yXG4gICAgICBkZW4gPSBAZGVuICogb3RoZXIubnVtZXJhdG9yXG5cbiAgICAgIDo6S2VybmVsLlJhdGlvbmFsKG51bSwgZGVuKVxuXG4gICAgd2hlbiA6OkludGVnZXJcbiAgICAgIGlmIG90aGVyID09IDBcbiAgICAgICAgdG9fZiAvIDAuMFxuICAgICAgZWxzZVxuICAgICAgICA6Oktlcm5lbC5SYXRpb25hbChAbnVtLCBAZGVuICogb3RoZXIpXG4gICAgICBlbmRcblxuICAgIHdoZW4gOjpGbG9hdFxuICAgICAgdG9fZiAvIG90aGVyXG5cbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6Lywgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmICoqKG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIDo6SW50ZWdlclxuICAgICAgaWYgc2VsZiA9PSAwICYmIG90aGVyIDwgMFxuICAgICAgICA6OkZsb2F0OjpJTkZJTklUWVxuICAgICAgZWxzaWYgb3RoZXIgPiAwXG4gICAgICAgIDo6S2VybmVsLlJhdGlvbmFsKEBudW0qKm90aGVyLCBAZGVuKipvdGhlcilcbiAgICAgIGVsc2lmIG90aGVyIDwgMFxuICAgICAgICA6Oktlcm5lbC5SYXRpb25hbChAZGVuKiotb3RoZXIsIEBudW0qKi1vdGhlcilcbiAgICAgIGVsc2VcbiAgICAgICAgOjpLZXJuZWwuUmF0aW9uYWwoMSwgMSlcbiAgICAgIGVuZFxuXG4gICAgd2hlbiA6OkZsb2F0XG4gICAgICB0b19mKipvdGhlclxuXG4gICAgd2hlbiA6OlJhdGlvbmFsXG4gICAgICBpZiBvdGhlciA9PSAwXG4gICAgICAgIDo6S2VybmVsLlJhdGlvbmFsKDEsIDEpXG4gICAgICBlbHNpZiBvdGhlci5kZW5vbWluYXRvciA9PSAxXG4gICAgICAgIGlmIG90aGVyIDwgMFxuICAgICAgICAgIDo6S2VybmVsLlJhdGlvbmFsKEBkZW4qKm90aGVyLm51bWVyYXRvci5hYnMsIEBudW0qKm90aGVyLm51bWVyYXRvci5hYnMpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICA6Oktlcm5lbC5SYXRpb25hbChAbnVtKipvdGhlci5udW1lcmF0b3IsIEBkZW4qKm90aGVyLm51bWVyYXRvcilcbiAgICAgICAgZW5kXG4gICAgICBlbHNpZiBzZWxmID09IDAgJiYgb3RoZXIgPCAwXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6WmVyb0RpdmlzaW9uRXJyb3IsICdkaXZpZGVkIGJ5IDAnXG4gICAgICBlbHNlXG4gICAgICAgIHRvX2YqKm90aGVyXG4gICAgICBlbmRcblxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDoqKiwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGFic1xuICAgIDo6S2VybmVsLlJhdGlvbmFsKEBudW0uYWJzLCBAZGVuLmFicylcbiAgZW5kXG5cbiAgZGVmIGNlaWwocHJlY2lzaW9uID0gMClcbiAgICBpZiBwcmVjaXNpb24gPT0gMFxuICAgICAgKC0oLUBudW0gLyBAZGVuKSkuY2VpbFxuICAgIGVsc2VcbiAgICAgIHdpdGhfcHJlY2lzaW9uKDpjZWlsLCBwcmVjaXNpb24pXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBmbG9vcihwcmVjaXNpb24gPSAwKVxuICAgIGlmIHByZWNpc2lvbiA9PSAwXG4gICAgICAoLSgtQG51bSAvIEBkZW4pKS5mbG9vclxuICAgIGVsc2VcbiAgICAgIHdpdGhfcHJlY2lzaW9uKDpmbG9vciwgcHJlY2lzaW9uKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIFs6OlJhdGlvbmFsLCBAbnVtLCBAZGVuXS5oYXNoXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIoI3tzZWxmfSlcIlxuICBlbmRcblxuICBkZWYgcmF0aW9uYWxpemUoZXBzID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBmb3IgMC4uMSlcIn07XG4gICAgICB9XG5cbiAgICAgIGlmIChlcHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGUgPSAje2Vwcy5hYnN9LFxuICAgICAgICAgIGEgPSAje3NlbGYgLSBgZWB9LFxuICAgICAgICAgIGIgPSAje3NlbGYgKyBgZWB9O1xuXG4gICAgICB2YXIgcDAgPSAwLFxuICAgICAgICAgIHAxID0gMSxcbiAgICAgICAgICBxMCA9IDEsXG4gICAgICAgICAgcTEgPSAwLFxuICAgICAgICAgIHAyLCBxMjtcblxuICAgICAgdmFyIGMsIGssIHQ7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGMgPSAje2BhYC5jZWlsfTtcblxuICAgICAgICBpZiAoI3tgY2AgPD0gYGJgfSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgayAgPSBjIC0gMTtcbiAgICAgICAgcDIgPSBrICogcDEgKyBwMDtcbiAgICAgICAgcTIgPSBrICogcTEgKyBxMDtcbiAgICAgICAgdCAgPSAjezEgLyAoYGJgIC0gYGtgKX07XG4gICAgICAgIGIgID0gI3sxIC8gKGBhYCAtIGBrYCl9O1xuICAgICAgICBhICA9IHQ7XG5cbiAgICAgICAgcDAgPSBwMTtcbiAgICAgICAgcTAgPSBxMTtcbiAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgcTEgPSBxMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7OjpLZXJuZWwuUmF0aW9uYWwoYGMgKiBwMSArIHAwYCwgYGMgKiBxMSArIHEwYCl9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJvdW5kKHByZWNpc2lvbiA9IDApXG4gICAgcmV0dXJuIHdpdGhfcHJlY2lzaW9uKDpyb3VuZCwgcHJlY2lzaW9uKSB1bmxlc3MgcHJlY2lzaW9uID09IDBcbiAgICByZXR1cm4gMCBpZiBAbnVtID09IDBcbiAgICByZXR1cm4gQG51bSBpZiBAZGVuID09IDFcblxuICAgIG51bSA9IEBudW0uYWJzICogMiArIEBkZW5cbiAgICBkZW4gPSBAZGVuICogMlxuXG4gICAgYXBwcm94ID0gKG51bSAvIGRlbikudHJ1bmNhdGVcblxuICAgIGlmIEBudW0gPCAwXG4gICAgICAtYXBwcm94XG4gICAgZWxzZVxuICAgICAgYXBwcm94XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB0b19mXG4gICAgQG51bSAvIEBkZW5cbiAgZW5kXG5cbiAgZGVmIHRvX2lcbiAgICB0cnVuY2F0ZVxuICBlbmRcblxuICBkZWYgdG9fclxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBcIiN7QG51bX0vI3tAZGVufVwiXG4gIGVuZFxuXG4gIGRlZiB0cnVuY2F0ZShwcmVjaXNpb24gPSAwKVxuICAgIGlmIHByZWNpc2lvbiA9PSAwXG4gICAgICBAbnVtIDwgMCA/IGNlaWwgOiBmbG9vclxuICAgIGVsc2VcbiAgICAgIHdpdGhfcHJlY2lzaW9uKDp0cnVuY2F0ZSwgcHJlY2lzaW9uKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgd2l0aF9wcmVjaXNpb24obWV0aG9kLCBwcmVjaXNpb24pXG4gICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsICdub3QgYW4gSW50ZWdlcicgdW5sZXNzIDo6SW50ZWdlciA9PT0gcHJlY2lzaW9uXG5cbiAgICBwID0gMTAqKnByZWNpc2lvblxuICAgIHMgPSBzZWxmICogcFxuXG4gICAgaWYgcHJlY2lzaW9uIDwgMVxuICAgICAgKHMuc2VuZChtZXRob2QpIC8gcCkudG9faVxuICAgIGVsc2VcbiAgICAgIDo6S2VybmVsLlJhdGlvbmFsKHMuc2VuZChtZXRob2QpLCBwKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2VsZi5mcm9tX3N0cmluZyhzdHJpbmcpXG4gICAgJXh7XG4gICAgICB2YXIgc3RyID0gc3RyaW5nLnRyaW1MZWZ0KCksXG4gICAgICAgICAgcmUgPSAvXlsrLV0/W1xcZF9dKyhcXC5bXFxkX10rKT8vLFxuICAgICAgICAgIG1hdGNoID0gc3RyLm1hdGNoKHJlKSxcbiAgICAgICAgICBudW1lcmF0b3IsIGRlbm9taW5hdG9yO1xuXG4gICAgICBmdW5jdGlvbiBpc0Zsb2F0KCkge1xuICAgICAgICByZXR1cm4gcmUudGVzdChzdHIpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjdXRGbG9hdCgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKHJlKTtcbiAgICAgICAgdmFyIG51bWJlciA9IG1hdGNoWzBdO1xuICAgICAgICBzdHIgPSBzdHIuc2xpY2UobnVtYmVyLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBudW1iZXIucmVwbGFjZSgvXy9nLCAnJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Zsb2F0KCkpIHtcbiAgICAgICAgbnVtZXJhdG9yID0gcGFyc2VGbG9hdChjdXRGbG9hdCgpKTtcblxuICAgICAgICBpZiAoc3RyWzBdID09PSAnLycpIHtcbiAgICAgICAgICAvLyByYXRpb25hbCByZWFsIHBhcnRcbiAgICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMSk7XG5cbiAgICAgICAgICBpZiAoaXNGbG9hdCgpKSB7XG4gICAgICAgICAgICBkZW5vbWluYXRvciA9IHBhcnNlRmxvYXQoY3V0RmxvYXQoKSk7XG4gICAgICAgICAgICByZXR1cm4gI3s6Oktlcm5lbC5SYXRpb25hbChgbnVtZXJhdG9yYCwgYGRlbm9taW5hdG9yYCl9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gI3s6Oktlcm5lbC5SYXRpb25hbChgbnVtZXJhdG9yYCwgMSl9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gI3s6Oktlcm5lbC5SYXRpb25hbChgbnVtZXJhdG9yYCwgMSl9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gI3s6Oktlcm5lbC5SYXRpb25hbCgwLCAxKX07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBkaXZpZGUgL1xuICBhbGlhcyBxdW8gL1xuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOlJhdGlvbmFsPiIsInJlZHVjZSIsIm51bSIsImRlbiIsInRvX2kiLCIwIiwiS2VybmVsIiwicmFpc2UiLCJaZXJvRGl2aXNpb25FcnJvciIsIjwiLCItQCIsIjEiLCJuZXciLCJnY2QiLCIvIiwiY29udmVydCIsIm5pbD8iLCJUeXBlRXJyb3IiLCJJbnRlZ2VyIiwiRmxvYXQiLCJTdHJpbmciLCJDb21wbGV4IiwidG9fciIsImVxdWFsPyIsIj09PSIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiUmF0aW9uYWwiLCJOdW1lcmljIiwiaW5pdGlhbGl6ZSIsIkBudW0iLCJAZGVuIiwiZnJlZXplIiwibnVtZXJhdG9yIiwiZGVub21pbmF0b3IiLCJjb2VyY2UiLCJvdGhlciIsIiRyZXRfb3JfMSIsInRvX2YiLCI9PSIsIiRyZXRfb3JfMiIsIjw9PiIsIi0iLCIqIiwiX19jb2VyY2VkX18iLCIrIiwiKioiLCJGbG9hdDo6SU5GSU5JVFkiLCI+IiwiYWJzIiwiY2VpbCIsInByZWNpc2lvbiIsIndpdGhfcHJlY2lzaW9uIiwiZmxvb3IiLCJoYXNoIiwiaW5zcGVjdCIsInJhdGlvbmFsaXplIiwiZXBzIiwiQXJndW1lbnRFcnJvciIsIjw9Iiwicm91bmQiLCIyIiwiYXBwcm94IiwidHJ1bmNhdGUiLCJ0b19zIiwibWV0aG9kIiwicCIsIjEwIiwicyIsInNlbmQiLCJmcm9tX3N0cmluZyIsInN0cmluZyJdLCJtYXBwaW5ncyI6IkFBQUFBLG1DQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQyxJQUFBQyxTQUFBQSxDQUFRRixpQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsdUJBQVJFO0VBRUFGLE9BQUFHO0VBQUFBOztJQUFBQTs7QUFBQUE7O0lBQ0VDLE1BQUlILElBQUpHLGFBQUFBLGtCQUFnQkMsR0FBRCxFQUFNQyxHQUFyQkY7QUFBQUEsTUFBQUE7OztNQUNFQyxNQUFNQSxHQUFHRSxNQUFBQSxDQUFBQTtNQUNURCxNQUFNQSxHQUFHQyxNQUFBQSxDQUFBQTtNQUVULElBQUEsTUFBR0QsR0FBSCxFQUFVRSxDQUFWLENBQUE7UUFDRUMsT0FBUUMsT0FBQUEsQ0FBT0Msd0JBQWYsRUFBb0NQLGNBQTVCTTtNQURWLE9BRUEsSUFBQSxRQUFVRSxPQUFKTixHQUFJTSxFQUFFSixDQUFGSSxDQUFWLENBQUE7O1FBQ0VQLE1BQU9BLEdBQURRLE9BQUFBLENBQUFBO1FBQ05QLE1BQU9BLEdBQURPLE9B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QTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQSxtQkFBcUJoRSxPQUFRcUIsVUFBQUEsQ0FBVzJDLFNBQW5CLEVBQWdDQSxXQUF4QjNDLENBQXNDMkM7QUFDbkVBO0FBQ0FBLG1CQUFxQmhFLE9BQVFxQixVQUFBQSxDQUFXMkMsU0FBbkIsRUFBK0IzRCxDQUF2QmdCLENBQTBCMkM7QUFDdkRBO0FBQ0FBO0FBQ0FBLGlCQUFtQmhFLE9BQVFxQixVQUFBQSxDQUFXMkMsU0FBbkIsRUFBK0IzRCxDQUF2QmdCLENBQTBCMkM7QUFDckRBO0FBQ0FBO0FBQ0FBLGVBQWlCaEUsT0FBUXFCLFVBQUFBLENBQVV0QixDQUFsQixFQUFxQk0sQ0FBYmdCLENBQWdCMkM7QUFDekNBO0FBQ0FBO0lBckNFQSxDQUFBQTtJQXdDQSxhQUFNLFFBQU4sRUFBYSxHQUFiO0lBQ0F0RSxPQUFBLGFBQU0sS0FBTixFQUFVLEdBQVY7RUFyWUZBLEdBQU0sSUFBTkEsRUFBbUI0QixjQUFuQjVCO0FBTEFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMjEwOCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvdGltZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHNsaWNlLCBkZW55X2Zyb3plbl9hY2Nlc3NcbiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxuXG5yZXF1aXJlICdjb3JlbGliL2NvbXBhcmFibGUnXG5cbmNsYXNzIDo6VGltZSA8IGBEYXRlYFxuICBpbmNsdWRlIDo6Q29tcGFyYWJsZVxuXG4gICV4e1xuICAgIHZhciBkYXlzX29mX3dlZWsgPSAjeyV3W1N1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5IFN1bmRheV19LFxuICAgICAgICBzaG9ydF9kYXlzICAgPSAjeyV3W1N1biBNb24gVHVlIFdlZCBUaHUgRnJpIFNhdF19LFxuICAgICAgICBzaG9ydF9tb250aHMgPSAjeyV3W0phbiBGZWIgTWFyIEFwciBNYXkgSnVuIEp1bCBBdWcgU2VwIE9jdCBOb3YgRGVjXX0sXG4gICAgICAgIGxvbmdfbW9udGhzICA9ICN7JXdbSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlcl19O1xuICB9XG5cbiAgZGVmIHNlbGYuYXQoc2Vjb25kcywgZnJhYyA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGlmICgjezo6VGltZSA9PT0gc2Vjb25kc30pIHtcbiAgICAgICAgaWYgKGZyYWMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwiY2FuJ3QgY29udmVydCBUaW1lIGludG8gYW4gZXhhY3QgbnVtYmVyXCJ9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gbmV3IERhdGUoc2Vjb25kcy5nZXRUaW1lKCkpO1xuICAgICAgICByZXN1bHQudGltZXpvbmUgPSBzZWNvbmRzLnRpbWV6b25lO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNlY29uZHMuJCRpc19udW1iZXIpIHtcbiAgICAgICAgc2Vjb25kcyA9ICN7OjpPcGFsLmNvZXJjZV90byEoc2Vjb25kcywgOjpJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICB9XG5cbiAgICAgIGlmIChmcmFjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHNlY29uZHMgKiAxMDAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFmcmFjLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIGZyYWMgPSAjezo6T3BhbC5jb2VyY2VfdG8hKGZyYWMsIDo6SW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IERhdGUoc2Vjb25kcyAqIDEwMDAgKyAoZnJhYyAvIDEwMDApKTtcbiAgICB9XG4gIGVuZFxuXG4gICV4e1xuICAgIGZ1bmN0aW9uIHRpbWVfcGFyYW1zKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgc2VjKSB7XG4gICAgICBpZiAoeWVhci4kJGlzX3N0cmluZykge1xuICAgICAgICB5ZWFyID0gcGFyc2VJbnQoeWVhciwgMTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWVhciA9ICN7OjpPcGFsLmNvZXJjZV90byEoYHllYXJgLCA6OkludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vbnRoID09PSBuaWwpIHtcbiAgICAgICAgbW9udGggPSAxO1xuICAgICAgfSBlbHNlIGlmICghbW9udGguJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKCN7YG1vbnRoYC5yZXNwb25kX3RvPyg6dG9fc3RyKX0pIHtcbiAgICAgICAgICBtb250aCA9ICN7YG1vbnRoYC50b19zdHJ9O1xuICAgICAgICAgIHN3aXRjaCAobW9udGgudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIGNhc2UgJ2phbic6IG1vbnRoID0gIDE7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2ZlYic6IG1vbnRoID0gIDI7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ21hcic6IG1vbnRoID0gIDM7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Fwcic6IG1vbnRoID0gIDQ7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ21heSc6IG1vbnRoID0gIDU7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2p1bic6IG1vbnRoID0gIDY7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2p1bCc6IG1vbnRoID0gIDc7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2F1Zyc6IG1vbnRoID0gIDg7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3NlcCc6IG1vbnRoID0gIDk7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ29jdCc6IG1vbnRoID0gMTA7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ25vdic6IG1vbnRoID0gMTE7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2RlYyc6IG1vbnRoID0gMTI7IGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6IG1vbnRoID0gI3tgbW9udGhgLnRvX2l9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb250aCA9ICN7OjpPcGFsLmNvZXJjZV90byEoYG1vbnRoYCwgOjpJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1vbnRoIDwgMSB8fCBtb250aCA+IDEyKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIm1vbnRoIG91dCBvZiByYW5nZTogI3tgbW9udGhgfVwifVxuICAgICAgfVxuICAgICAgbW9udGggPSBtb250aCAtIDE7XG5cbiAgICAgIGlmIChkYXkgPT09IG5pbCkge1xuICAgICAgICBkYXkgPSAxO1xuICAgICAgfSBlbHNlIGlmIChkYXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgZGF5ID0gcGFyc2VJbnQoZGF5LCAxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXkgPSAjezo6T3BhbC5jb2VyY2VfdG8hKGBkYXlgLCA6OkludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRheSA8IDEgfHwgZGF5ID4gMzEpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwiZGF5IG91dCBvZiByYW5nZTogI3tgZGF5YH1cIn1cbiAgICAgIH1cblxuICAgICAgaWYgKGhvdXIgPT09IG5pbCkge1xuICAgICAgICBob3VyID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoaG91ci4kJGlzX3N0cmluZykge1xuICAgICAgICBob3VyID0gcGFyc2VJbnQoaG91ciwgMTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaG91ciA9ICN7OjpPcGFsLmNvZXJjZV90byEoYGhvdXJgLCA6OkludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhvdXIgPCAwIHx8IGhvdXIgPiAyNCkge1xuICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJob3VyIG91dCBvZiByYW5nZTogI3tgaG91cmB9XCJ9XG4gICAgICB9XG5cbiAgICAgIGlmIChtaW4gPT09IG5pbCkge1xuICAgICAgICBtaW4gPSAwO1xuICAgICAgfSBlbHNlIGlmIChtaW4uJCRpc19zdHJpbmcpIHtcbiAgICAgICAgbWluID0gcGFyc2VJbnQobWluLCAxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW4gPSAjezo6T3BhbC5jb2VyY2VfdG8hKGBtaW5gLCA6OkludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1pbiA8IDAgfHwgbWluID4gNTkpIHtcbiAgICAgICAgI3s6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwibWluIG91dCBvZiByYW5nZTogI3tgbWluYH1cIn1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlYyA9PT0gbmlsKSB7XG4gICAgICAgIHNlYyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKCFzZWMuJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKHNlYy4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHNlYyA9IHBhcnNlSW50KHNlYywgMTApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlYyA9ICN7OjpPcGFsLmNvZXJjZV90byEoYHNlY2AsIDo6SW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWMgPCAwIHx8IHNlYyA+IDYwKSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcInNlYyBvdXQgb2YgcmFuZ2U6ICN7YHNlY2B9XCJ9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCBzZWNdO1xuICAgIH1cbiAgfVxuXG4gIGRlZiBzZWxmLm5ldyh5ZWFyID0gdW5kZWZpbmVkLCBtb250aCA9IG5pbCwgZGF5ID0gbmlsLCBob3VyID0gbmlsLCBtaW4gPSBuaWwsIHNlYyA9IG5pbCwgdXRjX29mZnNldCA9IG5pbClcbiAgICAleHtcbiAgICAgIHZhciBhcmdzLCByZXN1bHQsIHRpbWV6b25lLCB1dGNfZGF0ZTtcblxuICAgICAgaWYgKHllYXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoKTtcbiAgICAgIH1cblxuICAgICAgYXJncyAgPSB0aW1lX3BhcmFtcyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIHNlYyk7XG4gICAgICB5ZWFyICA9IGFyZ3NbMF07XG4gICAgICBtb250aCA9IGFyZ3NbMV07XG4gICAgICBkYXkgICA9IGFyZ3NbMl07XG4gICAgICBob3VyICA9IGFyZ3NbM107XG4gICAgICBtaW4gICA9IGFyZ3NbNF07XG4gICAgICBzZWMgICA9IGFyZ3NbNV07XG5cbiAgICAgIGlmICh1dGNfb2Zmc2V0ID09PSBuaWwpIHtcbiAgICAgICAgcmVzdWx0ID0gbmV3IERhdGUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCAwLCBzZWMgKiAxMDAwKTtcbiAgICAgICAgaWYgKHllYXIgPCAxMDApIHtcbiAgICAgICAgICByZXN1bHQuc2V0RnVsbFllYXIoeWVhcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgdGltZXpvbmUgPSAje19wYXJzZV9vZmZzZXQodXRjX29mZnNldCl9O1xuICAgICAgdXRjX2RhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIDAsIHNlYyAqIDEwMDApKTtcbiAgICAgIGlmICh5ZWFyIDwgMTAwKSB7XG4gICAgICAgIHV0Y19kYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIpO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBuZXcgRGF0ZSh1dGNfZGF0ZS5nZXRUaW1lKCkgLSB0aW1lem9uZSAqIDM2MDAwMDApO1xuICAgICAgcmVzdWx0LnRpbWV6b25lID0gdGltZXpvbmU7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICAjIEBwcml2YXRlXG4gIGRlZiBzZWxmLl9wYXJzZV9vZmZzZXQodXRjX29mZnNldClcbiAgICAleHtcbiAgICAgIHZhciB0aW1lem9uZTtcbiAgICAgIGlmICh1dGNfb2Zmc2V0LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIGlmICh1dGNfb2Zmc2V0ID09ICdVVEMnKSB7XG4gICAgICAgICAgdGltZXpvbmUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoL15bKy1dXFxkXFxkOlswLTVdXFxkJC8udGVzdCh1dGNfb2Zmc2V0KSkge1xuICAgICAgICAgIHZhciBzaWduLCBob3VycywgbWludXRlcztcbiAgICAgICAgICBzaWduID0gdXRjX29mZnNldFswXTtcbiAgICAgICAgICBob3VycyA9ICsodXRjX29mZnNldFsxXSArIHV0Y19vZmZzZXRbMl0pO1xuICAgICAgICAgIG1pbnV0ZXMgPSArKHV0Y19vZmZzZXRbNF0gKyB1dGNfb2Zmc2V0WzVdKTtcblxuICAgICAgICAgIHRpbWV6b25lID0gKHNpZ24gPT0gJy0nID8gLTEgOiAxKSAqIChob3VycyArIG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gVW5zdXBwb3J0ZWQ6IFwiQVwiLi5cIklcIixcIktcIi4uXCJaXCJcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJSdcIitISDpNTVwiLCBcIi1ISDpNTVwiLCBcIlVUQ1wiIGV4cGVjdGVkIGZvciB1dGNfb2Zmc2V0OiAje3V0Y19vZmZzZXR9J31cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAodXRjX29mZnNldC4kJGlzX251bWJlcikge1xuICAgICAgICB0aW1lem9uZSA9IHV0Y19vZmZzZXQgLyAzNjAwO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIk9wYWwgZG9lc24ndCBzdXBwb3J0IG90aGVyIHR5cGVzIGZvciBhIHRpbWV6b25lIGFyZ3VtZW50IHRoYW4gSW50ZWdlciBhbmQgU3RyaW5nXCJ9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGltZXpvbmU7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5sb2NhbCh5ZWFyLCBtb250aCA9IG5pbCwgZGF5ID0gbmlsLCBob3VyID0gbmlsLCBtaW4gPSBuaWwsIHNlYyA9IG5pbCwgbWlsbGlzZWNvbmQgPSBuaWwsIF9kdW1teTEgPSBuaWwsIF9kdW1teTIgPSBuaWwsIF9kdW1teTMgPSBuaWwpXG4gICAgIyBUaGUgX2R1bW15IGFyZ3MgYXJlIHRoZXJlIG9ubHkgYmVjYXVzZSB0aGUgTVJJIHZlcnNpb24gYWNjZXB0cyB1cCB0byAxMCBhcmd1bWVudHNcbiAgICAleHtcbiAgICAgIHZhciBhcmdzLCByZXN1bHQ7XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxMCkge1xuICAgICAgICBhcmdzICA9ICRzbGljZShhcmd1bWVudHMpO1xuICAgICAgICB5ZWFyICA9IGFyZ3NbNV07XG4gICAgICAgIG1vbnRoID0gYXJnc1s0XTtcbiAgICAgICAgZGF5ICAgPSBhcmdzWzNdO1xuICAgICAgICBob3VyICA9IGFyZ3NbMl07XG4gICAgICAgIG1pbiAgID0gYXJnc1sxXTtcbiAgICAgICAgc2VjICAgPSBhcmdzWzBdO1xuICAgICAgfVxuXG4gICAgICBhcmdzICA9IHRpbWVfcGFyYW1zKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgc2VjKTtcbiAgICAgIHllYXIgID0gYXJnc1swXTtcbiAgICAgIG1vbnRoID0gYXJnc1sxXTtcbiAgICAgIGRheSAgID0gYXJnc1syXTtcbiAgICAgIGhvdXIgID0gYXJnc1szXTtcbiAgICAgIG1pbiAgID0gYXJnc1s0XTtcbiAgICAgIHNlYyAgID0gYXJnc1s1XTtcblxuICAgICAgcmVzdWx0ID0gbmV3IERhdGUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCAwLCBzZWMgKiAxMDAwKTtcbiAgICAgIGlmICh5ZWFyIDwgMTAwKSB7XG4gICAgICAgIHJlc3VsdC5zZXRGdWxsWWVhcih5ZWFyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5nbSh5ZWFyLCBtb250aCA9IG5pbCwgZGF5ID0gbmlsLCBob3VyID0gbmlsLCBtaW4gPSBuaWwsIHNlYyA9IG5pbCwgbWlsbGlzZWNvbmQgPSBuaWwsIF9kdW1teTEgPSBuaWwsIF9kdW1teTIgPSBuaWwsIF9kdW1teTMgPSBuaWwpXG4gICAgIyBUaGUgX2R1bW15IGFyZ3MgYXJlIHRoZXJlIG9ubHkgYmVjYXVzZSB0aGUgTVJJIHZlcnNpb24gYWNjZXB0cyB1cCB0byAxMCBhcmd1bWVudHNcbiAgICAleHtcbiAgICAgIHZhciBhcmdzLCByZXN1bHQ7XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxMCkge1xuICAgICAgICBhcmdzICA9ICRzbGljZShhcmd1bWVudHMpO1xuICAgICAgICB5ZWFyICA9IGFyZ3NbNV07XG4gICAgICAgIG1vbnRoID0gYXJnc1s0XTtcbiAgICAgICAgZGF5ICAgPSBhcmdzWzNdO1xuICAgICAgICBob3VyICA9IGFyZ3NbMl07XG4gICAgICAgIG1pbiAgID0gYXJnc1sxXTtcbiAgICAgICAgc2VjICAgPSBhcmdzWzBdO1xuICAgICAgfVxuXG4gICAgICBhcmdzICA9IHRpbWVfcGFyYW1zKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgc2VjKTtcbiAgICAgIHllYXIgID0gYXJnc1swXTtcbiAgICAgIG1vbnRoID0gYXJnc1sxXTtcbiAgICAgIGRheSAgID0gYXJnc1syXTtcbiAgICAgIGhvdXIgID0gYXJnc1szXTtcbiAgICAgIG1pbiAgID0gYXJnc1s0XTtcbiAgICAgIHNlYyAgID0gYXJnc1s1XTtcblxuICAgICAgcmVzdWx0ID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCAwLCBzZWMgKiAxMDAwKSk7XG4gICAgICBpZiAoeWVhciA8IDEwMCkge1xuICAgICAgICByZXN1bHQuc2V0VVRDRnVsbFllYXIoeWVhcik7XG4gICAgICB9XG4gICAgICByZXN1bHQudGltZXpvbmUgPSAwO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLm5vd1xuICAgIG5ld1xuICBlbmRcblxuICBkZWYgKyhvdGhlcilcbiAgICBpZiA6OlRpbWUgPT09IG90aGVyXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgJ3RpbWUgKyB0aW1lPydcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKCFvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICBvdGhlciA9ICN7OjpPcGFsLmNvZXJjZV90byEob3RoZXIsIDo6SW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBEYXRlKHNlbGYuZ2V0VGltZSgpICsgKG90aGVyICogMTAwMCkpO1xuICAgICAgcmVzdWx0LnRpbWV6b25lID0gc2VsZi50aW1lem9uZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgLShvdGhlcilcbiAgICBpZiA6OlRpbWUgPT09IG90aGVyXG4gICAgICByZXR1cm4gYChzZWxmLmdldFRpbWUoKSAtIG90aGVyLmdldFRpbWUoKSkgLyAxMDAwYFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoIW90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIG90aGVyID0gI3s6Ok9wYWwuY29lcmNlX3RvIShvdGhlciwgOjpJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IERhdGUoc2VsZi5nZXRUaW1lKCkgLSAob3RoZXIgKiAxMDAwKSk7XG4gICAgICByZXN1bHQudGltZXpvbmUgPSBzZWxmLnRpbWV6b25lO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgaWYgOjpUaW1lID09PSBvdGhlclxuICAgICAgdG9fZiA8PT4gb3RoZXIudG9fZlxuICAgIGVsc2VcbiAgICAgIHIgPSBvdGhlciA8PT4gc2VsZlxuICAgICAgaWYgci5uaWw/XG4gICAgICAgIG5pbFxuICAgICAgZWxzaWYgciA+IDBcbiAgICAgICAgLTFcbiAgICAgIGVsc2lmIHIgPCAwXG4gICAgICAgIDFcbiAgICAgIGVsc2VcbiAgICAgICAgMFxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICA6OlRpbWUgPT09IG90aGVyICYmIGAje3RvX2Z9ID09PSAje290aGVyLnRvX2Z9YFxuICBlbmRcblxuICBkZWYgYXNjdGltZVxuICAgIHN0cmZ0aW1lICclYSAlYiAlZSAlSDolTTolUyAlWSdcbiAgZW5kXG5cbiAgW1xuICAgIFs6eWVhciwgJ2dldEZ1bGxZZWFyJywgJ2dldFVUQ0Z1bGxZZWFyJ10sXG4gICAgWzptb24sICdnZXRNb250aCcsICdnZXRVVENNb250aCcsIDFdLFxuICAgIFs6d2RheSwgJ2dldERheScsICdnZXRVVENEYXknXSxcbiAgICBbOmRheSwgJ2dldERhdGUnLCAnZ2V0VVRDRGF0ZSddLFxuICAgIFs6aG91ciwgJ2dldEhvdXJzJywgJ2dldFVUQ0hvdXJzJ10sXG4gICAgWzptaW4sICdnZXRNaW51dGVzJywgJ2dldFVUQ01pbnV0ZXMnXSxcbiAgICBbOnNlYywgJ2dldFNlY29uZHMnLCAnZ2V0VVRDU2Vjb25kcyddLFxuICBdLmVhY2ggZG8gfG1ldGhvZCwgZ2V0dGVyLCB1dGNnZXR0ZXIsIGRpZmZlcmVuY2UgPSAwfFxuICAgIGRlZmluZV9tZXRob2QgbWV0aG9kIGRvXG4gICAgICAleHtcbiAgICAgICAgcmV0dXJuIGRpZmZlcmVuY2UgKyAoKHNlbGYudGltZXpvbmUgIT0gbnVsbCkgP1xuICAgICAgICAgIChuZXcgRGF0ZShzZWxmLmdldFRpbWUoKSArIHNlbGYudGltZXpvbmUgKiAzNjAwMDAwKSlbdXRjZ2V0dGVyXSgpIDpcbiAgICAgICAgICBzZWxmW2dldHRlcl0oKSlcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHlkYXlcbiAgICAjIGh0dHA6Ly9qYXZhc2NyaXB0LmFib3V0LmNvbS9saWJyYXJ5L2JsZGF5eWVhci5odG1cbiAgICAjIGFsc28gc2VlIG1vbWVudC5qcyBpbXBsZW1lbnRhdGlvbjogaHR0cDovL2dpdC5pby92Q0tORVxuXG4gICAgc3RhcnRfb2ZfeWVhciA9IFRpbWUubmV3KHllYXIpLnRvX2lcbiAgICBzdGFydF9vZl9kYXkgID0gVGltZS5uZXcoeWVhciwgbW9udGgsIGRheSkudG9faVxuICAgIG9uZV9kYXkgICAgICAgPSA4Nl80MDBcblxuICAgICgoc3RhcnRfb2ZfZGF5IC0gc3RhcnRfb2ZfeWVhcikgLyBvbmVfZGF5KS5yb3VuZCArIDFcbiAgZW5kXG5cbiAgZGVmIGlzZHN0XG4gICAgJXh7XG4gICAgICB2YXIgamFuID0gbmV3IERhdGUoc2VsZi5nZXRGdWxsWWVhcigpLCAwLCAxKSxcbiAgICAgICAgICBqdWwgPSBuZXcgRGF0ZShzZWxmLmdldEZ1bGxZZWFyKCksIDYsIDEpO1xuICAgICAgcmV0dXJuIHNlbGYuZ2V0VGltZXpvbmVPZmZzZXQoKSA8IE1hdGgubWF4KGphbi5nZXRUaW1lem9uZU9mZnNldCgpLCBqdWwuZ2V0VGltZXpvbmVPZmZzZXQoKSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgY29weSA9IGBuZXcgRGF0ZShzZWxmLmdldFRpbWUoKSlgXG5cbiAgICBjb3B5LmNvcHlfaW5zdGFuY2VfdmFyaWFibGVzKHNlbGYpXG4gICAgY29weS5pbml0aWFsaXplX2R1cChzZWxmKVxuXG4gICAgY29weVxuICBlbmRcblxuICBkZWYgZXFsPyhvdGhlcilcbiAgICBvdGhlci5pc19hPyg6OlRpbWUpICYmIChzZWxmIDw9PiBvdGhlcikuemVybz9cbiAgZW5kXG5cbiAgW1xuICAgIFs6c3VuZGF5PywgMF0sXG4gICAgWzptb25kYXk/LCAxXSxcbiAgICBbOnR1ZXNkYXk/LCAyXSxcbiAgICBbOndlZG5lc2RheT8sIDNdLFxuICAgIFs6dGh1cnNkYXk/LCA0XSxcbiAgICBbOmZyaWRheT8sIDVdLFxuICAgIFs6c2F0dXJkYXk/LCA2XVxuICBdLmVhY2ggZG8gfG1ldGhvZCwgd2Vla2RheXxcbiAgICBkZWZpbmVfbWV0aG9kIG1ldGhvZCBkb1xuICAgICAgYCN7d2RheX0gPT09IHdlZWtkYXlgXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgWzo6VGltZSwgYHNlbGYuZ2V0VGltZSgpYF0uaGFzaFxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIGlmIHV0Yz9cbiAgICAgIHN0cmZ0aW1lICclWS0lbS0lZCAlSDolTTolUyBVVEMnXG4gICAgZWxzZVxuICAgICAgc3RyZnRpbWUgJyVZLSVtLSVkICVIOiVNOiVTICV6J1xuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc3VjY1xuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBEYXRlKHNlbGYuZ2V0VGltZSgpICsgMTAwMCk7XG4gICAgICByZXN1bHQudGltZXpvbmUgPSBzZWxmLnRpbWV6b25lO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB1c2VjXG4gICAgYHNlbGYuZ2V0TWlsbGlzZWNvbmRzKCkgKiAxMDAwYFxuICBlbmRcblxuICBkZWYgem9uZVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYudGltZXpvbmUgPT09IDApIHJldHVybiBcIlVUQ1wiO1xuICAgICAgZWxzZSBpZiAoc2VsZi50aW1lem9uZSAhPSBudWxsKSByZXR1cm4gbmlsO1xuXG4gICAgICB2YXIgc3RyaW5nID0gc2VsZi50b1N0cmluZygpLFxuICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgaWYgKHN0cmluZy5pbmRleE9mKCcoJykgPT0gLTEpIHtcbiAgICAgICAgcmVzdWx0ID0gc3RyaW5nLm1hdGNoKC9bQS1aXXszLDR9LylbMF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gc3RyaW5nLm1hdGNoKC9cXCgoLispXFwpKD86XFxzfCQpLylbMV1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdCA9PSBcIkdNVFwiICYmIC8oR01UXFxXKlxcZHs0fSkvLnRlc3Qoc3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gUmVnRXhwLiQxO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgZ2V0Z21cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgRGF0ZShzZWxmLmdldFRpbWUoKSk7XG4gICAgICByZXN1bHQudGltZXpvbmUgPSAwO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBnbXRpbWVcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLnRpbWV6b25lICE9PSAwKSB7XG4gICAgICAgICRkZW55X2Zyb3plbl9hY2Nlc3Moc2VsZik7XG4gICAgICAgIHNlbGYudGltZXpvbmUgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZ210P1xuICAgIGBzZWxmLnRpbWV6b25lID09PSAwYFxuICBlbmRcblxuICBkZWYgZ210X29mZnNldFxuICAgIGAoc2VsZi50aW1lem9uZSAhPSBudWxsKSA/IHNlbGYudGltZXpvbmUgKiA2MCA6IC1zZWxmLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MGBcbiAgZW5kXG5cbiAgZGVmIHN0cmZ0aW1lKGZvcm1hdClcbiAgICAleHtcbiAgICAgIHJldHVybiBmb3JtYXQucmVwbGFjZSgvJShbXFwtXyNeMF0qOnswLDJ9KShcXGQrKT8oW0VPXSopKC4pL2csIGZ1bmN0aW9uKGZ1bGwsIGZsYWdzLCB3aWR0aCwgXywgY29udikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIiwgamQsIGMsIHMsXG4gICAgICAgICAgICB6ZXJvICAgPSBmbGFncy5pbmRleE9mKCcwJykgIT09IC0xLFxuICAgICAgICAgICAgcGFkICAgID0gZmxhZ3MuaW5kZXhPZignLScpID09PSAtMSxcbiAgICAgICAgICAgIGJsYW5rICA9IGZsYWdzLmluZGV4T2YoJ18nKSAhPT0gLTEsXG4gICAgICAgICAgICB1cGNhc2UgPSBmbGFncy5pbmRleE9mKCdeJykgIT09IC0xLFxuICAgICAgICAgICAgaW52ZXJ0ID0gZmxhZ3MuaW5kZXhPZignIycpICE9PSAtMSxcbiAgICAgICAgICAgIGNvbG9ucyA9IChmbGFncy5tYXRjaCgnOicpIHx8IFtdKS5sZW5ndGg7XG5cbiAgICAgICAgd2lkdGggPSBwYXJzZUludCh3aWR0aCwgMTApO1xuXG4gICAgICAgIGlmICh6ZXJvICYmIGJsYW5rKSB7XG4gICAgICAgICAgaWYgKGZsYWdzLmluZGV4T2YoJzAnKSA8IGZsYWdzLmluZGV4T2YoJ18nKSkge1xuICAgICAgICAgICAgemVybyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJsYW5rID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChjb252KSB7XG4gICAgICAgICAgY2FzZSAnWSc6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3t5ZWFyfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgcmVzdWx0ICs9IE1hdGgucm91bmQoI3t5ZWFyfSAvIDEwMCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3knOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHJlc3VsdCArPSAoI3t5ZWFyfSAlIDEwMCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHJlc3VsdCArPSAje21vbn07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0InOlxuICAgICAgICAgICAgcmVzdWx0ICs9IGxvbmdfbW9udGhzWyN7bW9ufSAtIDFdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgIGJsYW5rICAgPSAhemVybztcbiAgICAgICAgICAgIHJlc3VsdCArPSBzaG9ydF9tb250aHNbI3ttb259IC0gMV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFua1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7ZGF5fTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICBibGFuayAgID0gIXplcm9cbiAgICAgICAgICAgIHJlc3VsdCArPSAje2RheX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2onOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHdpZHRoICAgPSBpc05hTih3aWR0aCkgPyAzIDogd2lkdGg7XG4gICAgICAgICAgICByZXN1bHQgKz0gI3t5ZGF5fTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7aG91cn07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2snOlxuICAgICAgICAgICAgYmxhbmsgICA9ICF6ZXJvO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7aG91cn07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0knOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHJlc3VsdCArPSAoI3tob3VyfSAlIDEyIHx8IDEyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICBibGFuayAgID0gIXplcm87XG4gICAgICAgICAgICByZXN1bHQgKz0gKCN7aG91cn0gJSAxMiB8fCAxMik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1AnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICgje2hvdXJ9ID49IDEyID8gXCJwbVwiIDogXCJhbVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICByZXN1bHQgKz0gKCN7aG91cn0gPj0gMTIgPyBcIlBNXCIgOiBcIkFNXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XG4gICAgICAgICAgICByZXN1bHQgKz0gI3ttaW59O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzZWN9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHdpZHRoICAgPSBpc05hTih3aWR0aCkgPyAzIDogd2lkdGg7XG4gICAgICAgICAgICByZXN1bHQgKz0gc2VsZi5nZXRNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnTic6XG4gICAgICAgICAgICB3aWR0aCAgID0gaXNOYU4od2lkdGgpID8gOSA6IHdpZHRoO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7YHNlbGYuZ2V0TWlsbGlzZWNvbmRzKCkudG9TdHJpbmcoKWAucmp1c3QoMywgJzAnKX07XG4gICAgICAgICAgICByZXN1bHQgID0gI3tgcmVzdWx0YC5sanVzdChgd2lkdGhgLCAnMCcpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ICA9IChzZWxmLnRpbWV6b25lID09IG51bGwpID8gc2VsZi5nZXRUaW1lem9uZU9mZnNldCgpIDogKC1zZWxmLnRpbWV6b25lICogNjApLFxuICAgICAgICAgICAgICAgIGhvdXJzICAgPSBNYXRoLmZsb29yKE1hdGguYWJzKG9mZnNldCkgLyA2MCksXG4gICAgICAgICAgICAgICAgbWludXRlcyA9IE1hdGguYWJzKG9mZnNldCkgJSA2MDtcblxuICAgICAgICAgICAgcmVzdWx0ICs9IG9mZnNldCA8IDAgPyBcIitcIiA6IFwiLVwiO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGhvdXJzIDwgMTAgPyBcIjBcIiA6IFwiXCI7XG4gICAgICAgICAgICByZXN1bHQgKz0gaG91cnM7XG5cbiAgICAgICAgICAgIGlmIChjb2xvbnMgPiAwKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSBcIjpcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ICs9IG1pbnV0ZXMgPCAxMCA/IFwiMFwiIDogXCJcIjtcbiAgICAgICAgICAgIHJlc3VsdCArPSBtaW51dGVzO1xuXG4gICAgICAgICAgICBpZiAoY29sb25zID4gMSkge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gXCI6MDBcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3pvbmV9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSBkYXlzX29mX3dlZWtbI3t3ZGF5fV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgcmVzdWx0ICs9IHNob3J0X2RheXNbI3t3ZGF5fV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICgje3dkYXl9ICsgMSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3cnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7d2RheX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1YnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7Y3dlZWtfY3llYXJbMF0udG9fcy5yanVzdCgyLCAnMCcpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnRyc6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tjd2Vla19jeWVhclsxXX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2cnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7Y3dlZWtfY3llYXJbMV1bLTIuLi0xXX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7dG9faX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxuXCI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFx0XCI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgcmVzdWx0ICs9IFwiJVwiO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclYSAlYiAlZSAlVCAlWScpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnRCc6XG4gICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJW0vJWQvJXknKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0YnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVZLSVtLSVkJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd2JzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclZS0lXmItJTRZJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclSTolTTolUyAlcCcpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnUic6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJUg6JU0nKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgIGNhc2UgJ1gnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVIOiVNOiVTJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBOb24tc3RhbmRhcmQ6IEpJUyBYIDAzMDEgZGF0ZSBmb3JtYXRcbiAgICAgICAgICBjYXNlICdKJzpcbiAgICAgICAgICAgIGpkID0gI3t0b19kYXRlLmpkfTtcbiAgICAgICAgICAgIGlmIChqZCA8IDI0MDUxNjApIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVZLSVtLSVkJyl9O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGpkIDwgMjQxOTYxNClcbiAgICAgICAgICAgICAgYyA9ICdNJywgcyA9IDE4Njc7XG4gICAgICAgICAgICBlbHNlIGlmIChqZCA8IDI0MjQ4NzUpXG4gICAgICAgICAgICAgIGMgPSAnVCcsIHMgPSAxOTExO1xuICAgICAgICAgICAgZWxzZSBpZiAoamQgPCAyNDQ3NTM1KVxuICAgICAgICAgICAgICBjID0gJ1MnLCBzID0gMTkyNTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGpkIDwgMjQ1ODYwNSlcbiAgICAgICAgICAgICAgYyA9ICdIJywgcyA9IDE5ODg7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGMgPSAnUicsIHMgPSAyMDE4O1xuXG4gICAgICAgICAgICByZXN1bHQgKz0gI3tmb3JtYXQgJyVjJTAyZCcsIGBjYCwgeWVhciAtIGBzYH07XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnLSVtLSVkJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZ1bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXBjYXNlKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW52ZXJ0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL1tBLVpdLywgZnVuY3Rpb24oYykgeyBjLnRvTG93ZXJDYXNlKCkgfSkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2UoL1thLXpdLywgZnVuY3Rpb24oYykgeyBjLnRvVXBwZXJDYXNlKCkgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFkICYmICh6ZXJvIHx8IGJsYW5rKSkge1xuICAgICAgICAgIHJlc3VsdCA9ICN7YHJlc3VsdGAucmp1c3QoYGlzTmFOKHdpZHRoKSA/IDIgOiB3aWR0aGAsIGBibGFuayA/IFwiIFwiIDogXCIwXCJgKX07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9fYVxuICAgIFtzZWMsIG1pbiwgaG91ciwgZGF5LCBtb250aCwgeWVhciwgd2RheSwgeWRheSwgaXNkc3QsIHpvbmVdXG4gIGVuZFxuXG4gIGRlZiB0b19mXG4gICAgYHNlbGYuZ2V0VGltZSgpIC8gMTAwMGBcbiAgZW5kXG5cbiAgZGVmIHRvX2lcbiAgICBgcGFyc2VJbnQoc2VsZi5nZXRUaW1lKCkgLyAxMDAwLCAxMClgXG4gIGVuZFxuXG4gIGRlZiBjd2Vla19jeWVhclxuICAgIGphbjAxID0gOjpUaW1lLm5ldyh5ZWFyLCAxLCAxKVxuICAgIGphbjAxX3dkYXkgPSBqYW4wMS53ZGF5XG4gICAgZmlyc3RfbW9uZGF5ID0gMFxuICAgIHllYXIgPSBzZWxmLnllYXJcbiAgICBpZiBqYW4wMV93ZGF5IDw9IDQgJiYgamFuMDFfd2RheSAhPSAwXG4gICAgICAjIEphbiAwMSBpcyBpbiB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhclxuICAgICAgb2Zmc2V0ID0gamFuMDFfd2RheSAtIDFcbiAgICBlbHNlXG4gICAgICAjIEphbiAwMSBpcyBpbiB0aGUgbGFzdCB3ZWVrIG9mIHRoZSBwcmV2aW91cyB5ZWFyXG4gICAgICBvZmZzZXQgPSBqYW4wMV93ZGF5IC0gNyAtIDFcbiAgICAgIG9mZnNldCA9IC0xIGlmIG9mZnNldCA9PSAtOCAjIEFkanVzdCBpZiBKYW4gMDEgaXMgYSBTdW5kYXlcbiAgICBlbmRcblxuICAgIHdlZWsgPSAoKHlkYXkgKyBvZmZzZXQpIC8gNy4wMCkuY2VpbFxuXG4gICAgaWYgd2VlayA8PSAwXG4gICAgICAjIEdldCB0aGUgbGFzdCB3ZWVrIG9mIHRoZSBwcmV2aW91cyB5ZWFyXG4gICAgICByZXR1cm4gOjpUaW1lLm5ldyhzZWxmLnllYXIgLSAxLCAxMiwgMzEpLmN3ZWVrX2N5ZWFyXG4gICAgZWxzaWYgd2VlayA9PSA1M1xuICAgICAgIyBGaW5kIG91dCB3aGV0aGVyIHRoaXMgaXMgYWN0dWFsbHkgd2VlayA1MyBvciBhbHJlYWR5IHdlZWsgMDEgb2YgdGhlIGZvbGxvd2luZyB5ZWFyXG4gICAgICBkZWMzMSA9IDo6VGltZS5uZXcoc2VsZi55ZWFyLCAxMiwgMzEpXG4gICAgICBkZWMzMV93ZGF5ID0gZGVjMzEud2RheVxuICAgICAgaWYgZGVjMzFfd2RheSA8PSAzICYmIGRlYzMxX3dkYXkgIT0gMFxuICAgICAgICB3ZWVrID0gMVxuICAgICAgICB5ZWFyICs9IDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgW3dlZWssIHllYXJdXG4gIGVuZFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBhbGlhcyBta3RpbWUgbG9jYWxcbiAgICBhbGlhcyB1dGMgZ21cbiAgZW5kXG5cbiAgYWxpYXMgY3RpbWUgYXNjdGltZVxuICBhbGlhcyBkc3Q/IGlzZHN0XG4gIGFsaWFzIGdldHV0YyBnZXRnbVxuICBhbGlhcyBnbXRvZmYgZ210X29mZnNldFxuICBhbGlhcyBtZGF5IGRheVxuICBhbGlhcyBtb250aCBtb25cbiAgYWxpYXMgdG9fcyBpbnNwZWN0XG4gIGFsaWFzIHR2X3NlYyB0b19pXG4gIGFsaWFzIHR2X3VzZWMgdXNlY1xuICBhbGlhcyB1dGMgZ210aW1lXG4gIGFsaWFzIHV0Yz8gZ210P1xuICBhbGlhcyB1dGNfb2Zmc2V0IGdtdF9vZmZzZXRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpUaW1lPiIsImluY2x1ZGUiLCJDb21wYXJhYmxlIiwiYXQiLCJzZWNvbmRzIiwiZnJhYyIsIlRpbWUiLCI9PT0iLCJLZXJuZWwiLCJyYWlzZSIsIlR5cGVFcnJvciIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiSW50ZWdlciIsInJlc3BvbmRfdG8/IiwidG9fc3RyIiwidG9faSIsIkFyZ3VtZW50RXJyb3IiLCJuZXciLCJ5ZWFyIiwibW9udGgiLCJkYXkiLCJob3VyIiwibWluIiwic2VjIiwidXRjX29mZnNldCIsIl9wYXJzZV9vZmZzZXQiLCJsb2NhbCIsIm1pbGxpc2Vjb25kIiwiX2R1bW15MSIsIl9kdW1teTIiLCJfZHVtbXkzIiwiZ20iLCJub3ciLCIrIiwib3RoZXIiLCItIiwiPD0+IiwidG9fZiIsInIiLCJuaWw/IiwiPiIsIjAiLCItMSIsIjwiLCIxIiwiPT0iLCIkcmV0X29yXzEiLCJhc2N0aW1lIiwic3RyZnRpbWUiLCJlYWNoIiwiYmxvY2sgaW4gPGNsYXNzOlRpbWU+IiwibWV0aG9kIiwiZ2V0dGVyIiwidXRjZ2V0dGVyIiwiZGlmZmVyZW5jZSIsImJsb2NrICgyIGxldmVscykgaW4gPGNsYXNzOlRpbWU+IiwiZGVmaW5lX21ldGhvZCIsImJsb2NrICgzIGxldmVscykgaW4gPGNsYXNzOlRpbWU+IiwieWRheSIsInN0YXJ0X29mX3llYXIiLCJzdGFydF9vZl9kYXkiLCJvbmVfZGF5IiwiODY0MDAiLCIvIiwicm91bmQiLCJpc2RzdCIsImR1cCIsImNvcHkiLCJjb3B5X2luc3RhbmNlX3ZhcmlhYmxlcyIsImluaXRpYWxpemVfZHVwIiwiZXFsPyIsImlzX2E/IiwiemVybz8iLCIyIiwiMyIsIjQiLCI1IiwiNiIsIndlZWtkYXkiLCJ3ZGF5IiwiaGFzaCIsImluc3BlY3QiLCJ1dGM/Iiwic3VjYyIsInVzZWMiLCJ6b25lIiwiZ2V0Z20iLCJnbXRpbWUiLCJnbXQ/IiwiZ210X29mZnNldCIsImZvcm1hdCIsIm1vbiIsInJqdXN0IiwibGp1c3QiLCJjd2Vla19jeWVhciIsIltdIiwidG9fcyIsIi0yIiwidG9fZGF0ZSIsImpkIiwidG9fYSIsImphbjAxIiwiamFuMDFfd2RheSIsImZpcnN0X21vbmRheSIsIjw9Iiwib2Zmc2V0IiwiNyIsIi04Iiwid2VlayIsImNlaWwiLCIxMiIsIjMxIiwiNTMiLCJkZWMzMSIsImRlYzMxX3dkYXkiXSwibWFwcGluZ3MiOiJBQUFBQSwrQkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFHQUMsSUFBQUMsU0FBQUEsQ0FBUUYsb0JBQVJFO0VBRUFGLE9BQUFHO0VBQUFBOztJQUFBQTs7O0lBQ0VGLElBQUFHLFNBQUFBLENBQVFDLGlCQUFSRDs7QUFHRkQsdUJBQXlCLENBQUdBLFFBQUgsRUFBVUEsUUFBVixFQUFpQkEsU0FBakIsRUFBeUJBLFdBQXpCLEVBQW1DQSxVQUFuQyxFQUE0Q0EsUUFBNUMsRUFBbURBLFVBQW5ELEVBQTREQSxRQUE1RCxDQUFvRUE7QUFDN0ZBLHVCQUF5QixDQUFHQSxLQUFILEVBQU9BLEtBQVAsRUFBV0EsS0FBWCxFQUFlQSxLQUFmLEVBQW1CQSxLQUFuQixFQUF1QkEsS0FBdkIsRUFBMkJBLEtBQTNCLENBQWdDQTtBQUN6REEsdUJBQXlCLENBQUdBLEtBQUgsRUFBT0EsS0FBUCxFQUFXQSxLQUFYLEVBQWVBLEtBQWYsRUFBbUJBLEtBQW5CLEVBQXVCQSxLQUF2QixFQUEyQkEsS0FBM0IsRUFBK0JBLEtBQS9CLEVBQW1DQSxLQUFuQyxFQUF1Q0EsS0FBdkMsRUFBMkNBLEtBQTNDLEVBQStDQSxLQUEvQyxDQUFvREE7QUFDN0VBLHVCQUF5QixDQUFHQSxTQUFILEVBQVdBLFVBQVgsRUFBb0JBLE9BQXBCLEVBQTBCQSxPQUExQixFQUFnQ0EsS0FBaEMsRUFBb0NBLE1BQXBDLEVBQXlDQSxNQUF6QyxFQUE4Q0EsUUFBOUMsRUFBcURBLFdBQXJELEVBQStEQSxTQUEvRCxFQUF1RUEsVUFBdkUsRUFBZ0ZBLFVBQWhGLENBQTBGQTtBQUNuSEE7SUFFRUcsTUFBSUwsSUFBSkssU0FBQUEsY0FBWUMsT0FBRCxFQUFVQyxJQUFyQkY7QUFBQUE7Ozs7QUFFRkE7O0FBRUFBLFVBQVlHLFdBQU9DLFFBQUFBLENBQUlILE9BQUpHLENBQVlK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WDtJQUNBLGFBQU0sT0FBTixFQUFZLEtBQVo7SUFDQSxhQUFNLE1BQU4sRUFBVyxTQUFYO0lBQ0EsYUFBTSxRQUFOLEVBQWEsTUFBYjtJQUNBLGFBQU0sU0FBTixFQUFjLE1BQWQ7SUFDQSxhQUFNLEtBQU4sRUFBVSxRQUFWO0lBQ0EsYUFBTSxNQUFOLEVBQVcsTUFBWDtJQUNBRSxPQUFBLGFBQU0sWUFBTixFQUFpQixZQUFqQjtFQTd3QkZBLEdBQU0sSUFBTkEsRUFBZ0JILElBQWhCRztBQUxBSDsifX0seyJvZmZzZXQiOnsibGluZSI6MjI5NzEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3N0cnVjdC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcblxucmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhYmxlJ1xuXG5jbGFzcyA6OlN0cnVjdFxuICBpbmNsdWRlIDo6RW51bWVyYWJsZVxuXG4gIGRlZiBzZWxmLm5ldyhjb25zdF9uYW1lLCAqYXJncywga2V5d29yZF9pbml0OiBmYWxzZSwgJmJsb2NrKVxuICAgIGlmIGNvbnN0X25hbWVcbiAgICAgIGlmIGNvbnN0X25hbWUuY2xhc3MgPT0gOjpTdHJpbmcgJiYgY29uc3RfbmFtZVswXS51cGNhc2UgIT0gY29uc3RfbmFtZVswXVxuICAgICAgICAjIEZhc3QgdHJhY2sgc28gdGhhdCB3ZSBza2lwIG5lZWRsZXNzbHkgZ29pbmcgdGhydSBleGNlcHRpb25zXG4gICAgICAgICMgaW4gbW9zdCBjYXNlcy5cbiAgICAgICAgYXJncy51bnNoaWZ0KGNvbnN0X25hbWUpXG4gICAgICAgIGNvbnN0X25hbWUgPSBuaWxcbiAgICAgIGVsc2VcbiAgICAgICAgYmVnaW5cbiAgICAgICAgICBjb25zdF9uYW1lID0gOjpPcGFsLmNvbnN0X25hbWUhKGNvbnN0X25hbWUpXG4gICAgICAgIHJlc2N1ZSA6OlR5cGVFcnJvciwgOjpOYW1lRXJyb3JcbiAgICAgICAgICBhcmdzLnVuc2hpZnQoY29uc3RfbmFtZSlcbiAgICAgICAgICBjb25zdF9uYW1lID0gbmlsXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBhcmdzLm1hcCBkbyB8YXJnfFxuICAgICAgOjpPcGFsLmNvZXJjZV90byEoYXJnLCA6OlN0cmluZywgOnRvX3N0cilcbiAgICBlbmRcblxuICAgIGtsYXNzID0gOjpDbGFzcy5uZXcoc2VsZikgZG9cbiAgICAgIGFyZ3MuZWFjaCB7IHxhcmd8IGRlZmluZV9zdHJ1Y3RfYXR0cmlidXRlKGFyZykgfVxuXG4gICAgICBjbGFzcyA8PCBzZWxmXG4gICAgICAgIGRlZiBuZXcoKmFyZ3MpXG4gICAgICAgICAgaW5zdGFuY2UgPSBhbGxvY2F0ZVxuICAgICAgICAgIGAje2luc3RhbmNlfS4kJGRhdGEgPSB7fWBcbiAgICAgICAgICBpbnN0YW5jZS5pbml0aWFsaXplKCphcmdzKVxuICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgIGVuZFxuXG4gICAgICAgIGFsaWFzX21ldGhvZCA6W10sIDpuZXdcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAga2xhc3MubW9kdWxlX2V2YWwoJmJsb2NrKSBpZiBibG9ja1xuICAgIGBrbGFzcy4kJGtleXdvcmRfaW5pdCA9IGtleXdvcmRfaW5pdGBcblxuICAgIGlmIGNvbnN0X25hbWVcbiAgICAgIDo6U3RydWN0LmNvbnN0X3NldChjb25zdF9uYW1lLCBrbGFzcylcbiAgICBlbmRcblxuICAgIGtsYXNzXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmRlZmluZV9zdHJ1Y3RfYXR0cmlidXRlKG5hbWUpXG4gICAgaWYgc2VsZiA9PSA6OlN0cnVjdFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAneW91IGNhbm5vdCBkZWZpbmUgYXR0cmlidXRlcyB0byB0aGUgU3RydWN0IGNsYXNzJ1xuICAgIGVuZFxuXG4gICAgbWVtYmVycyA8PCBuYW1lXG5cbiAgICBkZWZpbmVfbWV0aG9kIG5hbWUgZG9cbiAgICAgIGBzZWxmLiQkZGF0YVtuYW1lXWBcbiAgICBlbmRcblxuICAgIGRlZmluZV9tZXRob2QgXCIje25hbWV9PVwiIGRvIHx2YWx1ZXxcbiAgICAgIGBzZWxmLiQkZGF0YVtuYW1lXSA9IHZhbHVlYFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2VsZi5tZW1iZXJzXG4gICAgaWYgc2VsZiA9PSA6OlN0cnVjdFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAndGhlIFN0cnVjdCBjbGFzcyBoYXMgbm8gbWVtYmVycydcbiAgICBlbmRcblxuICAgIEBtZW1iZXJzIHx8PSBbXVxuICBlbmRcblxuICBkZWYgc2VsZi5pbmhlcml0ZWQoa2xhc3MpXG4gICAgbWVtYmVycyA9IEBtZW1iZXJzXG5cbiAgICBrbGFzcy5pbnN0YW5jZV9ldmFsIGRvXG4gICAgICBAbWVtYmVycyA9IG1lbWJlcnNcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoKmFyZ3MpXG4gICAgaWYgYCN7c2VsZi5jbGFzc30uJCRrZXl3b3JkX2luaXRgXG4gICAgICBrd2FyZ3MgPSBhcmdzLmxhc3QgfHwge31cblxuICAgICAgaWYgYXJncy5sZW5ndGggPiAxIHx8IGAoYXJncy5sZW5ndGggPT09IDEgJiYgIWt3YXJncy4kJGlzX2hhc2gpYFxuICAgICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoZ2l2ZW4gI3thcmdzLmxlbmd0aH0sIGV4cGVjdGVkIDApXCJcbiAgICAgIGVuZFxuXG4gICAgICBleHRyYSA9IGt3YXJncy5rZXlzIC0gc2VsZi5jbGFzcy5tZW1iZXJzXG4gICAgICBpZiBleHRyYS5hbnk/XG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ1bmtub3duIGtleXdvcmRzOiAje2V4dHJhLmpvaW4oJywgJyl9XCJcbiAgICAgIGVuZFxuXG4gICAgICBzZWxmLmNsYXNzLm1lbWJlcnMuZWFjaCBkbyB8bmFtZXxcbiAgICAgICAgc2VsZltuYW1lXSA9IGt3YXJnc1tuYW1lXVxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgaWYgYXJncy5sZW5ndGggPiBzZWxmLmNsYXNzLm1lbWJlcnMubGVuZ3RoXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3N0cnVjdCBzaXplIGRpZmZlcnMnXG4gICAgICBlbmRcblxuICAgICAgc2VsZi5jbGFzcy5tZW1iZXJzLmVhY2hfd2l0aF9pbmRleCBkbyB8bmFtZSwgaW5kZXh8XG4gICAgICAgIHNlbGZbbmFtZV0gPSBhcmdzW2luZGV4XVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2NvcHkoZnJvbSlcbiAgICAleHtcbiAgICAgIHNlbGYuJCRkYXRhID0ge31cbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJvbS4kJGRhdGEpLCBpLCBtYXgsIG5hbWU7XG4gICAgICBmb3IgKGkgPSAwLCBtYXggPSBrZXlzLmxlbmd0aDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgIG5hbWUgPSBrZXlzW2ldO1xuICAgICAgICBzZWxmLiQkZGF0YVtuYW1lXSA9IGZyb20uJCRkYXRhW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYua2V5d29yZF9pbml0P1xuICAgIGBzZWxmLiQka2V5d29yZF9pbml0YFxuICBlbmRcblxuICBkZWYgbWVtYmVyc1xuICAgIHNlbGYuY2xhc3MubWVtYmVyc1xuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIFtzZWxmLmNsYXNzLCB0b19hXS5oYXNoXG4gIGVuZFxuXG4gIGRlZiBbXShuYW1lKVxuICAgIGlmIDo6SW50ZWdlciA9PT0gbmFtZVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpJbmRleEVycm9yLCBcIm9mZnNldCAje25hbWV9IHRvbyBzbWFsbCBmb3Igc3RydWN0KHNpemU6I3tzZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZX0pXCIgaWYgbmFtZSA8IC1zZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpJbmRleEVycm9yLCBcIm9mZnNldCAje25hbWV9IHRvbyBsYXJnZSBmb3Igc3RydWN0KHNpemU6I3tzZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZX0pXCIgaWYgbmFtZSA+PSBzZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZVxuXG4gICAgICBuYW1lID0gc2VsZi5jbGFzcy5tZW1iZXJzW25hbWVdXG4gICAgZWxzaWYgOjpTdHJpbmcgPT09IG5hbWVcbiAgICAgICV4e1xuICAgICAgICBpZighc2VsZi4kJGRhdGEuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLm5ldyhcIm5vIG1lbWJlciAnI3tuYW1lfScgaW4gc3RydWN0XCIsIG5hbWUpfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwibm8gaW1wbGljaXQgY29udmVyc2lvbiBvZiAje25hbWUuY2xhc3N9IGludG8gSW50ZWdlclwiXG4gICAgZW5kXG5cbiAgICBuYW1lID0gOjpPcGFsLmNvZXJjZV90byEobmFtZSwgOjpTdHJpbmcsIDp0b19zdHIpXG4gICAgYHNlbGYuJCRkYXRhW25hbWVdYFxuICBlbmRcblxuICBkZWYgW109KG5hbWUsIHZhbHVlKVxuICAgIGlmIDo6SW50ZWdlciA9PT0gbmFtZVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpJbmRleEVycm9yLCBcIm9mZnNldCAje25hbWV9IHRvbyBzbWFsbCBmb3Igc3RydWN0KHNpemU6I3tzZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZX0pXCIgaWYgbmFtZSA8IC1zZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpJbmRleEVycm9yLCBcIm9mZnNldCAje25hbWV9IHRvbyBsYXJnZSBmb3Igc3RydWN0KHNpemU6I3tzZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZX0pXCIgaWYgbmFtZSA+PSBzZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZVxuXG4gICAgICBuYW1lID0gc2VsZi5jbGFzcy5tZW1iZXJzW25hbWVdXG4gICAgZWxzaWYgOjpTdHJpbmcgPT09IG5hbWVcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6TmFtZUVycm9yLm5ldyhcIm5vIG1lbWJlciAnI3tuYW1lfScgaW4gc3RydWN0XCIsIG5hbWUpIHVubGVzcyBzZWxmLmNsYXNzLm1lbWJlcnMuaW5jbHVkZT8obmFtZS50b19zeW0pXG4gICAgZWxzZVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwibm8gaW1wbGljaXQgY29udmVyc2lvbiBvZiAje25hbWUuY2xhc3N9IGludG8gSW50ZWdlclwiXG4gICAgZW5kXG5cbiAgICBuYW1lID0gOjpPcGFsLmNvZXJjZV90byEobmFtZSwgOjpTdHJpbmcsIDp0b19zdHIpXG4gICAgYHNlbGYuJCRkYXRhW25hbWVdID0gdmFsdWVgXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIG90aGVyLmluc3RhbmNlX29mPyhzZWxmLmNsYXNzKVxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVjdXJzZWQxID0ge30sIHJlY3Vyc2VkMiA9IHt9O1xuXG4gICAgICBmdW5jdGlvbiBfZXFlcShzdHJ1Y3QsIG90aGVyKSB7XG4gICAgICAgIHZhciBrZXksIGEsIGI7XG5cbiAgICAgICAgcmVjdXJzZWQxWyN7YHN0cnVjdGAuX19pZF9ffV0gPSB0cnVlO1xuICAgICAgICByZWN1cnNlZDJbI3tgb3RoZXJgLl9faWRfX31dID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGtleSBpbiBzdHJ1Y3QuJCRkYXRhKSB7XG4gICAgICAgICAgYSA9IHN0cnVjdC4kJGRhdGFba2V5XTtcbiAgICAgICAgICBiID0gb3RoZXIuJCRkYXRhW2tleV07XG5cbiAgICAgICAgICBpZiAoI3s6OlN0cnVjdCA9PT0gYGFgfSkge1xuICAgICAgICAgICAgaWYgKCFyZWN1cnNlZDEuaGFzT3duUHJvcGVydHkoI3tgYWAuX19pZF9ffSkgfHwgIXJlY3Vyc2VkMi5oYXNPd25Qcm9wZXJ0eSgje2BiYC5fX2lkX199KSkge1xuICAgICAgICAgICAgICBpZiAoIV9lcWVxKGEsIGIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghI3tgYWAgPT0gYGJgfSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXFlcShzZWxmLCBvdGhlcik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZXFsPyhvdGhlcilcbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIG90aGVyLmluc3RhbmNlX29mPyhzZWxmLmNsYXNzKVxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVjdXJzZWQxID0ge30sIHJlY3Vyc2VkMiA9IHt9O1xuXG4gICAgICBmdW5jdGlvbiBfZXFlcShzdHJ1Y3QsIG90aGVyKSB7XG4gICAgICAgIHZhciBrZXksIGEsIGI7XG5cbiAgICAgICAgcmVjdXJzZWQxWyN7YHN0cnVjdGAuX19pZF9ffV0gPSB0cnVlO1xuICAgICAgICByZWN1cnNlZDJbI3tgb3RoZXJgLl9faWRfX31dID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGtleSBpbiBzdHJ1Y3QuJCRkYXRhKSB7XG4gICAgICAgICAgYSA9IHN0cnVjdC4kJGRhdGFba2V5XTtcbiAgICAgICAgICBiID0gb3RoZXIuJCRkYXRhW2tleV07XG5cbiAgICAgICAgICBpZiAoI3s6OlN0cnVjdCA9PT0gYGFgfSkge1xuICAgICAgICAgICAgaWYgKCFyZWN1cnNlZDEuaGFzT3duUHJvcGVydHkoI3tgYWAuX19pZF9ffSkgfHwgIXJlY3Vyc2VkMi5oYXNPd25Qcm9wZXJ0eSgje2BiYC5fX2lkX199KSkge1xuICAgICAgICAgICAgICBpZiAoIV9lcWVxKGEsIGIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghI3tgYWAuZXFsPyhgYmApfSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXFlcShzZWxmLCBvdGhlcik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaFxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgc2VsZi5jbGFzcy5tZW1iZXJzLmVhY2ggeyB8bmFtZXwgeWllbGQgc2VsZltuYW1lXSB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZWFjaF9wYWlyXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3BhaXIpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHNlbGYuY2xhc3MubWVtYmVycy5lYWNoIHsgfG5hbWV8IHlpZWxkIFtuYW1lLCBzZWxmW25hbWVdXSB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgbGVuZ3RoXG4gICAgc2VsZi5jbGFzcy5tZW1iZXJzLmxlbmd0aFxuICBlbmRcblxuICBkZWYgdG9fYVxuICAgIHNlbGYuY2xhc3MubWVtYmVycy5tYXAgeyB8bmFtZXwgc2VsZltuYW1lXSB9XG4gIGVuZFxuXG4gIGB2YXIgaW5zcGVjdF9zdGFjayA9IFtdYFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgcmVzdWx0ID0gJyM8c3RydWN0ICdcblxuICAgIGlmIGBpbnNwZWN0X3N0YWNrYC5pbmNsdWRlPyBfX2lkX19cbiAgICAgIHJlc3VsdCArICc6Li4uPidcbiAgICBlbHNlXG4gICAgICBgaW5zcGVjdF9zdGFja2AgPDwgX19pZF9fXG4gICAgICBwdXNoZWQgPSB0cnVlXG5cbiAgICAgIGlmIDo6U3RydWN0ID09PSBzZWxmICYmIHNlbGYuY2xhc3MubmFtZVxuICAgICAgICByZXN1bHQgKz0gXCIje3NlbGYuY2xhc3N9IFwiXG4gICAgICBlbmRcblxuICAgICAgcmVzdWx0ICs9IGVhY2hfcGFpci5tYXAgZG8gfG5hbWUsIHZhbHVlfFxuICAgICAgICBcIiN7bmFtZX09I3tPcGFsLmluc3BlY3QodmFsdWUpfVwiXG4gICAgICBlbmQuam9pbiAnLCAnXG5cbiAgICAgIHJlc3VsdCArPSAnPidcblxuICAgICAgcmVzdWx0XG4gICAgZW5kXG4gIGVuc3VyZVxuICAgIGBpbnNwZWN0X3N0YWNrLnBvcCgpYCBpZiBwdXNoZWRcbiAgZW5kXG5cbiAgZGVmIHRvX2goKmFyZ3MsICZibG9jaylcbiAgICByZXR1cm4gbWFwKCZibG9jaykudG9faCgqYXJncykgaWYgYmxvY2tfZ2l2ZW4/XG5cbiAgICBzZWxmLmNsYXNzLm1lbWJlcnMuZWFjaF93aXRoX29iamVjdCh7fSkgeyB8bmFtZSwgaHwgaFtuYW1lXSA9IHNlbGZbbmFtZV0gfVxuICBlbmRcblxuICBkZWYgdmFsdWVzX2F0KCphcmdzKVxuICAgIGFyZ3MgPSBhcmdzLm1hcCB7IHxhcmd8IGBhcmcuJCRpc19yYW5nZSA/ICN7YXJnLnRvX2F9IDogYXJnYCB9LmZsYXR0ZW5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICghYXJnc1tpXS4kJGlzX251bWJlcikge1xuICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpUeXBlRXJyb3IsIFwibm8gaW1wbGljaXQgY29udmVyc2lvbiBvZiAje2BhcmdzW2ldYC5jbGFzc30gaW50byBJbnRlZ2VyXCJ9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goI3tzZWxmW2BhcmdzW2ldYF19KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGlnKGtleSwgKmtleXMpXG4gICAgaXRlbSA9IGlmIGBrZXkuJCRpc19zdHJpbmcgJiYgc2VsZi4kJGRhdGEuaGFzT3duUHJvcGVydHkoa2V5KWBcbiAgICAgICAgICAgICBgc2VsZi4kJGRhdGFba2V5XSB8fCBuaWxgXG4gICAgICAgICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoaXRlbSA9PT0gbmlsIHx8IGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfVxuICAgIH1cblxuICAgIHVubGVzcyBpdGVtLnJlc3BvbmRfdG8/KDpkaWcpXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OlR5cGVFcnJvciwgXCIje2l0ZW0uY2xhc3N9IGRvZXMgbm90IGhhdmUgI2RpZyBtZXRob2RcIlxuICAgIGVuZFxuXG4gICAgaXRlbS5kaWcoKmtleXMpXG4gIGVuZFxuXG4gIGFsaWFzIHNpemUgbGVuZ3RoXG4gIGFsaWFzIHRvX3MgaW5zcGVjdFxuICBhbGlhcyB2YWx1ZXMgdG9fYVxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOlN0cnVjdD4iLCJpbmNsdWRlIiwiRW51bWVyYWJsZSIsIm5ldyIsImNvbnN0X25hbWUiLCJjbGFzcyIsIlN0cmluZyIsIltdIiwiMCIsInVwY2FzZSIsImFyZ3MiLCJ1bnNoaWZ0IiwiT3BhbCIsImNvbnN0X25hbWUhIiwiVHlwZUVycm9yIiwiTmFtZUVycm9yIiwibWFwIiwiYmxvY2sgaW4gbmV3IiwiYXJnIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBuZXciLCJjb2VyY2VfdG8hIiwia2xhc3MiLCJDbGFzcyIsImVhY2giLCJibG9jayAoMyBsZXZlbHMpIGluIG5ldyIsImRlZmluZV9zdHJ1Y3RfYXR0cmlidXRlIiwiaW5zdGFuY2UiLCJhbGxvY2F0ZSIsImluaXRpYWxpemUiLCJhbGlhc19tZXRob2QiLCJibG9jayIsIm1vZHVsZV9ldmFsIiwidG9fcHJvYyIsIlN0cnVjdCIsImNvbnN0X3NldCIsIm5hbWUiLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJtZW1iZXJzIiwiPDwiLCJkZWZpbmVfbWV0aG9kIiwiYmxvY2sgaW4gZGVmaW5lX3N0cnVjdF9hdHRyaWJ1dGUiLCJibG9jayAoMiBsZXZlbHMpIGluIGRlZmluZV9zdHJ1Y3RfYXR0cmlidXRlIiwidmFsdWUiLCJAbWVtYmVycyIsIiRyZXRfb3JfMSIsImluaGVyaXRlZCIsImluc3RhbmNlX2V2YWwiLCJibG9jayBpbiBpbmhlcml0ZWQiLCJibG9jayAoMiBsZXZlbHMpIGluIGluaGVyaXRlZCIsImt3YXJncyIsImxhc3QiLCI+IiwibGVuZ3RoIiwiMSIsImV4dHJhIiwiLSIsImtleXMiLCJhbnk/Iiwiam9pbiIsImJsb2NrIGluIGluaXRpYWxpemUiLCJibG9jayAoMiBsZXZlbHMpIGluIGluaXRpYWxpemUiLCJbXT0iLCJlYWNoX3dpdGhfaW5kZXgiLCJpbmRleCIsImluaXRpYWxpemVfY29weSIsImZyb20iLCJrZXl3b3JkX2luaXQ/IiwiaGFzaCIsInRvX2EiLCJJbnRlZ2VyIiwiPCIsInNpemUiLCItQCIsIkluZGV4RXJyb3IiLCI+PSIsImluY2x1ZGU/IiwidG9fc3ltIiwiPT0iLCJvdGhlciIsImluc3RhbmNlX29mPyIsIl9faWRfXyIsIj09PSIsImVxbD8iLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsImJsb2NrIGluIGVhY2giLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2giLCJlYWNoX3BhaXIiLCJibG9jayBpbiBlYWNoX3BhaXIiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfcGFpciIsImJsb2NrIGluIHRvX2EiLCJibG9jayAoMiBsZXZlbHMpIGluIHRvX2EiLCJpbnNwZWN0IiwicmVzdWx0IiwiKyIsInB1c2hlZCIsImJsb2NrIGluIGluc3BlY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIGluc3BlY3QiLCJ0b19oIiwiZWFjaF93aXRoX29iamVjdCIsImJsb2NrIGluIHRvX2giLCJoIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0b19oIiwidmFsdWVzX2F0IiwiYmxvY2sgaW4gdmFsdWVzX2F0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB2YWx1ZXNfYXQiLCJmbGF0dGVuIiwiZGlnIiwia2V5IiwiaXRlbSIsInJlc3BvbmRfdG8/Il0sIm1hcHBpbmdzIjoiQUFBQUEsaUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBRUFDLElBQUFDLFNBQUFBLENBQVFGLG9CQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7OztJQUNFRixJQUFBRyxTQUFBQSxDQUFRQyxpQkFBUkQ7SUFFQUUsTUFBSUwsSUFBSkssVUFBQUEsdUJBQWFDLFVBQUQsRUFQZCxFQU9jLEVBUGQsRUFPRUQ7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFQRjtNQUFBO01BQUE7TUFPMkI7O01BQU8sa0RBQUEseUNBQWM7TUFDNUMsSUFBQSxRQUFHQyxVQUFILENBQUE7UUFDRSxJQUFHLENBQUEsTUFBQUEsVUFBVUMsT0FBQUEsQ0FBQUEsQ0FBVixFQUFvQkMsYUFBcEIsQ0FBQSxJQUFBLENBQUEsT0FBZ0NGLFVBQVVHLE9BQUFBLENBQUNDLENBQURELENBQUdFLFFBQUFBLENBQUFBLENBQTdDLEVBQXdETCxVQUFVRyxPQUFBQSxDQUFDQyxDQUFERCxDQUFsRSxDQUFBLENBQUEsQ0FBSDs7VUFHRUcsSUFBSUMsU0FBQUEsQ0FBU1AsVUFBVE87VUFDSlAsYUFBYTtRQUpmOztVQU9JO1lBQUFBLGFBQWFRLEtBQU1DLGdCQUFBQSxDQUFhVCxVQUFiUztVQUFuQjtZQUNGLHNCQUFPLENBQUFDLGdCQUFBLEVBQWFDLGdCQUFiLENBQVA7Y0FBQTs7Z0JBQ0VMLElBQUlDLFNBQUFBLENBQVNQ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R0FBQSxDQUFHaUcsSUFBSTFHLE9BQUFBLENBQUFBLENBQVAsQ0FBQSxHQUFjd0csNEJBQWxDeEU7TUFEVjtNQUlBd0UsT0FBSUEsTUFBSkUsSUFBSUYsT0FBQUEsRUFBSyxNQUFDbkQsSUFBRCxDQUFMbUQ7SUFmTkEsQ0FBQUEsSUFBQUE7SUFrQkEsYUFBTSxNQUFOLEVBQVcsUUFBWDtJQUNBLGFBQU0sTUFBTixFQUFXLFNBQVg7SUFDQTdHLE9BQUEsYUFBTSxRQUFOLEVBQWEsTUFBYjtFQXhVRkEsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQUpBSDsifX0seyJvZmZzZXQiOnsibGluZSI6MjM0MzIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3NldC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IGZyZWV6ZVxuIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXG5cbiMgUG9ydGlvbnMgQ29weXJpZ2h0IChjKSAyMDAyLTIwMTMgQWtpbm9yaSBNVVNIQSA8a251QGlEYWVtb25zLm9yZz5cbmNsYXNzIDo6U2V0XG4gIGluY2x1ZGUgOjpFbnVtZXJhYmxlXG5cbiAgZGVmIHNlbGYuW10oKmFyeSlcbiAgICBuZXcoYXJ5KVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZShlbnVtID0gbmlsLCAmYmxvY2spXG4gICAgQGhhc2ggPSB7fVxuXG4gICAgcmV0dXJuIGlmIGVudW0ubmlsP1xuICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3ZhbHVlIG11c3QgYmUgZW51bWVyYWJsZScgdW5sZXNzIDo6RW51bWVyYWJsZSA9PT0gZW51bVxuXG4gICAgaWYgYmxvY2tcbiAgICAgIGVudW0uZWFjaCB7IHxpdGVtfCBhZGQgeWllbGQoaXRlbSkgfVxuICAgIGVsc2VcbiAgICAgIG1lcmdlKGVudW0pXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBkdXBcbiAgICByZXN1bHQgPSBzZWxmLmNsYXNzLm5ld1xuICAgIHJlc3VsdC5tZXJnZShzZWxmKVxuICBlbmRcblxuICBkZWYgLShlbnVtKVxuICAgIHVubGVzcyBlbnVtLnJlc3BvbmRfdG8/IDplYWNoXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd2YWx1ZSBtdXN0IGJlIGVudW1lcmFibGUnXG4gICAgZW5kXG5cbiAgICBkdXAuc3VidHJhY3QoZW51bSlcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBcIiM8U2V0OiB7I3t0b19hLmpvaW4oJywnKX19PlwiXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBpZiBlcXVhbD8ob3RoZXIpXG4gICAgICB0cnVlXG4gICAgZWxzaWYgb3RoZXIuaW5zdGFuY2Vfb2Y/KHNlbGYuY2xhc3MpXG4gICAgICBAaGFzaCA9PSBvdGhlci5pbnN0YW5jZV92YXJpYWJsZV9nZXQoOkBoYXNoKVxuICAgIGVsc2lmIG90aGVyLmlzX2E/KDo6U2V0KSAmJiBzaXplID09IG90aGVyLnNpemVcbiAgICAgIG90aGVyLmFsbD8geyB8b3wgQGhhc2guaW5jbHVkZT8obykgfVxuICAgIGVsc2VcbiAgICAgIGZhbHNlXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBhZGQobylcbiAgICBAaGFzaFtvXSA9IHRydWVcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjbGFzc2lmeSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpjbGFzc2lmeSkgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgcmVzdWx0ID0gOjpIYXNoLm5ldyB7IHxoLCBrfCBoW2tdID0gc2VsZi5jbGFzcy5uZXcgfVxuXG4gICAgZWFjaCB7IHxpdGVtfCByZXN1bHRbeWllbGQoaXRlbSldLmFkZCBpdGVtIH1cblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgY29sbGVjdCEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6Y29sbGVjdCEpIHVubGVzcyBibG9ja19naXZlbj9cbiAgICByZXN1bHQgPSBzZWxmLmNsYXNzLm5ld1xuICAgIGVhY2ggeyB8aXRlbXwgcmVzdWx0IDw8IHlpZWxkKGl0ZW0pIH1cbiAgICByZXBsYWNlIHJlc3VsdFxuICBlbmRcblxuICBkZWYgY29tcGFyZV9ieV9pZGVudGl0eVxuICAgIGlmIEBoYXNoLnJlc3BvbmRfdG8/KDpjb21wYXJlX2J5X2lkZW50aXR5KVxuICAgICAgQGhhc2guY29tcGFyZV9ieV9pZGVudGl0eVxuICAgICAgc2VsZlxuICAgIGVsc2VcbiAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIFwiI3tzZWxmLmNsYXNzLm5hbWV9XFwjI3tfX21ldGhvZF9ffSBpcyBub3QgaW1wbGVtZW50ZWRcIlxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgY29tcGFyZV9ieV9pZGVudGl0eT9cbiAgICBAaGFzaC5yZXNwb25kX3RvPyg6Y29tcGFyZV9ieV9pZGVudGl0eT8pICYmIEBoYXNoLmNvbXBhcmVfYnlfaWRlbnRpdHk/XG4gIGVuZFxuXG4gIGRlZiBkZWxldGUobylcbiAgICBAaGFzaC5kZWxldGUobylcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBkZWxldGU/KG8pXG4gICAgaWYgaW5jbHVkZT8obylcbiAgICAgIGRlbGV0ZShvKVxuICAgICAgc2VsZlxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgZGVsZXRlX2lmXG4gICAgcmV0dXJuIGVudW1fZm9yKDpkZWxldGVfaWYpIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAjIEBoYXNoLmRlbGV0ZV9pZiBzaG91bGQgYmUgZmFzdGVyLCBidXQgdXNpbmcgaXQgYnJlYWtzIHRoZSBvcmRlclxuICAgICMgb2YgZW51bWVyYXRpb24gaW4gc3ViY2xhc3Nlcy5cbiAgICBzZWxlY3QgeyB8b3wgeWllbGQgbyB9LmVhY2ggeyB8b3wgQGhhc2guZGVsZXRlKG8pIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBmcmVlemVcbiAgICByZXR1cm4gc2VsZiBpZiBmcm96ZW4/XG5cbiAgICBAaGFzaC5mcmVlemVcbiAgICBgJGZyZWV6ZShzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIGtlZXBfaWZcbiAgICByZXR1cm4gZW51bV9mb3IoOmtlZXBfaWYpIHVubGVzcyBibG9ja19naXZlbj9cbiAgICByZWplY3QgeyB8b3wgeWllbGQgbyB9LmVhY2ggeyB8b3wgQGhhc2guZGVsZXRlKG8pIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByZWplY3QhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlamVjdCEpIHVubGVzcyBibG9ja19naXZlbj9cbiAgICBiZWZvcmUgPSBzaXplXG4gICAgZGVsZXRlX2lmKCZibG9jaylcbiAgICBzaXplID09IGJlZm9yZSA/IG5pbCA6IHNlbGZcbiAgZW5kXG5cbiAgZGVmIHNlbGVjdCEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6c2VsZWN0ISkgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgIGJlZm9yZSA9IHNpemVcbiAgICBrZWVwX2lmKCZibG9jaylcbiAgICBzaXplID09IGJlZm9yZSA/IG5pbCA6IHNlbGZcbiAgZW5kXG5cbiAgZGVmIGFkZD8obylcbiAgICBpZiBpbmNsdWRlPyhvKVxuICAgICAgbmlsXG4gICAgZWxzZVxuICAgICAgYWRkKG8pXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBlYWNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2gpIHVubGVzcyBibG9ja19naXZlbj9cbiAgICBAaGFzaC5lYWNoX2tleSgmYmxvY2spXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZW1wdHk/XG4gICAgQGhhc2guZW1wdHk/XG4gIGVuZFxuXG4gIGRlZiBlcWw/KG90aGVyKVxuICAgIEBoYXNoLmVxbD8ob3RoZXIuaW5zdGFuY2VfZXZhbCB7IEBoYXNoIH0pXG4gIGVuZFxuXG4gIGRlZiBjbGVhclxuICAgIEBoYXNoLmNsZWFyXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgaW5jbHVkZT8obylcbiAgICBAaGFzaC5pbmNsdWRlPyhvKVxuICBlbmRcblxuICBkZWYgbWVyZ2UoZW51bSlcbiAgICBlbnVtLmVhY2ggeyB8aXRlbXwgYWRkIGl0ZW0gfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHJlcGxhY2UoZW51bSlcbiAgICBjbGVhclxuICAgIG1lcmdlKGVudW0pXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBzaXplXG4gICAgQGhhc2guc2l6ZVxuICBlbmRcblxuICBkZWYgc3VidHJhY3QoZW51bSlcbiAgICBlbnVtLmVhY2ggeyB8aXRlbXwgZGVsZXRlIGl0ZW0gfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHwoZW51bSlcbiAgICB1bmxlc3MgZW51bS5yZXNwb25kX3RvPyA6ZWFjaFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAndmFsdWUgbXVzdCBiZSBlbnVtZXJhYmxlJ1xuICAgIGVuZFxuICAgIGR1cC5tZXJnZShlbnVtKVxuICBlbmRcblxuICAleHtcbiAgICBmdW5jdGlvbiBpc19zZXQoc2V0KSB7XG4gICAgICAje2BzZXRgLmlzX2E/KDo6U2V0KSB8fCA6Oktlcm5lbC5yYWlzZSg6OkFyZ3VtZW50RXJyb3IsICd2YWx1ZSBtdXN0IGJlIGEgc2V0Jyl9XG4gICAgfVxuICB9XG5cbiAgZGVmIHN1cGVyc2V0PyhzZXQpXG4gICAgYGlzX3NldChzZXQpYFxuICAgIHJldHVybiBmYWxzZSBpZiBzaXplIDwgc2V0LnNpemVcbiAgICBzZXQuYWxsPyB7IHxvfCBpbmNsdWRlPyhvKSB9XG4gIGVuZFxuXG4gIGRlZiBwcm9wZXJfc3VwZXJzZXQ/KHNldClcbiAgICBgaXNfc2V0KHNldClgXG4gICAgcmV0dXJuIGZhbHNlIGlmIHNpemUgPD0gc2V0LnNpemVcbiAgICBzZXQuYWxsPyB7IHxvfCBpbmNsdWRlPyhvKSB9XG4gIGVuZFxuXG4gIGRlZiBzdWJzZXQ/KHNldClcbiAgICBgaXNfc2V0KHNldClgXG4gICAgcmV0dXJuIGZhbHNlIGlmIHNldC5zaXplIDwgc2l6ZVxuICAgIGFsbD8geyB8b3wgc2V0LmluY2x1ZGU/KG8pIH1cbiAgZW5kXG5cbiAgZGVmIHByb3Blcl9zdWJzZXQ/KHNldClcbiAgICBgaXNfc2V0KHNldClgXG4gICAgcmV0dXJuIGZhbHNlIGlmIHNldC5zaXplIDw9IHNpemVcbiAgICBhbGw/IHsgfG98IHNldC5pbmNsdWRlPyhvKSB9XG4gIGVuZFxuXG4gIGRlZiBpbnRlcnNlY3Q/KHNldClcbiAgICBgaXNfc2V0KHNldClgXG4gICAgaWYgc2l6ZSA8IHNldC5zaXplXG4gICAgICBhbnk/IHsgfG98IHNldC5pbmNsdWRlPyhvKSB9XG4gICAgZWxzZVxuICAgICAgc2V0LmFueT8geyB8b3wgaW5jbHVkZT8obykgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgZGlzam9pbnQ/KHNldClcbiAgICAhaW50ZXJzZWN0PyhzZXQpXG4gIGVuZFxuXG4gIGRlZiB0b19hXG4gICAgQGhhc2gua2V5c1xuICBlbmRcblxuICBhbGlhcyArIHxcbiAgYWxpYXMgPCBwcm9wZXJfc3Vic2V0P1xuICBhbGlhcyA8PCBhZGRcbiAgYWxpYXMgPD0gc3Vic2V0P1xuICBhbGlhcyA+IHByb3Blcl9zdXBlcnNldD9cbiAgYWxpYXMgPj0gc3VwZXJzZXQ/XG4gIGFsaWFzIGRpZmZlcmVuY2UgLVxuICBhbGlhcyBmaWx0ZXIhIHNlbGVjdCFcbiAgYWxpYXMgbGVuZ3RoIHNpemVcbiAgYWxpYXMgbWFwISBjb2xsZWN0IVxuICBhbGlhcyBtZW1iZXI/IGluY2x1ZGU/XG4gIGFsaWFzIHVuaW9uIHxcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6U2V0PiIsInNlbGYiLCJpbmNsdWRlIiwiRW51bWVyYWJsZSIsIltdIiwibmV3IiwiYXJ5IiwiaW5pdGlhbGl6ZSIsImVudW0kIiwiQGhhc2giLCJuaWw/IiwiS2VybmVsIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwiYmxvY2siLCJlYWNoIiwiYmxvY2sgaW4gaW5pdGlhbGl6ZSIsIml0ZW0iLCJibG9jayAoMiBsZXZlbHMpIGluIGluaXRpYWxpemUiLCJhZGQiLCJtZXJnZSIsImR1cCIsInJlc3VsdCIsImNsYXNzIiwiLSIsInJlc3BvbmRfdG8/Iiwic3VidHJhY3QiLCJpbnNwZWN0IiwidG9fYSIsImpvaW4iLCI9PSIsIm90aGVyIiwiZXF1YWw/IiwiaW5zdGFuY2Vfb2Y/IiwiaW5zdGFuY2VfdmFyaWFibGVfZ2V0IiwiaXNfYT8iLCJTZXQiLCJzaXplIiwiYWxsPyIsImJsb2NrIGluID09IiwibyIsImJsb2NrICgyIGxldmVscykgaW4gPT0iLCJpbmNsdWRlPyIsIltdPSIsImNsYXNzaWZ5IiwiYmxvY2tfZ2l2ZW4/IiwiZW51bV9mb3IiLCJIYXNoIiwiYmxvY2sgaW4gY2xhc3NpZnkiLCJoIiwiayIsImJsb2NrICgyIGxldmVscykgaW4gY2xhc3NpZnkiLCJjb2xsZWN0ISIsImJsb2NrIGluIGNvbGxlY3QhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb2xsZWN0ISIsIjw8IiwicmVwbGFjZSIsImNvbXBhcmVfYnlfaWRlbnRpdHkiLCJOb3RJbXBsZW1lbnRlZEVycm9yIiwibmFtZSIsIl9fbWV0aG9kX18iLCJjb21wYXJlX2J5X2lkZW50aXR5PyIsIiRyZXRfb3JfMSIsImRlbGV0ZSIsImRlbGV0ZT8iLCJkZWxldGVfaWYiLCJzZWxlY3QiLCJibG9jayBpbiBkZWxldGVfaWYiLCJibG9jayAoMiBsZXZlbHMpIGluIGRlbGV0ZV9pZiIsImZyZWV6ZSIsImZyb3plbj8iLCJrZWVwX2lmIiwicmVqZWN0IiwiYmxvY2sgaW4ga2VlcF9pZiIsImJsb2NrICgyIGxldmVscykgaW4ga2VlcF9pZiIsInJlamVjdCEiLCJiZWZvcmUiLCJ0b19wcm9jIiwic2VsZWN0ISIsImFkZD8iLCJlYWNoX2tleSIsImVtcHR5PyIsImVxbD8iLCJpbnN0YW5jZV9ldmFsIiwiYmxvY2sgaW4gZXFsPyIsImJsb2NrICgyIGxldmVscykgaW4gZXFsPyIsImNsZWFyIiwiYmxvY2sgaW4gbWVyZ2UiLCJibG9jayAoMiBsZXZlbHMpIGluIG1lcmdlIiwiYmxvY2sgaW4gc3VidHJhY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIHN1YnRyYWN0IiwifCIsInN1cGVyc2V0PyIsInNldCIsIjwiLCJibG9jayBpbiBzdXBlcnNldD8iLCJibG9jayAoMiBsZXZlbHMpIGluIHN1cGVyc2V0PyIsInByb3Blcl9zdXBlcnNldD8iLCI8PSIsImJsb2NrIGluIHByb3Blcl9zdXBlcnNldD8iLCJibG9jayAoMiBsZXZlbHMpIGluIHByb3Blcl9zdXBlcnNldD8iLCJzdWJzZXQ/IiwiYmxvY2sgaW4gc3Vic2V0PyIsImJsb2NrICgyIGxldmVscykgaW4gc3Vic2V0PyIsInByb3Blcl9zdWJzZXQ/IiwiYmxvY2sgaW4gcHJvcGVyX3N1YnNldD8iLCJibG9jayAoMiBsZXZlbHMpIGluIHByb3Blcl9zdWJzZXQ/IiwiaW50ZXJzZWN0PyIsImFueT8iLCJibG9jayBpbiBpbnRlcnNlY3Q/IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbnRlcnNlY3Q/IiwiZGlzam9pbnQ/IiwiISIsImtleXMiXSwibWFwcGluZ3MiOiJBQUFBQSw4QkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUlBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0FBQUFBOztJQUNFQyxJQUFBQyxTQUFBQSxDQUFRQyxpQkFBUkQ7SUFFQUUsTUFBSUgsSUFBSkcsU0FBQUEsbUJBUEYsRUFPRUE7QUFBQUEsTUFBQUE7OztNQVBGO01BT2M7TUFDVkEsT0FBQUgsSUFBQUksS0FBQUEsQ0FBSUMsR0FBSkQ7SUFERkQsQ0FBQUEsSUFBQUE7O0FBSUFHLElBQUFBLDBCQUFBQSxzQkFBZUMsS0FBZkQ7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFBZSwyQkFBTztNQUNwQkUsWUFBUTtNQUVSLElBQUEsUUFBVUQsS0FBSUUsU0FBQUEsQ0FBQUEsQ0FBZCxDQUFBO1FBQUEsT0FBQTtNQUFBO01BQ0EsS0FBQSxRQUFrRVAsaUJBQWxFLEVBQW1GSyxLQUFuRixDQUFBO1FBQUFHLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWdDTiwwQkFBeEJLO01BQVI7TUFFQSxJQUFB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QWpCLEdBQUduRCxhQUFBQSxDQUFVRixDQUFWRSxFQUFkbUUsQ0FBQUQ7TUFERjtRQUdFRCxPQUFHQyxNQUFIZixHQUFHZSxRQUFBQSxFQUFBQSxFQUFBQSxFQUFIQyxjQUFZckUsQ0FBWnFFLEVBQUFDOzs7VUFBWTtVQUFHQSxPQUFBN0csSUFBQXlDLGFBQUFBLENBQVNGLENBQVRFLEVBQWZtRSxDQUFBQSxHQUFBQSxTQUFBQSxDQUFHRDtNQUhMO0lBRkZELENBQUFBOztBQVNBSSxJQUFBQSx5QkFBQUEsK0JBQWNsQixHQUFka0I7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUM5RyxJQUFBMEcsZUFBQUEsQ0FBV2QsR0FBWGMsQ0FBREssTUFBQUEsQ0FBQUE7SUFERkQsQ0FBQUE7O0FBSUFuRixJQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBbkIsU0FBS3dHLE1BQUFBLENBQUFBO0lBRFByRixDQUFBQTtJQUlBLGFBQU0sR0FBTixFQUFRLEdBQVI7SUFDQSxhQUFNLEdBQU4sRUFBUSxnQkFBUjtJQUNBLGFBQU0sSUFBTixFQUFTLEtBQVQ7SUFDQSxhQUFNLElBQU4sRUFBUyxTQUFUO0lBQ0EsYUFBTSxHQUFOLEVBQVEsa0JBQVI7SUFDQSxhQUFNLElBQU4sRUFBUyxXQUFUO0lBQ0EsYUFBTSxZQUFOLEVBQWlCLEdBQWpCO0lBQ0EsYUFBTSxTQUFOLEVBQWMsU0FBZDtJQUNBLGFBQU0sUUFBTixFQUFhLE1BQWI7SUFDQSxhQUFNLE1BQU4sRUFBVyxVQUFYO0lBQ0EsYUFBTSxTQUFOLEVBQWMsVUFBZDtJQUNBNUIsT0FBQSxhQUFNLE9BQU4sRUFBWSxHQUFaO0VBeFBGQSxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBSkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMzkwNiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvZGlyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxuXG5jbGFzcyA6OkRpclxuICBjbGFzcyA8PCBzZWxmXG4gICAgZGVmIGNoZGlyKGRpcilcbiAgICAgIHByZXZfY3dkID0gYE9wYWwuY3VycmVudF9kaXJgXG4gICAgICBgT3BhbC5jdXJyZW50X2RpciA9ICN7ZGlyfWBcbiAgICAgIHlpZWxkXG4gICAgZW5zdXJlXG4gICAgICBgT3BhbC5jdXJyZW50X2RpciA9ICN7cHJldl9jd2R9YFxuICAgIGVuZFxuXG4gICAgZGVmIHB3ZFxuICAgICAgYE9wYWwuY3VycmVudF9kaXIgfHwgJy4nYFxuICAgIGVuZFxuXG4gICAgZGVmIGhvbWVcbiAgICAgIDo6RU5WWydIT01FJ10gfHwgJy4nXG4gICAgZW5kXG5cbiAgICBhbGlhcyBnZXR3ZCBwd2RcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOkRpcj4iLCJjaGRpciIsImRpciIsInByZXZfY3dkIiwicHdkIiwiaG9tZSIsIiRyZXRfb3JfMSIsIkVOViIsIltdIiwic2VsZiJdLCJtYXBwaW5ncyI6IkFBQUFBLDhCQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBRUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQTs7OztBQUNFQyxNQUFBQSxxQkFBQUEsaUJBQVVDLEdBQVZEO0FBQUFBLFFBQUFBOztRQUFBQTtRQUNFQSxPQUFBLGNBQUE7O1FBQUFFLFdBQVlGO1FBQ1hBLG1CQUFxQkM7UUFDdEIsT0FBQSxxQkFBQSxFQUFBO1FBRkE7VUFJQ0QsbUJBQXFCRTtRQUp0QixDQUFBO01BREZGLENBQUFBOztBQVFBRyxNQUFBQSxtQkFBQUEsZUFBQUE7QUFBQUE7UUFDRUEsT0FBQ0EsdUJBQURBO01BREZBLENBQUFBOztBQUlBQyxNQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLFFBQUFBOztRQUNFLElBQUEsUUFBQUMsQ0FBQUEsWUFBQUMsVUFBS0MsT0FBQUEsQ0FBQ0gsTUFBREcsQ0FBTEYsQ0FBQSxDQUFBO1VBQUFELE9BQUE7UUFBQTtVQUFpQkEsT0FBQUE7UUFBakI7TUFERkEsQ0FBQUE7TUFJQSxPQUFBLGFBQU0sT0FBTixFQUFZLEtBQVo7SUFqQkYsNEJBQVNJLElBQVQ7RUFERlQsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtBQUZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MjM5NTIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2ZpbGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiB0cnV0aHlcbiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxuXG5jbGFzcyA6OkZpbGUgPCA6OklPXG4gIFNlcGFyYXRvciA9IFNFUEFSQVRPUiA9ICcvJ1xuICBBTFRfU0VQQVJBVE9SID0gbmlsXG4gIFBBVEhfU0VQQVJBVE9SID0gJzonXG4gICMgQXNzdW1pbmcgY2FzZSBpbnNlbnN0aXZlIGZpbGVzeXN0ZW1cbiAgRk5NX1NZU0NBU0UgPSAwXG4gIHdpbmRvd3Nfcm9vdF9yeCA9ICVye15bYS16QS1aXTooPzpcXFxcfFxcLyl9XG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhYnNvbHV0ZV9wYXRoKHBhdGgsIGJhc2VkaXIgPSBuaWwpXG4gICAgICBzZXAgPSBTRVBBUkFUT1JcbiAgICAgIHNlcF9jaGFycyA9IGAkc2VwX2NoYXJzKClgXG4gICAgICBuZXdfcGFydHMgPSBbXVxuXG4gICAgICBwYXRoID0gcGF0aC5yZXNwb25kX3RvPyg6dG9fcGF0aCkgPyBwYXRoLnRvX3BhdGggOiBwYXRoXG4gICAgICBwYXRoID0gOjpPcGFsLmNvZXJjZV90byEoYHBhdGhgLCA6OlN0cmluZywgOnRvX3N0cilcblxuICAgICAgYmFzZWRpciB8fD0gOjpEaXIucHdkXG4gICAgICBwYXRoX2FicyAgICA9IGBwYXRoLnN1YnN0cigwLCBzZXAubGVuZ3RoKSA9PT0gc2VwIHx8IHdpbmRvd3Nfcm9vdF9yeC50ZXN0KHBhdGgpYFxuICAgICAgYmFzZWRpcl9hYnMgPSBgYmFzZWRpci5zdWJzdHIoMCwgc2VwLmxlbmd0aCkgPT09IHNlcCB8fCB3aW5kb3dzX3Jvb3RfcngudGVzdChiYXNlZGlyKWBcblxuICAgICAgaWYgcGF0aF9hYnNcbiAgICAgICAgcGFydHMgICAgICAgPSBwYXRoLnNwbGl0KC9bI3tzZXBfY2hhcnN9XS8pXG4gICAgICAgIGxlYWRpbmdfc2VwID0gYHdpbmRvd3Nfcm9vdF9yeC50ZXN0KHBhdGgpID8gJycgOiAje3BhdGguc3ViKC9eKFsje3NlcF9jaGFyc31dKykuKiQvLCAnXFwxJyl9YFxuICAgICAgICBhYnMgICAgICAgICA9IHRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgcGFydHMgICAgICAgPSBiYXNlZGlyLnNwbGl0KC9bI3tzZXBfY2hhcnN9XS8pICsgcGF0aC5zcGxpdCgvWyN7c2VwX2NoYXJzfV0vKVxuICAgICAgICBsZWFkaW5nX3NlcCA9IGB3aW5kb3dzX3Jvb3RfcngudGVzdChiYXNlZGlyKSA/ICcnIDogI3tiYXNlZGlyLnN1YigvXihbI3tzZXBfY2hhcnN9XSspLiokLywgJ1xcMScpfWBcbiAgICAgICAgYWJzICAgICAgICAgPSBiYXNlZGlyX2Fic1xuICAgICAgZW5kXG5cbiAgICAgICV4e1xuICAgICAgICB2YXIgcGFydDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGFydHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgIHBhcnQgPSBwYXJ0c1tpXTtcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChwYXJ0ID09PSBuaWwpIHx8XG4gICAgICAgICAgICAocGFydCA9PT0gJycgICYmICgobmV3X3BhcnRzLmxlbmd0aCA9PT0gMCkgfHwgYWJzKSkgfHxcbiAgICAgICAgICAgIChwYXJ0ID09PSAnLicgJiYgKChuZXdfcGFydHMubGVuZ3RoID09PSAwKSB8fCBhYnMpKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICAgICAgICBuZXdfcGFydHMucG9wKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld19wYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYWJzICYmIHBhcnRzWzBdICE9PSAnLicpIHtcbiAgICAgICAgICAje25ld19wYXJ0cy51bnNoaWZ0ICcuJ31cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXdfcGF0aCA9IG5ld19wYXJ0cy5qb2luKHNlcClcbiAgICAgIG5ld19wYXRoID0gbGVhZGluZ19zZXAgKyBuZXdfcGF0aCBpZiBhYnNcbiAgICAgIG5ld19wYXRoXG4gICAgZW5kXG5cbiAgICBkZWYgZXhwYW5kX3BhdGgocGF0aCwgYmFzZWRpciA9IG5pbClcbiAgICAgIHNlcCA9IFNFUEFSQVRPUlxuICAgICAgc2VwX2NoYXJzID0gYCRzZXBfY2hhcnMoKWBcbiAgICAgIGlmIGBwYXRoWzBdID09PSAnficgfHwgKGJhc2VkaXIgJiYgYmFzZWRpclswXSA9PT0gJ34nKWBcbiAgICAgICAgaG9tZSA9IERpci5ob21lXG4gICAgICAgIDo6S2VybmVsLnJhaXNlKDo6QXJndW1lbnRFcnJvciwgXCJjb3VsZG4ndCBmaW5kIEhPTUUgZW52aXJvbm1lbnQgLS0gZXhwYW5kaW5nIGB+J1wiKSB1bmxlc3MgaG9tZVxuICAgICAgICBsZWFkaW5nX3NlcCA9IGB3aW5kb3dzX3Jvb3RfcngudGVzdChob21lKSA/ICcnIDogI3tob21lLnN1YigvXihbI3tzZXBfY2hhcnN9XSspLiokLywgJ1xcMScpfWBcbiAgICAgICAgOjpLZXJuZWwucmFpc2UoOjpBcmd1bWVudEVycm9yLCAnbm9uLWFic29sdXRlIGhvbWUnKSB1bmxlc3MgaG9tZS5zdGFydF93aXRoPyhsZWFkaW5nX3NlcClcblxuICAgICAgICBob21lICAgICAgICAgICAgKz0gc2VwXG4gICAgICAgIGhvbWVfcGF0aF9yZWdleHAgPSAvXlxcfig/OiN7c2VwfXwkKS9cbiAgICAgICAgcGF0aCAgICAgICAgICAgICA9IHBhdGguc3ViKGhvbWVfcGF0aF9yZWdleHAsIGhvbWUpXG4gICAgICAgIGJhc2VkaXIgICAgICAgICAgPSBiYXNlZGlyLnN1Yihob21lX3BhdGhfcmVnZXhwLCBob21lKSBpZiBiYXNlZGlyXG4gICAgICBlbmRcbiAgICAgIGFic29sdXRlX3BhdGgocGF0aCwgYmFzZWRpcilcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgLy8gQ29lcmNlIGEgZ2l2ZW4gcGF0aCB0byBhIHBhdGggc3RyaW5nIHVzaW5nICN0b19wYXRoIGFuZCAjdG9fc3RyXG4gICAgICBmdW5jdGlvbiAkY29lcmNlX3RvX3BhdGgocGF0aCkge1xuICAgICAgICBpZiAoJHRydXRoeSgje2BwYXRoYC5yZXNwb25kX3RvPyg6dG9fcGF0aCl9KSkge1xuICAgICAgICAgIHBhdGggPSBwYXRoLiR0b19wYXRoKCk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXRoID0gI3s6Ok9wYWwuY29lcmNlX3RvIShgcGF0aGAsIDo6U3RyaW5nLCA6dG9fc3RyKX07XG5cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiBhIFJlZ0V4cCBjb21wYXRpYmxlIGNoYXIgY2xhc3NcbiAgICAgIGZ1bmN0aW9uICRzZXBfY2hhcnMoKSB7XG4gICAgICAgIGlmICgje0FMVF9TRVBBUkFUT1J9ID09PSBuaWwpIHtcbiAgICAgICAgICByZXR1cm4gT3BhbC5lc2NhcGVfcmVnZXhwKCN7U0VQQVJBVE9SfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIE9wYWwuZXNjYXBlX3JlZ2V4cCgje1NFUEFSQVRPUiArIEFMVF9TRVBBUkFUT1J9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGRlZiBkaXJuYW1lKHBhdGgsIGxldmVsID0gMSlcbiAgICAgIHJldHVybiBwYXRoIGlmIGxldmVsID09IDBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJsZXZlbCBjYW4ndCBiZSBuZWdhdGl2ZVwiIGlmIGxldmVsIDwgMFxuXG4gICAgICBzZXBfY2hhcnMgPSBgJHNlcF9jaGFycygpYFxuICAgICAgcGF0aCA9IGAkY29lcmNlX3RvX3BhdGgocGF0aClgXG4gICAgICAleHtcbiAgICAgICAgdmFyIGFic29sdXRlID0gcGF0aC5tYXRjaChuZXcgUmVnRXhwKCN7XCJeWyN7c2VwX2NoYXJzfV1cIn0pKSwgb3V0O1xuXG4gICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UobmV3IFJlZ0V4cCgje1wiWyN7c2VwX2NoYXJzfV0rJFwifSksICcnKTsgLy8gcmVtb3ZlIHRyYWlsaW5nIHNlcGFyYXRvcnNcbiAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZShuZXcgUmVnRXhwKCN7XCJbXiN7c2VwX2NoYXJzfV0rJFwifSksICcnKTsgLy8gcmVtb3ZlIHRyYWlsaW5nIGJhc2VuYW1lXG4gICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UobmV3IFJlZ0V4cCgje1wiWyN7c2VwX2NoYXJzfV0rJFwifSksICcnKTsgLy8gcmVtb3ZlIGZpbmFsIHRyYWlsaW5nIHNlcGFyYXRvcnNcblxuICAgICAgICBpZiAocGF0aCA9PT0gJycpIHtcbiAgICAgICAgICBvdXQgPSBhYnNvbHV0ZSA/ICcvJyA6ICcuJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBvdXQgPSBwYXRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxldmVsID09IDEpIHtcbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiAje2Rpcm5hbWUoYG91dGAsIGxldmVsIC0gMSl9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGRlZiBiYXNlbmFtZShuYW1lLCBzdWZmaXggPSBuaWwpXG4gICAgICBzZXBfY2hhcnMgPSBgJHNlcF9jaGFycygpYFxuICAgICAgbmFtZSA9IGAkY29lcmNlX3RvX3BhdGgobmFtZSlgXG4gICAgICAleHtcbiAgICAgICAgaWYgKG5hbWUubGVuZ3RoID09IDApIHtcbiAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdWZmaXggIT09IG5pbCkge1xuICAgICAgICAgIHN1ZmZpeCA9ICN7OjpPcGFsLmNvZXJjZV90byEoc3VmZml4LCA6OlN0cmluZywgOnRvX3N0cil9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3VmZml4ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobmV3IFJlZ0V4cCgje1wiKC4pWyN7c2VwX2NoYXJzfV0qJFwifSksICckMScpO1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoI3tcIl4oPzouKlsje3NlcF9jaGFyc31dKT8oW14je3NlcF9jaGFyc31dKykkXCJ9KSwgJyQxJyk7XG5cbiAgICAgICAgaWYgKHN1ZmZpeCA9PT0gXCIuKlwiKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvXFwuW15cXC5dKyQvLCAnJyk7XG4gICAgICAgIH0gZWxzZSBpZihzdWZmaXggIT09IG51bGwpIHtcbiAgICAgICAgICBzdWZmaXggPSBPcGFsLmVzY2FwZV9yZWdleHAoc3VmZml4KTtcbiAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoI3tcIiN7c3VmZml4fSRcIn0pLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGRlZiBleHRuYW1lKHBhdGgpXG4gICAgICBgcGF0aCA9ICRjb2VyY2VfdG9fcGF0aChwYXRoKWBcbiAgICAgIGZpbGVuYW1lID0gYmFzZW5hbWUocGF0aClcbiAgICAgIHJldHVybiAnJyBpZiBmaWxlbmFtZS5lbXB0eT9cbiAgICAgIGxhc3RfZG90X2lkeCA9IGZpbGVuYW1lWzEuLi0xXS5yaW5kZXgoJy4nKVxuICAgICAgIyBleHRlbnNpb24gbmFtZSBtdXN0IGNvbnRhaW5zIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgLihzb21ldGhpbmcpXG4gICAgICBsYXN0X2RvdF9pZHgubmlsPyB8fCBsYXN0X2RvdF9pZHggKyAxID09IGZpbGVuYW1lLmxlbmd0aCAtIDEgPyAnJyA6IGZpbGVuYW1lWyhsYXN0X2RvdF9pZHggKyAxKS4uLTFdXG4gICAgZW5kXG5cbiAgICBkZWYgZXhpc3Q/KHBhdGgpXG4gICAgICBgT3BhbC5tb2R1bGVzWyN7cGF0aH1dICE9IG51bGxgXG4gICAgZW5kXG5cbiAgICBkZWYgZGlyZWN0b3J5PyhwYXRoKVxuICAgICAgZmlsZXMgPSBbXVxuICAgICAgJXh7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBPcGFsLm1vZHVsZXMpIHtcbiAgICAgICAgICAje2ZpbGVzfS5wdXNoKGtleSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGF0aCA9IHBhdGguZ3N1YigvKF4uI3tTRVBBUkFUT1J9K3wje1NFUEFSQVRPUn0rJCkvKVxuICAgICAgZmlsZSA9IGZpbGVzLmZpbmQgeyB8ZnwgZiA9fiAvXiN7cGF0aH0vIH1cbiAgICAgIGZpbGVcbiAgICBlbmRcblxuICAgIGRlZiBqb2luKCpwYXRocylcbiAgICAgIGlmIHBhdGhzLmVtcHR5P1xuICAgICAgICByZXR1cm4gJydcbiAgICAgIGVuZFxuICAgICAgcmVzdWx0ID0gJydcbiAgICAgIHBhdGhzID0gcGF0aHMuZmxhdHRlbi5lYWNoX3dpdGhfaW5kZXgubWFwIGRvIHxpdGVtLCBpbmRleHxcbiAgICAgICAgaWYgaW5kZXggPT0gMCAmJiBpdGVtLmVtcHR5P1xuICAgICAgICAgIFNFUEFSQVRPUlxuICAgICAgICBlbHNpZiBwYXRocy5sZW5ndGggPT0gaW5kZXggKyAxICYmIGl0ZW0uZW1wdHk/XG4gICAgICAgICAgU0VQQVJBVE9SXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBpdGVtXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICBwYXRocyA9IHBhdGhzLnJlamVjdCgmOmVtcHR5PylcbiAgICAgIHBhdGhzLmVhY2hfd2l0aF9pbmRleCBkbyB8aXRlbSwgaW5kZXh8XG4gICAgICAgIG5leHRfaXRlbSA9IHBhdGhzW2luZGV4ICsgMV1cbiAgICAgICAgaWYgbmV4dF9pdGVtLm5pbD9cbiAgICAgICAgICByZXN1bHQgPSBcIiN7cmVzdWx0fSN7aXRlbX1cIlxuICAgICAgICBlbHNlXG4gICAgICAgICAgaWYgaXRlbS5lbmRfd2l0aD8oU0VQQVJBVE9SKSAmJiBuZXh0X2l0ZW0uc3RhcnRfd2l0aD8oU0VQQVJBVE9SKVxuICAgICAgICAgICAgaXRlbSA9IGl0ZW0uc3ViKC8je1NFUEFSQVRPUn0rJC8sICcnKVxuICAgICAgICAgIGVuZFxuICAgICAgICAgIHJlc3VsdCA9IGlmIGl0ZW0uZW5kX3dpdGg/KFNFUEFSQVRPUikgfHwgbmV4dF9pdGVtLnN0YXJ0X3dpdGg/KFNFUEFSQVRPUilcbiAgICAgICAgICAgICAgICAgICAgIFwiI3tyZXN1bHR9I3tpdGVtfVwiXG4gICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgXCIje3Jlc3VsdH0je2l0ZW19I3tTRVBBUkFUT1J9XCJcbiAgICAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIHJlc3VsdFxuICAgIGVuZFxuXG4gICAgZGVmIHNwbGl0KHBhdGgpXG4gICAgICBwYXRoLnNwbGl0KFNFUEFSQVRPUilcbiAgICBlbmRcblxuICAgIGFsaWFzIHJlYWxwYXRoIGV4cGFuZF9wYXRoXG4gICAgYWxpYXMgZXhpc3RzPyBleGlzdD9cbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOkZpbGU+IiwiMCIsIndpbmRvd3Nfcm9vdF9yeCIsImFic29sdXRlX3BhdGgiLCJwYXRoIiwiYmFzZWRpciIsInNlcCIsIlNFUEFSQVRPUiIsInNlcF9jaGFycyIsIm5ld19wYXJ0cyIsInJlc3BvbmRfdG8/IiwidG9fcGF0aCIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiU3RyaW5nIiwiJHJldF9vcl8xIiwiRGlyIiwicHdkIiwicGF0aF9hYnMiLCJiYXNlZGlyX2FicyIsInBhcnRzIiwic3BsaXQiLCJsZWFkaW5nX3NlcCIsInN1YiIsImFicyIsIisiLCJ1bnNoaWZ0IiwibmV3X3BhdGgiLCJqb2luIiwiZXhwYW5kX3BhdGgiLCJob21lIiwiS2VybmVsIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwic3RhcnRfd2l0aD8iLCJob21lX3BhdGhfcmVnZXhwIiwic2VsZiIsIkFMVF9TRVBBUkFUT1IiLCJkaXJuYW1lIiwibGV2ZWwiLCIxIiwiPCIsIi0iLCJiYXNlbmFtZSIsIm5hbWUiLCJzdWZmaXgiLCJleHRuYW1lIiwiZmlsZW5hbWUiLCJlbXB0eT8iLCJsYXN0X2RvdF9pZHgiLCJbXSIsIi0xIiwicmluZGV4IiwibmlsPyIsImxlbmd0aCIsImV4aXN0PyIsImRpcmVjdG9yeT8iLCJmaWxlcyIsImdzdWIiLCJmaW5kIiwiYmxvY2sgaW4gZGlyZWN0b3J5PyIsImYiLCJibG9jayAoMiBsZXZlbHMpIGluIGRpcmVjdG9yeT8iLCI9fiIsInBhdGhzIiwicmVzdWx0IiwibWFwIiwiZmxhdHRlbiIsImVhY2hfd2l0aF9pbmRleCIsImJsb2NrIGluIGpvaW4iLCJpdGVtIiwiaW5kZXgiLCJibG9jayAoMiBsZXZlbHMpIGluIGpvaW4iLCJyZWplY3QiLCJ0b19wcm9jIiwibmV4dF9pdGVtIiwiZW5kX3dpdGg/IiwiSU8iXSwibWFwcGluZ3MiOiJBQUFBQSwrQkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUdBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNFLHFDQUFZLHFDQUFZQSxHQUFaLENBQVo7SUFDQSx5Q0FBZ0IsR0FBaEI7SUFDQSwwQ0FBaUJBLEdBQWpCO0lBRUEsdUNBQWNDLENBQWQ7SUFDQUMsa0JBQWtCO0lBRWxCRixPQUFBO01BQUE7Ozs7QUFDRUcsTUFB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QUF0QyxDQUFBLENBQUEsQ0FBSDtjQUNFb0MsT0FBT0EsSUFBSS9DLEtBQUFBLENBQUssU0FBR2hCLGVBQUgsRUFBYWlFLElBQWIsQ0FBQSxDQUFULEVBQTJCQSxFQUF2QmpEO1lBRGI7WUFHQWlELE9BQUFQLENBQUFBLFNBQVMsQ0FBRyxDQUFBLFFBQUFLLElBQUlNLGNBQUFBLENBQVdyRSxlQUFYcUUsQ0FBSixDQUFBLElBQUEsQ0FBQSxRQUE2QkQsU0FBU3pDLGdCQUFBQSxDQUFhM0IsZUFBYjJCLENBQXRDLENBQUEsQ0FBQSxDQUFILEdBQUEsQ0FDRSxFQUFBLEdBQUEsQ0FBRytCLE1BQUgsQ0FBQSxHQUFBLENBQVlLLElBQVosQ0FERixJQUFBLENBR0UsRUFBQSxHQUFBLENBQUdMLE1BQUgsQ0FBQSxHQUFBLENBQVlLLElBQVosQ0FBQSxHQUFBLENBQW1CL0QsZUFBbkIsQ0FIRixDQUFBLENBQVQwRDtVQU5GLEVBRkZJLENBQUtEO1FBZUx4QyxPQUFBcUM7TUE5QkZyQyxDQUFBQSxJQUFBQTs7QUFpQ0FQLE1BQUFBLHFCQUFBQSxpQkFBVWpCLElBQVZpQjtBQUFBQTtRQUNFQSxPQUFBakIsSUFBSWlCLE9BQUFBLENBQU9kLGVBQVBjO01BRE5BLENBQUFBO01BSUEsYUFBTSxVQUFOLEVBQWUsYUFBZjtNQUNBLE9BQUEsYUFBTSxTQUFOLEVBQWMsUUFBZDtJQW5ORiw0QkFBU2UsSUFBVDtFQVJGcEMsR0FBTSxJQUFOQSxFQUFlNkUsU0FBZjdFO0FBSEFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNDIzMSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcHJvY2Vzcy9iYXNlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIDo6U2lnbmFsXG4gIGRlZiBzZWxmLnRyYXAoKilcbiAgZW5kXG5lbmRcblxuY2xhc3MgOjpHQ1xuICBkZWYgc2VsZi5zdGFydFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6U2lnbmFsPiIsInRyYXAiLCJzZWxmIiwiPGNsYXNzOkdDPiIsInN0YXJ0Il0sIm1hcHBpbmdzIjoiQUFBQUEsdUNBQUFBLGdCQUFBQTtFQUFBQTs7O0VBQUFDO0VBQUFBOzs7SUFDRUEsT0FBQUMsTUFBSUMsSUFBSkQsV0FBQUEsZ0JBREYsRUFDRUE7QUFBQUEsTUFBQUE7OztNQURGO01BQ2dCO01BRGhCQSxPQUFBO0lBQ0VBLENBQUFBLElBQUFBO0VBREZELEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7RUFLQUQsT0FBQUk7RUFBQUE7OztJQUNFQSxPQUFBQyxNQUFJRixJQUFKRSxZQUFBQSxZQU5GLEdBTUVBLENBQUFBO0VBREZELEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7QUFMQUo7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0MjU2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9wcm9jZXNzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxuXG5tb2R1bGUgOjpQcm9jZXNzXG4gIEBfX2Nsb2Nrc19fID0gW11cbiAgZGVmIHNlbGYuX19yZWdpc3Rlcl9jbG9ja19fKG5hbWUsIGZ1bmMpXG4gICAgY29uc3Rfc2V0IG5hbWUsIEBfX2Nsb2Nrc19fLnNpemVcbiAgICBAX19jbG9ja3NfXyA8PCBmdW5jXG4gIGVuZFxuXG4gIF9fcmVnaXN0ZXJfY2xvY2tfXyA6Q0xPQ0tfUkVBTFRJTUUsIGBmdW5jdGlvbigpIHsgcmV0dXJuIERhdGUubm93KCkgfWBcblxuICBtb25vdG9uaWMgPSBmYWxzZVxuXG4gICV4e1xuICAgIGlmIChPcGFsLmdsb2JhbC5wZXJmb3JtYW5jZSkge1xuICAgICAgbW9ub3RvbmljID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoT3BhbC5nbG9iYWwucHJvY2VzcyAmJiBwcm9jZXNzLmhydGltZSkge1xuICAgICAgLy8gbGV0IG5vdyBiZSB0aGUgYmFzZSB0byBnZXQgc21hbGxlciBudW1iZXJzXG4gICAgICB2YXIgaHJ0aW1lX2Jhc2UgPSBwcm9jZXNzLmhydGltZSgpO1xuXG4gICAgICBtb25vdG9uaWMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhydGltZSA9IHByb2Nlc3MuaHJ0aW1lKGhydGltZV9iYXNlKTtcbiAgICAgICAgdmFyIHVzID0gKGhydGltZVsxXSAvIDEwMDApIHwgMDsgLy8gY3V0IGJlbG93IG1pY3Jvc2VjcztcbiAgICAgICAgcmV0dXJuICgoaHJ0aW1lWzBdICogMTAwMCkgKyAodXMgLyAxMDAwKSk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIF9fcmVnaXN0ZXJfY2xvY2tfXyg6Q0xPQ0tfTU9OT1RPTklDLCBtb25vdG9uaWMpIGlmIG1vbm90b25pY1xuXG4gIGRlZiBzZWxmLnBpZFxuICAgIDBcbiAgZW5kXG5cbiAgZGVmIHNlbGYudGltZXNcbiAgICB0ID0gOjpUaW1lLm5vdy50b19mXG4gICAgOjpCZW5jaG1hcms6OlRtcy5uZXcodCwgdCwgdCwgdCwgdClcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY2xvY2tfZ2V0dGltZShjbG9ja19pZCwgdW5pdCA9IDpmbG9hdF9zZWNvbmQpXG4gICAgKGNsb2NrID0gQF9fY2xvY2tzX19bY2xvY2tfaWRdKSB8fCA6Oktlcm5lbC5yYWlzZSg6OkVycm5vOjpFSU5WQUwsIFwiY2xvY2tfZ2V0dGltZSgje2Nsb2NrX2lkfSkgI3tAX19jbG9ja3NfX1tjbG9ja19pZF19XCIpXG4gICAgJXh7XG4gICAgICB2YXIgbXMgPSBjbG9jaygpO1xuICAgICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgIGNhc2UgJ2Zsb2F0X3NlY29uZCc6ICAgICAgcmV0dXJuICAobXMgLyAxMDAwKTsgICAgICAgICAvLyBudW1iZXIgb2Ygc2Vjb25kcyBhcyBhIGZsb2F0IChkZWZhdWx0KVxuICAgICAgICBjYXNlICdmbG9hdF9taWxsaXNlY29uZCc6IHJldHVybiAgKG1zIC8gMSk7ICAgICAgICAgICAgLy8gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBhcyBhIGZsb2F0XG4gICAgICAgIGNhc2UgJ2Zsb2F0X21pY3Jvc2Vjb25kJzogcmV0dXJuICAobXMgKiAxMDAwKTsgICAgICAgICAvLyBudW1iZXIgb2YgbWljcm9zZWNvbmRzIGFzIGEgZmxvYXRcbiAgICAgICAgY2FzZSAnc2Vjb25kJzogICAgICAgICAgICByZXR1cm4gKChtcyAvIDEwMDApICAgIHwgMCk7IC8vIG51bWJlciBvZiBzZWNvbmRzIGFzIGFuIGludGVnZXJcbiAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOiAgICAgICByZXR1cm4gKChtcyAvIDEpICAgICAgIHwgMCk7IC8vIG51bWJlciBvZiBtaWxsaXNlY29uZHMgYXMgYW4gaW50ZWdlclxuICAgICAgICBjYXNlICdtaWNyb3NlY29uZCc6ICAgICAgIHJldHVybiAoKG1zICogMTAwMCkgICAgfCAwKTsgLy8gbnVtYmVyIG9mIG1pY3Jvc2Vjb25kcyBhcyBhbiBpbnRlZ2VyXG4gICAgICAgIGNhc2UgJ25hbm9zZWNvbmQnOiAgICAgICAgcmV0dXJuICgobXMgKiAxMDAwMDAwKSB8IDApOyAvLyBudW1iZXIgb2YgbmFub3NlY29uZHMgYXMgYW4gaW50ZWdlclxuICAgICAgICBkZWZhdWx0OiAjezo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ1bmV4cGVjdGVkIHVuaXQ6ICN7dW5pdH1cIn1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6UHJvY2Vzcz4iLCJAX19jbG9ja3NfXyIsIl9fcmVnaXN0ZXJfY2xvY2tfXyIsInNlbGYiLCJuYW1lIiwiZnVuYyIsImNvbnN0X3NldCIsInNpemUiLCI8PCIsIm1vbm90b25pYyIsInBpZCIsIjAiLCJ0aW1lcyIsInQiLCJUaW1lIiwibm93IiwidG9fZiIsIkJlbmNobWFyazo6VG1zIiwiQmVuY2htYXJrIiwibmV3IiwiY2xvY2tfZ2V0dGltZSIsImNsb2NrX2lkIiwidW5pdCIsIiRyZXRfb3JfMSIsImNsb2NrIiwiW10iLCJLZXJuZWwiLCJyYWlzZSIsIkVycm5vOjpFSU5WQUwiLCJFcnJubyIsIkFyZ3VtZW50RXJyb3IiXSwibWFwcGluZ3MiOiJBQUFBQSxrQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUVBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNFQyxrQkFBYztJQUNkQyxNQUFJQyxJQUFKRCx5QkFBQUEsOEJBQTRCRSxJQUFELEVBQU9DLElBQWxDSDtBQUFBQSxNQUFBQTtBQUFBQTs7O01BQ0VDLElBQUFHLFdBQUFBLENBQVVGLElBQVYsRUFBZ0JILGVBQVdNLE1BQUFBLENBQUFBLENBQTNCRDtNQUNBSixPQUFBRCxlQUFZTyxPQUFBQSxDQUFHSCxJQUFIRztJQUZkTixDQUFBQTtJQUtBQyxJQUFBRCxvQkFBQUEsQ0FBbUIsZ0JBQW5CLEVBQXFDRixnQ0FBckNFO0lBRUFPLFlBQVk7O0FBR2RUO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtJQUVFLElBQUEsUUFBbURTLFNBQW5ELENBQUE7TUFBQU4sSUFBQUQsb0JBQUFBLENBQW1CLGlCQUFuQixFQUFxQ08sU0FBckNQO0lBQUE7SUFFQVEsTUFBSVAsSUFBSk8sVUFBQUEsWUFDRUMsQ0FERkQsQ0FBQUE7SUFJQUUsTUFBSVQsSUFBSlMsWUFBQUEsaUJBQUFBO0FBQUFBLE1BQUFBOzs7TUFDRUMsSUFBSUMsV0FBTUMsS0FBQUEsQ0FBQUEsQ0FBSUMsTUFBQUEsQ0FBQUE7TUFDZEosT0FBQUssSUFBQUMsZ0JBQUFELFFBQWdCRSxLQUFBQSxDQUFLTixDQUFyQixFQUF3QkEsQ0FBeEIsRUFBMkJBLENBQTNCLEVBQThCQSxDQUE5QixFQUFpQ0EsQ0FBakJNO0lBRmxCUCxDQUFBQTtJQUtBWixPQUFBb0IsTUFBSWpCLElBQUppQixvQkFBQUEseUJBQXVCQyxRQUFELEVBQVdDLElBQWpDRjtBQUFBQSxNQUFBQTtBQUFBQTs7O01BQWlDLHlCQUFPO01BQ3RDLElBQUEsUUFBQUcsQ0FBQUEsWUFBQ0MsQ0FBQUEsUUFBUXZCLGVBQVd3QixPQUFBQSxDQUFDSixRQUFESSxDQUFuQkQsQ0FBREQsQ0FBQSxDQUFBO1FBQUE7TUFBQTtRQUFtQ0csT0FBUUMsT0FBQUEsQ0FBT0MsSUFBQUMsWUFBQUQsV0FBZixFQUFpQ1IsZ0JBQUQsR0FBQSxDQUFpQkMsUUFBakIsQ0FBQSxHQUEwQkQsSUFBMUIsR0FBQSxDQUE4Qm5CLGVBQVd3QixPQUFBQSxDQUFDSixRQUFESSxDQUF6QyxDQUF4QkU7TUFBM0M7O0FBRUpQO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLGlCQUFtQk0sT0FBUUMsT0FBQUEsQ0FBT0csb0JBQWYsRUFBaUNWLG1CQUFELEdBQUEsQ0FBb0JFLElBQXBCLENBQXhCSztBQUMzQlA7QUFDQUE7SUFkRUEsQ0FBQUEsSUFBQUE7RUF4Q0ZwQixHQUFPLElBQVBBO0FBRkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNDMzMywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmFuZG9tL2Zvcm1hdHRlci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcblxuY2xhc3MgOjpSYW5kb21cbiAgbW9kdWxlIHNlbGY6OkZvcm1hdHRlclxuICAgIGRlZiBoZXgoY291bnQgPSBuaWwpXG4gICAgICBjb3VudCA9IDo6UmFuZG9tLl92ZXJpZnlfY291bnQoY291bnQpXG4gICAgICAleHtcbiAgICAgICAgdmFyIGJ5dGVzID0gI3tieXRlcyhjb3VudCl9O1xuICAgICAgICB2YXIgb3V0ID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAje2NvdW50fTsgaSsrKSB7XG4gICAgICAgICAgb3V0ICs9IGJ5dGVzLmNoYXJDb2RlQXQoaSkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICN7YG91dGAuZW5jb2RlKCdVUy1BU0NJSScpfTtcbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGRlZiByYW5kb21fYnl0ZXMoY291bnQgPSBuaWwpXG4gICAgICBieXRlcyhjb3VudClcbiAgICBlbmRcblxuICAgIGRlZiBiYXNlNjQoY291bnQgPSBuaWwpXG4gICAgICA6OkJhc2U2NC5zdHJpY3RfZW5jb2RlNjQocmFuZG9tX2J5dGVzKGNvdW50KSkuZW5jb2RlKCdVUy1BU0NJSScpXG4gICAgZW5kXG5cbiAgICBkZWYgdXJsc2FmZV9iYXNlNjQoY291bnQgPSBuaWwsIHBhZGRpbmcgPSBmYWxzZSlcbiAgICAgIDo6QmFzZTY0LnVybHNhZmVfZW5jb2RlNjQocmFuZG9tX2J5dGVzKGNvdW50KSwgcGFkZGluZykuZW5jb2RlKCdVUy1BU0NJSScpXG4gICAgZW5kXG5cbiAgICBkZWYgdXVpZFxuICAgICAgc3RyID0gaGV4KDE2KS5zcGxpdCgnJylcbiAgICAgIHN0clsxMl0gPSAnNCdcbiAgICAgIHN0clsxNl0gPSBgKHBhcnNlSW50KCN7c3RyWzE2XX0sIDE2KSAmIDMgfCA4KS50b1N0cmluZygxNilgXG4gICAgICBzdHIgPSBbc3RyWzAuLi44XSwgc3RyWzguLi4xMl0sIHN0clsxMi4uLjE2XSwgc3RyWzE2Li4uMjBdLCBzdHJbMjAuLi4zMl1dXG4gICAgICBzdHIgPSBzdHIubWFwKCY6am9pbilcbiAgICAgIHN0ci5qb2luKCctJylcbiAgICBlbmRcblxuICAgICMgSW1wbGVtZW50ZWQgaW4gdGVybXMgb2YgYCNieXRlc2AgZm9yIFNlY3VyZVJhbmRvbSwgYnV0IFJhbmRvbSBvdmVycmlkZXMgdGhpc1xuICAgICMgbWV0aG9kIHRvIGltcGxlbWVudCBgI2J5dGVzYCBpbiB0ZXJtcyBvZiBgI3JhbmRvbV9mbG9hdGAuIE5vdCBwYXJ0IG9mIHN0YW5kYXJkXG4gICAgIyBSdWJ5IGludGVyZmFjZSAtIHVzZSByYW5kb21fbnVtYmVyIGZvciBwb3J0YWJpbGl0eS5cbiAgICBkZWYgcmFuZG9tX2Zsb2F0XG4gICAgICBicyA9IGJ5dGVzKDQpXG4gICAgICBudW0gPSAwXG4gICAgICA0LnRpbWVzIGRvIHxpfFxuICAgICAgICBudW0gPDw9IDhcbiAgICAgICAgbnVtIHw9IGJzW2ldLm9yZFxuICAgICAgZW5kXG4gICAgICBudW0uYWJzIC8gMHg3ZmZmZmZmZlxuICAgIGVuZFxuXG4gICAgZGVmIHJhbmRvbV9udW1iZXIobGltaXQgPSB1bmRlZmluZWQpXG4gICAgICAleHtcbiAgICAgICAgZnVuY3Rpb24gcmFuZG9tRmxvYXQoKSB7XG4gICAgICAgICAgcmV0dXJuICN7cmFuZG9tX2Zsb2F0fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJhbmRvbUludChtYXgpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihyYW5kb21GbG9hdCgpICogbWF4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJhbmRvbVJhbmdlKCkge1xuICAgICAgICAgIHZhciBtaW4gPSBsaW1pdC5iZWdpbixcbiAgICAgICAgICAgICAgbWF4ID0gbGltaXQuZW5kO1xuXG4gICAgICAgICAgaWYgKG1pbiA9PT0gbmlsIHx8IG1heCA9PT0gbmlsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBsZW5ndGggPSBtYXggLSBtaW47XG5cbiAgICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbWluO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtYXggJSAxID09PSAwICYmIG1pbiAlIDEgPT09IDAgJiYgIWxpbWl0LmV4Y2wpIHtcbiAgICAgICAgICAgIGxlbmd0aCsrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByYW5kb21JbnQobGVuZ3RoKSArIG1pbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaW1pdCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHJhbmRvbUZsb2F0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAobGltaXQuJCRpc19yYW5nZSkge1xuICAgICAgICAgIHJldHVybiByYW5kb21SYW5nZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGxpbWl0LiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICAgaWYgKGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgYXJndW1lbnQgLSAje2xpbWl0fVwifVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsaW1pdCAlIDEgPT09IDApIHtcbiAgICAgICAgICAgIC8vIGludGVnZXJcbiAgICAgICAgICAgIHJldHVybiByYW5kb21JbnQobGltaXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmFuZG9tRmxvYXQoKSAqIGxpbWl0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaW1pdCA9ICN7OjpPcGFsLmNvZXJjZV90byEobGltaXQsIDo6SW50ZWdlciwgOnRvX2ludCl9O1xuXG4gICAgICAgICAgaWYgKGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcImludmFsaWQgYXJndW1lbnQgLSAje2xpbWl0fVwifVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByYW5kb21JbnQobGltaXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBkZWYgYWxwaGFudW1lcmljKGNvdW50ID0gbmlsKVxuICAgICAgY291bnQgPSBSYW5kb20uX3ZlcmlmeV9jb3VudChjb3VudClcbiAgICAgIG1hcCA9IFsnMCcuLic5JywgJ2EnLi4neicsICdBJy4uJ1onXS5tYXAoJjp0b19hKS5mbGF0dGVuXG4gICAgICA6OkFycmF5Lm5ldyhjb3VudCkgZG8gfGl8XG4gICAgICAgIG1hcFtyYW5kb21fbnVtYmVyKG1hcC5sZW5ndGgpXVxuICAgICAgZW5kLmpvaW5cbiAgICBlbmRcbiAgZW5kXG5cbiAgaW5jbHVkZSA6OlJhbmRvbTo6Rm9ybWF0dGVyXG4gIGV4dGVuZCA6OlJhbmRvbTo6Rm9ybWF0dGVyXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOlJhbmRvbT4iLCI8bW9kdWxlOnNlbGY6OkZvcm1hdHRlcj4iLCJoZXgiLCJjb3VudCIsIlJhbmRvbSIsIl92ZXJpZnlfY291bnQiLCJzZWxmIiwiYnl0ZXMiLCJlbmNvZGUiLCJyYW5kb21fYnl0ZXMiLCJiYXNlNjQiLCJCYXNlNjQiLCJzdHJpY3RfZW5jb2RlNjQiLCJ1cmxzYWZlX2Jhc2U2NCIsInBhZGRpbmciLCJ1cmxzYWZlX2VuY29kZTY0IiwidXVpZCIsInN0ciIsIjE2Iiwic3BsaXQiLCJbXT0iLCIxMiIsIltdIiwiMCIsIjgiLCIyMCIsIjMyIiwibWFwIiwidG9fcHJvYyIsImpvaW4iLCJyYW5kb21fZmxvYXQiLCJicyIsIjQiLCJudW0iLCJ0aW1lcyIsImJsb2NrIGluIHJhbmRvbV9mbG9hdCIsImkiLCI8PCIsImJsb2NrICgyIGxldmVscykgaW4gcmFuZG9tX2Zsb2F0IiwifCIsIm9yZCIsIi8iLCJhYnMiLCIyMTQ3NDgzNjQ3IiwicmFuZG9tX251bWJlciIsImxpbWl0IiwiS2VybmVsIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwiT3BhbCIsImNvZXJjZV90byEiLCJJbnRlZ2VyIiwiYWxwaGFudW1lcmljIiwiZmxhdHRlbiIsIm5ldyIsIkFycmF5IiwiYmxvY2sgaW4gYWxwaGFudW1lcmljIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBhbHBoYW51bWVyaWMiLCJsZW5ndGgiLCJpbmNsdWRlIiwiUmFuZG9tOjpGb3JtYXR0ZXIiLCJleHRlbmQiXSwibWFwcGluZ3MiOiJBQUFBQSwyQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUVBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNFQztJQUFBQTs7TUFBQUE7Ozs7QUFDRUMsTUFBQUEsbUJBQUFBLGVBQVFDLEtBQVJEO0FBQUFBLFFBQUFBOzs7UUFBUSwyQkFBUTtRQUNkQyxRQUFRQyxhQUFRQyxlQUFBQSxDQUFlRixLQUFmRTs7QUFFdEJILG9CQUFzQkksSUFBQUMsT0FBQUEsQ0FBTUosS0FBTkksQ0FBYUw7QUFDbkNBO0FBQ0FBLDRCQUE4QkMsS0FBTUQ7QUFDcENBO0FBQ0FBO0FBQ0FBLGVBQWlCQSxDQUFDQSxHQUFEQSxDQUFLTSxRQUFBQSxDQUFRTixVQUFSTSxDQUFvQk47QUFDMUNBO01BVElBLENBQUFBLElBQUFBOztBQVlBTyxNQUFBQSw0QkFBQUEsd0JBQWlCTixLQUFqQk07QUFBQUEsUUFBQUE7OztRQUFpQiwyQkFBUTtRQUN2QkEsT0FBQUgsSUFBQUMsT0FBQUEsQ0FBTUosS0FBTkk7TUFERkUsQ0FBQUEsSUFBQUE7O0FBSUFDLE1BQUFBLHNCQUFBQSxrQkFBV1AsS0FBWE87QUFBQUEsUUFBQUE7OztRQUFXLDJCQUFRO1FBQ2pCQSxPQUFBQyxhQUFRQyxpQkFBQUEsQ0FBaUJOLElBQUFHLGNBQUFBLENBQWFOLEtBQWJNLENBQWpCRyxDQUFxQ0osUUFBQUEsQ0FBUUUsVUFBUkY7TUFEL0NFLENBQUFBLElBQUFBOztBQUlBRyxNQUFBQSw4QkFBQUEsMEJBQW1CVixLQUFELEVBQWNXLE9BQWhDRDtBQUFBQSxRQUFBQTs7O1FBQW1CLDJCQUFRO1FBQUssK0JBQVU7UUFDeENBLE9BQUFGLGFBQVFJLGtCQUFBQSxDQUFrQlQsSUFBQUcsY0FBQUEsQ0FBYU4sS0FBYk0sQ0FBMUIsRUFBK0NLLE9BQXZDQyxDQUErQ1AsUUFBQUEsQ0FB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QVcsT0FBQUEsR0FBQSxFQUFLQSxHQUFMLFFBQVgsRUFBcUIsT0FBQUEsR0FBQSxFQUFLQSxHQUFMLFFBQXJCLENBQThCekIsT0FBQUEsRUFBQUEsRUFBQUEsRUFBTSxNQUFEQyxTQUFBQSxDQUFBQSxDQUFMRCxDQUFZMEIsU0FBQUEsQ0FBQUE7UUFDaERELE9BQU9FLE1BQVBDLFlBQU9ELE9BQUFBLEVBQUFBLENBQUtuRCxLQUFMbUQsQ0FBQUEsRUFBUEUsYUFBdUJwQixDQUF2Qm9CLEVBQUFDOzs7VUFBdUI7VUFDckJBLE9BQUE5QixHQUFHTCxPQUFBQSxDQUFDaEIsSUFBQXNDLGVBQUFBLENBQWNqQixHQUFHK0IsUUFBQUEsQ0FBQUEsQ0FBakJkLENBQUR0QixFQURMa0MsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBT0YsQ0FFSnpCLE1BQUFBLENBQUFBO01BTEx1QixDQUFBQSxJQUFBQTtJQTdHRm5ELEdBQU9LLElBQVBMO0lBc0hBSyxJQUFBcUQsU0FBQUEsQ0FBUUMsSUFBQXhELGFBQUF3RCxjQUFSRDtJQUNBM0QsT0FBQU0sSUFBQXVELFFBQUFBLENBQU9ELElBQUF4RCxhQUFBd0QsY0FBUEM7RUF4SEY3RCxHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBRkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNDUwMSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmFuZG9tL21lcnNlbm5lX3R3aXN0ZXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXG5cbiMgVGhpcyBpcyBiYXNlZCBvbiBhbiBhZGFwdGF0aW9uIG9mIE1ha290byBNYXRzdW1vdG8gYW5kIFRha3VqaSBOaXNoaW11cmEncyBjb2RlXG4jIGRvbmUgYnkgU2VhbiBNY0N1bGxvdWdoIDxiYW5rc2VhbkBnbWFpbC5jb20+IGFuZCBEYXZlIEhlaXR6bWFuXG4jIDxkYXZlaGVpdHptYW5AeWFob28uY29tPiwgc3Vic2VxdWVudGx5IHJlYWRhcHRlZCBmcm9tIGFuIHVwZGF0ZWQgdmVyc2lvbiBvZlxuIyBydWJ5J3MgcmFuZG9tLmMgKHJldiBjMzhhMTgzMDMyYTc4MjZkZjFhZGFiZDhhYTA3MjVjNzEzZDUzZTFjKS5cbiNcbiMgVGhlIG9yaWdpbmFsIGNvcHlyaWdodCBub3RpY2UgZnJvbSByYW5kb20uYyBmb2xsb3dzLlxuI1xuIyAgIFRoaXMgaXMgYmFzZWQgb24gdHJpbW1lZCB2ZXJzaW9uIG9mIE1UMTk5MzcuICBUbyBnZXQgdGhlIG9yaWdpbmFsIHZlcnNpb24sXG4jICAgY29udGFjdCA8aHR0cDovL3d3dy5tYXRoLnNjaS5oaXJvc2hpbWEtdS5hYy5qcC9+bS1tYXQvTVQvZW10Lmh0bWw+LlxuI1xuIyAgIFRoZSBvcmlnaW5hbCBjb3B5cmlnaHQgbm90aWNlIGZvbGxvd3MuXG4jXG4jICAgICAgQSBDLXByb2dyYW0gZm9yIE1UMTk5MzcsIHdpdGggaW5pdGlhbGl6YXRpb24gaW1wcm92ZWQgMjAwMi8yLzEwLlxuIyAgICAgIENvZGVkIGJ5IFRha3VqaSBOaXNoaW11cmEgYW5kIE1ha290byBNYXRzdW1vdG8uXG4jICAgICAgVGhpcyBpcyBhIGZhc3RlciB2ZXJzaW9uIGJ5IHRha2luZyBTaGF3biBDb2t1cydzIG9wdGltaXphdGlvbixcbiMgICAgICBNYXR0aGUgQmVsbGV3J3Mgc2ltcGxpZmljYXRpb24sIElzYWt1IFdhZGEncyByZWFsIHZlcnNpb24uXG4jXG4jICAgICAgQmVmb3JlIHVzaW5nLCBpbml0aWFsaXplIHRoZSBzdGF0ZSBieSB1c2luZyBpbml0X2dlbnJhbmQobXQsIHNlZWQpXG4jICAgICAgb3IgaW5pdF9ieV9hcnJheShtdCwgaW5pdF9rZXksIGtleV9sZW5ndGgpLlxuI1xuIyAgICAgIENvcHlyaWdodCAoQykgMTk5NyAtIDIwMDIsIE1ha290byBNYXRzdW1vdG8gYW5kIFRha3VqaSBOaXNoaW11cmEsXG4jICAgICAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiNcbiMgICAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiMgICAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiMgICAgICBhcmUgbWV0OlxuI1xuIyAgICAgICAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiMgICAgICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiNcbiMgICAgICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4jICAgICAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4jICAgICAgICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuI1xuIyAgICAgICAgMy4gVGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IG5vdCBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZVxuIyAgICAgICAgICAgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuXG4jICAgICAgICAgICBwZXJtaXNzaW9uLlxuI1xuIyAgICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiMgICAgICBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4jICAgICAgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4jICAgICAgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SXG4jICAgICAgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXG4jICAgICAgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuIyAgICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuIyAgICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiMgICAgICBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuIyAgICAgIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuIyAgICAgIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuI1xuI1xuIyAgICAgIEFueSBmZWVkYmFjayBpcyB2ZXJ5IHdlbGNvbWUuXG4jICAgICAgaHR0cDovL3d3dy5tYXRoLmtlaW8uYWMuanAvbWF0dW1vdG8vZW10Lmh0bWxcbiMgICAgICBlbWFpbDogbWF0dW1vdG9AbWF0aC5rZWlvLmFjLmpwXG5tZXJzZW5uZV90d2lzdGVyID0gJXh7KGZ1bmN0aW9uKCkge1xuICAvKiBQZXJpb2QgcGFyYW1ldGVycyAqL1xuICB2YXIgTiA9IDYyNDtcbiAgdmFyIE0gPSAzOTc7XG4gIHZhciBNQVRSSVhfQSA9IDB4OTkwOGIwZGY7ICAgICAgLyogY29uc3RhbnQgdmVjdG9yIGEgKi9cbiAgdmFyIFVNQVNLID0gMHg4MDAwMDAwMDsgICAgICAgICAvKiBtb3N0IHNpZ25pZmljYW50IHctciBiaXRzICovXG4gIHZhciBMTUFTSyA9IDB4N2ZmZmZmZmY7ICAgICAgICAgLyogbGVhc3Qgc2lnbmlmaWNhbnQgciBiaXRzICovXG4gIHZhciBNSVhCSVRTID0gZnVuY3Rpb24odSx2KSB7IHJldHVybiAoICgodSkgJiBVTUFTSykgfCAoKHYpICYgTE1BU0spICk7IH07XG4gIHZhciBUV0lTVCA9IGZ1bmN0aW9uKHUsdikgeyByZXR1cm4gKE1JWEJJVFMoKHUpLCh2KSkgPj4+IDEpIF4gKCh2ICYgMHgxKSA/IE1BVFJJWF9BIDogMHgwKTsgfTtcblxuICBmdW5jdGlvbiBpbml0KHMpIHtcbiAgICB2YXIgbXQgPSB7bGVmdDogMCwgbmV4dDogTiwgc3RhdGU6IG5ldyBBcnJheShOKX07XG4gICAgaW5pdF9nZW5yYW5kKG10LCBzKTtcbiAgICByZXR1cm4gbXQ7XG4gIH1cblxuICAvKiBpbml0aWFsaXplcyBtdFtOXSB3aXRoIGEgc2VlZCAqL1xuICBmdW5jdGlvbiBpbml0X2dlbnJhbmQobXQsIHMpIHtcbiAgICB2YXIgaiwgaTtcbiAgICBtdC5zdGF0ZVswXSA9IHMgPj4+IDA7XG4gICAgZm9yIChqPTE7IGo8TjsgaisrKSB7XG4gICAgICBtdC5zdGF0ZVtqXSA9ICgxODEyNDMzMjUzICogKChtdC5zdGF0ZVtqLTFdIF4gKG10LnN0YXRlW2otMV0gPj4gMzApID4+PiAwKSkgKyBqKTtcbiAgICAgIC8qIFNlZSBLbnV0aCBUQU9DUCBWb2wyLiAzcmQgRWQuIFAuMTA2IGZvciBtdWx0aXBsaWVyLiAqL1xuICAgICAgLyogSW4gdGhlIHByZXZpb3VzIHZlcnNpb25zLCBNU0JzIG9mIHRoZSBzZWVkIGFmZmVjdCAgICovXG4gICAgICAvKiBvbmx5IE1TQnMgb2YgdGhlIGFycmF5IHN0YXRlW10uICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgIC8qIDIwMDIvMDEvMDkgbW9kaWZpZWQgYnkgTWFrb3RvIE1hdHN1bW90byAgICAgICAgICAgICAqL1xuICAgICAgbXQuc3RhdGVbal0gJj0gMHhmZmZmZmZmZjsgIC8qIGZvciA+MzIgYml0IG1hY2hpbmVzICovXG4gICAgfVxuICAgIG10LmxlZnQgPSAxO1xuICAgIG10Lm5leHQgPSBOO1xuICB9XG5cbiAgLyogZ2VuZXJhdGUgTiB3b3JkcyBhdCBvbmUgdGltZSAqL1xuICBmdW5jdGlvbiBuZXh0X3N0YXRlKG10KSB7XG4gICAgdmFyIHAgPSAwLCBfcCA9IG10LnN0YXRlO1xuICAgIHZhciBqO1xuXG4gICAgbXQubGVmdCA9IE47XG4gICAgbXQubmV4dCA9IDA7XG5cbiAgICBmb3IgKGo9Ti1NKzE7IC0tajsgcCsrKVxuICAgICAgX3BbcF0gPSBfcFtwKyhNKV0gXiBUV0lTVChfcFtwKygwKV0sIF9wW3ArKDEpXSk7XG5cbiAgICBmb3IgKGo9TTsgLS1qOyBwKyspXG4gICAgICBfcFtwXSA9IF9wW3ArKE0tTildIF4gVFdJU1QoX3BbcCsoMCldLCBfcFtwKygxKV0pO1xuXG4gICAgX3BbcF0gPSBfcFtwKyhNLU4pXSBeIFRXSVNUKF9wW3ArKDApXSwgX3BbMF0pO1xuICB9XG5cbiAgLyogZ2VuZXJhdGVzIGEgcmFuZG9tIG51bWJlciBvbiBbMCwweGZmZmZmZmZmXS1pbnRlcnZhbCAqL1xuICBmdW5jdGlvbiBnZW5yYW5kX2ludDMyKG10KSB7XG4gICAgLyogbXQgbXVzdCBiZSBpbml0aWFsaXplZCAqL1xuICAgIHZhciB5O1xuXG4gICAgaWYgKC0tbXQubGVmdCA8PSAwKSBuZXh0X3N0YXRlKG10KTtcbiAgICB5ID0gbXQuc3RhdGVbbXQubmV4dCsrXTtcblxuICAgIC8qIFRlbXBlcmluZyAqL1xuICAgIHkgXj0gKHkgPj4+IDExKTtcbiAgICB5IF49ICh5IDw8IDcpICYgMHg5ZDJjNTY4MDtcbiAgICB5IF49ICh5IDw8IDE1KSAmIDB4ZWZjNjAwMDA7XG4gICAgeSBePSAoeSA+Pj4gMTgpO1xuXG4gICAgcmV0dXJuIHkgPj4+IDA7XG4gIH1cblxuICBmdW5jdGlvbiBpbnRfcGFpcl90b19yZWFsX2V4Y2x1c2l2ZShhLCBiKSB7XG4gICAgYSA+Pj49IDU7XG4gICAgYiA+Pj49IDY7XG4gICAgcmV0dXJuKGEqNjcxMDg4NjQuMCtiKSooMS4wLzkwMDcxOTkyNTQ3NDA5OTIuMCk7XG4gIH1cblxuICAvLyBnZW5lcmF0ZXMgYSByYW5kb20gbnVtYmVyIG9uIFswLDEpIHdpdGggNTMtYml0IHJlc29sdXRpb25cbiAgZnVuY3Rpb24gZ2VucmFuZF9yZWFsKG10KSB7XG4gICAgLyogbXQgbXVzdCBiZSBpbml0aWFsaXplZCAqL1xuICAgIHZhciBhID0gZ2VucmFuZF9pbnQzMihtdCksIGIgPSBnZW5yYW5kX2ludDMyKG10KTtcbiAgICByZXR1cm4gaW50X3BhaXJfdG9fcmVhbF9leGNsdXNpdmUoYSwgYik7XG4gIH1cblxuICByZXR1cm4geyBnZW5yYW5kX3JlYWw6IGdlbnJhbmRfcmVhbCwgaW5pdDogaW5pdCB9O1xufSkoKX1cblxuY2xhc3MgOjpSYW5kb21cbiAgYHZhciBNQVhfSU5UID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgTWF0aC5wb3coMiwgNTMpIC0gMWBcblxuICBzZWxmOjpNRVJTRU5ORV9UV0lTVEVSX0dFTkVSQVRPUiA9IGB7XG4gICAgbmV3X3NlZWQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogTUFYX0lOVCk7IH0sXG4gICAgcmVzZWVkOiBmdW5jdGlvbihzZWVkKSB7IHJldHVybiBtZXJzZW5uZV90d2lzdGVyLmluaXQoc2VlZCk7IH0sXG4gICAgcmFuZDogZnVuY3Rpb24obXQpIHsgcmV0dXJuIG1lcnNlbm5lX3R3aXN0ZXIuZ2VucmFuZF9yZWFsKG10KTsgfVxuICB9YFxuXG4gIHNlbGYuZ2VuZXJhdG9yID0gc2VsZjo6TUVSU0VOTkVfVFdJU1RFUl9HRU5FUkFUT1JcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJtZXJzZW5uZV90d2lzdGVyIiwiPGNsYXNzOlJhbmRvbT4iLCJzZWxmIiwiZ2VuZXJhdG9yPSIsInNlbGY6Ok1FUlNFTk5FX1RXSVNURVJfR0VORVJBVE9SIl0sIm1hcHBpbmdzIjoiQUFBQUEsa0RBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBd0RBQyxtQkFBc0JEO0FBQ3RCQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0VBRUFBLE9BQUFFO0VBQUFBOztJQUFBQTs7O0lBQ0dBO0lBRUQsV0FBQUMsSUFBQSxnQ0FBb0NEO0FBQ3RDQTtBQUNBQTtBQUNBQTtBQUNBQSxHQUpFO0lBTUFBLE9BQUlFLE1BQUFBLENBQWFDLElBQUFGLElBQUFFLCtCQUFiRCxDQUFBQSxFQUFBQSxNQUFKRCxJQUFJQyxjQUFBQSxFQUFBQSxFQUFBQSxDQUFBQSxFQUFBQTtFQVRORixHQUFNLElBQU5BLEVBQUFBLElBQUFBO0FBMUlBRjsifX0seyJvZmZzZXQiOnsibGluZSI6MjQ2MDMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3JhbmRvbS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHRydXRoeVxuIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXG5cbnJlcXVpcmUgJ2NvcmVsaWIvcmFuZG9tL2Zvcm1hdHRlcidcblxuY2xhc3MgOjpSYW5kb21cbiAgYXR0cl9yZWFkZXIgOnNlZWQsIDpzdGF0ZVxuXG4gIGRlZiBzZWxmLl92ZXJpZnlfY291bnQoY291bnQpXG4gICAgJXh7XG4gICAgICBpZiAoISR0cnV0aHkoY291bnQpKSBjb3VudCA9IDE2O1xuICAgICAgaWYgKHR5cGVvZiBjb3VudCAhPT0gXCJudW1iZXJcIikgY291bnQgPSAje2Bjb3VudGAudG9faW50fTtcbiAgICAgIGlmIChjb3VudCA8IDApICN7OjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgc3RyaW5nIHNpemUgKG9yIHNpemUgdG9vIGJpZyknfTtcbiAgICAgIGNvdW50ID0gTWF0aC5mbG9vcihjb3VudCk7XG4gICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZShzZWVkID0gOjpSYW5kb20ubmV3X3NlZWQpXG4gICAgc2VlZCA9IDo6T3BhbC5jb2VyY2VfdG8hKHNlZWQsIDo6SW50ZWdlciwgOnRvX2ludClcbiAgICBAc3RhdGUgPSBzZWVkXG4gICAgcmVzZWVkKHNlZWQpXG4gIGVuZFxuXG4gIGRlZiByZXNlZWQoc2VlZClcbiAgICBAc2VlZCA9IHNlZWRcbiAgICBgc2VsZi4kcm5nID0gT3BhbC4kJHJhbmQucmVzZWVkKHNlZWQpYFxuICBlbmRcblxuICBkZWYgc2VsZi5uZXdfc2VlZFxuICAgIGBPcGFsLiQkcmFuZC5uZXdfc2VlZCgpYFxuICBlbmRcblxuICBkZWYgc2VsZi5yYW5kKGxpbWl0ID0gdW5kZWZpbmVkKVxuICAgIHNlbGY6OkRFRkFVTFQucmFuZChsaW1pdClcbiAgZW5kXG5cbiAgZGVmIHNlbGYuc3JhbmQobiA9IDo6UmFuZG9tLm5ld19zZWVkKVxuICAgIG4gPSA6Ok9wYWwuY29lcmNlX3RvIShuLCA6OkludGVnZXIsIDp0b19pbnQpXG5cbiAgICBwcmV2aW91c19zZWVkID0gc2VsZjo6REVGQVVMVC5zZWVkXG4gICAgc2VsZjo6REVGQVVMVC5yZXNlZWQobilcbiAgICBwcmV2aW91c19zZWVkXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnVyYW5kb20oc2l6ZSlcbiAgICA6OlNlY3VyZVJhbmRvbS5ieXRlcyhzaXplKVxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyA6OlJhbmRvbSA9PT0gb3RoZXJcblxuICAgIHNlZWQgPT0gb3RoZXIuc2VlZCAmJiBzdGF0ZSA9PSBvdGhlci5zdGF0ZVxuICBlbmRcblxuICBkZWYgYnl0ZXMobGVuZ3RoKVxuICAgIGxlbmd0aCA9IDo6UmFuZG9tLl92ZXJpZnlfY291bnQobGVuZ3RoKVxuXG4gICAgOjpBcnJheS5uZXcobGVuZ3RoKSB7IHJhbmQoMjU1KS5jaHIgfS5qb2luLmVuY29kZSgnQVNDSUktOEJJVCcpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmJ5dGVzKGxlbmd0aClcbiAgICBzZWxmOjpERUZBVUxULmJ5dGVzKGxlbmd0aClcbiAgZW5kXG5cbiAgZGVmIHJhbmQobGltaXQgPSB1bmRlZmluZWQpXG4gICAgcmFuZG9tX251bWJlcihsaW1pdClcbiAgZW5kXG5cbiAgIyBOb3QgcGFydCBvZiB0aGUgUnVieSBpbnRlcmZhY2UgKHVzZSAjcmFuZG9tX251bWJlciBmb3IgcG9ydGFiaWxpdHkpLCBidXRcbiAgIyB1c2VkIGJ5IFJhbmRvbTo6Rm9ybWF0dGVyIGFzIGEgc2hvcnRjdXQsIGFzIGZvciBSYW5kb20gaW50ZXJmYWNlIHRoZSBmbG9hdFxuICAjIFJORyBpcyBwcmltYXJ5LlxuICBkZWYgcmFuZG9tX2Zsb2F0XG4gICAgJXh7XG4gICAgICBzZWxmLnN0YXRlKys7XG4gICAgICByZXR1cm4gT3BhbC4kJHJhbmQucmFuZChzZWxmLiRybmcpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYucmFuZG9tX2Zsb2F0XG4gICAgc2VsZjo6REVGQVVMVC5yYW5kb21fZmxvYXRcbiAgZW5kXG5cbiAgZGVmIHNlbGYuZ2VuZXJhdG9yPShnZW5lcmF0b3IpXG4gICAgYE9wYWwuJCRyYW5kID0gI3tnZW5lcmF0b3J9YFxuXG4gICAgaWYgY29uc3RfZGVmaW5lZD8gOkRFRkFVTFRcbiAgICAgIHNlbGY6OkRFRkFVTFQucmVzZWVkXG4gICAgZWxzZVxuICAgICAgY29uc3Rfc2V0IDpERUZBVUxULCBuZXcobmV3X3NlZWQpXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbnJlcXVpcmUgJ2NvcmVsaWIvcmFuZG9tL21lcnNlbm5lX3R3aXN0ZXInXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOlJhbmRvbT4iLCJhdHRyX3JlYWRlciIsIl92ZXJpZnlfY291bnQiLCJjb3VudCIsInRvX2ludCIsIktlcm5lbCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsImluaXRpYWxpemUiLCJzZWVkIiwiUmFuZG9tIiwibmV3X3NlZWQiLCJPcGFsIiwiY29lcmNlX3RvISIsIkludGVnZXIiLCJAc3RhdGUiLCJyZXNlZWQiLCJAc2VlZCIsInJhbmQiLCJsaW1pdCIsInNlbGY6OkRFRkFVTFQiLCJzcmFuZCIsIm4iLCJwcmV2aW91c19zZWVkIiwidXJhbmRvbSIsInNpemUiLCJTZWN1cmVSYW5kb20iLCJieXRlcyIsIj09Iiwib3RoZXIiLCIkcmV0X29yXzEiLCJzdGF0ZSIsImxlbmd0aCIsIm5ldyIsIkFycmF5IiwiYmxvY2sgaW4gYnl0ZXMiLCJibG9jayAoMiBsZXZlbHMpIGluIGJ5dGVzIiwiMjU1IiwiY2hyIiwiam9pbiIsImVuY29kZSIsInJhbmRvbV9udW1iZXIiLCJyYW5kb21fZmxvYXQiLCJnZW5lcmF0b3I9IiwiZ2VuZXJhdG9yIiwiY29uc3RfZGVmaW5lZD8iLCJjb25zdF9zZXQiXSwibWFwcGluZ3MiOiJBQUFBQSxpQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFHQUMsSUFBQUMsU0FBQUEsQ0FBUUYsMEJBQVJFO0VBRUFDO0VBQUFBOzs7O0lBQ0VGLElBQUFHLGFBQUFBLENBQVksTUFBWixFQUFtQixPQUFuQkE7SUFFQUMsTUFBSUosSUFBSkksb0JBQUFBLHlCQUF1QkMsS0FBdkJEO0FBQUFBOztBQUVGQTtBQUNBQSw2Q0FBK0NBLENBQUNBLEtBQURBLENBQU9FLFFBQUFBLENBQUFBLENBQVFGO0FBQzlEQSxxQkFBdUJHLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWdDTCx3Q0FBeEJJLENBQWlFSjtBQUNoR0E7QUFDQUE7QUFDQUE7SUFQRUEsQ0FBQUE7O0FBVUFNLElBQUFBLDBCQUFBQSxzQkFBZUMsSUFBZkQ7QUFBQUEsTUFBQUE7OztNQUFlLHlCQUFPRSxhQUFRQyxVQUFBQSxDQUFBQTtNQUM1QkYsT0FBT0csS0FBTUMsZUFBQUEsQ0FBWUosSUFBbEIsRUFBd0JLLGNBQXhCLEVBQW1DLFFBQTdCRDtNQUNiRSxhQUFTTjtNQUNURCxPQUFBVixJQUFBa0IsUUFBQUEsQ0FBT1AsSUFBUE87SUFIRlIsQ0FBQUEsSUFBQUE7O0FBTUFRLElBQUFBLHNCQUFBQSxrQkFBV1AsSUFBWE87QUFBQUEsTUFBQUE7OztNQUNFQyxZQUFRUjtNQUNSTyxPQUFDQSxvQ0FBREE7SUFGRkEsQ0FBQUE7SUFLQUwsTUFBSWIsSUFBSmEsZUFBQUEsb0JBQUFBO0FBQUFBO01BQ0VBLE9BQUNBLHNCQUFEQTtJQURGQSxDQUFBQTtJQUlBTyxNQUFJcEIsSUFBSm9CLFdBQUFBLGdCQUFjQyxLQUFkRDtBQUFBQSxNQUFBQTs7OztNQUNFQSxPQUFBRSxJQUFBdEIsSUFBQXNCLFlBQWFGLE1BQUFBLENBQU1DLEtBQU5EO0lBRGZBLENBQUFBLElBQUFBO0lBSUFHLE1BQUl2QixJQUFKdUIsWUFBQUEsaUJBQWVDLENBQWZEO0FBQUFBLE1BQUFBOzs7TUFBZSxtQkFBSVgsYUFBUUMsVUFBQUEsQ0FBQUE7TUFDekJXLElBQUlWLEtBQU1DLGVBQUFBLENBQVlTLENBQWxCLEVBQXFCUixjQUFyQixFQUFnQyxRQUExQkQ7TUFFVlUsZ0JBQWdCSCxJQUFBdEIsSUFBQXNCLFlBQWFYLE1BQUFBLENBQUFBO01BQzdCVyxJQUFBdEIsSUFBQXNCLFlBQWFKLFFBQUFBLENBQVFNLENBQVJOO01BQ2JLLE9BQUFFO0lBTEZGLENBQUFBLElBQUFBO0lBUUFHLE1BQUkxQixJQUFKMEIsY0FBQUEsbUJBQWlCQyxJQUFqQkQ7QUFBQUE7TUFDRUEsT0FBQUUsbUJBQWNDLE9BQUFBLENBQU9GLElBQVBFO0lBRGhCSCxDQUFBQTs7QUFJQUksSUFBQUEsa0JBQUFBLDBCQUFPQyxLQUFQRDtBQUFBQSxNQUFBQTs7O01BQ0UsS0FBQSxRQUFvQmxCLGFBQXBCLEVBQWlDbUIsS0FBakMsQ0FBQTtRQUFBLE9BQU87TUFBUDtNQUVBLElBQUEsUUFBQUMsQ0FBQUEsWUFBQWhDLElBQUFXLE1BQUFBLENBQUFBLENBQUttQixPQUFBQSxDQUFHQyxLQUFLcEIsTUFBQUEsQ0FBQUEsQ0FBUm1CLENBQUxFLENBQUEsQ0FBQTtRQUFzQkYsT0FBQTlCLElBQUFpQyxPQUFBQSxDQUFBQSxDQUFNSCxPQUFBQSxDQUFHQyxLQUFLRSxPQUFBQSxDQUFBQSxDQUFSSDtNQUE1QjtRQUFBQSxPQUFBO01BQUE7SUFIRkEsQ0FBQUE7O0FBTUFELElBQUFBLHFCQUFBQSxpQkFBVUssTUFBVkw7QUFBQUEsTUFBQUE7OztNQUNFSyxTQUFTdEIsYUFBUVIsZUFBQUEsQ0FBZThCLE1BQWY5QjtNQUVqQnlCLE9BQU9NLE1BQVBDLFlBQU9ELE9BQUFBLEVBQUFBLENBQUtELE1BQUxDLENBQUFBLEVBQVBFLGFBQUFBLEVBQUFDOztRQUFzQkEsT0FBQXRDLElBQUFvQixNQUFBQSxDQUFLbUIsR0FBTG5CLENBQVNvQixLQUFBQSxDQUFBQSxDQUEvQkgsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBT0YsQ0FBOEJNLE1BQUFBLENBQUFBLENBQUtDLFFBQUFBLENBQVFiLFlBQVJhO0lBSDVDYixDQUFBQTtJQU1BQSxNQUFJN0IsSUFBSjZCLFlBQUFBLGlCQUFlSyxNQUFmTDtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQVAsSUFBQXRCLElBQUFzQixZQUFhTyxPQUFBQSxDQUFPSyxNQUFQTDtJQURmQSxDQUFBQTs7QUFJQVQsSUFBQUEsb0JBQUFBLGdCQUFTQyxLQUFURDtBQUFBQSxNQUFBQTs7OztNQUNFQSxPQUFBcEIsSUFBQTJDLGVBQUFBLENBQWN0QixLQUFkc0I7SUFERnZCLENBQUFBLElBQUFBOztBQU9Bd0IsSUFBQUEsNEJBQUFBLHdCQUFBQTtBQUFBQSxNQUFBQTs7O0FBRUZBO0FBQ0FBO0FBQ0FBO0lBSkVBLENBQUFBO0lBT0FBLE1BQUk1QyxJQUFKNEMsbUJBQUFBLHdCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQXRCLElBQUF0QixJQUFBc0IsWUFBYXNCLGNBQUFBLENBQUFBO0lBRGZBLENBQUFBO0lBSUExQyxPQUFBMkMsTUFBSTdDLElBQUo2QyxpQkFBQUEsZ0NBQW9CQyxTQUFwQkQ7QUFBQUEsTUFBQUE7OztNQUNHQSxjQUFnQkM7TUFFakIsSUFBQSxRQUFHOUMsSUFBQStDLG1CQUFBQSxDQUFlLFNBQWZBLENBQUgsQ0FBQTtRQUNFRixPQUFBdkIsSUFBQXRCLElBQUFzQixZQUFhSixRQUFBQSxDQUFBQTtNQURmO1FBR0UyQixPQUFBN0MsSUFBQWdELFdBQUFBLENBQVUsU0FBVixFQUFvQmhELElBQUFtQyxLQUFBQSxDQUFJbkMsSUFBQWEsVUFBQUEsQ0FBQUEsQ0FBSnNCLENBQXBCYTtNQUhGO0lBSEZILENBQUFBO0VBOUVGM0MsR0FBTSxJQUFOQSxFQUFBQSxJQUFBQTtFQXlGQUgsT0FBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsaUNBQVJFO0FBOUZBRjsifX0seyJvZmZzZXQiOnsibGluZSI6MjQ3MzQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3Vuc3VwcG9ydGVkLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxuXG4leHtcbiAgdmFyIHdhcm5pbmdzID0ge307XG5cbiAgZnVuY3Rpb24gaGFuZGxlX3Vuc3VwcG9ydGVkX2ZlYXR1cmUobWVzc2FnZSkge1xuICAgIHN3aXRjaCAoT3BhbC5jb25maWcudW5zdXBwb3J0ZWRfZmVhdHVyZXNfc2V2ZXJpdHkpIHtcbiAgICBjYXNlICdlcnJvcic6XG4gICAgICAjezo6S2VybmVsLnJhaXNlIDo6Tm90SW1wbGVtZW50ZWRFcnJvciwgYG1lc3NhZ2VgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnd2FybmluZyc6XG4gICAgICB3YXJuKG1lc3NhZ2UpXG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OiAvLyBpZ25vcmVcbiAgICAgIC8vIG5vb3BcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB3YXJuKHN0cmluZykge1xuICAgIGlmICh3YXJuaW5nc1tzdHJpbmddKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmluZ3Nbc3RyaW5nXSA9IHRydWU7XG4gICAgI3t3YXJuKGBzdHJpbmdgKX07XG4gIH1cbn1cblxuY2xhc3MgOjpTdHJpbmdcbiAgYHZhciBFUlJPUiA9IFwiU3RyaW5nIyVzIG5vdCBzdXBwb3J0ZWQuIE11dGFibGUgU3RyaW5nIG1ldGhvZHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gT3BhbC5cImBcblxuICAlaVtcbiAgICA8PCBjYXBpdGFsaXplISBjaG9tcCEgY2hvcCEgZG93bmNhc2UhIGdzdWIhIGxzdHJpcCEgbmV4dCEgcmV2ZXJzZSFcbiAgICBzbGljZSEgc3F1ZWV6ZSEgc3RyaXAhIHN1YiEgc3VjYyEgc3dhcGNhc2UhIHRyISB0cl9zISB1cGNhc2UhIHByZXBlbmRcbiAgICBbXT0gY2xlYXIgZW5jb2RlISB1bmljb2RlX25vcm1hbGl6ZSFcbiAgXS5lYWNoIGRvIHxtZXRob2RfbmFtZXxcbiAgICBkZWZpbmVfbWV0aG9kIG1ldGhvZF9uYW1lIGRvIHwqfFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgbWV0aG9kX25hbWVcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxubW9kdWxlIDo6S2VybmVsXG4gIGB2YXIgRVJST1IgPSBcIk9iamVjdCB0YWludGluZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IE9wYWxcImBcblxuICBkZWYgdGFpbnRcbiAgICBgaGFuZGxlX3Vuc3VwcG9ydGVkX2ZlYXR1cmUoRVJST1IpYFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHVudGFpbnRcbiAgICBgaGFuZGxlX3Vuc3VwcG9ydGVkX2ZlYXR1cmUoRVJST1IpYFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRhaW50ZWQ/XG4gICAgYGhhbmRsZV91bnN1cHBvcnRlZF9mZWF0dXJlKEVSUk9SKWBcbiAgICBmYWxzZVxuICBlbmRcbmVuZFxuXG5jbGFzcyA6Ok1vZHVsZVxuICBkZWYgcHVibGljKCptZXRob2RzKVxuICAgICV4e1xuICAgICAgaWYgKG1ldGhvZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNlbGYuJCRtb2R1bGVfZnVuY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAobWV0aG9kcy5sZW5ndGggPT09IDEpID8gbWV0aG9kc1swXSA6IG1ldGhvZHM7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcHJpdmF0ZV9jbGFzc19tZXRob2QoKm1ldGhvZHMpXG4gICAgYHJldHVybiAobWV0aG9kcy5sZW5ndGggPT09IDEpID8gbWV0aG9kc1swXSA6IG1ldGhvZHNgXG4gIGVuZFxuXG4gIGRlZiBwcml2YXRlX21ldGhvZF9kZWZpbmVkPyhvYmopXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIHByaXZhdGVfY29uc3RhbnQoKilcbiAgZW5kXG5cbiAgYWxpYXMgbmVzdGluZyBwdWJsaWNcbiAgYWxpYXMgcHJpdmF0ZSBwdWJsaWNcbiAgYWxpYXMgcHJvdGVjdGVkIHB1YmxpY1xuICBhbGlhcyBwcm90ZWN0ZWRfbWV0aG9kX2RlZmluZWQ/IHByaXZhdGVfbWV0aG9kX2RlZmluZWQ/XG4gIGFsaWFzIHB1YmxpY19jbGFzc19tZXRob2QgcHJpdmF0ZV9jbGFzc19tZXRob2RcbiAgYWxpYXMgcHVibGljX2luc3RhbmNlX21ldGhvZCBpbnN0YW5jZV9tZXRob2RcbiAgYWxpYXMgcHVibGljX2luc3RhbmNlX21ldGhvZHMgaW5zdGFuY2VfbWV0aG9kc1xuICBhbGlhcyBwdWJsaWNfbWV0aG9kX2RlZmluZWQ/IG1ldGhvZF9kZWZpbmVkP1xuZW5kXG5cbm1vZHVsZSA6Oktlcm5lbFxuICBkZWYgcHJpdmF0ZV9tZXRob2RzKCptZXRob2RzKVxuICAgIFtdXG4gIGVuZFxuXG4gIGFsaWFzIHByb3RlY3RlZF9tZXRob2RzIHByaXZhdGVfbWV0aG9kc1xuICBhbGlhcyBwcml2YXRlX2luc3RhbmNlX21ldGhvZHMgcHJpdmF0ZV9tZXRob2RzXG4gIGFsaWFzIHByb3RlY3RlZF9pbnN0YW5jZV9tZXRob2RzIHByaXZhdGVfbWV0aG9kc1xuZW5kXG5cbm1vZHVsZSA6Oktlcm5lbFxuICBkZWYgZXZhbCgqKVxuICAgIDo6S2VybmVsLnJhaXNlIDo6Tm90SW1wbGVtZW50ZWRFcnJvciwgXCJUbyB1c2UgS2VybmVsI2V2YWwsIHlvdSBtdXN0IGZpcnN0IHJlcXVpcmUgJ29wYWwtcGFyc2VyJy4gXCJcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJTZWUgaHR0cHM6Ly9naXRodWIuY29tL29wYWwvb3BhbC9ibG9iLyN7UlVCWV9FTkdJTkVfVkVSU0lPTn0vZG9jcy9vcGFsX3BhcnNlci5tZCBmb3IgZGV0YWlscy5cIlxuICBlbmRcbmVuZFxuXG5kZWYgc2VsZi5wdWJsaWMoKm1ldGhvZHMpXG4gIGByZXR1cm4gKG1ldGhvZHMubGVuZ3RoID09PSAxKSA/IG1ldGhvZHNbMF0gOiBtZXRob2RzYFxuZW5kXG5cbmRlZiBzZWxmLnByaXZhdGUoKm1ldGhvZHMpXG4gIGByZXR1cm4gKG1ldGhvZHMubGVuZ3RoID09PSAxKSA/IG1ldGhvZHNbMF0gOiBtZXRob2RzYFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIktlcm5lbCIsInJhaXNlIiwiTm90SW1wbGVtZW50ZWRFcnJvciIsInNlbGYiLCJ3YXJuIiwiPGNsYXNzOlN0cmluZz4iLCJlYWNoIiwiYmxvY2sgaW4gPGNsYXNzOlN0cmluZz4iLCJtZXRob2RfbmFtZSIsImJsb2NrICgyIGxldmVscykgaW4gPGNsYXNzOlN0cmluZz4iLCJkZWZpbmVfbWV0aG9kIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiA8Y2xhc3M6U3RyaW5nPiIsIiUiLCI8bW9kdWxlOktlcm5lbD4iLCJ0YWludCIsInVudGFpbnQiLCJ0YWludGVkPyIsIjxjbGFzczpNb2R1bGU+IiwicHVibGljIiwicHJpdmF0ZV9jbGFzc19tZXRob2QiLCJwcml2YXRlX21ldGhvZF9kZWZpbmVkPyIsInByaXZhdGVfY29uc3RhbnQiLCJwcml2YXRlX21ldGhvZHMiLCJldmFsIiwiUlVCWV9FTkdJTkVfVkVSU0lPTiIsInByaXZhdGUiXSwibWFwcGluZ3MiOiJBQUFBQSxzQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7O0FBR0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQSxNQUFRQyxPQUFRQyxPQUFBQSxDQUFPQywwQkFBZixFQUF1Q0gsT0FBL0JFO0FBQ2hCRjtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBLElBQU1JLElBQUFDLE1BQUFBLENBQU1MLE1BQU5LLENBQWVMO0FBQ3JCQTs7RUFHQU07RUFBQUE7Ozs7SUFDR0E7SUFFREEsT0FJQ0MsTUFKRCxDQUNFLElBREYsRUFDSyxhQURMLEVBQ2lCLFFBRGpCLEVBQ3dCLE9BRHhCLEVBQzhCLFdBRDlCLEVBQ3dDLE9BRHhDLEVBQzhDLFNBRDlDLEVBQ3NELE9BRHRELEVBQzRELFVBRDVELEVBRUUs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RUE4R0FBO0FBQUFBLElBQUFBOzs7SUE5R0E7SUE4R2dCO0lBQ2JBLG9EQUFEQTtFQURGQSxDQUFBQSxJQUFBQTtFQUlBbkIsT0FBQTBCLE1BQUl0QixJQUFKc0IsY0FBQUEsb0JBbEhBLEVBa0hBQTtBQUFBQSxJQUFBQTs7O0lBbEhBO0lBa0hpQjtJQUNkQSxvREFBREE7RUFERkEsQ0FBQUEsSUFBQUE7QUFsSEExQjsifX0seyJvZmZzZXQiOnsibGluZSI6MjQ5MDksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2JpbmRpbmcucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXG5cbmNsYXNzIDo6QmluZGluZ1xuICAjIEBwcml2YXRlXG4gIGRlZiBpbml0aWFsaXplKGpzZXZhbCwgc2NvcGVfdmFyaWFibGVzID0gW10sIHJlY2VpdmVyID0gdW5kZWZpbmVkLCBzb3VyY2VfbG9jYXRpb24gPSBuaWwpXG4gICAgQGpzZXZhbCwgQHNjb3BlX3ZhcmlhYmxlcywgQHJlY2VpdmVyLCBAc291cmNlX2xvY2F0aW9uID0gXFxcbiAgICAgIGpzZXZhbCwgc2NvcGVfdmFyaWFibGVzLCByZWNlaXZlciwgc291cmNlX2xvY2F0aW9uXG4gICAgcmVjZWl2ZXIgPSBqc19ldmFsKCdzZWxmJykgdW5sZXNzIGB0eXBlb2YgcmVjZWl2ZXIgIT09IHVuZGVmaW5lZGBcbiAgZW5kXG5cbiAgZGVmIGpzX2V2YWwoKmFyZ3MpXG4gICAgaWYgQGpzZXZhbFxuICAgICAgQGpzZXZhbC5jYWxsKCphcmdzKVxuICAgIGVsc2VcbiAgICAgIDo6S2VybmVsLnJhaXNlICdFdmFsdWF0aW9uIG9uIGEgUHJvYyNiaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBsb2NhbF92YXJpYWJsZV9nZXQoc3ltYm9sKVxuICAgIGpzX2V2YWwoc3ltYm9sKVxuICByZXNjdWUgOjpFeGNlcHRpb25cbiAgICA6Oktlcm5lbC5yYWlzZSA6Ok5hbWVFcnJvciwgXCJsb2NhbCB2YXJpYWJsZSBgI3tzeW1ib2x9JyBpcyBub3QgZGVmaW5lZCBmb3IgI3tpbnNwZWN0fVwiXG4gIGVuZFxuXG4gIGRlZiBsb2NhbF92YXJpYWJsZV9zZXQoc3ltYm9sLCB2YWx1ZSlcbiAgICBgT3BhbC5CaW5kaW5nLnRtcF92YWx1ZSA9IHZhbHVlYFxuICAgIGpzX2V2YWwoXCIje3N5bWJvbH0gPSBPcGFsLkJpbmRpbmcudG1wX3ZhbHVlXCIpXG4gICAgYGRlbGV0ZSBPcGFsLkJpbmRpbmcudG1wX3ZhbHVlYFxuICAgIHZhbHVlXG4gIGVuZFxuXG4gIGRlZiBsb2NhbF92YXJpYWJsZXNcbiAgICBAc2NvcGVfdmFyaWFibGVzXG4gIGVuZFxuXG4gIGRlZiBsb2NhbF92YXJpYWJsZV9kZWZpbmVkPyh2YWx1ZSlcbiAgICBAc2NvcGVfdmFyaWFibGVzLmluY2x1ZGU/KHZhbHVlKVxuICBlbmRcblxuICBkZWYgZXZhbChzdHIsIGZpbGUgPSBuaWwsIGxpbmUgPSBuaWwpXG4gICAgcmV0dXJuIHJlY2VpdmVyIGlmIHN0ciA9PSAnc2VsZidcblxuICAgIDo6S2VybmVsLmV2YWwoc3RyLCBzZWxmLCBmaWxlLCBsaW5lKVxuICBlbmRcblxuICBhdHRyX3JlYWRlciA6cmVjZWl2ZXIsIDpzb3VyY2VfbG9jYXRpb25cbmVuZFxuXG5tb2R1bGUgOjpLZXJuZWxcbiAgZGVmIGJpbmRpbmdcbiAgICA6Oktlcm5lbC5yYWlzZSBcIk9wYWwgZG9lc24ndCBzdXBwb3J0IGR5bmFtaWMgY2FsbHMgdG8gYmluZGluZ1wiXG4gIGVuZFxuZW5kXG5cblRPUExFVkVMX0JJTkRJTkcgPSA6OkJpbmRpbmcubmV3KFxuICAleHtcbiAgICBmdW5jdGlvbihqcykge1xuICAgICAgcmV0dXJuIChuZXcgRnVuY3Rpb24oXCJzZWxmXCIsIFwicmV0dXJuIFwiICsganMpKShzZWxmKTtcbiAgICB9XG4gIH0sXG4gIFtdLCBzZWxmLCBbJzxtYWluPicsIDBdXG4pXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpCaW5kaW5nPiIsImluaXRpYWxpemUiLCJqc2V2YWwiLCJzY29wZV92YXJpYWJsZXMiLCJyZWNlaXZlciIsInNvdXJjZV9sb2NhdGlvbiIsIkBqc2V2YWwiLCJAc2NvcGVfdmFyaWFibGVzIiwiQHJlY2VpdmVyIiwiQHNvdXJjZV9sb2NhdGlvbiIsInNlbGYiLCJqc19ldmFsIiwiY2FsbCIsImFyZ3MiLCJLZXJuZWwiLCJyYWlzZSIsImxvY2FsX3ZhcmlhYmxlX2dldCIsInN5bWJvbCIsIkV4Y2VwdGlvbiIsIk5hbWVFcnJvciIsImluc3BlY3QiLCJsb2NhbF92YXJpYWJsZV9zZXQiLCJ2YWx1ZSIsImxvY2FsX3ZhcmlhYmxlcyIsImxvY2FsX3ZhcmlhYmxlX2RlZmluZWQ/IiwiaW5jbHVkZT8iLCJldmFsIiwic3RyIiwiZmlsZSIsImxpbmUiLCJhdHRyX3JlYWRlciIsIjxtb2R1bGU6S2VybmVsPiIsImJpbmRpbmciLCJCaW5kaW5nIiwibmV3IiwiMCJdLCJtYXBwaW5ncyI6IkFBQUFBLGtDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQztFQUFBQTs7SUFBQUE7O0FBQUFBOzs7QUFFRUMsSUFBQUEsMEJBQUFBLHNCQUFlQyxNQUFELEVBQVNDLGVBQVQsRUFBK0JDLFFBQS9CLEVBQXFEQyxlQUFuRUo7QUFBQUEsTUFBQUE7OztNQUF1QiwrQ0FBa0I7O01BQTBCLCtDQUFrQjtNQUNuRixLQUNFLENBQUFDLE1BQUEsRUFBUUMsZUFBUixFQUF5QkMsUUFBekIsRUFBbUNDLGVBQW5DLENBREYsRUFBQUMsQ0FBQUEsY0FBQSxLQUFBQSxDQUFBLEVBQVNDLENBQUFBLHVCQUFULEtBQVNBLENBQVQsRUFBMkJDLENBQUFBLGdCQUEzQixLQUEyQkEsQ0FBM0IsRUFBc0NDLENBQUFBLHVCQUF0QyxLQUFzQ0EsQ0FBdEM7TUFFQSxJQUFBLFFBQW1DUiw2QkFBbkMsQ0FBQTtRQVBKQSxPQUFBO01BT0k7UUFBQUEsT0FBQUcsQ0FBQUEsV0FBV00sSUFBQUMsU0FBQUEsQ0FBUVYsTUFBUlUsQ0FBWFA7TUFBQTtJQUhGSCxDQUFBQSxJQUFBQTs7QUFNQVUsSUFBQUEsdUJBQUFBLG1CQVZGLEVBVUVBO0FBQUFBLE1BQUFBOzs7TUFWRjtNQVVjO01BQ1YsSUFBQSxRQUFHTCxXQUFILENBQUE7UUFDRUssT0FBT0MsTUFBUE4sV0FBT00sUUFBQUEsRUFBTSxNQUFDQyxJQUFELENBQU5EO01BRFQ7UUFHRUQsT0FBQUcsT0FBUUMsT0FBQUEsQ0FBT0osK0NBQVBJO01BSFY7SUFERkosQ0FBQUEsSUFBQUE7O0FBUUFLLElBQUFBLGtDQUFBQSw4QkFBdUJDLE1BQXZCRDtBQUFBQSxNQUFBQTs7TUFDRTtRQUFBQSxPQUFBTixJQUFBQyxTQUFBQSxDQUFRTSxNQUFSTjtNQUFBO1FBQ0Ysc0JBQU8sQ0FBQU8sZ0JBQUEsQ0FBUDtVQUFBO1lBQ0VGLE9BQUFGLE9BQVFDLE9BQUFBLENBQU9JLGdCQUFmLEVBQTZCSCxrQkFBRCxHQUFBLENBQW1CQyxNQUFuQixDQUFBLEdBQTBCRCx1QkFBMUIsR0FBQSxDQUFpRE4sSUFBQVUsU0FBQUEsQ0FBQUEsQ0FBakQsQ0FBcEJMO1VBRFY7UUFBQSxDQURFO01BQUE7SUFERkMsQ0FBQUE7O0FBTUFLLElBQUFBLGtDQUFBQSw4QkFBdUJKLE1BQUQsRUFBU0ssS0FBL0JEO0FBQUFBLE1BQUFBOzs7TUFDR0E7TUFDRFgsSUFBQUMsU0FBQUEsQ0FBUSxFQUFBLEdBQUEsQ0FBR00sTUFBSCxDQUFBLEdBQVVJLDJCQUFsQlY7TUFDQ1U7TUFDREEsT0FBQUM7SUFKRkQsQ0FBQUE7O0FBT0FFLElBQUFBLCtCQUFBQSxhQUNFLGlCQURGQSxDQUFBQTs7QUFJQUMsSUFBQUEsdUNBQUFBLGdEQUE0QkYsS0FBNUJFO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBakIsb0JBQWdCa0IsYUFBQUEsQ0FBVUgsS0FBVkc7SUFEbEJELENBQUFBOztBQUlBRSxJQUFBQSxvQkFBQUEseUJBQVNDLEdBQUQsRUFBTUMsSUFBTixFQUFrQkMsSUFBMUJILEdBQUFBO0FBQUFBLE1BQUFBOzs7TUFBYyx5QkFBTztNQUFLLHlCQUFPO01BQy9CLElBQUEsTUFBbUJDLEdBQW5CLEVBQTBCRCxNQUExQixDQUFBO1FBQUEsT0FBT2hCLElBQUFOLFVBQUFBLENBQUFBO01BQVA7TUFFQXNCLE9BQUFaLE9BQVFZLE1BQUFBLENBQU1DLEdBQWQsRUFBbUJqQixJQUFuQixFQUF5QmtCLElBQXpCLEVBQStCQyxJQUF2QkgsRUFIVkE7UUFBQUE7UUFBQUE7TUFBQUE7SUFBQUEsQ0FBQUEsSUFBQUE7SUFNQTFCLE9BQUFVLElBQUFvQixhQUFBQSxDQUFZLFVBQVosRUFBdUIsaUJBQXZCQTtFQTNDRjlCLEdBQU0sSUFBTkEsRUFBQUEsSUFBQUE7RUE4Q0ErQjtFQUFBQTs7O0lBQ0VBLE9BQUFDLHVCQUFBQSxtQkFBQUE7QUFBQUE7TUFDRUEsT0FBQWxCLE9BQVFDLE9BQUFBLENBQU9pQiwrQ0FBUGpCO0lBRFZpQixDQUFBQTtFQURGRCxHQUFPLElBQVBBO0VBTUFoQyxPQUFBLDRDQUFtQmtDLGNBQVNDLEtBQUFBO0FBRTVCbkM7QUFDQUE7QUFDQUE7QUFDQUEsRUFMbUIsRUFNakIsRUFOaUIsRUFNYlcsSUFOYSxFQU1QLENBQUNYLFFBQUQsRUFBV29DLENBQVgsQ0FOZ0JELENBQTVCO0FBdERBbkM7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI1MDE0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9pcmIucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXG5cbiMgRGVidWcgaXMgYSBoZWxwZXIgbW9kdWxlIHRoYXQgYWxsb3dzIHVzIHRvIGNvbmR1Y3Qgc29tZSBkZWJ1Z2dpbmcgb25cbiMgYSBsaXZlIGNvZGViYXNlLiBJdCBnb2VzIHdpdGggYW4gYXNzdW1wdGlvbiwgdGhhdCBvcGFsLXBhcnNlciBvclxuIyBvcGFsLXJlcGx1dGlscyB3aWxsIG5vdCBiZSBsb2FkZWQsIGluIHdoaWNoIGNhc2Ugd2Ugd2lsbCBkbyB3aGF0IHdlIGNhblxuIyB0byBwcm92aXNpb24gaXQuXG5cbm1vZHVsZSBPcGFsXG4gIG1vZHVsZSBJUkJcbiAgICBkZWYgc2VsZi5lbnN1cmVfbG9hZGVkKGxpYnJhcnkpXG4gICAgICByZXR1cm4gaWYgYE9wYWwubG9hZGVkX2ZlYXR1cmVzYC5pbmNsdWRlPyBsaWJyYXJ5XG5cbiAgICAgIHZlcnNpb24gPSBpZiBSVUJZX0VOR0lORV9WRVJTSU9OLmluY2x1ZGU/ICdkZXYnXG4gICAgICAgICAgICAgICAgICAnbWFzdGVyJ1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgIFJVQllfRU5HSU5FX1ZFUlNJT05cbiAgICAgICAgICAgICAgICBlbmRcblxuICAgICAgdXJsID0gXCJodHRwczovL2Nkbi5vcGFscmIuY29tL29wYWwvI3t2ZXJzaW9ufS8je2xpYnJhcnl9LmpzXCJcblxuICAgICAgJXh7XG4gICAgICAgIHZhciBsaWJjb2RlO1xuXG4gICAgICAgIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7IC8vIEJyb3dzZXJcbiAgICAgICAgICB2YXIgciA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgIHIub3BlbihcIkdFVFwiLCB1cmwsIGZhbHNlKTtcbiAgICAgICAgICByLnNlbmQoJycpO1xuICAgICAgICAgIGxpYmNvZGUgPSByLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAjezo6S2VybmVsLnJhaXNlIFwiWW91IG5lZWQgdG8gcHJvdmlzaW9uICN7bGlicmFyeX0geW91cnNlbGYgaW4gdGhpcyBlbnZpcm9ubWVudFwifVxuICAgICAgICB9XG5cbiAgICAgICAgKG5ldyBGdW5jdGlvbignT3BhbCcsIGxpYmNvZGUpKShPcGFsKTtcblxuICAgICAgICBPcGFsLnJlcXVpcmUobGlicmFyeSk7XG4gICAgICB9XG5cbiAgICAgIDo6S2VybmVsLnJhaXNlIFwiQ291bGQgbm90IGxvYWQgI3tsaWJyYXJ5fSBmb3Igc29tZSByZWFzb25cIiB1bmxlc3MgYE9wYWwubG9hZGVkX2ZlYXR1cmVzYC5pbmNsdWRlPyBsaWJyYXJ5XG4gICAgZW5kXG5cbiAgICBzaW5nbGV0b25fY2xhc3MuYXR0cl9hY2Nlc3NvciA6b3V0cHV0XG5cbiAgICBkZWYgc2VsZi5wcmVwYXJlX2NvbnNvbGUoJmJsb2NrKVxuICAgICAgc2VsZi5vdXRwdXQgPSAnJ1xuXG4gICAgICBvcmlnaW5hbCA9IHtcbiAgICAgICAgJHN0ZG91dCA9PiAtPihpKSB7ICRzdGRvdXQgPSBpIH0sXG4gICAgICAgICRzdGRlcnIgPT4gLT4oaSkgeyAkc3RkZXJyID0gaSB9LFxuICAgICAgfVxuXG4gICAgICAjIFByZXBhcmUgYSBiZXR0ZXIgcHJvbXB0IGV4cGVyaWVuY2UgZm9yIGEgYnJvd3NlclxuICAgICAgaWYgYnJvd3Nlcj9cbiAgICAgICAgb3JpZ2luYWwuZWFjaCBkbyB8cGlwZSwgcGlwZV9zZXR0ZXJ8XG4gICAgICAgICAgbmV3X3BpcGUgPSBwaXBlLmR1cFxuICAgICAgICAgIG5ld19waXBlLndyaXRlX3Byb2MgPSBwcm9jIGRvIHxzdHJ8XG4gICAgICAgICAgICBzZWxmLm91dHB1dCArPSBzdHJcbiAgICAgICAgICAgIHNlbGYub3V0cHV0ID0gb3V0cHV0LnNwbGl0KFwiXFxuXCIpLmxhc3QoMzApLmpvaW4oXCJcXG5cIilcbiAgICAgICAgICAgIHNlbGYub3V0cHV0ICs9IFwiXFxuXCIgaWYgc3RyLmVuZF93aXRoPyBcIlxcblwiXG5cbiAgICAgICAgICAgIHBpcGUud3JpdGVfcHJvYy5jYWxsKHN0cilcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBuZXdfcGlwZS50dHkgPSBmYWxzZVxuICAgICAgICAgIHBpcGVfc2V0dGVyLmNhbGwobmV3X3BpcGUpXG4gICAgICAgIGVuZFxuXG4gICAgICAgIG9yaWdpbmFsX3JlYWRfcHJvYyA9ICRzdGRpbi5yZWFkX3Byb2NcbiAgICAgICAgJHN0ZGluLnJlYWRfcHJvYyA9IGBmdW5jdGlvbihzKSB7IHZhciBwID0gcHJvbXB0KCN7b3V0cHV0fSk7IGlmIChwICE9PSBudWxsKSByZXR1cm4gcCArIFwiXFxuXCI7IHJldHVybiBuaWw7IH1gXG4gICAgICBlbmRcblxuICAgICAgeWllbGRcbiAgICBlbnN1cmVcbiAgICAgIG9yaWdpbmFsLmVhY2ggZG8gfHBpcGUsIHBpcGVfc2V0dGVyfFxuICAgICAgICBwaXBlX3NldHRlci5jYWxsKHBpcGUpXG4gICAgICBlbmRcbiAgICAgICRzdGRpbi5yZWFkX3Byb2MgPSBvcmlnaW5hbF9yZWFkX3Byb2NcbiAgICAgIHNlbGYub3V0cHV0ID0gJydcbiAgICBlbmRcblxuICAgIGRlZiBzZWxmLmJyb3dzZXI/XG4gICAgICBgdHlwZW9mKGRvY3VtZW50KSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mKHByb21wdCkgIT09ICd1bmRlZmluZWQnYFxuICAgIGVuZFxuXG4gICAgTElORUJSRUFLUyA9IFtcbiAgICAgICd1bmV4cGVjdGVkIHRva2VuICRlbmQnLFxuICAgICAgJ3VudGVybWluYXRlZCBzdHJpbmcgbWVldHMgZW5kIG9mIGZpbGUnXG4gICAgXS5mcmVlemVcblxuICAgIGNsYXNzIFNpbGVuY2VyXG4gICAgICBkZWYgaW5pdGlhbGl6ZVxuICAgICAgICBAc3RkZXJyID0gJHN0ZGVyclxuICAgICAgZW5kXG5cbiAgICAgIGRlZiBzaWxlbmNlXG4gICAgICAgIEBjb2xsZWN0b3IgPSA6OlN0cmluZ0lPLm5ld1xuICAgICAgICAkc3RkZXJyID0gQGNvbGxlY3RvclxuICAgICAgICB5aWVsZFxuICAgICAgZW5zdXJlXG4gICAgICAgICRzdGRlcnIgPSBAc3RkZXJyXG4gICAgICBlbmRcblxuICAgICAgZGVmIHdhcm5pbmdzXG4gICAgICAgIEBjb2xsZWN0b3Iuc3RyaW5nXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuY2xhc3MgOjpCaW5kaW5nXG4gIGRlZiBpcmJcbiAgICA6Ok9wYWw6OklSQi5lbnN1cmVfbG9hZGVkKCdvcGFsLXJlcGx1dGlscycpXG5cbiAgICBzaWxlbmNlciA9IDo6T3BhbDo6SVJCOjpTaWxlbmNlci5uZXdcblxuICAgIDo6T3BhbDo6SVJCLnByZXBhcmVfY29uc29sZSBkb1xuICAgICAgbG9vcCBkb1xuICAgICAgICBwcmludCAnPj4gJ1xuICAgICAgICBsaW5lID0gZ2V0c1xuICAgICAgICBicmVhayB1bmxlc3MgbGluZVxuICAgICAgICBjb2RlID0gJydcblxuICAgICAgICBwdXRzIGxpbmUgaWYgOjpPcGFsOjpJUkIuYnJvd3Nlcj9cblxuICAgICAgICBpZiBsaW5lLnN0YXJ0X3dpdGg/ICdscyAnXG4gICAgICAgICAgY29kZSA9IGxpbmVbMy4uLTFdXG4gICAgICAgICAgbW9kZSA9IDpsc1xuICAgICAgICBlbHNpZiBsaW5lID09IFwibHNcXG5cIlxuICAgICAgICAgIGNvZGUgPSAnc2VsZidcbiAgICAgICAgICBtb2RlID0gOmxzXG4gICAgICAgIGVsc2lmIGxpbmUuc3RhcnRfd2l0aD8gJ3Nob3cgJ1xuICAgICAgICAgIGNvZGUgPSBsaW5lWzUuLi0xXVxuICAgICAgICAgIG1vZGUgPSA6c2hvd1xuICAgICAgICBlbHNlXG4gICAgICAgICAgY29kZSA9IGxpbmVcbiAgICAgICAgICBtb2RlID0gOmluc3BlY3RcbiAgICAgICAgZW5kXG5cbiAgICAgICAganNfY29kZSA9IG5pbFxuXG4gICAgICAgIGJlZ2luXG4gICAgICAgICAgc2lsZW5jZXIuc2lsZW5jZSBkb1xuICAgICAgICAgICAganNfY29kZSA9IGBPcGFsLmNvbXBpbGUoY29kZSwge2lyYjogdHJ1ZX0pYFxuICAgICAgICAgIGVuZFxuICAgICAgICByZXNjdWUgU3ludGF4RXJyb3IgPT4gZVxuICAgICAgICAgIGlmIDo6T3BhbDo6SVJCOjpMSU5FQlJFQUtTLmluY2x1ZGU/KGUubWVzc2FnZSlcbiAgICAgICAgICAgIHByaW50ICcuLiAnXG4gICAgICAgICAgICBsaW5lID0gZ2V0c1xuICAgICAgICAgICAgcmV0dXJuIHVubGVzcyBsaW5lXG4gICAgICAgICAgICBwdXRzIGxpbmUgaWYgOjpPcGFsOjpJUkIuYnJvd3Nlcj9cbiAgICAgICAgICAgIGNvZGUgKz0gbGluZVxuICAgICAgICAgICAgcmV0cnlcbiAgICAgICAgICBlbHNpZiBzaWxlbmNlci53YXJuaW5ncy5lbXB0eT9cbiAgICAgICAgICAgIHdhcm4gZS5mdWxsX21lc3NhZ2VcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAjIE1vc3QgbGlrZWx5IGEgcGFyc2VyIGVycm9yXG4gICAgICAgICAgICB3YXJuIHNpbGVuY2VyLndhcm5pbmdzXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuXG4gICAgICAgIGlmIG1vZGUgPT0gOnNob3dcbiAgICAgICAgICBwdXRzIGpzX2NvZGVcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgZW5kXG5cbiAgICAgICAgcHV0cyA6OlJFUExVdGlscy5ldmFsX2FuZF9wcmludChqc19jb2RlLCBtb2RlLCBmYWxzZSwgc2VsZilcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG4leHtcbiAgLy8gUnVuIGluIFdlYlRvb2xzIGNvbnNvbGUgd2l0aDogT3BhbC5pcmIoYyA9PiBldmFsKGMpKVxuICBPcGFsLmlyYiA9IGZ1bmN0aW9uKGZ1bikge1xuICAgICN7OjpCaW5kaW5nLm5ldyhgZnVuYCkuaXJifVxuICB9XG5cbiAgT3BhbC5sb2FkX3BhcnNlciA9IGZ1bmN0aW9uKCkge1xuICAgIE9wYWwuT3BhbC5JUkIuJGVuc3VyZV9sb2FkZWQoJ29wYWwtcGFyc2VyJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIE9wYWwuZXZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBPcGFsLmV2YWwgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgIE9wYWwubG9hZF9wYXJzZXIoKTtcbiAgICAgIHJldHVybiBPcGFsLmV2YWwoc3RyKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIE9wYWwuY29tcGlsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBPcGFsLmNvbXBpbGUgPSBmdW5jdGlvbihzdHIsIG9wdGlvbnMpIHtcbiAgICAgIE9wYWwubG9hZF9wYXJzZXIoKTtcbiAgICAgIHJldHVybiBPcGFsLmNvbXBpbGUoc3RyLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpPcGFsPiIsIjxtb2R1bGU6SVJCPiIsImVuc3VyZV9sb2FkZWQiLCJzZWxmIiwibGlicmFyeSIsImluY2x1ZGU/IiwidmVyc2lvbiIsIlJVQllfRU5HSU5FX1ZFUlNJT04iLCJ1cmwiLCJLZXJuZWwiLCJyYWlzZSIsInNpbmdsZXRvbl9jbGFzcyIsImF0dHJfYWNjZXNzb3IiLCJwcmVwYXJlX2NvbnNvbGUiLCJvdXRwdXQ9Iiwib3JpZ2luYWwiLCIkc3Rkb3V0IiwiYmxvY2sgaW4gcHJlcGFyZV9jb25zb2xlIiwiaSIsImJsb2NrICgyIGxldmVscykgaW4gcHJlcGFyZV9jb25zb2xlIiwiJHN0ZGVyciIsImJyb3dzZXI/IiwiZWFjaCIsInBpcGUiLCJwaXBlX3NldHRlciIsIm5ld19waXBlIiwiZHVwIiwid3JpdGVfcHJvYz0iLCJwcm9jIiwic3RyIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiBwcmVwYXJlX2NvbnNvbGUiLCIrIiwib3V0cHV0Iiwic3BsaXQiLCJsYXN0IiwiMzAiLCJqb2luIiwiZW5kX3dpdGg/Iiwid3JpdGVfcHJvYyIsImNhbGwiLCJ0dHk9Iiwib3JpZ2luYWxfcmVhZF9wcm9jIiwiJHN0ZGluIiwicmVhZF9wcm9jIiwicmVhZF9wcm9jPSIsImZyZWV6ZSIsIjxjbGFzczpTaWxlbmNlcj4iLCJpbml0aWFsaXplIiwiQHN0ZGVyciIsInNpbGVuY2UiLCJAY29sbGVjdG9yIiwiU3RyaW5nSU8iLCJuZXciLCJ3YXJuaW5ncyIsInN0cmluZyIsIjxjbGFzczpCaW5kaW5nPiIsImlyYiIsIk9wYWw6OklSQiIsIk9wYWwiLCJzaWxlbmNlciIsIk9wYWw6OklSQjo6U2lsZW5jZXIiLCJibG9jayBpbiBpcmIiLCJibG9jayAoMiBsZXZlbHMpIGluIGlyYiIsImxvb3AiLCJibG9jayAoMyBsZXZlbHMpIGluIGlyYiIsInByaW50IiwibGluZSIsImdldHMiLCJjb2RlIiwicHV0cyIsInN0YXJ0X3dpdGg/IiwiW10iLCIzIiwiLTEiLCJtb2RlIiwiNSIsImpzX2NvZGUiLCJibG9jayAoNCBsZXZlbHMpIGluIGlyYiIsIlN5bnRheEVycm9yIiwiZSIsIk9wYWw6OklSQjo6TElORUJSRUFLUyIsIm1lc3NhZ2UiLCJlbXB0eT8iLCJ3YXJuIiwiZnVsbF9tZXNzYWdlIiwiUkVQTFV0aWxzIiwiZXZhbF9hbmRfcHJpbnQiLCJCaW5kaW5nIl0sIm1hcHBpbmdzIjoiQUFBQUEsOEJBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBT0FDO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUM7SUFBQUE7O01BQUFBOzs7TUFDRUMsTUFBSUMsSUFBSkQsb0JBQUFBLHlCQUF1QkUsT0FBdkJGO0FBQUFBLFFBQUFBOzs7UUFDRSxJQUFBLFFBQVVBLENBQUNBLG9CQUFEQSxDQUFzQkcsYUFBQUEsQ0FBVUQsT0FBVkMsQ0FBaEMsQ0FBQTtVQUFBLE9BQUE7UUFBQTtRQUVBQyxVQUFVLENBQUEsUUFBR0MseUJBQW1CRixhQUFBQSxDQUFVSCxLQUFWRyxDQUF0QixDQUFBLEdBQUEsQ0FDRUgsUUFERixJQUFBLENBR0VLLHlCQUhGLENBQUE7UUFNVkMsTUFBT04sOEJBQUQsR0FBQSxDQUErQkksT0FBL0IsQ0FBQSxHQUF1Q0osR0FBdkMsR0FBQSxDQUEwQ0UsT0FBMUMsQ0FBQSxHQUFrREY7O0FBRzlEQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsVUFBWU8sT0FBUUMsT0FBQUEsQ0FBUVIsd0JBQUQsR0FBQSxDQUF5QkUsT0FBekIsQ0FBQSxHQUFpQ0YsK0JBQXhDUTtBQUNwQlI7O0FBRUFBOztBQUVBQTtBQUNBQTtRQUVN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OztBQStEQXhEO0FBQ0FBO0FBQ0FBLElBQU13RixjQUFTbkMsS0FBQUEsQ0FBTXJELEdBQU5xRCxDQUFXSSxLQUFBQSxDQUFBQTtBQUMxQnpEOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQWhNQUE7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI1MjY1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9vcGFsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIjo6T2JqZWN0LnJlcXVpcmUgJ29wYWwvYmFzZSdcbjo6T2JqZWN0LnJlcXVpcmUgJ29wYWwvbWluaSdcblxuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9rZXJuZWwvZm9ybWF0J1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9zdHJpbmcvZW5jb2RpbmcnXG46Ok9iamVjdC5hdXRvbG9hZCA6TWF0aCwgJ2NvcmVsaWIvbWF0aCdcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvY29tcGxleC9iYXNlJ1xuOjpPYmplY3QuYXV0b2xvYWQgOkNvbXBsZXgsICdjb3JlbGliL2NvbXBsZXgnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3JhdGlvbmFsL2Jhc2UnXG46Ok9iamVjdC5hdXRvbG9hZCA6UmF0aW9uYWwsICdjb3JlbGliL3JhdGlvbmFsJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi90aW1lJ1xuOjpPYmplY3QuYXV0b2xvYWQgOlN0cnVjdCwgJ2NvcmVsaWIvc3RydWN0J1xuOjpPYmplY3QuYXV0b2xvYWQgOlNldCwgJ2NvcmVsaWIvc2V0J1xuOjpPYmplY3QuYXV0b2xvYWQgOkRpciwgJ2NvcmVsaWIvZGlyJ1xuOjpPYmplY3QuYXV0b2xvYWQgOkZpbGUsICdjb3JlbGliL2ZpbGUnXG5cbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvcHJvY2Vzcy9iYXNlJ1xuOjpPYmplY3QuYXV0b2xvYWQgOlByb2Nlc3MsICdjb3JlbGliL3Byb2Nlc3MnXG46Ok9iamVjdC5hdXRvbG9hZCA6UmFuZG9tLCAnY29yZWxpYi9yYW5kb20nXG5cbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvdW5zdXBwb3J0ZWQnXG5cbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvYmluZGluZydcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvaXJiJ1xuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJPYmplY3QiLCJyZXF1aXJlIiwiYXV0b2xvYWQiXSwibWFwcGluZ3MiOiJBQUFBQSx1QkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsT0FBUUMsU0FBQUEsQ0FBU0YsV0FBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YsV0FBVEU7RUFFUkQsT0FBUUMsU0FBQUEsQ0FBU0YsdUJBQVRFO0VBQ1JELE9BQVFDLFNBQUFBLENBQVNGLHlCQUFURTtFQUNSRCxPQUFRRSxVQUFBQSxDQUFVLE1BQWxCLEVBQXlCSCxjQUFqQkc7RUFDUkYsT0FBUUMsU0FBQUEsQ0FBU0Ysc0JBQVRFO0VBQ1JELE9BQVFFLFVBQUFBLENBQVUsU0FBbEIsRUFBNEJILGlCQUFwQkc7RUFDUkYsT0FBUUMsU0FBQUEsQ0FBU0YsdUJBQVRFO0VBQ1JELE9BQVFFLFVBQUFBLENBQVUsVUFBbEIsRUFBNkJILGtCQUFyQkc7RUFDUkYsT0FBUUMsU0FBQUEsQ0FBU0YsY0FBVEU7RUFDUkQsT0FBUUUsVUFBQUEsQ0FBVSxRQUFsQixFQUEyQkgsZ0JBQW5CRztFQUNSRixPQUFRRSxVQUFBQSxDQUFVLEtBQWxCLEVBQXdCSCxhQUFoQkc7RUFDUkYsT0FBUUUsVUFBQUEsQ0FBVSxLQUFsQixFQUF3QkgsYUFBaEJHO0VBQ1JGLE9BQVFFLFVBQUFBLENBQVUsTUFBbEIsRUFBeUJILGNBQWpCRztFQUVSRixPQUFRQyxTQUFBQSxDQUFTRixzQkFBVEU7RUFDUkQsT0FBUUUsVUFBQUEsQ0FBVSxTQUFsQixFQUE0QkgsaUJBQXBCRztFQUNSRixPQUFRRSxVQUFBQSxDQUFVLFFBQWxCLEVBQTJCSCxnQkFBbkJHO0VBRVJGLE9BQVFDLFNBQUFBLENBQVNGLHFCQUFURTtFQUVSRCxPQUFRQyxTQUFBQSxDQUFTRixpQkFBVEU7RUFDUkYsT0FBQUMsT0FBUUMsU0FBQUEsQ0FBU0YsYUFBVEU7QUF2QlJGOztBQUFBQTsifX0seyJvZmZzZXQiOnsibGluZSI6MjUyOTQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL29wYWwucmIiXSwic291cmNlc0NvbnRlbnQiOlsiOjpPYmplY3QucmVxdWlyZSAnb3BhbC9iYXNlJ1xuOjpPYmplY3QucmVxdWlyZSAnb3BhbC9taW5pJ1xuXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL2tlcm5lbC9mb3JtYXQnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3N0cmluZy9lbmNvZGluZydcbjo6T2JqZWN0LmF1dG9sb2FkIDpNYXRoLCAnY29yZWxpYi9tYXRoJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9jb21wbGV4L2Jhc2UnXG46Ok9iamVjdC5hdXRvbG9hZCA6Q29tcGxleCwgJ2NvcmVsaWIvY29tcGxleCdcbjo6T2JqZWN0LnJlcXVpcmUgJ2NvcmVsaWIvcmF0aW9uYWwvYmFzZSdcbjo6T2JqZWN0LmF1dG9sb2FkIDpSYXRpb25hbCwgJ2NvcmVsaWIvcmF0aW9uYWwnXG46Ok9iamVjdC5yZXF1aXJlICdjb3JlbGliL3RpbWUnXG46Ok9iamVjdC5hdXRvbG9hZCA6U3RydWN0LCAnY29yZWxpYi9zdHJ1Y3QnXG46Ok9iamVjdC5hdXRvbG9hZCA6U2V0LCAnY29yZWxpYi9zZXQnXG46Ok9iamVjdC5hdXRvbG9hZCA6RGlyLCAnY29yZWxpYi9kaXInXG46Ok9iamVjdC5hdXRvbG9hZCA6RmlsZSwgJ2NvcmVsaWIvZmlsZSdcblxuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9wcm9jZXNzL2Jhc2UnXG46Ok9iamVjdC5hdXRvbG9hZCA6UHJvY2VzcywgJ2NvcmVsaWIvcHJvY2Vzcydcbjo6T2JqZWN0LmF1dG9sb2FkIDpSYW5kb20sICdjb3JlbGliL3JhbmRvbSdcblxuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi91bnN1cHBvcnRlZCdcblxuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9iaW5kaW5nJ1xuOjpPYmplY3QucmVxdWlyZSAnY29yZWxpYi9pcmInXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIk9iamVjdCIsInJlcXVpcmUiLCJhdXRvbG9hZCJdLCJtYXBwaW5ncyI6IkFBQUFBLHVCQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxPQUFRQyxTQUFBQSxDQUFTRixXQUFURTtFQUNSRCxPQUFRQyxTQUFBQSxDQUFTRixXQUFURTtFQUVSRCxPQUFRQyxTQUFBQSxDQUFTRix1QkFBVEU7RUFDUkQsT0FBUUMsU0FBQUEsQ0FBU0YseUJBQVRFO0VBQ1JELE9BQVFFLFVBQUFBLENBQVUsTUFBbEIsRUFBeUJILGNBQWpCRztFQUNSRixPQUFRQyxTQUFBQSxDQUFTRixzQkFBVEU7RUFDUkQsT0FBUUUsVUFBQUEsQ0FBVSxTQUFsQixFQUE0QkgsaUJBQXBCRztFQUNSRixPQUFRQyxTQUFBQSxDQUFTRix1QkFBVEU7RUFDUkQsT0FBUUUsVUFBQUEsQ0FBVSxVQUFsQixFQUE2Qkgsa0JBQXJCRztFQUNSRixPQUFRQyxTQUFBQSxDQUFTRixjQUFURTtFQUNSRCxPQUFRRSxVQUFBQSxDQUFVLFFBQWxCLEVBQTJCSCxnQkFBbkJHO0VBQ1JGLE9BQVFFLFVBQUFBLENBQVUsS0FBbEIsRUFBd0JILGFBQWhCRztFQUNSRixPQUFRRSxVQUFBQSxDQUFVLEtBQWxCLEVBQXdCSCxhQUFoQkc7RUFDUkYsT0FBUUUsVUFBQUEsQ0FBVSxNQUFsQixFQUF5QkgsY0FBakJHO0VBRVJGLE9BQVFDLFNBQUFBLENBQVNGLHNCQUFURTtFQUNSRCxPQUFRRSxVQUFBQSxDQUFVLFNBQWxCLEVBQTRCSCxpQkFBcEJHO0VBQ1JGLE9BQVFFLFVBQUFBLENBQVUsUUFBbEIsRUFBMkJILGdCQUFuQkc7RUFFUkYsT0FBUUMsU0FBQUEsQ0FBU0YscUJBQVRFO0VBRVJELE9BQVFDLFNBQUFBLENBQVNGLGlCQUFURTtFQUNSRixPQUFBQyxPQUFRQyxTQUFBQSxDQUFTRixhQUFURTtBQXZCUkY7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI1MzIxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9uYXRpdmUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXG4jIGhlbHBlcnM6IGhhc2hfcHV0XG5cbiMgUHJvdmlkZXMgYSBjb21wbGV0ZSBzZXQgb2YgdG9vbHMgdG8gd3JhcCBuYXRpdmUgSmF2YVNjcmlwdFxuIyBpbnRvIG5pY2UgUnVieSBvYmplY3RzLlxuI1xuIyBAZXhhbXBsZVxuI1xuIyAgICQkLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3AnKS5jbGFzc0xpc3QuYWRkKCdibHVlJylcbiMgICAjID0+IGFkZHMgXCJibHVlXCIgY2xhc3MgdG8gPHA+XG4jXG4jICAgJCQubG9jYXRpb24uaHJlZiA9ICdodHRwczovL2dvb2dsZS5jb20nXG4jICAgIyA9PiBjaGFuZ2VzIHBhZ2UgbG9jYXRpb25cbiNcbiMgICBkb19sYXRlciA9ICQkWzpzZXRUaW1lb3V0XSAjIEFjY2Vzc2luZyB0aGUgXCJzZXRUaW1lb3V0XCIgcHJvcGVydHlcbiMgICBkb19sYXRlci5jYWxsKC0+eyBwdXRzIDpoZWxsb30sIDUwMClcbiNcbiMgYCQkYCBhbmQgYCRnbG9iYWxgIHdyYXAgYE9wYWwuZ2xvYmFsYCwgd2hpY2ggdGhlIE9wYWwgSlMgcnVudGltZVxuIyBzZXRzIHRvIHRoZSBnbG9iYWwgYHRoaXNgIG9iamVjdC5cbiNcbm1vZHVsZSBOYXRpdmVcbiAgZGVmIHNlbGYuaXNfYT8ob2JqZWN0LCBrbGFzcylcbiAgICAleHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAje29iamVjdH0gaW5zdGFuY2VvZiAje3RyeV9jb252ZXJ0KGtsYXNzKX07XG4gICAgICB9XG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi50cnlfY29udmVydCh2YWx1ZSwgZGVmYXVsdCA9IG5pbClcbiAgICAleHtcbiAgICAgIGlmICgje25hdGl2ZT8odmFsdWUpfSkge1xuICAgICAgICByZXR1cm4gI3t2YWx1ZX07XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgje3ZhbHVlLnJlc3BvbmRfdG8/IDp0b19ufSkge1xuICAgICAgICByZXR1cm4gI3t2YWx1ZS50b19ufTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tkZWZhdWx0fTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvbnZlcnQodmFsdWUpXG4gICAgJXh7XG4gICAgICBpZiAoI3tuYXRpdmU/KHZhbHVlKX0pIHtcbiAgICAgICAgcmV0dXJuICN7dmFsdWV9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoI3t2YWx1ZS5yZXNwb25kX3RvPyA6dG9fbn0pIHtcbiAgICAgICAgcmV0dXJuICN7dmFsdWUudG9fbn07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIiN7dmFsdWUuaW5zcGVjdH0gaXNuJ3QgbmF0aXZlXCJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYuY2FsbChvYmosIGtleSwgKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBwcm9wID0gI3tvYmp9WyN7a2V5fV07XG5cbiAgICAgIGlmIChwcm9wIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIGNvbnZlcnRlZCA9IG5ldyBBcnJheShhcmdzLmxlbmd0aCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBpdGVtID0gYXJnc1tpXSxcbiAgICAgICAgICAgICAgY29udiA9ICN7dHJ5X2NvbnZlcnQoYGl0ZW1gKX07XG5cbiAgICAgICAgICBjb252ZXJ0ZWRbaV0gPSBjb252ID09PSBuaWwgPyBpdGVtIDogY29udjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICAgY29udmVydGVkLnB1c2goYmxvY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICN7TmF0aXZlKGBwcm9wLmFwcGx5KCN7b2JqfSwgY29udmVydGVkKWApfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tOYXRpdmUoYHByb3BgKX07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5wcm9jKCZibG9jaylcbiAgICByYWlzZSBMb2NhbEp1bXBFcnJvciwgJ25vIGJsb2NrIGdpdmVuJyB1bmxlc3MgYmxvY2tcblxuICAgIDo6S2VybmVsLnByb2MgeyB8KmFyZ3N8XG4gICAgICBhcmdzLm1hcCEgeyB8YXJnfCBOYXRpdmUoYXJnKSB9XG4gICAgICBpbnN0YW5jZSA9IE5hdGl2ZShgdGhpc2ApXG5cbiAgICAgICV4e1xuICAgICAgICAvLyBpZiBnbG9iYWwgaXMgY3VycmVudCBzY29wZSwgcnVuIHRoZSBibG9jayBpbiB0aGUgc2NvcGUgaXQgd2FzIGRlZmluZWRcbiAgICAgICAgaWYgKHRoaXMgPT09IE9wYWwuZ2xvYmFsKSB7XG4gICAgICAgICAgcmV0dXJuIGJsb2NrLmFwcGx5KHNlbGYsICN7YXJnc30pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlbGZfID0gYmxvY2suJCRzO1xuICAgICAgICBibG9jay4kJHMgPSBudWxsO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGJsb2NrLmFwcGx5KCN7aW5zdGFuY2V9LCAje2FyZ3N9KTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICBibG9jay4kJHMgPSBzZWxmXztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgbW9kdWxlIEhlbHBlcnNcbiAgICAjIEV4cG9zZXMgYSBuYXRpdmUgSmF2YVNjcmlwdCBtZXRob2QgdG8gUnVieVxuICAgICNcbiAgICAjXG4gICAgIyBAcGFyYW0gbmV3IFtTdHJpbmddXG4gICAgIyAgICAgICBUaGUgbmFtZSBvZiB0aGUgbmV3bHkgY3JlYXRlZCBtZXRob2QuXG4gICAgI1xuICAgICMgQHBhcmFtIG9sZCBbU3RyaW5nXVxuICAgICMgICAgICAgVGhlIG5hbWUgb2YgdGhlIG5hdGl2ZSBKYXZhU2NyaXB0IG1ldGhvZCB0byBiZSBleHBvc2VkLlxuICAgICMgICAgICAgSWYgdGhlIG5hbWUgZW5kcyB3aXRoIFwiPVwiIChlLmcuIGBmb289YCkgaXQgd2lsbCBiZSBpbnRlcnByZXRlZCBhc1xuICAgICMgICAgICAgYSBwcm9wZXJ0eSBzZXR0ZXIuIChkZWZhdWx0OiB0aGUgdmFsdWUgb2YgXCJuZXdcIilcbiAgICAjXG4gICAgIyBAcGFyYW0gYXMgW0NsYXNzXVxuICAgICMgICAgICAgSWYgcHJvdmlkZWQgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgb3JpZ2luYWwgbWV0aG9kIHdpbGwgYmVcbiAgICAjICAgICAgIHJldHVybmVkIGFzIGluc3RhbmNlcyBvZiB0aGUgcGFzc2VkIGNsYXNzLiBUaGUgY2xhc3MgcGFzc2VkIHRvIFwiYXNcIlxuICAgICMgICAgICAgaXMgZXhwZWN0ZWQgdG8gYWNjZXB0IGEgbmF0aXZlIEphdmFTY3JpcHQgdmFsdWUuXG4gICAgI1xuICAgICMgQGV4YW1wbGVcbiAgICAjXG4gICAgIyAgIGNsYXNzIEVsZW1lbnRcbiAgICAjICAgICBleHRlbmQgTmF0aXZlOjpIZWxwZXJzXG4gICAgI1xuICAgICMgICAgIGFsaWFzX25hdGl2ZSA6YWRkX2NsYXNzLCA6YWRkQ2xhc3NcbiAgICAjICAgICBhbGlhc19uYXRpdmUgOnNob3dcbiAgICAjICAgICBhbGlhc19uYXRpdmUgOmhpZGVcbiAgICAjXG4gICAgIyAgICAgZGVmIGluaXRpYWxpemUoc2VsZWN0b3IpXG4gICAgIyAgICAgICBAbmF0aXZlID0gYCQoI3tzZWxlY3Rvcn0pYFxuICAgICMgICAgIGVuZFxuICAgICMgICBlbmRcbiAgICAjXG4gICAgIyAgIHRpdGxlcyA9IEVsZW1lbnQubmV3KCdoMScpXG4gICAgIyAgIHRpdGxlcy5hZGRfY2xhc3MgOmZvb1xuICAgICMgICB0aXRsZXMuaGlkZVxuICAgICMgICB0aXRsZXMuc2hvd1xuICAgICNcbiAgICBkZWYgYWxpYXNfbmF0aXZlKG5ldywgb2xkID0gbmV3LCBhczogbmlsKVxuICAgICAgaWYgb2xkLmVuZF93aXRoPyAnPSdcbiAgICAgICAgZGVmaW5lX21ldGhvZCBuZXcgZG8gfHZhbHVlfFxuICAgICAgICAgIGAje0BuYXRpdmV9WyN7b2xkWzAuLi0yXX1dID0gI3tOYXRpdmUuY29udmVydCh2YWx1ZSl9YFxuXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgZW5kXG4gICAgICBlbHNpZiBhc1xuICAgICAgICBkZWZpbmVfbWV0aG9kIG5ldyBkbyB8KmFyZ3MsICZibG9ja3xcbiAgICAgICAgICB2YWx1ZSA9IE5hdGl2ZS5jYWxsKEBuYXRpdmUsIG9sZCwgKmFyZ3MsICZibG9jaylcbiAgICAgICAgICBpZiB2YWx1ZVxuICAgICAgICAgICAgYXMubmV3KHZhbHVlLnRvX24pXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZWxzZVxuICAgICAgICBkZWZpbmVfbWV0aG9kIG5ldyBkbyB8KmFyZ3MsICZibG9ja3xcbiAgICAgICAgICBOYXRpdmUuY2FsbChAbmF0aXZlLCBvbGQsICphcmdzLCAmYmxvY2spXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgbmF0aXZlX3JlYWRlcigqbmFtZXMpXG4gICAgICBuYW1lcy5lYWNoIGRvIHxuYW1lfFxuICAgICAgICBkZWZpbmVfbWV0aG9kIG5hbWUgZG9cbiAgICAgICAgICBOYXRpdmUoYCN7QG5hdGl2ZX1bbmFtZV1gKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIG5hdGl2ZV93cml0ZXIoKm5hbWVzKVxuICAgICAgbmFtZXMuZWFjaCBkbyB8bmFtZXxcbiAgICAgICAgZGVmaW5lX21ldGhvZCBcIiN7bmFtZX09XCIgZG8gfHZhbHVlfFxuICAgICAgICAgIE5hdGl2ZShgI3tAbmF0aXZlfVtuYW1lXSA9IHZhbHVlYClcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBuYXRpdmVfYWNjZXNzb3IoKm5hbWVzKVxuICAgICAgbmF0aXZlX3JlYWRlcigqbmFtZXMpXG4gICAgICBuYXRpdmVfd3JpdGVyKCpuYW1lcylcbiAgICBlbmRcbiAgZW5kXG5cbiAgbW9kdWxlIFdyYXBwZXJcbiAgICBkZWYgaW5pdGlhbGl6ZShuYXRpdmUpXG4gICAgICB1bmxlc3MgOjpLZXJuZWwubmF0aXZlPyhuYXRpdmUpXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIEFyZ3VtZW50RXJyb3IsIFwiI3tuYXRpdmUuaW5zcGVjdH0gaXNuJ3QgbmF0aXZlXCJcbiAgICAgIGVuZFxuXG4gICAgICBAbmF0aXZlID0gbmF0aXZlXG4gICAgZW5kXG5cbiAgICAjIFJldHVybnMgdGhlIGludGVybmFsIG5hdGl2ZSBKYXZhU2NyaXB0IHZhbHVlXG4gICAgZGVmIHRvX25cbiAgICAgIEBuYXRpdmVcbiAgICBlbmRcblxuICAgIGRlZiBzZWxmLmluY2x1ZGVkKGtsYXNzKVxuICAgICAga2xhc3MuZXh0ZW5kIEhlbHBlcnNcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNlbGYuaW5jbHVkZWQoYmFzZSlcbiAgICB3YXJuICdJbmNsdWRpbmcgOjpOYXRpdmUgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIGluY2x1ZGUgTmF0aXZlOjpXcmFwcGVyIGluc3RlYWQuJ1xuICAgIGJhc2UuaW5jbHVkZSBXcmFwcGVyXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBLZXJuZWxcbiAgZGVmIG5hdGl2ZT8odmFsdWUpXG4gICAgYHZhbHVlID09IG51bGwgfHwgIXZhbHVlLiQkY2xhc3NgXG4gIGVuZFxuXG4gICMgV3JhcHMgYSBuYXRpdmUgSmF2YVNjcmlwdCB3aXRoIGBOYXRpdmU6Ok9iamVjdC5uZXdgXG4gICNcbiAgIyBAcmV0dXJuIFtOYXRpdmU6Ok9iamVjdF0gVGhlIHdyYXBwZWQgb2JqZWN0IGlmIGl0IGlzIG5hdGl2ZVxuICAjIEByZXR1cm4gW25pbF0gZm9yIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgIyBAcmV0dXJuIFtvYmpdIFRoZSBvYmplY3QgaXRzZWxmIGlmIGl0J3Mgbm90IG5hdGl2ZVxuICBkZWYgTmF0aXZlKG9iailcbiAgICBpZiBgI3tvYmp9ID09IG51bGxgXG4gICAgICBuaWxcbiAgICBlbHNpZiBuYXRpdmU/KG9iailcbiAgICAgIE5hdGl2ZTo6T2JqZWN0Lm5ldyhvYmopXG4gICAgZWxzaWYgb2JqLmlzX2E/KEFycmF5KVxuICAgICAgb2JqLm1hcCBkbyB8b3xcbiAgICAgICAgTmF0aXZlKG8pXG4gICAgICBlbmRcbiAgICBlbHNpZiBvYmouaXNfYT8oUHJvYylcbiAgICAgIHByb2MgZG8gfCphcmdzLCAmYmxvY2t8XG4gICAgICAgIE5hdGl2ZShvYmouY2FsbCgqYXJncywgJmJsb2NrKSlcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIG9ialxuICAgIGVuZFxuICBlbmRcblxuICBhbGlhcyBfQXJyYXkgQXJyYXlcblxuICAjIFdyYXBzIGFycmF5LWxpa2UgSmF2YVNjcmlwdCBvYmplY3RzIGluIE5hdGl2ZTo6QXJyYXlcbiAgZGVmIEFycmF5KG9iamVjdCwgKmFyZ3MsICZibG9jaylcbiAgICBpZiBuYXRpdmU/KG9iamVjdClcbiAgICAgIHJldHVybiBOYXRpdmU6OkFycmF5Lm5ldyhvYmplY3QsICphcmdzLCAmYmxvY2spLnRvX2FcbiAgICBlbmRcbiAgICBfQXJyYXkob2JqZWN0KVxuICBlbmRcbmVuZFxuXG5jbGFzcyBOYXRpdmU6Ok9iamVjdCA8IEJhc2ljT2JqZWN0XG4gIGluY2x1ZGUgOjpOYXRpdmU6OldyYXBwZXJcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgYCN7QG5hdGl2ZX0gPT09ICN7OjpOYXRpdmUudHJ5X2NvbnZlcnQob3RoZXIpfWBcbiAgZW5kXG5cbiAgZGVmIGhhc19rZXk/KG5hbWUpXG4gICAgYE9wYWwuaGFzT3duUHJvcGVydHkuY2FsbCgje0BuYXRpdmV9LCAje25hbWV9KWBcbiAgZW5kXG5cbiAgZGVmIGVhY2goKmFyZ3MpXG4gICAgaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICAleHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluICN7QG5hdGl2ZX0pIHtcbiAgICAgICAgICAje3lpZWxkIGBrZXlgLCBgI3tAbmF0aXZlfVtrZXldYH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmXG4gICAgZWxzZVxuICAgICAgbWV0aG9kX21pc3NpbmcoOmVhY2gsICphcmdzKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgW10oa2V5KVxuICAgICV4e1xuICAgICAgdmFyIHByb3AgPSAje0BuYXRpdmV9W2tleV07XG5cbiAgICAgIGlmIChwcm9wIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7OjpOYXRpdmUuY2FsbChAbmF0aXZlLCBrZXkpfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIFtdPShrZXksIHZhbHVlKVxuICAgIG5hdGl2ZSA9IDo6TmF0aXZlLnRyeV9jb252ZXJ0KHZhbHVlKVxuXG4gICAgaWYgYCN7bmF0aXZlfSA9PT0gbmlsYFxuICAgICAgYCN7QG5hdGl2ZX1ba2V5XSA9ICN7dmFsdWV9YFxuICAgIGVsc2VcbiAgICAgIGAje0BuYXRpdmV9W2tleV0gPSAje25hdGl2ZX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBtZXJnZSEob3RoZXIpXG4gICAgJXh7XG4gICAgICBvdGhlciA9ICN7OjpOYXRpdmUuY29udmVydChvdGhlcil9O1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIG90aGVyKSB7XG4gICAgICAgICN7QG5hdGl2ZX1bcHJvcF0gPSBvdGhlcltwcm9wXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByZXNwb25kX3RvPyhuYW1lLCBpbmNsdWRlX2FsbCA9IGZhbHNlKVxuICAgIDo6S2VybmVsLmluc3RhbmNlX21ldGhvZCg6cmVzcG9uZF90bz8pLmJpbmQoc2VsZikuY2FsbChuYW1lLCBpbmNsdWRlX2FsbClcbiAgZW5kXG5cbiAgZGVmIHJlc3BvbmRfdG9fbWlzc2luZz8obmFtZSwgaW5jbHVkZV9hbGwgPSBmYWxzZSlcbiAgICBgT3BhbC5oYXNPd25Qcm9wZXJ0eS5jYWxsKCN7QG5hdGl2ZX0sICN7bmFtZX0pYFxuICBlbmRcblxuICBkZWYgbWV0aG9kX21pc3NpbmcobWlkLCAqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKG1pZC5jaGFyQXQobWlkLmxlbmd0aCAtIDEpID09PSAnPScpIHtcbiAgICAgICAgcmV0dXJuICN7c2VsZlttaWQuc2xpY2UoMCwgbWlkLmxlbmd0aCAtIDEpXSA9IGFyZ3NbMF19O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAjezo6TmF0aXZlLmNhbGwoQG5hdGl2ZSwgbWlkLCAqYXJncywgJmJsb2NrKX07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgbmlsP1xuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiBpc19hPyhrbGFzcylcbiAgICBgT3BhbC5pc19hKHNlbGYsIGtsYXNzKWBcbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX29mPyhrbGFzcylcbiAgICBgc2VsZi4kJGNsYXNzID09PSBrbGFzc2BcbiAgZW5kXG5cbiAgZGVmIGNsYXNzXG4gICAgYHNlbGYuJCRjbGFzc2BcbiAgZW5kXG5cbiAgZGVmIHRvX2Eob3B0aW9ucyA9IHt9LCAmYmxvY2spXG4gICAgOjpOYXRpdmU6OkFycmF5Lm5ldyhAbmF0aXZlLCBvcHRpb25zLCAmYmxvY2spLnRvX2FcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBcIiM8TmF0aXZlOiN7YFN0cmluZygje0BuYXRpdmV9KWB9PlwiXG4gIGVuZFxuXG4gIGFsaWFzIGluY2x1ZGU/IGhhc19rZXk/XG4gIGFsaWFzIGtleT8gaGFzX2tleT9cbiAgYWxpYXMga2luZF9vZj8gaXNfYT9cbiAgYWxpYXMgbWVtYmVyPyBoYXNfa2V5P1xuZW5kXG5cbmNsYXNzIE5hdGl2ZTo6QXJyYXlcbiAgaW5jbHVkZSBOYXRpdmU6OldyYXBwZXJcbiAgaW5jbHVkZSBFbnVtZXJhYmxlXG5cbiAgZGVmIGluaXRpYWxpemUobmF0aXZlLCBvcHRpb25zID0ge30sICZibG9jaylcbiAgICBzdXBlcihuYXRpdmUpXG5cbiAgICBAZ2V0ICAgID0gb3B0aW9uc1s6Z2V0XSB8fCBvcHRpb25zWzphY2Nlc3NdXG4gICAgQG5hbWVkICA9IG9wdGlvbnNbOm5hbWVkXVxuICAgIEBzZXQgICAgPSBvcHRpb25zWzpzZXRdIHx8IG9wdGlvbnNbOmFjY2Vzc11cbiAgICBAbGVuZ3RoID0gb3B0aW9uc1s6bGVuZ3RoXSB8fCA6bGVuZ3RoXG4gICAgQGJsb2NrICA9IGJsb2NrXG5cbiAgICBpZiBgI3tsZW5ndGh9ID09IG51bGxgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnbm8gbGVuZ3RoIGZvdW5kIG9uIHRoZSBhcnJheS1saWtlIG9iamVjdCdcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaCB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9ICN7bGVuZ3RofTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCAje3NlbGZbYGlgXX0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIFtdKGluZGV4KVxuICAgIHJlc3VsdCA9IGNhc2UgaW5kZXhcbiAgICAgICAgICAgICB3aGVuIFN0cmluZywgU3ltYm9sXG4gICAgICAgICAgICAgICBAbmFtZWQgPyBgI3tAbmF0aXZlfVsje0BuYW1lZH1dKCN7aW5kZXh9KWAgOiBgI3tAbmF0aXZlfVsje2luZGV4fV1gXG4gICAgICAgICAgICAgd2hlbiBJbnRlZ2VyXG4gICAgICAgICAgICAgICBAZ2V0ID8gYCN7QG5hdGl2ZX1bI3tAZ2V0fV0oI3tpbmRleH0pYCA6IGAje0BuYXRpdmV9WyN7aW5kZXh9XWBcbiAgICAgICAgICAgICBlbmRcblxuICAgIGlmIHJlc3VsdFxuICAgICAgaWYgQGJsb2NrXG4gICAgICAgIEBibG9jay5jYWxsKHJlc3VsdClcbiAgICAgIGVsc2VcbiAgICAgICAgTmF0aXZlKHJlc3VsdClcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgW109KGluZGV4LCB2YWx1ZSlcbiAgICBpZiBAc2V0XG4gICAgICBgI3tAbmF0aXZlfVsje0BzZXR9XSgje2luZGV4fSwgI3tOYXRpdmUuY29udmVydCh2YWx1ZSl9KWBcbiAgICBlbHNlXG4gICAgICBgI3tAbmF0aXZlfVsje2luZGV4fV0gPSAje05hdGl2ZS5jb252ZXJ0KHZhbHVlKX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBsYXN0KGNvdW50ID0gbmlsKVxuICAgIGlmIGNvdW50XG4gICAgICBpbmRleCAgPSBsZW5ndGggLSAxXG4gICAgICByZXN1bHQgPSBbXVxuXG4gICAgICB3aGlsZSBpbmRleCA+PSAwXG4gICAgICAgIHJlc3VsdCA8PCBzZWxmW2luZGV4XVxuICAgICAgICBpbmRleCAgLT0gMVxuICAgICAgZW5kXG5cbiAgICAgIHJlc3VsdFxuICAgIGVsc2VcbiAgICAgIHNlbGZbbGVuZ3RoIC0gMV1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGxlbmd0aFxuICAgIGAje0BuYXRpdmV9WyN7QGxlbmd0aH1dYFxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIHRvX2EuaW5zcGVjdFxuICBlbmRcblxuICBhbGlhcyB0b19hcnkgdG9fYVxuZW5kXG5cbmNsYXNzIE51bWVyaWNcbiAgIyBAcmV0dXJuIHRoZSBpbnRlcm5hbCBKYXZhU2NyaXB0IHZhbHVlICh3aXRoIGB2YWx1ZU9mYCkuXG4gIGRlZiB0b19uXG4gICAgYHNlbGYudmFsdWVPZigpYFxuICBlbmRcbmVuZFxuXG5jbGFzcyBQcm9jXG4gICMgQHJldHVybiBpdHNlbGYgKGFuIGluc3RhbmNlIG9mIGBGdW5jdGlvbmApXG4gIGRlZiB0b19uXG4gICAgc2VsZlxuICBlbmRcbmVuZFxuXG5jbGFzcyBTdHJpbmdcbiAgIyBAcmV0dXJuIHRoZSBpbnRlcm5hbCBKYXZhU2NyaXB0IHZhbHVlICh3aXRoIGB2YWx1ZU9mYCkuXG4gIGRlZiB0b19uXG4gICAgYHNlbGYudmFsdWVPZigpYFxuICBlbmRcbmVuZFxuXG5jbGFzcyBSZWdleHBcbiAgIyBAcmV0dXJuIHRoZSBpbnRlcm5hbCBKYXZhU2NyaXB0IHZhbHVlICh3aXRoIGB2YWx1ZU9mYCkuXG4gIGRlZiB0b19uXG4gICAgYHNlbGYudmFsdWVPZigpYFxuICBlbmRcbmVuZFxuXG5jbGFzcyBNYXRjaERhdGFcbiAgIyBAcmV0dXJuIHRoZSBhcnJheSBvZiBtYXRjaGVzXG4gIGRlZiB0b19uXG4gICAgQG1hdGNoZXNcbiAgZW5kXG5lbmRcblxuY2xhc3MgU3RydWN0XG4gICMgQHJldHVybiBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGggdGhlIG1lbWJlcnMgYXMga2V5cyBhbmQgdGhlaXJcbiAgIyB2YWx1ZXMgYXMgdmFsdWVzLlxuICBkZWYgdG9fblxuICAgIHJlc3VsdCA9IGB7fWBcblxuICAgIGVhY2hfcGFpciBkbyB8bmFtZSwgdmFsdWV8XG4gICAgICBgI3tyZXN1bHR9WyN7bmFtZX1dID0gI3tOYXRpdmUudHJ5X2NvbnZlcnQodmFsdWUsIHZhbHVlKX1gXG4gICAgZW5kXG5cbiAgICByZXN1bHRcbiAgZW5kXG5lbmRcblxuY2xhc3MgQXJyYXlcbiAgIyBSZXR1bnMgYSBjb3B5IG9mIGl0c2VsZiB0cnlpbmcgdG8gY2FsbCAjdG9fbiBvbiBlYWNoIG1lbWJlci5cbiAgZGVmIHRvX25cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG9iaiA9IHNlbGZbaV07XG5cbiAgICAgICAgcmVzdWx0LnB1c2goI3tOYXRpdmUudHJ5X2NvbnZlcnQoYG9iamAsIGBvYmpgKX0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5lbmRcblxuY2xhc3MgQm9vbGVhblxuICAjIEByZXR1cm4gdGhlIGludGVybmFsIEphdmFTY3JpcHQgdmFsdWUgKHdpdGggYHZhbHVlT2ZgKS5cbiAgZGVmIHRvX25cbiAgICBgc2VsZi52YWx1ZU9mKClgXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFRpbWVcbiAgIyBAcmV0dXJuIGl0c2VsZiAoYW4gaW5zdGFuY2Ugb2YgYERhdGVgKS5cbiAgZGVmIHRvX25cbiAgICBzZWxmXG4gIGVuZFxuZW5kXG5cbmNsYXNzIE5pbENsYXNzXG4gICMgQHJldHVybiB0aGUgY29ycmVzcG9uZGluZyBKYXZhU2NyaXB0IHZhbHVlIChgbnVsbGApLlxuICBkZWYgdG9fblxuICAgIGBudWxsYFxuICBlbmRcbmVuZFxuXG4jIFJ1bm5pbmcgdGhpcyBjb2RlIHR3aWNlIHJlc3VsdHMgaW4gYW4gaW5maW5pdGUgbG9vcC4gV2hpbGUgaXQncyB0cnVlXG4jIHRoYXQgd2Ugc2hvdWxkbid0IHJ1biB0aGlzIGZpbGUgdHdpY2UsIHRoZXJlIGFyZSBjZXJ0YWluIGNhc2VzLCBsaWtlXG4jIGZvciBleGFtcGxlIGxpdmUgcmVsb2FkLCB3aGVuIHRoaXMgbWF5IGhhcHBlbi5cbnVubGVzcyBIYXNoLm1ldGhvZF9kZWZpbmVkPyA6X2luaXRpYWxpemVcbiAgY2xhc3MgSGFzaFxuICAgIGFsaWFzIF9pbml0aWFsaXplIGluaXRpYWxpemVcblxuICAgICV4e1xuICAgICAgZnVuY3Rpb24gJGhhc2hfY29udmVydF9hbmRfcHV0X3ZhbHVlKGhhc2gsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgKHZhbHVlLmNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QgfHxcbiAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgTWFwKSkge1xuICAgICAgICAgJGhhc2hfcHV0KGhhc2gsIGtleSwgI3tIYXNoLm5ldyhgdmFsdWVgKX0pO1xuICAgICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgdmFsdWUuJCRpc19hcnJheSkge1xuICAgICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICBpZiAoaXRlbSAmJlxuICAgICAgICAgICAgICAoaXRlbS5jb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICBpdGVtLmNvbnN0cnVjdG9yID09PSBPYmplY3QgfHxcbiAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgTWFwKSkge1xuICAgICAgICAgICAgIHJldHVybiAje0hhc2gubmV3KGBpdGVtYCl9O1xuICAgICAgICAgICB9XG4gICAgICAgICAgIHJldHVybiAje05hdGl2ZShgaXRlbWApfTtcbiAgICAgICAgIH0pO1xuICAgICAgICAgJGhhc2hfcHV0KGhhc2gsIGtleSwgdmFsdWUpXG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgICRoYXNoX3B1dChoYXNoLCBrZXksICN7TmF0aXZlKGB2YWx1ZWApfSk7XG4gICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGRlZiBpbml0aWFsaXplKGRlZmF1bHRzID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgICAleHtcbiAgICAgICAgaWYgKGRlZmF1bHRzICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoZGVmYXVsdHMuY29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICBkZWZhdWx0cy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIga2V5LCB2YWx1ZTtcblxuICAgICAgICAgICAgZm9yIChrZXkgaW4gZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBkZWZhdWx0c1trZXldO1xuICAgICAgICAgICAgICAkaGFzaF9jb252ZXJ0X2FuZF9wdXRfdmFsdWUoc2VsZiwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGVmYXVsdHMgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgIE9wYWwuaGFzaF9lYWNoKGRlZmF1bHRzLCBmYWxzZSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAkaGFzaF9jb252ZXJ0X2FuZF9wdXRfdmFsdWUoc2VsZiwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBbZmFsc2UsIGZhbHNlXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAje19pbml0aWFsaXplKGRlZmF1bHRzLCAmYmxvY2spfTtcbiAgICAgIH1cbiAgICBlbmRcblxuICAgICMgQHJldHVybiBhIEphdmFTY3JpcHQgb2JqZWN0LCBpbiB0dXJuIGFsc28gY2FsbGluZyAjdG9fbiBvblxuICAgICMgYWxsIGtleXMgYW5kIHZhbHVlcy5cbiAgICBkZWYgdG9fblxuICAgICAgJXh7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgICAgICBPcGFsLmhhc2hfZWFjaChzZWxmLCBmYWxzZSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgIHJlc3VsdFsje05hdGl2ZS50cnlfY29udmVydChga2V5YCwgYGtleWApfV0gPSAje05hdGl2ZS50cnlfY29udmVydChgdmFsdWVgLCBgdmFsdWVgKX07XG4gICAgICAgICAgcmV0dXJuIFtmYWxzZSwgZmFsc2VdO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5jbGFzcyBNb2R1bGVcbiAgIyBFeHBvc2VzIHRoZSBjdXJyZW50IG1vZHVsZSBhcyBhIHByb3BlcnR5IG9mXG4gICMgdGhlIGdsb2JhbCBvYmplY3QgKGUuZy4gYHdpbmRvd2ApLlxuICBkZWYgbmF0aXZlX21vZHVsZVxuICAgIGBPcGFsLmdsb2JhbFsje25hbWV9XSA9ICN7c2VsZn1gXG4gIGVuZFxuZW5kXG5cbmNsYXNzIENsYXNzXG4gIGRlZiBuYXRpdmVfYWxpYXMobmV3X2pzaWQsIGV4aXN0aW5nX21pZClcbiAgICAleHtcbiAgICAgIHZhciBhbGlhc2VkID0gI3tzZWxmfS5wcm90b3R5cGVbT3BhbC5qc2lkKCN7ZXhpc3RpbmdfbWlkfSldO1xuICAgICAgaWYgKCFhbGlhc2VkKSB7XG4gICAgICAgICN7cmFpc2UgTmFtZUVycm9yLm5ldyhcInVuZGVmaW5lZCBtZXRob2QgYCN7ZXhpc3RpbmdfbWlkfScgZm9yIGNsYXNzIGAje2luc3BlY3R9J1wiLCBleGlzdGluZ19taWQpfTtcbiAgICAgIH1cbiAgICAgICN7c2VsZn0ucHJvdG90eXBlWyN7bmV3X2pzaWR9XSA9IGFsaWFzZWQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbmF0aXZlX2NsYXNzXG4gICAgbmF0aXZlX21vZHVsZVxuICAgIGBzZWxmW1wibmV3XCJdID0gc2VsZi4kbmV3YFxuICBlbmRcbmVuZFxuXG4jIEV4cG9zZXMgdGhlIGdsb2JhbCB2YWx1ZSAod291bGQgYmUgYHdpbmRvd2AgaW5zaWRlIGEgYnJvd3NlcilcbiQkID0gJGdsb2JhbCA9IE5hdGl2ZShgT3BhbC5nbG9iYWxgKVxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOk5hdGl2ZT4iLCJpc19hPyIsInNlbGYiLCJvYmplY3QiLCJrbGFzcyIsInRyeV9jb252ZXJ0IiwidmFsdWUiLCJkZWZhdWx0JCIsIm5hdGl2ZT8iLCJyZXNwb25kX3RvPyIsInRvX24iLCJjb252ZXJ0IiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwiaW5zcGVjdCIsImNhbGwiLCJvYmoiLCJrZXkiLCJOYXRpdmUiLCJwcm9jIiwiYmxvY2siLCJMb2NhbEp1bXBFcnJvciIsIktlcm5lbCIsImJsb2NrIGluIHByb2MiLCJibG9jayAoMiBsZXZlbHMpIGluIHByb2MiLCJtYXAhIiwiYXJncyIsImFyZyIsImJsb2NrICgzIGxldmVscykgaW4gcHJvYyIsImluc3RhbmNlIiwiPG1vZHVsZTpIZWxwZXJzPiIsImFsaWFzX25hdGl2ZSIsIm5ldyQiLCJvbGQiLCJlbmRfd2l0aD8iLCJkZWZpbmVfbWV0aG9kIiwiYmxvY2sgaW4gYWxpYXNfbmF0aXZlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBhbGlhc19uYXRpdmUiLCJAbmF0aXZlIiwiW10iLCIwIiwiLTIiLCJhcyIsInRvX3Byb2MiLCJuZXciLCJuYXRpdmVfcmVhZGVyIiwiZWFjaCIsIm5hbWVzIiwiYmxvY2sgaW4gbmF0aXZlX3JlYWRlciIsIm5hbWUiLCJibG9jayAoMiBsZXZlbHMpIGluIG5hdGl2ZV9yZWFkZXIiLCJibG9jayAoMyBsZXZlbHMpIGluIG5hdGl2ZV9yZWFkZXIiLCJuYXRpdmVfd3JpdGVyIiwiYmxvY2sgaW4gbmF0aXZlX3dyaXRlciIsImJsb2NrICgyIGxldmVscykgaW4gbmF0aXZlX3dyaXRlciIsImJsb2NrICgzIGxldmVscykgaW4gbmF0aXZlX3dyaXRlciIsIm5hdGl2ZV9hY2Nlc3NvciIsIjxtb2R1bGU6V3JhcHBlcj4iLCJpbml0aWFsaXplIiwibmF0aXZlJCIsImluY2x1ZGVkIiwiZXh0ZW5kIiwiSGVscGVycyIsImJhc2UiLCJ3YXJuIiwiaW5jbHVkZSIsIldyYXBwZXIiLCI8bW9kdWxlOktlcm5lbD4iLCJOYXRpdmU6Ok9iamVjdCIsIkFycmF5IiwibWFwIiwiYmxvY2sgaW4gTmF0aXZlIiwibyIsImJsb2NrICgyIGxldmVscykgaW4gTmF0aXZlIiwiUHJvYyIsIk5hdGl2ZTo6QXJyYXkiLCJ0b19hIiwiX0FycmF5IiwiPGNsYXNzOk5hdGl2ZTo6T2JqZWN0PiIsIk5hdGl2ZTo6V3JhcHBlciIsIj09Iiwib3RoZXIiLCJoYXNfa2V5PyIsImJsb2NrX2dpdmVuPyIsIm1ldGhvZF9taXNzaW5nIiwiW109IiwibWVyZ2UhIiwiaW5jbHVkZV9hbGwiLCJpbnN0YW5jZV9tZXRob2QiLCJiaW5kIiwicmVzcG9uZF90b19taXNzaW5nPyIsIm1pZCIsInNsaWNlIiwiLSIsImxlbmd0aCIsIjEiLCJuaWw/IiwiaW5zdGFuY2Vfb2Y/IiwiY2xhc3MiLCJvcHRpb25zIiwiQmFzaWNPYmplY3QiLCI8Y2xhc3M6TmF0aXZlOjpBcnJheT4iLCJFbnVtZXJhYmxlIiwiQGdldCIsIiRyZXRfb3JfMSIsIkBuYW1lZCIsIkBzZXQiLCJAbGVuZ3RoIiwiQGJsb2NrIiwiZW51bV9mb3IiLCJpbmRleCIsInJlc3VsdCIsIlN0cmluZyIsIlN5bWJvbCIsIkludGVnZXIiLCJsYXN0IiwiY291bnQiLCI+PSIsIjw8IiwiPGNsYXNzOk51bWVyaWM+IiwiPGNsYXNzOlByb2M+IiwiPGNsYXNzOlN0cmluZz4iLCI8Y2xhc3M6UmVnZXhwPiIsIjxjbGFzczpNYXRjaERhdGE+IiwiPGNsYXNzOlN0cnVjdD4iLCJlYWNoX3BhaXIiLCJibG9jayBpbiB0b19uIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0b19uIiwiPGNsYXNzOkFycmF5PiIsIjxjbGFzczpCb29sZWFuPiIsIjxjbGFzczpUaW1lPiIsIjxjbGFzczpOaWxDbGFzcz4iLCJIYXNoIiwibWV0aG9kX2RlZmluZWQ/IiwiPGNsYXNzOkhhc2g+IiwiZGVmYXVsdHMiLCJfaW5pdGlhbGl6ZSIsIjxjbGFzczpNb2R1bGU+IiwibmF0aXZlX21vZHVsZSIsIjxjbGFzczpDbGFzcz4iLCJuYXRpdmVfYWxpYXMiLCJuZXdfanNpZCIsImV4aXN0aW5nX21pZCIsIk5hbWVFcnJvciIsIm5hdGl2ZV9jbGFzcyIsIiQkIiwiJGdsb2JhbCJdLCJtYXBwaW5ncyI6IkFBQUFBLHlCQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQW9CQUM7RUFBQUE7O0lBQUFBOzs7SUFDRUMsTUFBSUMsSUFBSkQsWUFBQUEsNkJBQWVFLE1BQUQsRUFBU0MsS0FBdkJIO0FBQUFBLE1BQUFBOzs7QUFFRkE7QUFDQUEsZUFBaUJFLE1BQU9GLFlBQWNDLElBQUFHLGFBQUFBLENBQVlELEtBQVpDLENBQW1CSjtBQUN6REE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUFSRUEsQ0FBQUE7SUFXQUksTUFBSUgsSUFBSkcsa0JBQUFBLHVCQUFxQkMsS0FBRCxFQUFRQyxRQUE1QkY7QUFBQUEsTUFBQUE7OztNQUE0QixpQ0FBVTs7QUFFeENBLFVBQVlILElBQUFNLFlBQUFBLENBQVFGLEtBQVJFLENBQWVIO0FBQzNCQSxlQUFpQkMsS0FBTUQ7QUFDdkJBO0FBQ0FBLGVBQWlCQyxLQUFLRyxnQkFBQUEsQ0FBYSxNQUFiQSxDQUFtQko7QUFDekNBLGVBQWlCQyxLQUFLSSxNQUFBQSxDQUFBQSxDQUFNTDtBQUM1QkE7QUFDQUE7QUFDQUEsZUFBaUJFLFFBQVFGO0FBQ3pCQTtBQUNBQTtJQVhFQSxDQUFBQSxJQUFBQTtJQWNBTSxNQUFJVCxJQUFKUyxjQUFBQSxtQkFBaUJMLEtBQWpCSztBQUFBQSxNQUFBQTs7O0FBRUZBLFVBQVlULElBQUFNLFlBQUFBLENBQVFGLEtBQVJFLENBQWVHO0FBQzNCQSxlQUFpQkwsS0FBTUs7QUFDdkJBO0FBQ0FBLGVBQWlCTCxLQUFLRyxnQkFBQUEsQ0FBYSxNQUFiQSxDQUFtQkU7QUFDekNBLGVBQWlCTCxLQUFLSSxNQUFBQSxDQUFBQSxDQUFNQztBQUM1QkE7QUFDQUE7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b290IjoiIiwic291cmNlcyI6WyIuL2NvbnNvbGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXG5cbnJlcXVpcmUgJ25hdGl2ZSdcblxuIyBNYW5pcHVsYXRlIHRoZSBicm93c2VyIGNvbnNvbGUuXG4jXG4jIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL2NvbnNvbGVcbmNsYXNzIENvbnNvbGVcbiAgaW5jbHVkZSBOYXRpdmU6OldyYXBwZXJcblxuICAjIENsZWFyIHRoZSBjb25zb2xlLlxuICBkZWYgY2xlYXJcbiAgICBgI3tAbmF0aXZlfS5jbGVhcigpYFxuICBlbmRcblxuICAjIFByaW50IGEgc3RhY2t0cmFjZSBmcm9tIHRoZSBjYWxsIHNpdGUuXG4gIGRlZiB0cmFjZVxuICAgIGAje0BuYXRpdmV9LnRyYWNlKClgXG4gIGVuZFxuXG4gICMgTG9nIHRoZSBwYXNzZWQgb2JqZWN0cyBiYXNlZCBvbiBhbiBvcHRpb25hbCBpbml0aWFsIGZvcm1hdC5cbiAgZGVmIGxvZygqYXJncylcbiAgICBgI3tAbmF0aXZlfS5sb2cuYXBwbHkoI3tAbmF0aXZlfSwgYXJncylgXG4gIGVuZFxuXG4gICMgTG9nIHRoZSBwYXNzZWQgb2JqZWN0cyBiYXNlZCBvbiBhbiBvcHRpb25hbCBpbml0aWFsIGZvcm1hdCBhcyBpbmZvcm1hdGlvbmFsXG4gICMgbG9nLlxuICBkZWYgaW5mbygqYXJncylcbiAgICBgI3tAbmF0aXZlfS5pbmZvLmFwcGx5KCN7QG5hdGl2ZX0sIGFyZ3MpYFxuICBlbmRcblxuICAjIExvZyB0aGUgcGFzc2VkIG9iamVjdHMgYmFzZWQgb24gYW4gb3B0aW9uYWwgaW5pdGlhbCBmb3JtYXQgYXMgd2FybmluZy5cbiAgZGVmIHdhcm4oKmFyZ3MpXG4gICAgYCN7QG5hdGl2ZX0ud2Fybi5hcHBseSgje0BuYXRpdmV9LCBhcmdzKWBcbiAgZW5kXG5cbiAgIyBMb2cgdGhlIHBhc3NlZCBvYmplY3RzIGJhc2VkIG9uIGFuIG9wdGlvbmFsIGluaXRpYWwgZm9ybWF0IGFzIGVycm9yLlxuICBkZWYgZXJyb3IoKmFyZ3MpXG4gICAgYCN7QG5hdGl2ZX0uZXJyb3IuYXBwbHkoI3tAbmF0aXZlfSwgYXJncylgXG4gIGVuZFxuXG4gICMgVGltZSB0aGUgZ2l2ZW4gYmxvY2sgd2l0aCB0aGUgZ2l2ZW4gbGFiZWwuXG4gIGRlZiB0aW1lKGxhYmVsLCAmYmxvY2spXG4gICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ25vIGJsb2NrIGdpdmVuJyB1bmxlc3MgYmxvY2tcblxuICAgIGAje0BuYXRpdmV9LnRpbWUobGFiZWwpYFxuXG4gICAgYmVnaW5cbiAgICAgIGlmIGJsb2NrLmFyaXR5ID09IDBcbiAgICAgICAgaW5zdGFuY2VfZXhlYygmYmxvY2spXG4gICAgICBlbHNlXG4gICAgICAgIHlpZWxkKHNlbGYpXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGAje0BuYXRpdmV9LnRpbWVFbmQoKWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgIyBHcm91cCB0aGUgZ2l2ZW4gYmxvY2suXG4gIGRlZiBncm91cCgqYXJncywgJmJsb2NrKVxuICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICBgI3tAbmF0aXZlfS5ncm91cC5hcHBseSgje0BuYXRpdmV9LCBhcmdzKWBcblxuICAgIGJlZ2luXG4gICAgICBpZiBibG9jay5hcml0eSA9PSAwXG4gICAgICAgIGluc3RhbmNlX2V4ZWMoJmJsb2NrKVxuICAgICAgZWxzZVxuICAgICAgICB5aWVsZChzZWxmKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBgI3tAbmF0aXZlfS5ncm91cEVuZCgpYFxuICAgIGVuZFxuICBlbmRcblxuICAjIEdyb3VwIHRoZSBnaXZlbiBibG9jayBidXQgY29sbGFwc2UgaXQuXG4gIGRlZiBncm91cCEoKmFyZ3MsICZibG9jaylcbiAgICByZXR1cm4gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgYCN7QG5hdGl2ZX0uZ3JvdXBDb2xsYXBzZWQuYXBwbHkoI3tAbmF0aXZlfSwgYXJncylgXG5cbiAgICBiZWdpblxuICAgICAgaWYgYmxvY2suYXJpdHkgPT0gMFxuICAgICAgICBpbnN0YW5jZV9leGVjKCZibG9jaylcbiAgICAgIGVsc2VcbiAgICAgICAgeWllbGQoc2VsZilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgYCN7QG5hdGl2ZX0uZ3JvdXBFbmQoKWBcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuaWYgZGVmaW5lZD8oYE9wYWwuZ2xvYmFsLmNvbnNvbGVgKVxuICAkY29uc29sZSA9IENvbnNvbGUubmV3KGBPcGFsLmdsb2JhbC5jb25zb2xlYClcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpDb25zb2xlPiIsImluY2x1ZGUiLCJOYXRpdmU6OldyYXBwZXIiLCJOYXRpdmUiLCJjbGVhciIsIkBuYXRpdmUiLCJ0cmFjZSIsImxvZyIsImluZm8iLCJ3YXJuIiwiZXJyb3IiLCJ0aW1lIiwibGFiZWwiLCJibG9jayIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsImFyaXR5IiwiMCIsImluc3RhbmNlX2V4ZWMiLCJ0b19wcm9jIiwiZ3JvdXAiLCJncm91cCEiLCJibG9ja19naXZlbj8iLCIkY29uc29sZSIsIkNvbnNvbGUiLCJuZXciXSwibWFwcGluZ3MiOiJBQUFBQSwwQkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFFQUMsSUFBQUMsU0FBQUEsQ0FBUUYsUUFBUkU7RUFLQUM7RUFBQUE7O0lBQUFBOztBQUFBQTs7SUFDRUYsSUFBQUcsU0FBQUEsQ0FBUUMsSUFBQUMsWUFBQUQsWUFBUkQ7O0FBR0FHLElBQUFBLHFCQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUdDLGNBQVFEO0lBRGJBLENBQUFBOztBQUtBRSxJQUFBQSxxQkFBQUEsaUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFH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Ijp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4vcHJvbWlzZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIHtQcm9taXNlfSBpcyB1c2VkIHRvIGhlbHAgc3RydWN0dXJlIGFzeW5jaHJvbm91cyBjb2RlLlxuI1xuIyBJdCBpcyBhdmFpbGFibGUgaW4gdGhlIE9wYWwgc3RhbmRhcmQgbGlicmFyeSwgYW5kIGNhbiBiZSByZXF1aXJlZCBpbiBhbnkgT3BhbFxuIyBhcHBsaWNhdGlvbjpcbiNcbiMgICAgIHJlcXVpcmUgJ3Byb21pc2UnXG4jXG4jICMjIEJhc2ljIFVzYWdlXG4jXG4jIFByb21pc2VzIGFyZSBjcmVhdGVkIGFuZCByZXR1cm5lZCBhcyBvYmplY3RzIHdpdGggdGhlIGFzc3VtcHRpb24gdGhhdCB0aGV5XG4jIHdpbGwgZXZlbnR1YWxseSBiZSByZXNvbHZlZCBvciByZWplY3RlZCwgYnV0IG5ldmVyIGJvdGguIEEge1Byb21pc2V9IGhhc1xuIyBhIHsjdGhlbn0gYW5kIHsjZmFpbH0gbWV0aG9kIChvciBvbmUgb2YgdGhlaXIgYWxpYXNlcykgdGhhdCBjYW4gYmUgdXNlZCB0b1xuIyByZWdpc3RlciBhIGJsb2NrIHRoYXQgZ2V0cyBjYWxsZWQgb25jZSByZXNvbHZlZCBvciByZWplY3RlZC5cbiNcbiMgICAgIHByb21pc2UgPSBQcm9taXNlLm5ld1xuI1xuIyAgICAgcHJvbWlzZS50aGVuIHtcbiMgICAgICAgcHV0cyBcInJlc29sdmVkIVwiXG4jICAgICB9LmZhaWwge1xuIyAgICAgICBwdXRzIFwicmVqZWN0ZWQhXCJcbiMgICAgIH1cbiNcbiMgICAgICMgc29tZSB0aW1lIGxhdGVyXG4jICAgICBwcm9taXNlLnJlc29sdmVcbiNcbiMgICAgICMgPT4gXCJyZXNvbHZlZCFcIlxuI1xuIyBJdCBpcyBpbXBvcnRhbnQgdG8gcmVtZW1iZXIgdGhhdCBhIHByb21pc2UgY2FuIG9ubHkgYmUgcmVzb2x2ZWQgb3IgcmVqZWN0ZWRcbiMgb25jZSwgc28gdGhlIGJsb2NrIHdpbGwgb25seSBldmVyIGJlIGNhbGxlZCBvbmNlIChvciBub3QgYXQgYWxsKS5cbiNcbiMgIyMgUmVzb2x2aW5nIFByb21pc2VzXG4jXG4jIFRvIHJlc29sdmUgYSBwcm9taXNlLCBtZWFucyB0byBpbmZvcm0gdGhlIHtQcm9taXNlfSB0aGF0IGl0IGhhcyBzdWNjZWVkZWRcbiMgb3IgZXZhbHVhdGVkIHRvIGEgdXNlZnVsIHZhbHVlLiB7I3Jlc29sdmV9IGNhbiBiZSBwYXNzZWQgYSB2YWx1ZSB3aGljaCBpc1xuIyB0aGVuIHBhc3NlZCBpbnRvIHRoZSBibG9jayBoYW5kbGVyOlxuI1xuIyAgICAgZGVmIGdldF9qc29uXG4jICAgICAgIHByb21pc2UgPSBQcm9taXNlLm5ld1xuI1xuIyAgICAgICBIVFRQLmdldChcInNvbWVfdXJsXCIpIGRvIHxyZXF8XG4jICAgICAgICAgcHJvbWlzZS5yZXNvbHZlIHJlcS5qc29uXG4jICAgICAgIGVuZFxuI1xuIyAgICAgICBwcm9taXNlXG4jICAgICBlbmRcbiNcbiMgICAgIGdldF9qc29uLnRoZW4gZG8gfGpzb258XG4jICAgICAgIHB1dHMgXCJnb3Qgc29tZSBKU09OIGZyb20gc2VydmVyXCJcbiMgICAgIGVuZFxuI1xuIyAjIyBSZWplY3RpbmcgUHJvbWlzZXNcbiNcbiMgUHJvbWlzZXMgYXJlIGFsc28gZGVzaWduZWQgdG8gaGFuZGxlIGVycm9yIGNhc2VzLCBvciBzaXR1YXRpb25zIHdoZXJlIGFuXG4jIG91dGNvbWUgaXMgbm90IGFzIGV4cGVjdGVkLiBUYWtpbmcgdGhlIHByZXZpb3VzIGV4YW1wbGUsIHdlIGNhbiBhbHNvIHBhc3NcbiMgYSB2YWx1ZSB0byBhIHsjcmVqZWN0fSBjYWxsLCB3aGljaCBwYXNzZXMgdGhhdCBvYmplY3QgdG8gdGhlIHJlZ2lzdGVyZWRcbiMgeyNmYWlsfSBoYW5kbGVyOlxuI1xuIyAgICAgZGVmIGdldF9qc29uXG4jICAgICAgIHByb21pc2UgPSBQcm9taXNlLm5ld1xuI1xuIyAgICAgICBIVFRQLmdldChcInNvbWVfdXJsXCIpIGRvIHxyZXF8XG4jICAgICAgICAgaWYgcmVxLm9rP1xuIyAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlIHJlcS5qc29uXG4jICAgICAgICAgZWxzZVxuIyAgICAgICAgICAgcHJvbWlzZS5yZWplY3QgcmVxXG4jICAgICAgICAgZW5kXG4jXG4jICAgICAgIHByb21pc2VcbiMgICAgIGVuZFxuI1xuIyAgICAgZ2V0X2pzb24udGhlbiB7XG4jICAgICAgICMgLi4uXG4jICAgICB9LmZhaWwgeyB8cmVxfFxuIyAgICAgICBwdXRzIFwiaXQgd2VudCB3cm9uZzogI3tyZXEubWVzc2FnZX1cIlxuIyAgICAgfVxuI1xuIyAjIyBDaGFpbmluZyBQcm9taXNlc1xuI1xuIyBQcm9taXNlcyBiZWNvbWUgZXZlbiBtb3JlIHVzZWZ1bCB3aGVuIGNoYWluZWQgdG9nZXRoZXIuIEVhY2ggeyN0aGVufSBvclxuIyB7I2ZhaWx9IGNhbGwgcmV0dXJucyBhIG5ldyB7UHJvbWlzZX0gd2hpY2ggY2FuIGJlIHVzZWQgdG8gY2hhaW4gbW9yZSBhbmQgbW9yZVxuIyBoYW5kbGVycyB0b2dldGhlci5cbiNcbiMgICAgIHByb21pc2UudGhlbiB7IHdhaXRfZm9yX3NvbWV0aGluZyB9LnRoZW4geyBkb19zb21ldGhpbmdfZWxzZSB9XG4jXG4jIFJlamVjdGlvbnMgYXJlIHByb3BhZ2F0ZWQgdGhyb3VnaCB0aGUgZW50aXJlIGNoYWluLCBzbyBhIFwiY2F0Y2ggYWxsXCIgaGFuZGxlclxuIyBjYW4gYmUgYXR0YWNoZWQgYXQgdGhlIGVuZCBvZiB0aGUgdGFpbDpcbiNcbiMgICAgIHByb21pc2UudGhlbiB7IC4uLiB9LnRoZW4geyAuLi4gfS5mYWlsIHsgLi4uIH1cbiNcbiMgIyMgQ29tcG9zaW5nIFByb21pc2VzXG4jXG4jIHtQcm9taXNlLndoZW59IGNhbiBiZSB1c2VkIHRvIHdhaXQgZm9yIG1vcmUgdGhhbiBvbmUgcHJvbWlzZSB0byByZXNvbHZlIChvclxuIyByZWplY3QpLiBVc2luZyB0aGUgcHJldmlvdXMgZXhhbXBsZSwgd2UgY291bGQgcmVxdWVzdCB0d28gZGlmZmVyZW50IGpzb25cbiMgcmVxdWVzdHMgYW5kIHdhaXQgZm9yIGJvdGggdG8gZmluaXNoOlxuI1xuIyAgICAgUHJvbWlzZS53aGVuKGdldF9qc29uLCBnZXRfanNvbjIpLnRoZW4gfGZpcnN0LCBzZWNvbmR8XG4jICAgICAgIHB1dHMgXCJnb3QgdHdvIGpzb24gcGF5bG9hZHM6ICN7Zmlyc3R9LCAje3NlY29uZH1cIlxuIyAgICAgZW5kXG4jXG5jbGFzcyBQcm9taXNlXG4gIGRlZiBzZWxmLnZhbHVlKHZhbHVlKVxuICAgIG5ldy5yZXNvbHZlKHZhbHVlKVxuICBlbmRcblxuICBkZWYgc2VsZi5lcnJvcih2YWx1ZSlcbiAgICBuZXcucmVqZWN0KHZhbHVlKVxuICBlbmRcblxuICBkZWYgc2VsZi53aGVuKCpwcm9taXNlcylcbiAgICBXaGVuLm5ldyhwcm9taXNlcylcbiAgZW5kXG5cbiAgYXR0cl9yZWFkZXIgOmVycm9yLCA6cHJldiwgOm5leHRcblxuICBkZWYgaW5pdGlhbGl6ZShhY3Rpb24gPSB7fSlcbiAgICBAYWN0aW9uID0gYWN0aW9uXG5cbiAgICBAcmVhbGl6ZWQgID0gZmFsc2VcbiAgICBAZXhjZXB0aW9uID0gZmFsc2VcbiAgICBAdmFsdWUgICAgID0gbmlsXG4gICAgQGVycm9yICAgICA9IG5pbFxuICAgIEBkZWxheWVkICAgPSBmYWxzZVxuXG4gICAgQHByZXYgPSBuaWxcbiAgICBAbmV4dCA9IFtdXG4gIGVuZFxuXG4gIGRlZiB2YWx1ZVxuICAgIGlmIFByb21pc2UgPT09IEB2YWx1ZVxuICAgICAgQHZhbHVlLnZhbHVlXG4gICAgZWxzZVxuICAgICAgQHZhbHVlXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBhY3Q/XG4gICAgQGFjdGlvbi5rZXk/KDpzdWNjZXNzKSB8fCBAYWN0aW9uLmtleT8oOmFsd2F5cylcbiAgZW5kXG5cbiAgZGVmIGFjdGlvblxuICAgIEBhY3Rpb24ua2V5c1xuICBlbmRcblxuICBkZWYgZXhjZXB0aW9uP1xuICAgIEBleGNlcHRpb25cbiAgZW5kXG5cbiAgZGVmIHJlYWxpemVkP1xuICAgIEByZWFsaXplZCAhPSBmYWxzZVxuICBlbmRcblxuICBkZWYgcmVzb2x2ZWQ/XG4gICAgQHJlYWxpemVkID09IDpyZXNvbHZlXG4gIGVuZFxuXG4gIGRlZiByZWplY3RlZD9cbiAgICBAcmVhbGl6ZWQgPT0gOnJlamVjdFxuICBlbmRcblxuICBkZWYgXihwcm9taXNlKVxuICAgIHByb21pc2UgPDwgc2VsZlxuICAgIHNlbGYgPj4gcHJvbWlzZVxuXG4gICAgcHJvbWlzZVxuICBlbmRcblxuICBkZWYgPDwocHJvbWlzZSlcbiAgICBAcHJldiA9IHByb21pc2VcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmID4+KHByb21pc2UpXG4gICAgQG5leHQgPDwgcHJvbWlzZVxuXG4gICAgaWYgZXhjZXB0aW9uP1xuICAgICAgcHJvbWlzZS5yZWplY3QoQGRlbGF5ZWRbMF0pXG4gICAgZWxzaWYgcmVzb2x2ZWQ/XG4gICAgICBwcm9taXNlLnJlc29sdmUoQGRlbGF5ZWQgPyBAZGVsYXllZFswXSA6IHZhbHVlKVxuICAgIGVsc2lmIHJlamVjdGVkP1xuICAgICAgaWYgIUBhY3Rpb24ua2V5Pyg6ZmFpbHVyZSkgfHwgUHJvbWlzZSA9PT0gKEBkZWxheWVkID8gQGRlbGF5ZWRbMF0gOiBAZXJyb3IpXG4gICAgICAgIHByb21pc2UucmVqZWN0KEBkZWxheWVkID8gQGRlbGF5ZWRbMF0gOiBlcnJvcilcbiAgICAgIGVsc2lmIHByb21pc2UuYWN0aW9uLmluY2x1ZGU/KDphbHdheXMpXG4gICAgICAgIHByb21pc2UucmVqZWN0KEBkZWxheWVkID8gQGRlbGF5ZWRbMF0gOiBlcnJvcilcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmVzb2x2ZSh2YWx1ZSA9IG5pbClcbiAgICBpZiByZWFsaXplZD9cbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd0aGUgcHJvbWlzZSBoYXMgYWxyZWFkeSBiZWVuIHJlYWxpemVkJ1xuICAgIGVuZFxuXG4gICAgaWYgUHJvbWlzZSA9PT0gdmFsdWVcbiAgICAgIHJldHVybiAodmFsdWUgPDwgQHByZXYpIF4gc2VsZlxuICAgIGVuZFxuXG4gICAgYmVnaW5cbiAgICAgIGJsb2NrID0gQGFjdGlvbls6c3VjY2Vzc10gfHwgQGFjdGlvbls6YWx3YXlzXVxuICAgICAgaWYgYmxvY2tcbiAgICAgICAgdmFsdWUgPSBibG9jay5jYWxsKHZhbHVlKVxuICAgICAgZW5kXG5cbiAgICAgIHJlc29sdmUhKHZhbHVlKVxuICAgIHJlc2N1ZSBFeGNlcHRpb24gPT4gZVxuICAgICAgZXhjZXB0aW9uIShlKVxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmVzb2x2ZSEodmFsdWUpXG4gICAgQHJlYWxpemVkID0gOnJlc29sdmVcbiAgICBAdmFsdWUgICAgPSB2YWx1ZVxuXG4gICAgaWYgQG5leHQuYW55P1xuICAgICAgQG5leHQuZWFjaCB7IHxwfCBwLnJlc29sdmUodmFsdWUpIH1cbiAgICBlbHNlXG4gICAgICBAZGVsYXllZCA9IFt2YWx1ZV1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHJlamVjdCh2YWx1ZSA9IG5pbClcbiAgICBpZiByZWFsaXplZD9cbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd0aGUgcHJvbWlzZSBoYXMgYWxyZWFkeSBiZWVuIHJlYWxpemVkJ1xuICAgIGVuZFxuXG4gICAgaWYgUHJvbWlzZSA9PT0gdmFsdWVcbiAgICAgIHJldHVybiAodmFsdWUgPDwgQHByZXYpIF4gc2VsZlxuICAgIGVuZFxuXG4gICAgYmVnaW5cbiAgICAgIGJsb2NrID0gQGFjdGlvbls6ZmFpbHVyZV0gfHwgQGFjdGlvbls6YWx3YXlzXVxuICAgICAgaWYgYmxvY2tcbiAgICAgICAgdmFsdWUgPSBibG9jay5jYWxsKHZhbHVlKVxuICAgICAgZW5kXG5cbiAgICAgIGlmIEBhY3Rpb24ua2V5Pyg6YWx3YXlzKVxuICAgICAgICByZXNvbHZlISh2YWx1ZSlcbiAgICAgIGVsc2VcbiAgICAgICAgcmVqZWN0ISh2YWx1ZSlcbiAgICAgIGVuZFxuICAgIHJlc2N1ZSBFeGNlcHRpb24gPT4gZVxuICAgICAgZXhjZXB0aW9uIShlKVxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmVqZWN0ISh2YWx1ZSlcbiAgICBAcmVhbGl6ZWQgPSA6cmVqZWN0XG4gICAgQGVycm9yICAgID0gdmFsdWVcblxuICAgIGlmIEBuZXh0LmFueT9cbiAgICAgIEBuZXh0LmVhY2ggeyB8cHwgcC5yZWplY3QodmFsdWUpIH1cbiAgICBlbHNlXG4gICAgICBAZGVsYXllZCA9IFt2YWx1ZV1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGV4Y2VwdGlvbiEoZXJyb3IpXG4gICAgQGV4Y2VwdGlvbiA9IHRydWVcblxuICAgIHJlamVjdCEoZXJyb3IpXG4gIGVuZFxuXG4gIGRlZiB0aGVuKCZibG9jaylcbiAgICBzZWxmIF4gUHJvbWlzZS5uZXcoc3VjY2VzczogYmxvY2spXG4gIGVuZFxuXG4gIGRlZiB0aGVuISgmYmxvY2spXG4gICAgdGhlcmVfY2FuX2JlX29ubHlfb25lIVxuICAgIHNlbGYudGhlbigmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBmYWlsKCZibG9jaylcbiAgICBzZWxmIF4gUHJvbWlzZS5uZXcoZmFpbHVyZTogYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBmYWlsISgmYmxvY2spXG4gICAgdGhlcmVfY2FuX2JlX29ubHlfb25lIVxuICAgIGZhaWwoJmJsb2NrKVxuICBlbmRcblxuICBkZWYgYWx3YXlzKCZibG9jaylcbiAgICBzZWxmIF4gUHJvbWlzZS5uZXcoYWx3YXlzOiBibG9jaylcbiAgZW5kXG5cbiAgZGVmIGFsd2F5cyEoJmJsb2NrKVxuICAgIHRoZXJlX2Nhbl9iZV9vbmx5X29uZSFcbiAgICBhbHdheXMoJmJsb2NrKVxuICBlbmRcblxuICBkZWYgdHJhY2UoZGVwdGggPSBuaWwsICZibG9jaylcbiAgICBzZWxmIF4gVHJhY2UubmV3KGRlcHRoLCBibG9jaylcbiAgZW5kXG5cbiAgZGVmIHRyYWNlISgqYXJncywgJmJsb2NrKVxuICAgIHRoZXJlX2Nhbl9iZV9vbmx5X29uZSFcbiAgICB0cmFjZSgqYXJncywgJmJsb2NrKVxuICBlbmRcblxuICBkZWYgdGhlcmVfY2FuX2JlX29ubHlfb25lIVxuICAgIGlmIEBuZXh0LmFueT9cbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdhIHByb21pc2UgaGFzIGFscmVhZHkgYmVlbiBjaGFpbmVkJ1xuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIHJlc3VsdCA9IFwiIzwje3NlbGYuY2xhc3N9KCN7b2JqZWN0X2lkfSlcIlxuXG4gICAgaWYgQG5leHQuYW55P1xuICAgICAgcmVzdWx0ICs9IFwiID4+ICN7QG5leHQuaW5zcGVjdH1cIlxuICAgIGVuZFxuXG4gICAgcmVzdWx0ICs9IGlmIHJlYWxpemVkP1xuICAgICAgICAgICAgICAgIFwiOiAjeyhAdmFsdWUgfHwgQGVycm9yKS5pbnNwZWN0fT5cIlxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgJz4nXG4gICAgICAgICAgICAgIGVuZFxuXG4gICAgcmVzdWx0XG4gIGVuZFxuXG4gIGRlZiB0b192MlxuICAgIHYyID0gUHJvbWlzZVYyLm5ld1xuXG4gICAgc2VsZi50aGVuIHsgfGl8IHYyLnJlc29sdmUoaSkgfS5yZXNjdWUgeyB8aXwgdjIucmVqZWN0KGkpIH1cblxuICAgIHYyXG4gIGVuZFxuXG4gICMgUHJvbWlzZVYxIGlzIG5vdCBhIG5hdGl2ZSBjb25zdHJ1Y3QsIHdlIG11c3QgY29udmVydCBpdCB0byBhIHYyIHByb21pc2VcbiAgYWxpYXMgYXdhaXQgdG9fdjJcblxuICBhbGlhcyBjYXRjaCBmYWlsXG4gIGFsaWFzIGNhdGNoISBmYWlsIVxuICBhbGlhcyBkbyB0aGVuXG4gIGFsaWFzIGRvISB0aGVuIVxuICBhbGlhcyBlbnN1cmUgYWx3YXlzXG4gIGFsaWFzIGVuc3VyZSEgYWx3YXlzIVxuICBhbGlhcyBmaW5hbGx5IGFsd2F5c1xuICBhbGlhcyBmaW5hbGx5ISBhbHdheXMhXG4gIGFsaWFzIHJlc2N1ZSBmYWlsXG4gIGFsaWFzIHJlc2N1ZSEgZmFpbCFcbiAgYWxpYXMgdG9fbiB0b192MlxuICBhbGlhcyB0b192MSBpdHNlbGZcblxuICBjbGFzcyBUcmFjZSA8IHNlbGZcbiAgICBkZWYgc2VsZi5pdChwcm9taXNlKVxuICAgICAgY3VycmVudCA9IFtdXG5cbiAgICAgIGlmIHByb21pc2UuYWN0PyB8fCBwcm9taXNlLnByZXYubmlsP1xuICAgICAgICBjdXJyZW50LnB1c2gocHJvbWlzZS52YWx1ZSlcbiAgICAgIGVuZFxuXG4gICAgICBwcmV2ID0gcHJvbWlzZS5wcmV2XG4gICAgICBpZiBwcmV2XG4gICAgICAgIGN1cnJlbnQuY29uY2F0KGl0KHByZXYpKVxuICAgICAgZWxzZVxuICAgICAgICBjdXJyZW50XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBpbml0aWFsaXplKGRlcHRoLCBibG9jaylcbiAgICAgIEBkZXB0aCA9IGRlcHRoXG5cbiAgICAgIHN1cGVyIHN1Y2Nlc3M6IHByb2Mge1xuICAgICAgICB0cmFjZSA9IFRyYWNlLml0KHNlbGYpLnJldmVyc2VcbiAgICAgICAgdHJhY2UucG9wXG5cbiAgICAgICAgaWYgZGVwdGggJiYgZGVwdGggPD0gdHJhY2UubGVuZ3RoXG4gICAgICAgICAgdHJhY2Uuc2hpZnQodHJhY2UubGVuZ3RoIC0gZGVwdGgpXG4gICAgICAgIGVuZFxuXG4gICAgICAgIGJsb2NrLmNhbGwoKnRyYWNlKVxuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBjbGFzcyBXaGVuIDwgc2VsZlxuICAgIGRlZiBpbml0aWFsaXplKHByb21pc2VzID0gW10pXG4gICAgICBzdXBlcigpXG5cbiAgICAgIEB3YWl0ID0gW11cblxuICAgICAgcHJvbWlzZXMuZWFjaCBkbyB8cHJvbWlzZXxcbiAgICAgICAgd2FpdCBwcm9taXNlXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBlYWNoKCZibG9jaylcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICAgIHNlbGYudGhlbiBkbyB8dmFsdWVzfFxuICAgICAgICB2YWx1ZXMuZWFjaCgmYmxvY2spXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBjb2xsZWN0KCZibG9jaylcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICAgIHNlbGYudGhlbiBkbyB8dmFsdWVzfFxuICAgICAgICBXaGVuLm5ldyh2YWx1ZXMubWFwKCZibG9jaykpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBpbmplY3QoKmFyZ3MsICZibG9jaylcbiAgICAgIHNlbGYudGhlbiBkbyB8dmFsdWVzfFxuICAgICAgICB2YWx1ZXMucmVkdWNlKCphcmdzLCAmYmxvY2spXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiB3YWl0KHByb21pc2UpXG4gICAgICB1bmxlc3MgUHJvbWlzZSA9PT0gcHJvbWlzZVxuICAgICAgICBwcm9taXNlID0gUHJvbWlzZS52YWx1ZShwcm9taXNlKVxuICAgICAgZW5kXG5cbiAgICAgIGlmIHByb21pc2UuYWN0P1xuICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuXG4gICAgICBlbmRcblxuICAgICAgQHdhaXQgPDwgcHJvbWlzZVxuXG4gICAgICBwcm9taXNlLmFsd2F5cyBkb1xuICAgICAgICB0cnkgaWYgQG5leHQuYW55P1xuICAgICAgZW5kXG5cbiAgICAgIHNlbGZcbiAgICBlbmRcblxuICAgIGRlZiA+PigqKVxuICAgICAgc3VwZXIudGFwIGRvXG4gICAgICAgIHRyeVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgdHJ5XG4gICAgICBpZiBAd2FpdC5hbGw/KCY6cmVhbGl6ZWQ/KVxuICAgICAgICBwcm9taXNlID0gQHdhaXQuZmluZCgmOnJlamVjdGVkPylcbiAgICAgICAgaWYgcHJvbWlzZVxuICAgICAgICAgIHJlamVjdChwcm9taXNlLmVycm9yKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgcmVzb2x2ZShAd2FpdC5tYXAoJjp2YWx1ZSkpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBhbGlhcyBtYXAgY29sbGVjdFxuICAgIGFsaWFzIHJlZHVjZSBpbmplY3RcbiAgICBhbGlhcyBhbmQgd2FpdFxuICBlbmRcbmVuZFxuXG5Qcm9taXNlVjEgPSBQcm9taXNlXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpQcm9taXNlPiIsInZhbHVlIiwic2VsZiIsIm5ldyIsInJlc29sdmUiLCJlcnJvciIsInJlamVjdCIsIndoZW4iLCJXaGVuIiwicHJvbWlzZXMiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJhY3Rpb24iLCJAYWN0aW9uIiwiQHJlYWxpemVkIiwiQGV4Y2VwdGlvbiIsIkB2YWx1ZSIsIkBlcnJvciIsIkBkZWxheWVkIiwiQHByZXYiLCJAbmV4dCIsIlByb21pc2UiLCJhY3Q/IiwiJHJldF9vcl8xIiwia2V5PyIsImtleXMiLCJleGNlcHRpb24/IiwicmVhbGl6ZWQ/IiwiIT0iLCJyZXNvbHZlZD8iLCI9PSIsInJlamVjdGVkPyIsIl4iLCJwcm9taXNlIiwiPDwiLCI+PiIsIltdIiwiMCIsImluY2x1ZGU/IiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwiYmxvY2siLCJjYWxsIiwicmVzb2x2ZSEiLCJFeGNlcHRpb24iLCJlIiwiZXhjZXB0aW9uISIsImFueT8iLCJlYWNoIiwiYmxvY2sgaW4gcmVzb2x2ZSEiLCJwIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZXNvbHZlISIsInJlamVjdCEiLCJibG9jayBpbiByZWplY3QhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZWplY3QhIiwidGhlbiIsInRoZW4hIiwidGhlcmVfY2FuX2JlX29ubHlfb25lISIsInRvX3Byb2MiLCJmYWlsIiwiZmFpbCEiLCJhbHdheXMiLCJhbHdheXMhIiwidHJhY2UiLCJkZXB0aCIsIlRyYWNlIiwidHJhY2UhIiwiYXJncyIsImluc3BlY3QiLCJyZXN1bHQiLCJjbGFzcyIsIm9iamVjdF9pZCIsIisiLCJ0b192MiIsInYyIiwiUHJvbWlzZVYyIiwicmVzY3VlIiwiYmxvY2sgaW4gdG9fdjIiLCJpIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0b192MiIsIjxjbGFzczpUcmFjZT4iLCJpdCIsImN1cnJlbnQiLCJwcmV2IiwibmlsPyIsInB1c2giLCJjb25jYXQiLCJAZGVwdGgiLCJwcm9jIiwiYmxvY2sgaW4gaW5pdGlhbGl6ZSIsImJsb2NrICgyIGxldmVscykgaW4gaW5pdGlhbGl6ZSIsInJldmVyc2UiLCJwb3AiLCI8PSIsImxlbmd0aCIsInNoaWZ0IiwiLSIsIjxjbGFzczpXaGVuPiIsIkB3YWl0Iiwid2FpdCIsImJsb2NrIGluIGVhY2giLCJ2YWx1ZXMiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2giLCJjb2xsZWN0IiwiYmxvY2sgaW4gY29sbGVjdCIsImJsb2NrICgyIGxldmVscykgaW4gY29sbGVjdCIsIm1hcCIsImluamVjdCIsImJsb2NrIGluIGluamVjdCIsImJsb2NrICgyIGxldmVscykgaW4gaW5qZWN0IiwicmVkdWNlIiwiYmxvY2sgaW4gd2FpdCIsImJsb2NrICgyIGxldmVscykgaW4gd2FpdCIsInRyeSIsInRhcCIsIiRmd2RfcmVzdCIsImJsb2NrIGluID4+IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA+PiIsImFsbD8iLCJmaW5kIl0sIm1hcHBpbmdzIjoiQUFBQUEsMEJBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBbUdBQztFQUFBQTs7SUFBQUE7O0FBQUFBOztJQUNFQyxNQUFJQyxJQUFKRCxZQUFBQSxpQkFBZUEsS0FBZkE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFDLElBQUFDLEtBQUFBLENBQUFBLENBQUdDLFNBQUFBLENBQVNILEtBQVRHO0lBRExILENBQUFBO0lBSUFJLE1BQUlILElBQUpHLFlBQUFBLGlCQUFlSixLQUFmSTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQUgsSUFBQUMsS0FBQUEsQ0FBQUEsQ0FBR0csUUFBQUEsQ0FBUUwsS0FBUks7SUFETEQsQ0FBQUE7SUFJQUUsTUFBSUwsSUFBSkssV0FBQUEsZ0JBNUdGLEVBNEdFQTtBQUFBQSxNQUFBQTs7O01BNUdGO01BNEdnQjtNQUNaQSxPQUFBQyxVQUFJTCxLQUFBQSxDQUFLTSxRQUFMTjtJQUROSSxDQUFBQSxJQUFBQTtJQUlBTCxJQUFBUSxhQUFBQSxDQUFZLE9BQVosRUFBb0IsTUFBcEIsRUFBMkIsTUFBM0JBOztBQUVBQyxJQUFBQSwwQkFBQUEsc0JBQWVDLE1BQWZEO0FBQUFBLE1BQUFBOzs7TUFBZSw2QkFBUztNQUN0QkUsY0FBVUQ7TUFFVkUsZ0JBQWE7TUFDYkMsaUJBQWE7TUFDYkMsYUFBYTtNQUNiQyxhQUFhO01BQ2JDLGVBQWE7TUFFYkMsWUFBUTtNQUNSUixPQUFBUyxDQUFBQSxZQUFRLEVBQVJBO0lBVkZULENBQUFBLElBQUFBOztBQWFBVixJQUFBQSxxQkFBQUEsaUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFLElBQUEsUUFBR29CLGFBQUgsRUFBZUwsVUFBZixDQUFBO1FBQ0VmLE9BQUFlLFVBQU1mLE9BQUFBLENBQUFBO01BRFI7UUFHRUEsT0FBQWU7TUFIRjtJQURGZixDQUFBQTs7QUFRQXFCLElBQUFBLG9CQUFBQSw2QkFBQUE7QUFBQUEsTUFBQUE7O01BQ0UsSUFBQSxRQUFBQyxDQUFBQSxZQUFBVixXQUFPVyxTQUFBQSxDQUFNLFNBQU5BLENBQVBELENBQUEsQ0FBQTtRQUFBRCxPQUFBO01BQUE7UUFBMEJBLE9BQUFULFdBQU9XLFNBQUFBLENBQU0sUUFBTkE7TUFBakM7SUFERkYsQ0FBQUE7O0FBSUFWLElBQUFBLHNCQUFBQSxrQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFDLFdBQU9ZLE1BQUFBLENBQUFBO0lBRFRiLENBQUFBOztBQUlBYyxJQUFBQSwwQkFBQUEsYUFDRSxXQURGQSxDQUFBQTs7QUFJQUMsSUFBQUEseUJBQUFBLGtDQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQWIsYUFBVWMsT0FBQUEsQ0FBRyxLQUFIQTtJQURaRCxDQUFBQTs7QUFJQUUsSUFBQUEseUJBQUFBLGtDQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQWYsYUFBVWdCLE9BQUFBLENBQUcsU0FBSEE7SUFEWkQsQ0FBQUE7O0FBSUFFLElBQUFBLHlCQUFBQSxrQ0FBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFqQixhQUFVZ0IsT0FBQUEsQ0FBRyxRQUFIQTtJQURaQyxDQUFBQTs7QUFJQUMsSUFBQUEsaUJBQUFBLHNCQUFNQyxPQUFORDtBQUFBQSxNQUFBQTs7O01BQ0VDLE9BQVFDLE9BQUFBLENBQUdoQyxJQUFIZ0M7TUFDUmhDLElBQUtpQyxPQUFBQSxDQUFHRixPQUFIRTtNQUVMSCxPQUFBQztJQUpGRCxDQUFBQTs7QUFPQUUsSUFBQUEsa0JBQUFBLDJCQUFPRCxPQUFQQztBQUFBQSxNQUFBQTs7O01BQ0VmLFlBQVFjO01BRVJDLE9BQUFoQztJQUhGZ0MsQ0FBQUE7O0FBTUFDLElBQUFBLGtCQUFBQSwyQkFBT0YsT0FBUEU7QUFBQUEsTUFBQUE7OztNQUNFZixTQUFNYyxPQUFBQSxDQUFHRCxPQUFIQztNQUVOLElBQUEsUUFBR2hDLElBQUF3QixlQUFBQSxDQUFBQSxDQUFILENBQUE7UUFDRU8sT0FBTzNCLFFBQUFBLENBQVFZLFlBQVFrQixPQUFBQSxDQUFDQyxDQUFERCxDQUFoQjlCO01BRFQsT0FFQSxJQUFBLFFBQU1KLElBQUEyQixjQUFBQSxDQUFBQSxDQUFOLENBQUE7UUFDRUksT0FBTzdCLFNBQUFBLENBQVMsQ0FBQSxRQUFBYyxZQUFBLENBQUEsR0FBQSxDQUFXQSxZQUFRa0IsT0FBQUEsQ0FBQ0MsQ0FBREQsQ0FBbkIsSUFBQSxDQUF5QmxDLElBQUFELE9BQUFBLENBQUFBLENBQXpCLENBQUEsQ0FBVEc7TUFEVCxPQUVBLElBQUEsUUFBTUYsSUFBQTZCLGNBQUFBLENBQUFBLENBQU4sQ0FBQTtRQUNFLElBQUcsQ0FBQSxLQUFDbEIsV0FBT1csU0FBQUEsQ0FBTSxTQUFOQSxDQUFSLENBQUEsSUFBQSxDQUFBLFFBQTJCSCxhQUEzQixFQUF3QyxDQUFBLFFBQUFILFlBQUEsQ0FBQSxHQUFBLENBQVdBLFlBQVFrQixPQUFBQSxDQUFDQyxDQUFERCxDQUFuQixJQUFBLENBQXlCbkIsVUFBekIsQ0FBQSxDQUF4QyxDQUFBLENBQUEsQ0FBSDtVQUNFZ0IsT0FBTzNCLFFBQUFBLENBQVEsQ0FBQSxRQUFBWSxZQUFBLENBQUEsR0FBQSxDQUFXQSxZQUFRa0IsT0FBQUEsQ0FBQ0MsQ0FBREQsQ0FBbkIsSUFBQSxDQUF5QmxDLElBQUFHLE9BQUFBLENBQUFBLENBQXpCLENBQUEsQ0FBUkM7UUFEVCxPQUVBLElBQUEsUUFBTTJCLE9BQU9yQixRQUFBQSxDQUFBQSxDQUFPMEIsYUFBQUEsQ0FBVSxRQUFWQSxDQUFwQixDQUFBO1VBQ0VMLE9BQU8zQixRQUFBQSxDQUFRLENBQUEsUUFBQVksWUFBQSxDQUFBLEdBQUEsQ0FBV0EsWUFBUWtCLE9BQUFBLENBQUNDLENBQURELENBQW5CLElBQUEsQ0FBeUJsQyxJQUFBRyxPQUFBQSxDQUFBQSxDQUF6QixDQUFBLENBQVJDO1FBRFQ7TUFIRjtNQVFBNkIsT0FBQWpDO0lBZkZpQyxDQUFBQTs7QUFrQkEvQixJQUFBQSx1QkFBQUEsbUJBQVlILEtBQVpHO0FBQUFBLE1BQUFBOzs7TUFBWSwyQkFBUTtNQUNsQixJQUFBLFFBQUdGLElBQUF5QixjQUFBQSxDQUFBQSxDQUFILENBQUE7UUFDRXpCLElBQUFxQyxPQUFBQSxDQUFNQyxtQkFBTixFQUFxQnBDLHVDQUFyQm1DO01BREY7TUFJQSxJQUFBLFFBQUdsQixhQUFILEVBQWVwQixLQUFmLENBQUE7UUFDRSxPQUFRQSxLQUFNaUMsT0FBQUEsQ0FBR2YsU0FBSGUsQ0FBVUYsTUFBQUEsQ0FBRTlCLElBQUY4QjtNQUQxQjs7TUFLRTs7UUFBQVMsUUFBUSxDQUFBLFFBQUFsQixDQUFBQSxZQUFBVixXQUFPdUIsT0FBQUEsQ0FBQyxTQUFEQSxDQUFQYixDQUFBLENBQUEsR0FBQSxDQUFBLFNBQUEsSUFBQSxDQUFxQlYsV0FBT3VCLE9BQUFBLENBQUMsUUFBREEsQ0FBNUIsQ0FBQTtRQUNSLElBQUEsUUFBR0ssS0FBSCxDQUFBO1VBQ0V4QyxRQUFRd0MsS0FBS0MsTUFBQUEsQ0FBTXpDLEtBQU55QztRQURmO1FBSUF4QyxJQUFBeUMsYUFBQUEsQ0FBUzFDLEtBQVQwQztNQUxBO1FBTUYsc0JBQU8sQ0FBQUMsZUFBQSxDQUFQLElBQW9CQyxDQUFBQSxJQUFwQixJQUFvQkE7VUFBcEI7WUFDRTNDLElBQUE0QyxlQUFBQSxDQUFXRCxDQUFYQztVQURGO1FBQUEsQ0FORTtNQUFBO01BVUYxQyxPQUFBRjtJQXBCRkUsQ0FBQUEsSUFBQUE7O0FBdUJBdUMsSUFBQUEsd0JBQUFBLGlDQUFhMUMsS0FBYjBDO0FBQUFBLE1BQUFBOzs7TUFDRTdCLGdCQUFZO01BQ1pFLGFBQVlmO01BRVosSUFBQSxRQUFHbUIsU0FBSzJCLFNBQUFBLENBQUFBLENBQVIsQ0FBQTtRQUNFSixPQUFLSyxNQUFMNUIsU0FBSzRCLFFBQUFBLEVBQUFBLEVBQUFBLEVBQUxDLGFBQWNDLENBQWREOztVQUFjO1VBQUdFLE9BQUFELENBQUM5QyxTQUFBQSxDQUFTSCxLQUFURyxFQUFsQjZDLENBQUtEO01BRFA7UUFHRUwsT0FBQXpCLENBQUFBLGVBQVcsQ0FBQ2pCLEtBQUQsQ0FBWGlCO01BSEY7SUFKRnlCLENBQUFBOztBQVdBckMsSUFBQUEsc0JBQUFBLGtCQUFXTCxLQUFYSztBQUFBQSxNQUFBQTs7O01BQVcsMkJBQVE7TUFDakIsSUFBQSxRQUFHSixJQUFBeUIsY0FBQUEsQ0FBQUEsQ0FBSCxDQUFBO1FBQ0V6QixJQUFBcUMsT0FBQUEsQ0FBTUMsbUJBQU4sRUFBcUJsQyx1Q0FBckJpQztNQURGO01BSUEsSUFBQSxRQUFHbEIsYUFBSCxFQUFlcEIsS0FBZixDQUFBO1FBQ0UsT0FBUUEsS0FBTWlDLE9BQUFBLENBQUdmLFNBQUhlLENBQVVGLE1BQUFBLENBQUU5QixJQUFGOEI7TUFEMUI7O01BS0U7O1FBQUFTLFFBQVEsQ0FBQSxRQUFBbEIsQ0FBQUEsWUFBQVYsV0FBT3VCLE9BQUFBLENBQUMsU0FBREEsQ0FBUGIsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxTQUFBLElBQUEsQ0FBcUJWLFdBQU91QixPQUFBQSxDQUFDLFFBQURBLENBQTVCLENBQUE7UUFDUixJQUFBLFFBQUdLLEtBQUgsQ0FBQTtVQUNFeEMsUUFBUXdDLEtBQUtDLE1BQUFBLENBQU16QyxLQUFOeUM7UUFEZjtRQUlBLElBQUEsUUFBRzdCLFdBQU9XLFNBQUFBLENBQU0sUUFBTkEsQ0FBVixDQUFBO1VBQ0V0QixJQUFBeUMsYUFBQUEsQ0FBUzFDLEtBQVQwQztRQURGO1VBR0V6QyxJQUFBa0QsWUFBQUEsQ0FBUW5ELEtBQVJtRDtRQUhGO01BTEE7UUFVRixzQkFBTyxDQUFBUixlQUFBLENBQVAsSUFBb0JDLENBQUFBLElBQXBCLElBQW9CQTtVQUFwQjtZQUNFM0MsSUFBQTRDLGVBQUFBLENBQVdELENBQVhDO1VBREY7UUFBQSxDQVZFO01BQUE7TUFjRnhDLE9BQUFKO0lBeEJGSSxDQUFBQSxJQUFBQTs7QUEyQkE4QyxJQUFBQSx1QkFBQUEsaUNBQVluRCxLQUFabUQ7QUFBQUEsTUFBQUE7OztNQUNFdEMsZ0JBQVk7TUFDWkcsYUFBWWhCO01BRVosSUFBQSxRQUFHbUIsU0FBSzJCLFNBQUFBLENBQUFBLENBQVIsQ0FBQTtRQUNFSyxPQUFLSixNQUFMNUIsU0FBSzRCLFFBQUFBLEVBQUFBLEVBQUFBLEVBQUxLLGNBQWNILENBQWRHOztVQUFjO1VBQUdDLE9BQUFKLENBQUM1QyxRQUFBQSxDQUFRTCxLQUFSSyxFQUFsQitDLENBQUtMO01BRFA7UUFHRUksT0FBQWxDLENBQUFBLGVBQVcsQ0FBQ2pCLEtBQUQsQ0FBWGlCO01BSEY7SUFKRmtDLENBQUFBOztBQVdBTixJQUFBQSwwQkFBQUEsb0NBQWV6QyxLQUFmeUM7QUFBQUEsTUFBQUE7OztNQUNFL0IsaUJBQWE7TUFFYitCLE9BQUE1QyxJQUFBa0QsWUFBQUEsQ0FBUS9DLEtBQVIrQztJQUhGTixDQUFBQTs7QUFNQVMsSUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUNFQSxPQUFBckQsSUFBSzhCLE1BQUFBLENBQUVYLGFBQU9sQixLQUFBQSxDQUFLLFVBQUEsVUFBQSxFQUFTc0MsS0FBVCxDQUFBLEdBQUx0QyxDQUFUNkI7SUFEUHVCLENBQUFBOztBQUlBQyxJQUFBQSxxQkFBQUEsK0JBQUFBO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQ0V0RCxJQUFBdUQsMkJBQUFBLENBQUFBO01BQ0FELE9BQUlELE1BQUpyRCxJQUFJcUQsUUFBQUEsRUFBQUEsRUFBQUEsRUFBT2QsS0FBRGlCLFNBQUFBLENBQUFBLENBQU5IO0lBRk5DLENBQUFBOztBQUtBRyxJQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQ0VBLE9BQUF6RCxJQUFLOEIsTUFBQUEsQ0FBRVgsYUFBT2xCLEtBQUFBLENBQUssVUFBQSxVQUFBLEVBQVNzQyxLQUFULENBQUEsR0FBTHRDLENBQVQ2QjtJQURQMkIsQ0FBQUE7O0FBSUFDLElBQUFBLHFCQUFBQSwrQkFBQUE7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFDRTFELElBQUF1RCwyQkFBQUEsQ0FBQUE7TUFDQUcsT0FBQUQsTUFBQXpELElBQUF5RCxRQUFBQSxFQUFBQSxFQUFBQSxFQUFNbEIsS0FBRGlCLFNBQUFBLENBQUFBLENBQUxDO0lBRkZDLENBQUFBOztBQUtBQyxJQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQ0VBLE9BQUEzRCxJQUFLOEIsTUFBQUEsQ0FBRVgsYUFBT2xCLEtBQUFBLENBQUssVUFBQSxTQUFBLEVBQVFzQyxLQUFSLENBQUEsR0FBTHRDLENBQVQ2QjtJQURQNkIsQ0FBQUE7O0FBSUFDLElBQUFBLHVCQUFBQSxpQ0FBQUE7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFDRTVELElBQUF1RCwyQkFBQUEsQ0FBQUE7TUFDQUssT0FBQUQsTUFBQTNELElBQUEyRCxVQUFBQSxFQUFBQSxFQUFBQSxFQUFRcEIsS0FBRGlCLFNBQUFBLENBQUFBLENBQVBHO0lBRkZDLENBQUFBOztBQUtBQyxJQUFBQSxxQkFBQUEsaUJBQVVDLEtBQVZEO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQVUsMkJBQVE7TUFDaEJBLE9BQUE3RCxJQUFLOEIsTUFBQUEsQ0FBRWlDLFdBQUs5RCxLQUFBQSxDQUFLNkQsS0FBVixFQUFpQnZCLEtBQVp0QyxDQUFQNkI7SUFEUCtCLENBQUFBLElBQUFBOztBQUlBRyxJQUFBQSxzQkFBQUEsZ0NBM1NGLEVBMlNFQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQTNTRjtNQTJTYTtNQUNUaEUsSUFBQXVELDJCQUFBQSxDQUFBQTtNQUNBUyxPQUFBSCxNQUFBN0QsSUFBQTZELFNBQUFBLEVBQU0sTUFBQ0ksSUFBRCxDQUFOSixFQUFjdEIsS0FBRGlCLFNBQUFBLENBQUFBLENBQWJLO0lBRkZHLENBQUFBLElBQUFBOztBQUtBVCxJQUFBQSxzQ0FBQUEsZ0RBQUFBO0FBQUFBLE1BQUFBOztNQUNFLElBQUEsUUFBR3JDLFNBQUsyQixTQUFBQSxDQUFBQSxDQUFSLENBQUE7UUFDRVUsT0FBQXZELElBQUFxQyxPQUFBQSxDQUFNQyxtQkFBTixFQUFxQmlCLG9DQUFyQmxCO01BREY7UUFqVEprQixPQUFBO01BaVRJO0lBREZBLENBQUFBOztBQU1BVyxJQUFBQSx1QkFBQUEsbUJBQUFBO0FBQUFBLE1BQUFBOzs7TUFDRUMsU0FBVUQsSUFBRCxHQUFBLENBQUtsRSxJQUFJb0UsT0FBQUEsQ0FBQUEsQ0FBVCxDQUFBLEdBQWdCRixHQUFoQixHQUFBLENBQW1CbEUsSUFBQXFFLFdBQUFBLENBQUFBLENBQW5CLENBQUEsR0FBNkJIO01BRXRDLElBQUEsUUFBR2hELFNBQUsyQixTQUFBQSxDQUFBQSxDQUFSLENBQUE7UUFDRXNCLFNBQU9HLFNBQVBILE1BQU9HLEVBQUlKLE1BQUQsR0FBQSxDQUFPaEQsU0FBS2dELFNBQUFBLENBQUFBLENBQVosQ0FBSEk7TUFEVDtNQUlBSCxTQUFPRyxTQUFQSCxNQUFPRyxFQUFHLENBQUEsUUFBR3RFLElBQUF5QixjQUFBQSxDQUFBQSxDQUFILENBQUEsR0FBQSxDQUNHeUMsSUFBRCxHQUFBLENBQU0sQ0FBQSxRQUFBN0MsQ0FBQUEsWUFBQVAsVUFBQU8sQ0FBQSxDQUFBLEdBQUEsQ0FBQSxTQUFBLElBQUEsQ0FBVU4sVUFBVixDQUFBLENBQWlCbUQsU0FBQUEsQ0FBQUEsQ0FBdkIsQ0FBQSxHQUFnQ0EsR0FEbEMsSUFBQSxDQUdFQSxHQUhGLENBQUEsQ0FBSEk7TUFNUEosT0FBQUM7SUFiRkQsQ0FBQUE7O0FBZ0JBSyxJQUFBQSxxQkFBQUEsaUJBQUFBO0FBQUFBLE1BQUFBOzs7TUFDRUMsS0FBS0MsZUFBU3hFLEtBQUFBLENBQUFBO01BRWlCeUUsTUFBM0JyQixNQUFKckQsSUFBSXFELFFBQUFBLEVBQUFBLEVBQUFBLEVBQUpzQixjQUFhQyxDQUFiRDs7UUFBYTtRQUFHRSxPQUFBTCxFQUFFdEUsU0FBQUEsQ0FBUzBFLENBQVQxRSxFQUFsQnlFLENBQUl0QixDQUEyQnFCLFVBQUFBLEVBQUFBLEVBQUFBLEVBQS9CQyxjQUEwQ0MsQ0FBMUNEOztRQUEwQztRQUFHRSxPQUFBTCxFQUFFcEUsUUFBQUEsQ0FBUXdFLENBQVJ4RSxFQUEvQ3VFLENBQStCRDtNQUUvQkgsT0FBQUM7SUFMRkQsQ0FBQUE7SUFTQSxhQUFNLE9BQU4sRUFBWSxPQUFaO0lBRUEsYUFBTSxPQUFOLEVBQVksTUFBWjtJQUNBLGFBQU0sUUFBTixFQUFhLE9BQWI7SUFDQSxhQUFNLElBQU4sRUFBUyxNQUFUO0lBQ0EsYUFBTSxLQUFOLEVBQVUsT0FBVjtJQUNBLGFBQU0sUUFBTixFQUFhLFFBQWI7SUFDQSxhQUFNLFNBQU4sRUFBYyxTQUFkO0lBQ0EsYUFBTSxTQUFOLEVBQWMsUUFBZDtJQUNBLGFBQU0sVUFBTixFQUFlLFNBQWY7SUFDQSxhQUFNLFFBQU4sRUFBYSxNQUFiO0lBQ0EsYUFBTSxTQUFOLEVBQWMsT0FBZDtJQUNBLGFBQU0sTUFBTixFQUFXLE9BQVg7SUFDQSxhQUFNLE9BQU4sRUFBWSxRQUFaO0lBRUFPO0lBQUFBOztNQUFBQTs7O01BQ0VDLE1BQUkvRSxJQUFKK0UsU0FBQUEsY0FBWWhELE9BQVpnRDtBQUFBQSxRQUFBQTs7O1FBQ0VDLFVBQVU7UUFFVixJQUFHLENBQUEsUUFBQWpELE9BQU9YLFNBQUFBLENBQUFBLENBQVAsQ0FBQSxJQUFBLENBQUEsUUFBZ0JXLE9BQU9rRCxNQUFBQSxDQUFBQSxDQUFLQyxTQUFBQSxDQUFBQSxDQUE1QixDQUFBLENBQUEsQ0FBSDtVQUNFRixPQUFPRyxNQUFBQSxDQUFNcEQsT0FBT2hDLE9BQUFBLENBQUFBLENBQWJvRjtRQURUO1FBSUFGLE9BQU9sRCxPQUFPa0QsTUFBQUEsQ0FBQUE7UUFDZCxJQUFBLFFBQUdBLElBQUgsQ0FBQTtVQUNFRixPQUFBQyxPQUFPSSxRQUFBQSxDQUFRcEYsSUFBQStFLElBQUFBLENBQUdFLElBQUhGLENBQVJLO1FBRFQ7VUFHRUwsT0FBQUM7UUFIRjtNQVJGRCxDQUFBQTtNQWVBRCxPQUFBckUsMEJBQUFBLHNCQUFlcUQsS0FBRCxFQUFRdkIsS0FBdEI5QjtBQUFBQSxRQUFBQTs7UUFBQUE7O1FBQ0U0RSxhQUFTdkI7UUFFVHJELE9BQUEsT0FBQVQsSUFBQSxFQUFBLDBEQUFBLGNBQUEsRUFBQSxDQUFNLFVBQUEsVUFBQSxFQUFTc0YsTUFBQXRGLElBQUFzRixRQUFBQSxFQUFBQSxFQUFBQSxFQUFBQyxjQUFBQSxFQUFBQzs7O1VBQ2IzQixRQUFRRSxXQUFLZ0IsSUFBQUEsQ0FBSS9FLElBQUorRSxDQUFTVSxTQUFBQSxDQUFBQTtVQUN0QjVCLEtBQUs2QixLQUFBQSxDQUFBQTtVQUVMLElBQUcsQ0FBQSxRQUFBNUIsS0FBQSxDQUFBLElBQUEsQ0FBQSxRQUFlNkIsT0FBTjdCLEtBQU02QixFQUFHOUIsS0FBSytCLFFBQUFBLENBQUFBLENBQVJELENBQWYsQ0FBQSxDQUFBLENBQUg7WUFDRTlCLEtBQUtnQyxPQUFBQSxDQUFvQkMsVUFBYmpDLEtBQUsrQixRQUFBQSxDQUFBQSxDQUFRRSxFQUFFaEMsS0FBRmdDLENBQXBCRDtVQURQO1VBSUFMLE9BQUtoRCxNQUFMRCxLQUFLQyxRQUFBQSxFQUFNLE1BQUNxQixLQUFELENBQU5yQixFQVJRK0MsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBQUQsQ0FBVCxDQUFBLEdBQU4sQ0FBQSxFQUFBLElBQUE7TUFIRjdFLENBQUFBO0lBaEJGcUUsR0FBQUEsV0FBQUEsRUFBYzlFLElBQWQ4RTtJQWdDQWhGLE9BQUFpRztJQUFBQTs7TUFBQUE7O0FBQUFBOzs7QUFDRXRGLE1BQUFBLDBCQUFBQSxzQkFBZUYsUUFBZkU7QUFBQUEsUUFBQUE7O1FBQUFBOztRQUFlLGlDQUFXO1FBQ3hCLE9BQUFULElBQUEsRUFBQSwwREFBQSxjQUFBLEVBQUEsRUFBQSxFQUFBLElBQUE7UUFFQWdHLFlBQVE7UUFFUnZGLE9BQVFxQyxNQUFSdkMsUUFBUXVDLFFBQUFBLEVBQUFBLEVBQUFBLEVBQVJ5QyxjQUFrQnhELE9BQWxCd0QsRUFBQUM7OztVQUFrQjtVQUNoQkEsT0FBQXhGLElBQUFpRyxNQUFBQSxDQUFLbEUsT0FBTGtFLEVBREZWLENBQUFBLEdBQUFBLFNBQUFBLENBQVF6QztNQUxWckMsQ0FBQUEsSUFBQUE7O0FBVUFxQyxNQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLFFBQUFBOztRQUFBQTs7O1FBQ0UsS0FBQSxRQUE2Q1AsS0FBN0MsQ0FBQTtVQUFBdkMsSUFBQXFDLE9BQUFBLENBQU1DLG1CQUFOLEVBQXFCUSxnQkFBckJUO1FBQUE7UUFFQVMsT0FBSU8sTUFBSnJELElBQUlxRCxRQUFBQSxFQUFBQSxFQUFBQSxFQUFKNkMsY0FBY0MsTUFBZEQ7O1VBQWM7VUFDWkUsT0FBTXRELE1BQU5xRCxNQUFNckQsUUFBQUEsRUFBQUEsRUFBQUEsRUFBT1AsS0FBRGlCLFNBQUFBLENBQUFBLENBQU5WLEVBRFJvRCxDQUFJN0M7TUFITlAsQ0FBQUE7O0FBUUF1RCxNQUFBQSx1QkFBQUEsbUJBQUFBO0FBQUFBLFFBQUFBOztRQUFBQTs7O1FBQ0UsS0FBQSxRQUE2QzlELEtBQTdDLENBQUE7VUFBQXZDLElBQUFxQyxPQUFBQSxDQUFNQyxtQkFBTixFQUFxQitELGdCQUFyQmhFO1FBQUE7UUFFQWdFLE9BQUloRCxNQUFKckQsSUFBSXFELFFBQUFBLEVBQUFBLEVBQUFBLEVBQUppRCxjQUFjSCxNQUFkRzs7VUFBYztVQUNaQyxPQUFBakcsVUFBSUwsS0FBQUEsQ0FBV3VHLE1BQU5MLE1BQU1LLE9BQUFBLEVBQUFBLEVBQUFBLEVBQU1qRSxLQUFEaUIsU0FBQUEsQ0FBQUEsQ0FBTGdELENBQVh2RyxFQUROcUcsQ0FBSWpEO01BSE5nRCxDQUFBQTs7QUFRQUksTUFBQUEsc0JBQUFBLGtCQXpaSixFQXlaSUE7QUFBQUEsUUFBQUE7O1FBQUFBOzs7UUF6Wko7UUF5WmU7UUFDVEEsT0FBSXBELE1BQUpyRCxJQUFJcUQsUUFBQUEsRUFBQUEsRUFBQUEsRUFBSnFELGNBQWNQLE1BQWRPOztVQUFjO1VBQ1pDLE9BQU1DLE1BQU5ULE1BQU1TLFVBQUFBLEVBQVEsTUFBQzNDLElBQUQsQ0FBUjJDLEVBQWdCckUsS0FBRGlCLFNBQUFBLENBQUFBLENBQWZvRCxFQURSRixDQUFJckQ7TUFETm9ELENBQUFBLElBQUFBOztBQU1BUixNQUFBQSxvQkFBQUEsZ0JBQVNsRSxPQUFUa0U7QUFBQUEsUUFBQUE7OztRQUNFLEtBQUEsUUFBTzlFLGFBQVAsRUFBbUJZLE9BQW5CLENBQUE7VUFDRUEsVUFBVVosYUFBT3BCLE9BQUFBLENBQU9nQyxPQUFQaEM7UUFEbkI7UUFJQSxJQUFBLFFBQUdnQyxPQUFPWCxTQUFBQSxDQUFBQSxDQUFWLENBQUE7VUFDRVcsVUFBVUEsT0FBT3NCLE1BQUFBLENBQUFBO1FBRG5CO1FBSUEyQyxTQUFNaEUsT0FBQUEsQ0FBR0QsT0FBSEM7UUFFQzJCLE1BQVA1QixPQUFPNEIsVUFBQUEsRUFBQUEsRUFBQUEsRUFBUGtELGNBQUFBLEVBQUFDO0FBQUFBOztVQUNFLElBQUEsUUFBTzVGLFNBQUsyQixTQUFBQSxDQUFBQSxDQUFaLENBQUE7WUFBQWlFLE9BQUE5RyxJQUFBK0csS0FBQUEsQ0FBQUE7VUFBQTtZQTNhUkQsT0FBQTtVQTJhUSxDQURGRCxDQUFBQSxHQUFBQSxTQUFBQSxDQUFPbEQ7UUFJUHNDLE9BQUFqRztNQWZGaUcsQ0FBQUE7O0FBa0JBaEUsTUFBQUEsa0JBQUFBLHlCQWpiSixFQWliSUE7QUFBQUEsUUFBQUE7O1FBQUFBOztRQWpiSjtRQWliVztRQUNMQSxPQUFLK0UsTUFBTCxPQUFBaEgsSUFBQSxFQUFBLHFEQUFBLE1BQUEsRUFBQSxNQUFBaUgsU0FBQSxDQUFBLEVBQUEsTUFBQSxDQUFLRCxPQUFBQSxFQUFBQSxFQUFBQSxFQUFMRSxjQUFBQSxFQUFBQzs7VUFDRUEsT0FBQW5ILElBQUErRyxLQUFBQSxDQUFBQSxDQURGRyxDQUFBQSxHQUFBQSxTQUFBQSxDQUFLRjtNQURQL0UsQ0FBQUEsSUFBQUE7O0FBTUE4RSxNQUFBQSxtQkFBQUEsc0JBQUFBO0FBQUFBLFFBQUFBOztRQUNFLElBQUEsUUFBUUssTUFBTHBCLFNBQUtvQixRQUFBQSxFQUFBQSxFQUFBQSxFQUFPLFdBQUQ1RCxTQUFBQSxDQUFBQSxDQUFONEQsQ0FBUixDQUFBOztVQUNFckYsVUFBZXNGLE1BQUxyQixTQUFLcUIsUUFBQUEsRUFBQUEsRUFBQUEsRUFBTyxXQUFEN0QsU0FBQUEsQ0FBQUEsQ0FBTjZEO1VBQ2YsSUFBQSxRQUFHdEYsT0FBSCxDQUFBO1lBQ0VnRixPQUFBL0csSUFBQUksUUFBQUEsQ0FBTzJCLE9BQU81QixPQUFBQSxDQUFBQSxDQUFkQztVQURGO1lBR0UyRyxPQUFBL0csSUFBQUUsU0FBQUEsQ0FBYXNHLE1BQUxSLFNBQUtRLE9BQUFBLEVBQUFBLEVBQUFBLEVBQU0sT0FBRGhELFNBQUFBLENBQUFBLENBQUxnRCxDQUFidEc7VUFIRjtRQUZGO1VBeGJONkcsT0FBQTtRQXdiTTtNQURGQSxDQUFBQTtNQVdBLGFBQU0sS0FBTixFQUFVLFNBQVY7TUFDQSxhQUFNLFFBQU4sRUFBYSxRQUFiO01BQ0FoQixPQUFBLGFBQU0sS0FBTixFQUFVLE1BQVY7SUF0RUZBLEdBQUFBLFdBQUFBLEVBQWEvRixJQUFiK0Y7RUEzUkZqRyxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQXFXQUQsT0FBQSxxQ0FBWXNCLGFBQVo7QUF4Y0F0QjsifX0seyJvZmZzZXQiOnsibGluZSI6MjY3NzMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwYWdnaW8vdXRpbHMucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIy0tXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgICAgICAgICAgICAgICAgICAgVmVyc2lvbiAyLCBEZWNlbWJlciAyMDA0XG4jXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBDT1BZSU5HLCBESVNUUklCVVRJT04gQU5EIE1PRElGSUNBVElPTlxuI1xuIyAgMC4gWW91IGp1c3QgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTy5cbiMrK1xuXG5jbGFzcyBQYWdnaW9cblxubW9kdWxlIFV0aWxzXG4gIGRlZiBzZWxmLmhlcmVkb2Moc3RyaW5nKVxuICAgIGluZGVudCA9IHN0cmluZy5zY2FuKC9eWyBcXHRdKig/PVxcUykvKS5taW4uc2l6ZSByZXNjdWUgMFxuXG4gICAgc3RyaW5nLmdzdWIoL15bIFxcdF17I3tpbmRlbnR9fS8sICcnKVxuICBlbmRcblxuICBkZWYgc2VsZi5kZWVwX21lcmdlKGEsIGIpXG4gICAgbWVyZ2VyID0gcHJvYyB7fGtleSwgdjEsIHYyfFxuICAgICAgaWYgSGFzaCA9PT0gdjEgJiYgSGFzaCA9PT0gdjJcbiAgICAgICAgdjEubWVyZ2UodjIsICZtZXJnZXIpXG4gICAgICBlbHNlXG4gICAgICAgIHYyXG4gICAgICBlbmRcbiAgICB9XG5cbiAgICBhLm1lcmdlKGIsICZtZXJnZXIpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmRlZXBfbWVyZ2UhKGEsIGIpXG4gICAgbWVyZ2VyID0gcHJvYyB7fGtleSwgdjEsIHYyfFxuICAgICAgaWYgSGFzaCA9PT0gdjEgJiYgSGFzaCA9PT0gdjJcbiAgICAgICAgdjEubWVyZ2UhKHYyLCAmbWVyZ2VyKVxuICAgICAgICB2MVxuICAgICAgZWxzZVxuICAgICAgICB2MlxuICAgICAgZW5kXG4gICAgfVxuXG4gICAgYS5tZXJnZSEoYiwgJm1lcmdlcilcbiAgZW5kXG5lbmRcblxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpQYWdnaW8+IiwiPG1vZHVsZTpVdGlscz4iLCJoZXJlZG9jIiwic2VsZiIsInN0cmluZyIsImluZGVudCIsInNjYW4iLCJtaW4iLCJzaXplIiwiU3RhbmRhcmRFcnJvciIsIjAiLCJnc3ViIiwiZGVlcF9tZXJnZSIsImEiLCJiIiwibWVyZ2VyIiwicHJvYyIsImJsb2NrIGluIGRlZXBfbWVyZ2UiLCJrZXkiLCJ2MSIsInYyIiwiSGFzaCIsImJsb2NrICgyIGxldmVscykgaW4gZGVlcF9tZXJnZSIsIm1lcmdlIiwidG9fcHJvYyIsImRlZXBfbWVyZ2UhIiwiYmxvY2sgaW4gZGVlcF9tZXJnZSEiLCJtZXJnZSEiLCJibG9jayAoMiBsZXZlbHMpIGluIGRlZXBfbWVyZ2UhIl0sIm1hcHBpbmdzIjoiQUFBQUEsK0JBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFVQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUVBQSxPQUFBQztJQUFBQTs7TUFBQUE7OztNQUNFQyxNQUFJQyxJQUFKRCxjQUFBQSxtQkFBaUJFLE1BQWpCRjtBQUFBQSxRQUFBQTs7O1FBQ0VHLFNBQVMsY0FBQTtVQUFBSCxPQUFBRSxNQUFNRSxNQUFBQSxDQUFNLGVBQU5BLENBQXNCQyxLQUFBQSxDQUFBQSxDQUFJQyxNQUFBQSxDQUFBQTtRQUFoQztVQUFzQyxzQkFBQSxDQUFBQyxtQkFBQSxDQUFBO1lBQUE7Y0FBT1AsT0FBQVE7WUFBUDtVQUFBLENBQXRDO1FBQUEsQ0FBQTtRQUVUUixPQUFBRSxNQUFNTyxNQUFBQSxDQUFNLFNBQUNULFVBQUQsRUFBVUcsTUFBVixFQUFpQkgsR0FBakIsQ0FBQSxDQUFaLEVBQWlDQSxFQUEzQlM7TUFIUlQsQ0FBQUE7TUFNQVUsTUFBSVQsSUFBSlMsaUJBQUFBLHNCQUFvQkMsQ0FBRCxFQUFJQyxDQUF2QkY7QUFBQUEsUUFBQUE7OztRQUNFRyxTQUFTQyxNQUFBYixJQUFBYSxRQUFBQSxFQUFBQSxFQUFBQSxFQUFBQyxhQUFPQyxHQUFELEVBQU1DLEVBQU4sRUFBVUMsRUFBaEJIOztVQUFPO1VBQUs7VUFBSTtVQUN2QixJQUFHLENBQUEsUUFBQUksVUFBQSxFQUFTRixFQUFULENBQUEsSUFBQSxDQUFBLFFBQWVFLFVBQWYsRUFBd0JELEVBQXhCLENBQUEsQ0FBQSxDQUFIO1lBQ0VFLE9BQUVDLE1BQUZKLEVBQUVJLFNBQUFBLEVBQUFBLENBQU9ILEVBQVBHLENBQUFBLEVBQVlSLE1BQURTLFNBQUFBLENBQUFBLENBQVhEO1VBREo7WUFHRUQsT0FBQUY7VUFIRixFQURPSCxDQUFBRDtRQVFUSixPQUFDVyxNQUFEVixDQUFDVSxTQUFBQSxFQUFBQSxDQUFPVCxDQUFQUyxDQUFBQSxFQUFXUixNQUFEUyxTQUFBQSxDQUFBQSxDQUFWRDtNQVRIWCxDQUFBQTtNQVlBWCxPQUFBd0IsTUFBSXRCLElBQUpzQixrQkFBQUEsa0NBQXFCWixDQUFELEVBQUlDLENBQXhCVztBQUFBQSxRQUFBQTs7O1FBQ0VWLFNBQVNDLE1BQUFiLElBQUFhLFFBQUFBLEVBQUFBLEVBQUFBLEVBQUFVLGFBQU9SLEdBQUQsRUFBTUMsRUFBTixFQUFVQyxFQUFoQk07O1VBQU87VUFBSztVQUFJO1VBQ3ZCLElBQUcsQ0FBQSxRQUFBTCxVQUFBLEVBQVNGLEVBQVQsQ0FBQSxJQUFBLENBQUEsUUFBZUUsVUFBZixFQUF3QkQsRUFBeEIsQ0FBQSxDQUFBLENBQUg7O1lBQ0lPLE1BQUZSLEVBQUVRLFVBQUFBLEVBQUFBLENBQVFQLEVBQVJPLENBQUFBLEVBQWFaLE1BQURTLFNBQUFBLENBQUFBLENBQVpHO1lBQ0ZDLE9BQUFUO1VBRkY7WUFJRVMsT0FBQVI7VUFKRixFQURPTSxDQUFBVjtRQVNUUyxPQUFDRSxNQUFEZCxDQUFDYyxVQUFBQSxFQUFBQSxDQUFRYixDQUFSYSxDQUFBQSxFQUFZWixNQUFEUyxTQUFBQSxDQUFBQSxDQUFYRztNQVZIRixDQUFBQTtJQW5CRnhCLEdBQUFBLFdBQUFBO0VBRkFELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBVkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNjg0MSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInBhZ2dpby9odG1sL2hlbHBlcnMucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIy0tXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgICAgICAgICAgICAgICAgICAgVmVyc2lvbiAyLCBEZWNlbWJlciAyMDA0XG4jXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBDT1BZSU5HLCBESVNUUklCVVRJT04gQU5EIE1PRElGSUNBVElPTlxuI1xuIyAgMC4gWW91IGp1c3QgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTy5cbiMrK1xuXG5jbGFzcyBQYWdnaW87IGNsYXNzIEhUTUwgPCBCYXNpY09iamVjdFxuXG5jbGFzcyBFbGVtZW50IDwgQmFzaWNPYmplY3RcbiAgZGVmIHNlbGYuZGVmaGVscGVyKG5hbWUsICZibG9jaylcbiAgICBkZWZpbmVfbWV0aG9kIG5hbWUgZG8gfCphcmdzLCAmYm9keXxcbiAgICAgIGluc3RhbmNlX2V4ZWMoKmFyZ3MsICZibG9jaylcblxuICAgICAgc2VsZi5kbygmYm9keSkgaWYgYm9keVxuICAgICAgc2VsZlxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2VsZi5kZWZoZWxwZXIhKG5hbWUsIGF0dHJpYnV0ZSA9IG5hbWUpXG4gICAgZGVmaGVscGVyIFwiI3tuYW1lfSFcIiBkb1xuICAgICAgQGF0dHJpYnV0ZXNbYXR0cmlidXRlXSA9IHRydWVcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOlBhZ2dpbz4iLCI8Y2xhc3M6SFRNTD4iLCI8Y2xhc3M6RWxlbWVudD4iLCJkZWZoZWxwZXIiLCJzZWxmIiwibmFtZSIsImRlZmluZV9tZXRob2QiLCJibG9jayBpbiBkZWZoZWxwZXIiLCJibG9jayAoMiBsZXZlbHMpIGluIGRlZmhlbHBlciIsImluc3RhbmNlX2V4ZWMiLCJhcmdzIiwiYmxvY2siLCJ0b19wcm9jIiwiYm9keSIsImRvIiwiZGVmaGVscGVyISIsImF0dHJpYnV0ZSIsImJsb2NrIGluIGRlZmhlbHBlciEiLCJibG9jayAoMiBsZXZlbHMpIGluIGRlZmhlbHBlciEiLCJbXT0iLCJAYXR0cmlidXRlcyIsIkJhc2ljT2JqZWN0Il0sIm1hcHBpbmdzIjoiQUFBQUEsc0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFVQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFjQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWRBLE9BQUFDO01BQUFBOzs7O1FBQ0VDLE1BQUlDLElBQUpELGdCQUFBQSxxQkFBbUJFLElBQW5CRjtBQUFBQSxVQUFBQTs7VUFBQUE7OztVQUNFQSxPQUFBRyxNQUFBRixJQUFBRSxpQkFBQUEsRUFBQUEsQ0FBY0QsSUFBZEMsQ0FBQUEsRUFBQUMsYUFkSixFQWNJQSxFQUFBQzs7WUFBQUE7OztZQWRKO1lBYzJCO1lBQ3JCQyxNQUFBTCxJQUFBSyxpQkFBQUEsRUFBYyxNQUFDQyxJQUFELENBQWRELEVBQXNCRSxLQUFEQyxTQUFBQSxDQUFBQSxDQUFyQkg7WUFFQSxJQUFBLFFBQWtCSSxJQUFsQixDQUFBO2NBQUlDLE1BQUpWLElBQUlVLE1BQUFBLEVBQUFBLEVBQUFBLEVBQUtELElBQURELFNBQUFBLENBQUFBLENBQUpFO1lBQUo7WUFDQU4sT0FBQUosS0FKRkcsQ0FBQUEsR0FBQUEsc0JBQUFBLENBQUFEO1FBREZILENBQUFBO1FBU0FELE9BQUFhLE1BQUlYLElBQUpXLGlCQUFBQSxtQ0FBb0JWLElBQUQsRUFBT1csU0FBMUJEO0FBQUFBLFVBQUFBOzs7VUFBMEIsbUNBQVlWO1VBQ3BDVSxPQUFBWixNQUFBQyxJQUFBRCxhQUFBQSxFQUFBQSxDQUFVLEVBQUEsR0FBQSxDQUFHRSxJQUFILENBQUEsR0FBUVUsR0FBbEJaLENBQUFBLEVBQUFjLGFBQUFBLEVBQUFDO0FBQUFBOztZQUNFQSxPQUFXQyxNQUFBQSxDQUFDSCxTQUFaLEVBQXlCLElBQWRHLENBQUFBLEVBQUFBLE1BQVhDLGVBQVdELE9BQUFBLEVBQUFBLEVBQUFBLENBQUFBLEVBQUFBLGtCQURiRixDQUFBQSxHQUFBQSxTQUFBQSxDQUFBZDtRQURGWSxDQUFBQSxJQUFBQTtNQVZGYixHQUFBQSxXQUFBQSxFQUFnQm1CLGlCQUFoQm5CO0lBRmNELEdBQUFBLFdBQUFBLEVBQWFvQixpQkFBYnBCO0VBQWRELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBVkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNjg5NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInBhZ2dpby9odG1sL2VsZW1lbnQvYS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjLS1cbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgICAgICAgICAgICAgICAgICBWZXJzaW9uIDIsIERlY2VtYmVyIDIwMDRcbiNcbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgVEVSTVMgQU5EIENPTkRJVElPTlMgRk9SIENPUFlJTkcsIERJU1RSSUJVVElPTiBBTkQgTU9ESUZJQ0FUSU9OXG4jXG4jICAwLiBZb3UganVzdCBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPLlxuIysrXG5cbmNsYXNzIFBhZ2dpbzsgY2xhc3MgSFRNTCA8IEJhc2ljT2JqZWN0OyBjbGFzcyBFbGVtZW50IDwgQmFzaWNPYmplY3RcblxuY2xhc3MgQSA8IHNlbGZcbiAgeyBocmVmOiA6aHJlZixcbiAgICB1cmw6ICA6aHJlZixcblxuICAgIHJlbDogICAgICA6cmVsLFxuICAgIHJlbGF0aXZlOiA6cmVsLFxuXG4gICAgdGFyZ2V0OiA6dGFyZ2V0LFxuXG4gICAgdHlwZTogOnR5cGUsXG5cbiAgICBsYW5nOiAgICAgOmhyZWZsYW5nLFxuICAgIGxhbmd1YWdlOiA6aHJlZmxhbmcsXG5cbiAgICBtZWRpYTogOm1lZGlhLFxuICB9LmVhY2gge3xuYW1lLCBhdHRyaWJ1dGV8XG4gICAgZGVmaGVscGVyIG5hbWUgZG8gfHZhbHVlfFxuICAgICAgQGF0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZS50b19zXG4gICAgZW5kXG4gIH1cblxuICBkZWZoZWxwZXIhIDpkb3dubG9hZFxuICBkZWZoZWxwZXIhIDpwaW5nXG5cbiAgZGVmaGVscGVyIDp0ZXh0IGRvIHxzdHJpbmd8XG4gICAgc2VsZiA8PCBzdHJpbmdcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6UGFnZ2lvPiIsIjxjbGFzczpIVE1MPiIsIjxjbGFzczpFbGVtZW50PiIsIjxjbGFzczpBPiIsImVhY2giLCJibG9jayBpbiA8Y2xhc3M6QT4iLCJuYW1lIiwiYXR0cmlidXRlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8Y2xhc3M6QT4iLCJkZWZoZWxwZXIiLCJzZWxmIiwidmFsdWUiLCJibG9jayAoMyBsZXZlbHMpIGluIDxjbGFzczpBPiIsIltdPSIsInRvX3MiLCJAYXR0cmlidXRlcyIsImRlZmhlbHBlciEiLCJzdHJpbmciLCI8PCIsIkJhc2ljT2JqZWN0Il0sIm1hcHBpbmdzIjoiQUFBQUEsd0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFVQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFjQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BQTBCQSxPQUFBQztNQUFBQTs7UUFBQUE7O1FBRXhDQSxPQUFBQztRQUFBQTs7OztVQWVHQyxNQWRELFVBQUEsT0FBQSxFQUFRLE1BQVIsQ0FBQSxFQUFBLE1BQUEsRUFDUSxNQURSLENBQUEsRUFBQSxNQUFBLEVBR1ksS0FIWixDQUFBLEVBQUEsV0FBQSxFQUlZLEtBSlosQ0FBQSxFQUFBLFNBQUEsRUFNVSxRQU5WLENBQUEsRUFBQSxPQUFBLEVBUVEsTUFSUixDQUFBLEVBQUEsT0FBQSxFQVVZLFVBVlosQ0FBQSxFQUFBLFdBQUEsRUFXWSxVQVhaLENBQUEsRUFBQSxRQUFBLEVBYVMsT0FiVCxDQUFBLEdBY0NBLFFBQUFBLEVBQUFBLEVBQUFBLEVBZERDLGNBY1NDLElBQUQsRUFBT0MsU0FkZkYsRUFBQUc7OztZQWNTO1lBQU07WUFDYkEsT0FBQUMsTUFBQUMsSUFBQUQsYUFBQUEsRUFBQUEsQ0FBVUgsSUFBVkcsQ0FBQUEsRUFBQUQsYUFBbUJHLEtBQW5CSCxFQUFBSTtBQUFBQTs7O2NBQW1CO2NBQ2pCQSxPQUFXQyxNQUFBQSxDQUFDUCxJQUFaLEVBQW9CSyxLQUFLRyxNQUFBQSxDQUFBQSxDQUFkRCxDQUFBQSxFQUFBQSxNQUFYRSxlQUFXRixPQUFBQSxFQUFBQSxFQUFBQSxDQUFBQSxFQUFBQSxtQkFEYkwsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBQUMsRUFmRkosQ0FBQUEsR0FBQUEsU0FBQUEsQ0FjQ0Q7VUFNRE0sSUFBQU0sZUFBQUEsQ0FBVyxVQUFYQTtVQUNBTixJQUFBTSxlQUFBQSxDQUFXLE1BQVhBO1VBRUFiLE9BQUFNLE1BQUFDLElBQUFELGFBQUFBLEVBQUFBLENBQVUsTUFBVkEsQ0FBQUEsRUFBQUosY0FBb0JZLE1BQXBCWixFQUFBRzs7O1lBQW9CO1lBQ2xCQSxPQUFBRSxJQUFLUSxPQUFBQSxDQUFHRCxNQUFIQyxFQURQYixDQUFBQSxHQUFBQSxTQUFBQSxDQUFBSTtRQXhCRk4sR0FBQUEsV0FBQUEsRUFBVU8sSUFBVlA7TUFGd0NELEdBQUFBLFdBQUFBLEVBQWdCaUIsaUJBQWhCakI7SUFBMUJELEdBQUFBLFdBQUFBLEVBQWFrQixpQkFBYmxCO0VBQWRELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBVkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNjk0MiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInBhZ2dpby9odG1sL2VsZW1lbnQvYmFzZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjLS1cbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgICAgICAgICAgICAgICAgICBWZXJzaW9uIDIsIERlY2VtYmVyIDIwMDRcbiNcbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgVEVSTVMgQU5EIENPTkRJVElPTlMgRk9SIENPUFlJTkcsIERJU1RSSUJVVElPTiBBTkQgTU9ESUZJQ0FUSU9OXG4jXG4jICAwLiBZb3UganVzdCBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPLlxuIysrXG5cbmNsYXNzIFBhZ2dpbzsgY2xhc3MgSFRNTCA8IEJhc2ljT2JqZWN0OyBjbGFzcyBFbGVtZW50IDwgQmFzaWNPYmplY3RcblxuY2xhc3MgQmFzZSA8IHNlbGZcbiAgeyBocmVmOiA6aHJlZixcbiAgICB1cmw6ICA6aHJlZixcblxuICAgIHRhcmdldDogOnRhcmdldCxcbiAgfS5lYWNoIHt8bmFtZSwgYXR0cmlidXRlfFxuICAgIGRlZmhlbHBlciBuYW1lIGRvIHx2YWx1ZXxcbiAgICAgIEBhdHRyaWJ1dGVzW25hbWVdID0gdmFsdWUudG9fc1xuICAgIGVuZFxuICB9XG5lbmRcblxuZW5kOyBlbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6UGFnZ2lvPiIsIjxjbGFzczpIVE1MPiIsIjxjbGFzczpFbGVtZW50PiIsIjxjbGFzczpCYXNlPiIsImVhY2giLCJibG9jayBpbiA8Y2xhc3M6QmFzZT4iLCJuYW1lIiwiYXR0cmlidXRlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8Y2xhc3M6QmFzZT4iLCJkZWZoZWxwZXIiLCJzZWxmIiwidmFsdWUiLCJibG9jayAoMyBsZXZlbHMpIGluIDxjbGFzczpCYXNlPiIsIltdPSIsInRvX3MiLCJAYXR0cmlidXRlcyIsIkJhc2ljT2JqZWN0Il0sIm1hcHBpbmdzIjoiQUFBQUEsMkNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFVQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFjQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BQTBCQSxPQUFBQztNQUFBQTs7UUFBQUE7O1FBRXhDQSxPQUFBQztRQUFBQTs7O1VBQ0VBLE9BSUNDLE1BSkQsVUFBQSxPQUFBLEVBQVEsTUFBUixDQUFBLEVBQUEsTUFBQSxFQUNRLE1BRFIsQ0FBQSxFQUFBLFNBQUEsRUFHVSxRQUhWLENBQUEsR0FJQ0EsUUFBQUEsRUFBQUEsRUFBQUEsRUFKREMsaUJBSVNDLElBQUQsRUFBT0MsU0FKZkYsRUFBQUc7OztZQUlTO1lBQU07WUFDYkEsT0FBQUMsTUFBQUMsSUFBQUQsYUFBQUEsRUFBQUEsQ0FBVUgsSUFBVkcsQ0FBQUEsRUFBQUQsYUFBbUJHLEtBQW5CSCxFQUFBSTtBQUFBQTs7O2NBQW1CO2NBQ2pCQSxPQUFXQyxNQUFBQSxDQUFDUCxJQUFaLEVBQW9CSyxLQUFLRyxNQUFBQSxDQUFBQSxDQUFkRCxDQUFBQSxFQUFBQSxNQUFYRSxlQUFXRixPQUFBQSxFQUFBQSxFQUFBQSxDQUFBQSxFQUFBQSxtQkFEYkwsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBQUMsRUFMRkosQ0FBQUEsR0FBQUEsU0FBQUEsQ0FJQ0Q7UUFMSEQsR0FBQUEsV0FBQUEsRUFBYU8sSUFBYlA7TUFGd0NELEdBQUFBLFdBQUFBLEVBQWdCYyxpQkFBaEJkO0lBQTFCRCxHQUFBQSxXQUFBQSxFQUFhZSxpQkFBYmY7RUFBZEQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFWQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI2OTgyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGFnZ2lvL2h0bWwvZWxlbWVudC9ibG9ja3F1b3RlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMtLVxuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICAgICAgICAgICAgICAgICAgIFZlcnNpb24gMiwgRGVjZW1iZXIgMjAwNFxuI1xuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICBURVJNUyBBTkQgQ09ORElUSU9OUyBGT1IgQ09QWUlORywgRElTVFJJQlVUSU9OIEFORCBNT0RJRklDQVRJT05cbiNcbiMgIDAuIFlvdSBqdXN0IERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8uXG4jKytcblxuY2xhc3MgUGFnZ2lvOyBjbGFzcyBIVE1MIDwgQmFzaWNPYmplY3Q7IGNsYXNzIEVsZW1lbnQgPCBCYXNpY09iamVjdFxuXG5jbGFzcyBCbG9ja3F1b3RlIDwgc2VsZlxuICBkZWZoZWxwZXIgOmNpdGUgZG8gfHZhbHVlfFxuICAgIEBhdHRyaWJ1dGVzWzpjaXRlXSA9IHZhbHVlLnRvX3NcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6UGFnZ2lvPiIsIjxjbGFzczpIVE1MPiIsIjxjbGFzczpFbGVtZW50PiIsIjxjbGFzczpCbG9ja3F1b3RlPiIsImRlZmhlbHBlciIsInNlbGYiLCJibG9jayBpbiA8Y2xhc3M6QmxvY2txdW90ZT4iLCJ2YWx1ZSIsImJsb2NrICgyIGxldmVscykgaW4gPGNsYXNzOkJsb2NrcXVvdGU+IiwiW109IiwidG9fcyIsIkBhdHRyaWJ1dGVzIiwiQmFzaWNPYmplY3QiXSwibWFwcGluZ3MiOiJBQUFBQSxpREFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQVVBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWNBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFBMEJBLE9BQUFDO01BQUFBOztRQUFBQTs7UUFFeENBLE9BQUFDO1FBQUFBOzs7VUFDRUEsT0FBQUMsTUFBQUMsSUFBQUQsYUFBQUEsRUFBQUEsQ0FBVSxNQUFWQSxDQUFBQSxFQUFBRSx1QkFBb0JDLEtBQXBCRCxFQUFBRTtBQUFBQTs7O1lBQW9CO1lBQ2xCQSxPQUFXQyxNQUFBQSxDQUFDLE1BQVosRUFBcUJGLEtBQUtHLE1BQUFBLENBQUFBLENBQWZELENBQUFBLEVBQUFBLE1BQVhFLGVBQVdGLE9BQUFBLEVBQUFBLEVBQUFBLENBQUFBLEVBQUFBLG1CQURiSCxDQUFBQSxHQUFBQSxTQUFBQSxDQUFBRjtRQURGRCxHQUFBQSxXQUFBQSxFQUFtQkUsSUFBbkJGO01BRndDRCxHQUFBQSxXQUFBQSxFQUFnQlUsaUJBQWhCVjtJQUExQkQsR0FBQUEsV0FBQUEsRUFBYVcsaUJBQWJYO0VBQWRELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBVkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNzAxNywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInBhZ2dpby9odG1sL2VsZW1lbnQvYnV0dG9uLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMtLVxuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICAgICAgICAgICAgICAgICAgIFZlcnNpb24gMiwgRGVjZW1iZXIgMjAwNFxuI1xuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICBURVJNUyBBTkQgQ09ORElUSU9OUyBGT1IgQ09QWUlORywgRElTVFJJQlVUSU9OIEFORCBNT0RJRklDQVRJT05cbiNcbiMgIDAuIFlvdSBqdXN0IERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8uXG4jKytcblxuY2xhc3MgUGFnZ2lvOyBjbGFzcyBIVE1MIDwgQmFzaWNPYmplY3Q7IGNsYXNzIEVsZW1lbnQgPCBCYXNpY09iamVjdFxuXG5jbGFzcyBCdXR0b24gPCBzZWxmXG4gIHsgZm9ybTogIDpmb3JtLFxuICAgIG5hbWU6ICA6bmFtZSxcbiAgICB0eXBlOiAgOnR5cGUsXG4gICAgdmFsdWU6IDp2YWx1ZSxcblxuICAgIGFjdGlvbjogICA6Zm9ybWFjdGlvbixcbiAgICBlbmNvZGluZzogOmZvcm1lbmN0eXBlLFxuICAgIG1ldGhvZDogICA6Zm9ybW1ldGhvZCxcbiAgICB0YXJnZXQ6ICAgOmZvcm10YXJnZXQsXG4gIH0uZWFjaCB7fG5hbWUsIGF0dHJpYnV0ZXN8XG4gICAgZGVmaGVscGVyIG5hbWUgZG8gfHZhbHVlfFxuICAgICAgQGF0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZS50b19zXG4gICAgZW5kXG4gIH1cblxuICBkZWZoZWxwZXIhIDphdXRvZm9jdXNcbiAgZGVmaGVscGVyISA6ZGlzYWJsZWRcbmVuZFxuXG5lbmQ7IGVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpQYWdnaW8+IiwiPGNsYXNzOkhUTUw+IiwiPGNsYXNzOkVsZW1lbnQ+IiwiPGNsYXNzOkJ1dHRvbj4iLCJlYWNoIiwiYmxvY2sgaW4gPGNsYXNzOkJ1dHRvbj4iLCJuYW1lIiwiYXR0cmlidXRlcyIsImJsb2NrICgyIGxldmVscykgaW4gPGNsYXNzOkJ1dHRvbj4iLCJkZWZoZWxwZXIiLCJzZWxmIiwidmFsdWUiLCJibG9jayAoMyBsZXZlbHMpIGluIDxjbGFzczpCdXR0b24+IiwiW109IiwidG9fcyIsIkBhdHRyaWJ1dGVzIiwiZGVmaGVscGVyISIsIkJhc2ljT2JqZWN0Il0sIm1hcHBpbmdzIjoiQUFBQUEsNkNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFVQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFjQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BQTBCQSxPQUFBQztNQUFBQTs7UUFBQUE7O1FBRXhDQSxPQUFBQztRQUFBQTs7OztVQVVHQyxNQVRELFVBQUEsT0FBQSxFQUFTLE1BQVQsQ0FBQSxFQUFBLE9BQUEsRUFDUyxNQURULENBQUEsRUFBQSxPQUFBLEVBRVMsTUFGVCxDQUFBLEVBQUEsUUFBQSxFQUdTLE9BSFQsQ0FBQSxFQUFBLFNBQUEsRUFLWSxZQUxaLENBQUEsRUFBQSxXQUFBLEVBTVksYUFOWixDQUFBLEVBQUEsU0FBQSxFQU9ZLFlBUFosQ0FBQSxFQUFBLFNBQUEsRUFRWSxZQVJaLENBQUEsR0FTQ0EsUUFBQUEsRUFBQUEsRUFBQUEsRUFUREMsbUJBU1NDLElBQUQsRUFBT0MsVUFUZkYsRUFBQUc7OztZQVNTO1lBQU07WUFDYkEsT0FBQUMsTUFBQUMsSUFBQUQsYUFBQUEsRUFBQUEsQ0FBVUgsSUFBVkcsQ0FBQUEsRUFBQUQsYUFBbUJHLEtBQW5CSCxFQUFBSTtBQUFBQTs7O2NBQW1CO2NBQ2pCQSxPQUFXQyxNQUFBQSxDQUFDUCxJQUFaLEVBQW9CSyxLQUFLRyxNQUFBQSxDQUFBQSxDQUFkRCxDQUFBQSxFQUFBQSxNQUFYRSxlQUFXRixPQUFBQSxFQUFBQSxFQUFBQSxDQUFBQSxFQUFBQSxtQkFEYkwsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBQUMsRUFWRkosQ0FBQUEsR0FBQUEsU0FBQUEsQ0FTQ0Q7VUFNRE0sSUFBQU0sZUFBQUEsQ0FBVyxXQUFYQTtVQUNBYixPQUFBTyxJQUFBTSxlQUFBQSxDQUFXLFVBQVhBO1FBakJGYixHQUFBQSxXQUFBQSxFQUFlTyxJQUFmUDtNQUZ3Q0QsR0FBQUEsV0FBQUEsRUFBZ0JlLGlCQUFoQmY7SUFBMUJELEdBQUFBLFdBQUFBLEVBQWFnQixpQkFBYmhCO0VBQWRELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBVkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNzA2MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInBhZ2dpby9odG1sL2VsZW1lbnQvY2FudmFzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMtLVxuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICAgICAgICAgICAgICAgICAgIFZlcnNpb24gMiwgRGVjZW1iZXIgMjAwNFxuI1xuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICBURVJNUyBBTkQgQ09ORElUSU9OUyBGT1IgQ09QWUlORywgRElTVFJJQlVUSU9OIEFORCBNT0RJRklDQVRJT05cbiNcbiMgIDAuIFlvdSBqdXN0IERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8uXG4jKytcblxuY2xhc3MgUGFnZ2lvOyBjbGFzcyBIVE1MIDwgQmFzaWNPYmplY3Q7IGNsYXNzIEVsZW1lbnQgPCBCYXNpY09iamVjdFxuXG5jbGFzcyBDYW52YXMgPCBzZWxmXG4gIHsgd2lkdGg6ICA6d2lkdGgsXG4gICAgaGVpZ2h0OiA6aGVpZ2h0XG4gIH0uZWFjaCB7fG5hbWUsIGF0dHJpYnV0ZXxcbiAgICBkZWZoZWxwZXIgbmFtZSBkbyB8dmFsdWV8XG4gICAgICBAYXR0cmlidXRlc1tuYW1lXSA9IHZhbHVlLnRvX3NcbiAgICBlbmRcbiAgfVxuZW5kXG5cbmVuZDsgZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOlBhZ2dpbz4iLCI8Y2xhc3M6SFRNTD4iLCI8Y2xhc3M6RWxlbWVudD4iLCI8Y2xhc3M6Q2FudmFzPiIsImVhY2giLCJibG9jayBpbiA8Y2xhc3M6Q2FudmFzPiIsIm5hbWUiLCJhdHRyaWJ1dGUiLCJibG9jayAoMiBsZXZlbHMpIGluIDxjbGFzczpDYW52YXM+IiwiZGVmaGVscGVyIiwic2VsZiIsInZhbHVlIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiA8Y2xhc3M6Q2FudmFzPiIsIltdPSIsInRvX3MiLCJAYXR0cmlidXRlcyIsIkJhc2ljT2JqZWN0Il0sIm1hcHBpbmdzIjoiQUFBQUEsNkNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFVQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFjQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BQTBCQSxPQUFBQztNQUFBQTs7UUFBQUE7O1FBRXhDQSxPQUFBQztRQUFBQTs7O1VBQ0VBLE9BRUNDLE1BRkQsVUFBQSxRQUFBLEVBQVUsT0FBVixDQUFBLEVBQUEsU0FBQSxFQUNVLFFBRFYsQ0FBQSxHQUVDQSxRQUFBQSxFQUFBQSxFQUFBQSxFQUZEQyxtQkFFU0MsSUFBRCxFQUFPQyxTQUZmRixFQUFBRzs7O1lBRVM7WUFBTTtZQUNiQSxPQUFBQyxNQUFBQyxJQUFBRCxhQUFBQSxFQUFBQSxDQUFVSCxJQUFWRyxDQUFBQSxFQUFBRCxhQUFtQkcsS0FBbkJILEVBQUFJO0FBQUFBOzs7Y0FBbUI7Y0FDakJBLE9BQVdDLE1BQUFBLENBQUNQLElBQVosRUFBb0JLLEtBQUtHLE1BQUFBLENBQUFBLENBQWRELENBQUFBLEVBQUFBLE1BQVhFLGVBQVdGLE9BQUFBLEVBQUFBLEVBQUFBLENBQUFBLEVBQUFBLG1CQURiTCxDQUFBQSxHQUFBQSxTQUFBQSxDQUFBQyxFQUhGSixDQUFBQSxHQUFBQSxTQUFBQSxDQUVDRDtRQUhIRCxHQUFBQSxXQUFBQSxFQUFlTyxJQUFmUDtNQUZ3Q0QsR0FBQUEsV0FBQUEsRUFBZ0JjLGlCQUFoQmQ7SUFBMUJELEdBQUFBLFdBQUFBLEVBQWFlLGlCQUFiZjtFQUFkRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQVZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MjcxMDAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwYWdnaW8vaHRtbC9lbGVtZW50L2VtYmVkLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMtLVxuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICAgICAgICAgICAgICAgICAgIFZlcnNpb24gMiwgRGVjZW1iZXIgMjAwNFxuI1xuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICBURVJNUyBBTkQgQ09ORElUSU9OUyBGT1IgQ09QWUlORywgRElTVFJJQlVUSU9OIEFORCBNT0RJRklDQVRJT05cbiNcbiMgIDAuIFlvdSBqdXN0IERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8uXG4jKytcblxuY2xhc3MgUGFnZ2lvOyBjbGFzcyBIVE1MIDwgQmFzaWNPYmplY3Q7IGNsYXNzIEVsZW1lbnQgPCBCYXNpY09iamVjdFxuXG5jbGFzcyBFbWJlZCA8IHNlbGZcbiAgeyB0eXBlOiAgIDp0eXBlLFxuICAgIGhlaWdodDogOmhlaWdodCxcbiAgICB3aWR0aDogIDp3aWR0aFxuICB9LmVhY2gge3xuYW1lLCBhdHRyaWJ1dGV8XG4gICAgZGVmaGVscGVyIG5hbWUgZG8gfHZhbHVlfFxuICAgICAgQGF0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZVxuICAgIGVuZFxuICB9XG5lbmRcblxuZW5kOyBlbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6UGFnZ2lvPiIsIjxjbGFzczpIVE1MPiIsIjxjbGFzczpFbGVtZW50PiIsIjxjbGFzczpFbWJlZD4iLCJlYWNoIiwiYmxvY2sgaW4gPGNsYXNzOkVtYmVkPiIsIm5hbWUiLCJhdHRyaWJ1dGUiLCJibG9jayAoMiBsZXZlbHMpIGluIDxjbGFzczpFbWJlZD4iLCJkZWZoZWxwZXIiLCJzZWxmIiwidmFsdWUiLCJibG9jayAoMyBsZXZlbHMpIGluIDxjbGFzczpFbWJlZD4iLCJbXT0iLCJAYXR0cmlidXRlcyIsIkJhc2ljT2JqZWN0Il0sIm1hcHBpbmdzIjoiQUFBQUEsNENBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFVQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFjQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BQTBCQSxPQUFBQztNQUFBQTs7UUFBQUE7O1FBRXhDQSxPQUFBQztRQUFBQTs7O1VBQ0VBLE9BR0NDLE1BSEQsVUFBQSxPQUFBLEVBQVUsTUFBVixDQUFBLEVBQUEsU0FBQSxFQUNVLFFBRFYsQ0FBQSxFQUFBLFFBQUEsRUFFVSxPQUZWLENBQUEsR0FHQ0EsUUFBQUEsRUFBQUEsRUFBQUEsRUFIREMsa0JBR1NDLElBQUQsRUFBT0MsU0FIZkYsRUFBQUc7OztZQUdTO1lBQU07WUFDYkEsT0FBQUMsTUFBQUMsSUFBQUQsYUFBQUEsRUFBQUEsQ0FBVUgsSUFBVkcsQ0FBQUEsRUFBQUQsYUFBbUJHLEtBQW5CSCxFQUFBSTtBQUFBQTs7O2NBQW1CO2NBQ2pCQSxPQUFXQyxNQUFBQSxDQUFDUCxJQUFaLEVBQW9CSyxLQUFURSxDQUFBQSxFQUFBQSxNQUFYQyxlQUFXRCxPQUFBQSxFQUFBQSxFQUFBQSxDQUFBQSxFQUFBQSxtQkFEYkwsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBQUMsRUFKRkosQ0FBQUEsR0FBQUEsU0FBQUEsQ0FHQ0Q7UUFKSEQsR0FBQUEsV0FBQUEsRUFBY08sSUFBZFA7TUFGd0NELEdBQUFBLFdBQUFBLEVBQWdCYSxpQkFBaEJiO0lBQTFCRCxHQUFBQSxXQUFBQSxFQUFhYyxpQkFBYmQ7RUFBZEQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFWQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI3MTQwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGFnZ2lvL2h0bWwvZWxlbWVudC9pbWcucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIy0tXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgICAgICAgICAgICAgICAgICAgVmVyc2lvbiAyLCBEZWNlbWJlciAyMDA0XG4jXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBDT1BZSU5HLCBESVNUUklCVVRJT04gQU5EIE1PRElGSUNBVElPTlxuI1xuIyAgMC4gWW91IGp1c3QgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTy5cbiMrK1xuXG5jbGFzcyBQYWdnaW87IGNsYXNzIEhUTUwgPCBCYXNpY09iamVjdDsgY2xhc3MgRWxlbWVudCA8IEJhc2ljT2JqZWN0XG5cbmNsYXNzIEltZyA8IHNlbGZcbiAgeyBzcmM6IDpzcmMsXG4gICAgdXJsOiA6c3JjLFxuXG4gICAgYWx0OiAgICAgICAgIDphbHQsXG4gICAgZGVzY3JpcHRpb246IDphbHQsXG5cbiAgICBoZWlnaHQ6IDpoZWlnaHQsXG4gICAgd2lkdGg6ICA6d2lkdGgsXG5cbiAgICBtYXA6IDp1c2VtYXAsXG4gIH0uZWFjaCB7fG5hbWUsIGF0dHJpYnV0ZXxcbiAgICBkZWZoZWxwZXIgbmFtZSBkbyB8dmFsdWV8XG4gICAgICBAYXR0cmlidXRlc1tuYW1lXSA9IHZhbHVlLnRvX3NcbiAgICBlbmRcbiAgfVxuXG4gIGRlZmhlbHBlciA6bWFwISBkb1xuICAgIEBhdHRyaWJ1dGVzWzppc21hcF0gPSB0cnVlXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOlBhZ2dpbz4iLCI8Y2xhc3M6SFRNTD4iLCI8Y2xhc3M6RWxlbWVudD4iLCI8Y2xhc3M6SW1nPiIsImVhY2giLCJibG9jayBpbiA8Y2xhc3M6SW1nPiIsIm5hbWUiLCJhdHRyaWJ1dGUiLCJibG9jayAoMiBsZXZlbHMpIGluIDxjbGFzczpJbWc+IiwiZGVmaGVscGVyIiwic2VsZiIsInZhbHVlIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiA8Y2xhc3M6SW1nPiIsIltdPSIsInRvX3MiLCJAYXR0cmlidXRlcyIsIkJhc2ljT2JqZWN0Il0sIm1hcHBpbmdzIjoiQUFBQUEsMENBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFVQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFjQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BQTBCQSxPQUFBQztNQUFBQTs7UUFBQUE7O1FBRXhDQSxPQUFBQztRQUFBQTs7OztVQVdHQyxNQVZELFVBQUEsTUFBQSxFQUFPLEtBQVAsQ0FBQSxFQUFBLE1BQUEsRUFDTyxLQURQLENBQUEsRUFBQSxNQUFBLEVBR2UsS0FIZixDQUFBLEVBQUEsY0FBQSxFQUllLEtBSmYsQ0FBQSxFQUFBLFNBQUEsRUFNVSxRQU5WLENBQUEsRUFBQSxRQUFBLEVBT1UsT0FQVixDQUFBLEVBQUEsTUFBQSxFQVNPLFFBVFAsQ0FBQSxHQVVDQSxRQUFBQSxFQUFBQSxFQUFBQSxFQVZEQyxnQkFVU0MsSUFBRCxFQUFPQyxTQVZmRixFQUFBRzs7O1lBVVM7WUFBTTtZQUNiQSxPQUFBQyxNQUFBQyxJQUFBRCxhQUFBQSxFQUFBQSxDQUFVSCxJQUFWRyxDQUFBQSxFQUFBRCxhQUFtQkcsS0FBbkJILEVBQUFJO0FBQUFBOzs7Y0FBbUI7Y0FDakJBLE9BQVdDLE1BQUFBLENBQUNQLElBQVosRUFBb0JLLEtBQUtHLE1BQUFBLENBQUFBLENBQWRELENBQUFBLEVBQUFBLE1BQVhFLGVBQVdGLE9BQUFBLEVBQUFBLEVBQUFBLENBQUFBLEVBQUFBLG1CQURiTCxDQUFBQSxHQUFBQSxTQUFBQSxDQUFBQyxFQVhGSixDQUFBQSxHQUFBQSxTQUFBQSxDQVVDRDtVQU1ERCxPQUFBTSxNQUFBQyxJQUFBRCxhQUFBQSxFQUFBQSxDQUFVLE1BQVZBLENBQUFBLEVBQUFKLGdCQUFBQSxFQUFBRztBQUFBQTs7WUFDRUEsT0FBV0ssTUFBQUEsQ0FBQyxPQUFaLEVBQXNCLElBQVhBLENBQUFBLEVBQUFBLE1BQVhFLGVBQVdGLE9BQUFBLEVBQUFBLEVBQUFBLENBQUFBLEVBQUFBLGtCQURiUixDQUFBQSxHQUFBQSxTQUFBQSxDQUFBSTtRQWpCRk4sR0FBQUEsV0FBQUEsRUFBWU8sSUFBWlA7TUFGd0NELEdBQUFBLFdBQUFBLEVBQWdCYyxpQkFBaEJkO0lBQTFCRCxHQUFBQSxXQUFBQSxFQUFhZSxpQkFBYmY7RUFBZEQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFWQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI3MTg1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGFnZ2lvL2h0bWwvZWxlbWVudC9pbnB1dC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjLS1cbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgICAgICAgICAgICAgICAgICBWZXJzaW9uIDIsIERlY2VtYmVyIDIwMDRcbiNcbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgVEVSTVMgQU5EIENPTkRJVElPTlMgRk9SIENPUFlJTkcsIERJU1RSSUJVVElPTiBBTkQgTU9ESUZJQ0FUSU9OXG4jXG4jICAwLiBZb3UganVzdCBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPLlxuIysrXG5cbmNsYXNzIFBhZ2dpbzsgY2xhc3MgSFRNTCA8IEJhc2ljT2JqZWN0OyBjbGFzcyBFbGVtZW50IDwgQmFzaWNPYmplY3RcblxuY2xhc3MgSW5wdXQgPCBzZWxmXG4gIHsgdHlwZTogICAgICAgICA6dHlwZSxcbiAgICBuYW1lOiAgICAgICAgIDpuYW1lLFxuICAgIHZhbHVlOiAgICAgICAgOnZhbHVlLFxuICAgIHNpemU6ICAgICAgICAgOnNpemUsXG4gICAgcGxhY2VfaG9sZGVyOiA6cGxhY2Vob2xkZXIsXG4gICAgcmVhZF9vbmx5OiAgICA6cmVhZG9ubHksXG4gICAgcmVxdWlyZWQ6ICAgICA6cmVxdWlyZWQsXG4gICAgbGltaXQ6ICAgICAgICA6bWF4bGVuZ3RoXG4gIH0uZWFjaCB7fG5hbWUsIGF0dHJpYnV0ZXxcbiAgICBkZWZoZWxwZXIgbmFtZSBkbyB8dmFsdWV8XG4gICAgICBAYXR0cmlidXRlc1tuYW1lXSA9IHZhbHVlXG4gICAgZW5kXG4gIH1cbmVuZFxuXG5lbmQ7IGVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpQYWdnaW8+IiwiPGNsYXNzOkhUTUw+IiwiPGNsYXNzOkVsZW1lbnQ+IiwiPGNsYXNzOklucHV0PiIsImVhY2giLCJibG9jayBpbiA8Y2xhc3M6SW5wdXQ+IiwibmFtZSIsImF0dHJpYnV0ZSIsImJsb2NrICgyIGxldmVscykgaW4gPGNsYXNzOklucHV0PiIsImRlZmhlbHBlciIsInNlbGYiLCJ2YWx1ZSIsImJsb2NrICgzIGxldmVscykgaW4gPGNsYXNzOklucHV0PiIsIltdPSIsIkBhdHRyaWJ1dGVzIiwiQmFzaWNPYmplY3QiXSwibWFwcGluZ3MiOiJBQUFBQSw0Q0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQVVBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWNBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFBMEJBLE9BQUFDO01BQUFBOztRQUFBQTs7UUFFeENBLE9BQUFDO1FBQUFBOzs7VUFDRUEsT0FRQ0MsTUFSRCxVQUFBLE9BQUEsRUFBZ0IsTUFBaEIsQ0FBQSxFQUFBLE9BQUEsRUFDZ0IsTUFEaEIsQ0FBQSxFQUFBLFFBQUEsRUFFZ0IsT0FGaEIsQ0FBQSxFQUFBLE9BQUEsRUFHZ0IsTUFIaEIsQ0FBQSxFQUFBLGVBQUEsRUFJZ0IsYUFKaEIsQ0FBQSxFQUFBLFlBQUEsRUFLZ0IsVUFMaEIsQ0FBQSxFQUFBLFdBQUEsRUFNZ0IsVUFOaEIsQ0FBQSxFQUFBLFFBQUEsRUFPZ0IsV0FQaEIsQ0FBQSxHQVFDQSxRQUFBQSxFQUFBQSxFQUFBQSxFQVJEQyxrQkFRU0MsSUFBRCxFQUFPQyxTQVJmRixFQUFBRzs7O1lBUVM7WUFBTTtZQUNiQSxPQUFBQyxNQUFBQyxJQUFBRCxhQUFBQSxFQUFBQSxDQUFVSCxJQUFWRyxDQUFBQSxFQUFBRCxhQUFtQkcsS0FBbkJILEVBQUFJO0FBQUFBOzs7Y0FBbUI7Y0FDakJBLE9BQVdDLE1BQUFBLENBQUNQLElBQVosRUFBb0JLLEtBQVRFLENBQUFBLEVBQUFBLE1BQVhDLGVBQVdELE9BQUFBLEVBQUFBLEVBQUFBLENBQUFBLEVBQUFBLG1CQURiTCxDQUFBQSxHQUFBQSxTQUFBQSxDQUFBQyxFQVRGSixDQUFBQSxHQUFBQSxTQUFBQSxDQVFDRDtRQVRIRCxHQUFBQSxXQUFBQSxFQUFjTyxJQUFkUDtNQUZ3Q0QsR0FBQUEsV0FBQUEsRUFBZ0JhLGlCQUFoQmI7SUFBMUJELEdBQUFBLFdBQUFBLEVBQWFjLGlCQUFiZDtFQUFkRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQVZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MjcyMjUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwYWdnaW8vaHRtbC9lbGVtZW50L2xpbmsucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgUGFnZ2lvOyBjbGFzcyBIVE1MIDwgQmFzaWNPYmplY3Q7IGNsYXNzIEVsZW1lbnQgPCBCYXNpY09iamVjdFxuXG5jbGFzcyBMaW5rIDwgc2VsZlxuICB7IGNyb3NzX29yaWdpbjogOmNyb3Nzb3JpZ2luLFxuXG4gICAgaHJlZjogICAgICA6aHJlZixcbiAgICBocmVmX2xhbmc6IDpocmVmbGFuZyxcblxuICAgIG1lZGlhOiA6bWVkaWEsXG4gICAgcmVsOiAgIDpyZWwsXG4gICAgc2l6ZXM6IDpzaXplcyxcbiAgICB0eXBlOiAgOnR5cGUsXG4gIH0uZWFjaCB7fG5hbWUsIGF0dHJpYnV0ZXxcbiAgICBkZWZoZWxwZXIgbmFtZSBkbyB8dmFsdWV8XG4gICAgICBAYXR0cmlidXRlc1tuYW1lXSA9IHZhbHVlLnRvX3NcbiAgICBlbmRcbiAgfVxuZW5kXG5cbmVuZDsgZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOlBhZ2dpbz4iLCI8Y2xhc3M6SFRNTD4iLCI8Y2xhc3M6RWxlbWVudD4iLCI8Y2xhc3M6TGluaz4iLCJlYWNoIiwiYmxvY2sgaW4gPGNsYXNzOkxpbms+IiwibmFtZSIsImF0dHJpYnV0ZSIsImJsb2NrICgyIGxldmVscykgaW4gPGNsYXNzOkxpbms+IiwiZGVmaGVscGVyIiwic2VsZiIsInZhbHVlIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiA8Y2xhc3M6TGluaz4iLCJbXT0iLCJ0b19zIiwiQGF0dHJpYnV0ZXMiLCJCYXNpY09iamVjdCJdLCJtYXBwaW5ncyI6IkFBQUFBLDJDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBY0EsT0FBQUM7SUFBQUE7O01BQUFBOztNQUEwQkEsT0FBQUM7TUFBQUE7O1FBQUFBOztRQUV4Q0EsT0FBQUM7UUFBQUE7OztVQUNFQSxPQVNDQyxNQVRELFVBQUEsZUFBQSxFQUFnQixhQUFoQixDQUFBLEVBQUEsT0FBQSxFQUVhLE1BRmIsQ0FBQSxFQUFBLFlBQUEsRUFHYSxVQUhiLENBQUEsRUFBQSxRQUFBLEVBS1MsT0FMVCxDQUFBLEVBQUEsTUFBQSxFQU1TLEtBTlQsQ0FBQSxFQUFBLFFBQUEsRUFPUyxPQVBULENBQUEsRUFBQSxPQUFBLEVBUVMsTUFSVCxDQUFBLEdBU0NBLFFBQUFBLEVBQUFBLEVBQUFBLEVBVERDLGlCQVNTQyxJQUFELEVBQU9DLFNBVGZGLEVBQUFHOzs7WUFTUztZQUFNO1lBQ2JBLE9BQUFDLE1BQUFDLElBQUFELGFBQUFBLEVBQUFBLENBQVVILElBQVZHLENBQUFBLEVBQUFELGFBQW1CRyxLQUFuQkgsRUFBQUk7QUFBQUE7OztjQUFtQjtjQUNqQkEsT0FBV0MsTUFBQUEsQ0FBQ1AsSUFBWixFQUFvQkssS0FBS0csTUFBQUEsQ0FBQUEsQ0FBZEQsQ0FBQUEsRUFBQUEsTUFBWEUsZUFBV0YsT0FBQUEsRUFBQUEsRUFBQUEsQ0FBQUEsRUFBQUEsbUJBRGJMLENBQUFBLEdBQUFBLFNBQUFBLENBQUFDLEVBVkZKLENBQUFBLEdBQUFBLFNBQUFBLENBU0NEO1FBVkhELEdBQUFBLFdBQUFBLEVBQWFPLElBQWJQO01BRndDRCxHQUFBQSxXQUFBQSxFQUFnQmMsaUJBQWhCZDtJQUExQkQsR0FBQUEsV0FBQUEsRUFBYWUsaUJBQWJmO0VBQWRELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNzI2NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInBhZ2dpby9odG1sL2VsZW1lbnQvb2JqZWN0LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMtLVxuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICAgICAgICAgICAgICAgICAgIFZlcnNpb24gMiwgRGVjZW1iZXIgMjAwNFxuI1xuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICBURVJNUyBBTkQgQ09ORElUSU9OUyBGT1IgQ09QWUlORywgRElTVFJJQlVUSU9OIEFORCBNT0RJRklDQVRJT05cbiNcbiMgIDAuIFlvdSBqdXN0IERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8uXG4jKytcblxuY2xhc3MgUGFnZ2lvOyBjbGFzcyBIVE1MIDwgQmFzaWNPYmplY3Q7IGNsYXNzIEVsZW1lbnQgPCBCYXNpY09iamVjdFxuXG5jbGFzcyBPYmplY3QgPCBzZWxmXG4gIHsgdHlwZTogOnR5cGUsXG4gICAgZGF0YTogOmRhdGEsXG4gICAgbmFtZTogOm5hbWUsXG5cbiAgICBoZWlnaHQ6IDpoZWlnaHQsXG4gICAgd2lkdGg6ICA6d2lkdGhcbiAgfS5lYWNoIHt8bmFtZSwgYXR0cmlidXRlfFxuICAgIGRlZmhlbHBlciBuYW1lIGRvIHx2YWx1ZXxcbiAgICAgIEBhdHRyaWJ1dGVzW25hbWVdID0gdmFsdWVcbiAgICBlbmRcbiAgfVxuZW5kXG5cbmVuZDsgZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOlBhZ2dpbz4iLCI8Y2xhc3M6SFRNTD4iLCI8Y2xhc3M6RWxlbWVudD4iLCI8Y2xhc3M6T2JqZWN0PiIsImVhY2giLCJibG9jayBpbiA8Y2xhc3M6T2JqZWN0PiIsIm5hbWUiLCJhdHRyaWJ1dGUiLCJibG9jayAoMiBsZXZlbHMpIGluIDxjbGFzczpPYmplY3Q+IiwiZGVmaGVscGVyIiwic2VsZiIsInZhbHVlIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiA8Y2xhc3M6T2JqZWN0PiIsIltdPSIsIkBhdHRyaWJ1dGVzIiwiQmFzaWNPYmplY3QiXSwibWFwcGluZ3MiOiJBQUFBQSw2Q0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQVVBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWNBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFBMEJBLE9BQUFDO01BQUFBOztRQUFBQTs7UUFFeENBLE9BQUFDO1FBQUFBOzs7VUFDRUEsT0FNQ0MsTUFORCxVQUFBLE9BQUEsRUFBUSxNQUFSLENBQUEsRUFBQSxPQUFBLEVBQ1EsTUFEUixDQUFBLEVBQUEsT0FBQSxFQUVRLE1BRlIsQ0FBQSxFQUFBLFNBQUEsRUFJVSxRQUpWLENBQUEsRUFBQSxRQUFBLEVBS1UsT0FMVixDQUFBLEdBTUNBLFFBQUFBLEVBQUFBLEVBQUFBLEVBTkRDLG1CQU1TQyxJQUFELEVBQU9DLFNBTmZGLEVBQUFHOzs7WUFNUztZQUFNO1lBQ2JBLE9BQUFDLE1BQUFDLElBQUFELGFBQUFBLEVBQUFBLENBQVVILElBQVZHLENBQUFBLEVBQUFELGFBQW1CRyxLQUFuQkgsRUFBQUk7QUFBQUE7OztjQUFtQjtjQUNqQkEsT0FBV0MsTUFBQUEsQ0FBQ1AsSUFBWixFQUFvQkssS0FBVEUsQ0FBQUEsRUFBQUEsTUFBWEMsZUFBV0QsT0FBQUEsRUFBQUEsRUFBQUEsQ0FBQUEsRUFBQUEsbUJBRGJMLENBQUFBLEdBQUFBLFNBQUFBLENBQUFDLEVBUEZKLENBQUFBLEdBQUFBLFNBQUFBLENBTUNEO1FBUEhELEdBQUFBLFdBQUFBLEVBQWVPLElBQWZQO01BRndDRCxHQUFBQSxXQUFBQSxFQUFnQmEsaUJBQWhCYjtJQUExQkQsR0FBQUEsV0FBQUEsRUFBYWMsaUJBQWJkO0VBQWRELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBVkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNzMwNSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInBhZ2dpby9odG1sL2VsZW1lbnQvb3B0aW9uLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMtLVxuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICAgICAgICAgICAgICAgICAgIFZlcnNpb24gMiwgRGVjZW1iZXIgMjAwNFxuI1xuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICBURVJNUyBBTkQgQ09ORElUSU9OUyBGT1IgQ09QWUlORywgRElTVFJJQlVUSU9OIEFORCBNT0RJRklDQVRJT05cbiNcbiMgIDAuIFlvdSBqdXN0IERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8uXG4jKytcblxuY2xhc3MgUGFnZ2lvOyBjbGFzcyBIVE1MIDwgQmFzaWNPYmplY3Q7IGNsYXNzIEVsZW1lbnQgPCBCYXNpY09iamVjdFxuXG5jbGFzcyBPcHRpb24gPCBzZWxmXG4gICV3W2xhYmVsIHZhbHVlXS5lYWNoIHt8bmFtZXxcbiAgICBkZWZoZWxwZXIgbmFtZSBkbyB8dmFsdWV8XG4gICAgICBAYXR0cmlidXRlc1tuYW1lXSA9IHZhbHVlXG4gICAgZW5kXG4gIH1cblxuICBkZWZoZWxwZXIhIDpkaXNhYmxlZFxuICBkZWZoZWxwZXIhIDpzZWxlY3RlZFxuZW5kXG5cbmVuZDsgZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOlBhZ2dpbz4iLCI8Y2xhc3M6SFRNTD4iLCI8Y2xhc3M6RWxlbWVudD4iLCI8Y2xhc3M6T3B0aW9uPiIsImVhY2giLCJibG9jayBpbiA8Y2xhc3M6T3B0aW9uPiIsIm5hbWUiLCJibG9jayAoMiBsZXZlbHMpIGluIDxjbGFzczpPcHRpb24+IiwiZGVmaGVscGVyIiwic2VsZiIsInZhbHVlIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiA8Y2xhc3M6T3B0aW9uPiIsIltdPSIsIkBhdHRyaWJ1dGVzIiwiZGVmaGVscGVyISIsIkJhc2ljT2JqZWN0Il0sIm1hcHBpbmdzIjoiQUFBQUEsNkNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFVQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFjQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BQTBCQSxPQUFBQztNQUFBQTs7UUFBQUE7O1FBRXhDQSxPQUFBQztRQUFBQTs7OztVQUNpQkMsTUFBZixDQUFHRCxPQUFILEVBQVNBLE9BQVQsQ0FBZUMsUUFBQUEsRUFBQUEsRUFBQUEsRUFBZkMsbUJBQXVCQyxJQUF2QkQsRUFBQUU7OztZQUF1QjtZQUNyQkEsT0FBQUMsTUFBQUMsSUFBQUQsYUFBQUEsRUFBQUEsQ0FBVUYsSUFBVkUsQ0FBQUEsRUFBQUQsYUFBbUJHLEtBQW5CSCxFQUFBSTtBQUFBQTs7O2NBQW1CO2NBQ2pCQSxPQUFXQyxNQUFBQSxDQUFDTixJQUFaLEVBQW9CSSxLQUFURSxDQUFBQSxFQUFBQSxNQUFYQyxlQUFXRCxPQUFBQSxFQUFBQSxFQUFBQSxDQUFBQSxFQUFBQSxtQkFEYkwsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBQUMsRUFERkgsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBZUQ7VUFNZkssSUFBQUssZUFBQUEsQ0FBVyxVQUFYQTtVQUNBWCxPQUFBTSxJQUFBSyxlQUFBQSxDQUFXLFVBQVhBO1FBUkZYLEdBQUFBLFdBQUFBLEVBQWVNLElBQWZOO01BRndDRCxHQUFBQSxXQUFBQSxFQUFnQmEsaUJBQWhCYjtJQUExQkQsR0FBQUEsV0FBQUEsRUFBYWMsaUJBQWJkO0VBQWRELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBVkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNzM0NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInBhZ2dpby9odG1sL2VsZW1lbnQvb3B0Z3JvdXAucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIy0tXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgICAgICAgICAgICAgICAgICAgVmVyc2lvbiAyLCBEZWNlbWJlciAyMDA0XG4jXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBDT1BZSU5HLCBESVNUUklCVVRJT04gQU5EIE1PRElGSUNBVElPTlxuI1xuIyAgMC4gWW91IGp1c3QgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTy5cbiMrK1xuXG5jbGFzcyBQYWdnaW87IGNsYXNzIEhUTUwgPCBCYXNpY09iamVjdDsgY2xhc3MgRWxlbWVudCA8IEJhc2ljT2JqZWN0XG5cbmNsYXNzIE9wdGdyb3VwIDwgc2VsZlxuICAld1tsYWJlbCB2YWx1ZV0uZWFjaCB7fG5hbWV8XG4gICAgZGVmaGVscGVyIG5hbWUgZG8gfHZhbHVlfFxuICAgICAgQGF0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZVxuICAgIGVuZFxuICB9XG5cbiAgZGVmaGVscGVyISA6ZGlzYWJsZWRcbiAgZGVmaGVscGVyISA6c2VsZWN0ZWRcbmVuZFxuXG5lbmQ7IGVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpQYWdnaW8+IiwiPGNsYXNzOkhUTUw+IiwiPGNsYXNzOkVsZW1lbnQ+IiwiPGNsYXNzOk9wdGdyb3VwPiIsImVhY2giLCJibG9jayBpbiA8Y2xhc3M6T3B0Z3JvdXA+IiwibmFtZSIsImJsb2NrICgyIGxldmVscykgaW4gPGNsYXNzOk9wdGdyb3VwPiIsImRlZmhlbHBlciIsInNlbGYiLCJ2YWx1ZSIsImJsb2NrICgzIGxldmVscykgaW4gPGNsYXNzOk9wdGdyb3VwPiIsIltdPSIsIkBhdHRyaWJ1dGVzIiwiZGVmaGVscGVyISIsIkJhc2ljT2JqZWN0Il0sIm1hcHBpbmdzIjoiQUFBQUEsK0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFVQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFjQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BQTBCQSxPQUFBQztNQUFBQTs7UUFBQUE7O1FBRXhDQSxPQUFBQztRQUFBQTs7OztVQUNpQkMsTUFBZixDQUFHRCxPQUFILEVBQVNBLE9BQVQsQ0FBZUMsUUFBQUEsRUFBQUEsRUFBQUEsRUFBZkMscUJBQXVCQyxJQUF2QkQsRUFBQUU7OztZQUF1QjtZQUNyQkEsT0FBQUMsTUFBQUMsSUFBQUQsYUFBQUEsRUFBQUEsQ0FBVUYsSUFBVkUsQ0FBQUEsRUFBQUQsYUFBbUJHLEtBQW5CSCxFQUFBSTtBQUFBQTs7O2NBQW1CO2NBQ2pCQSxPQUFXQyxNQUFBQSxDQUFDTixJQUFaLEVBQW9CSSxLQUFURSxDQUFBQSxFQUFBQSxNQUFYQyxlQUFXRCxPQUFBQSxFQUFBQSxFQUFBQSxDQUFBQSxFQUFBQSxtQkFEYkwsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBQUMsRUFERkgsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBZUQ7VUFNZkssSUFBQUssZUFBQUEsQ0FBVyxVQUFYQTtVQUNBWCxPQUFBTSxJQUFBSyxlQUFBQSxDQUFXLFVBQVhBO1FBUkZYLEdBQUFBLFdBQUFBLEVBQWlCTSxJQUFqQk47TUFGd0NELEdBQUFBLFdBQUFBLEVBQWdCYSxpQkFBaEJiO0lBQTFCRCxHQUFBQSxXQUFBQSxFQUFhYyxpQkFBYmQ7RUFBZEQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFWQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI3Mzg5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGFnZ2lvL2h0bWwvZWxlbWVudC9zZWxlY3QucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIy0tXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgICAgICAgICAgICAgICAgICAgVmVyc2lvbiAyLCBEZWNlbWJlciAyMDA0XG4jXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBDT1BZSU5HLCBESVNUUklCVVRJT04gQU5EIE1PRElGSUNBVElPTlxuI1xuIyAgMC4gWW91IGp1c3QgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTy5cbiMrK1xuXG5jbGFzcyBQYWdnaW87IGNsYXNzIEhUTUwgPCBCYXNpY09iamVjdDsgY2xhc3MgRWxlbWVudCA8IEJhc2ljT2JqZWN0XG5cbmNsYXNzIFNlbGVjdCA8IHNlbGZcbiAgJXdbZm9ybSBuYW1lIHNpemVdLmVhY2gge3xuYW1lfFxuICAgIGRlZmhlbHBlciBuYW1lIGRvIHx2YWx1ZXxcbiAgICAgIEBhdHRyaWJ1dGVzW25hbWVdID0gdmFsdWVcbiAgICBlbmRcbiAgfVxuXG4gIGRlZmhlbHBlciEgOmF1dG9fZm9jdXMsIDphdXRvZm9jdXNcbiAgZGVmaGVscGVyISA6ZGlzYWJsZWRcbiAgZGVmaGVscGVyISA6cmVxdWlyZWRcbmVuZFxuXG5lbmQ7IGVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpQYWdnaW8+IiwiPGNsYXNzOkhUTUw+IiwiPGNsYXNzOkVsZW1lbnQ+IiwiPGNsYXNzOlNlbGVjdD4iLCJlYWNoIiwiYmxvY2sgaW4gPGNsYXNzOlNlbGVjdD4iLCJuYW1lIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8Y2xhc3M6U2VsZWN0PiIsImRlZmhlbHBlciIsInNlbGYiLCJ2YWx1ZSIsImJsb2NrICgzIGxldmVscykgaW4gPGNsYXNzOlNlbGVjdD4iLCJbXT0iLCJAYXR0cmlidXRlcyIsImRlZmhlbHBlciEiLCJCYXNpY09iamVjdCJdLCJtYXBwaW5ncyI6IkFBQUFBLDZDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBVUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBY0EsT0FBQUM7SUFBQUE7O01BQUFBOztNQUEwQkEsT0FBQUM7TUFBQUE7O1FBQUFBOztRQUV4Q0EsT0FBQUM7UUFBQUE7Ozs7VUFDb0JDLE1BQWxCLENBQUdELE1BQUgsRUFBUUEsTUFBUixFQUFhQSxNQUFiLENBQWtCQyxRQUFBQSxFQUFBQSxFQUFBQSxFQUFsQkMsbUJBQTBCQyxJQUExQkQsRUFBQUU7OztZQUEwQjtZQUN4QkEsT0FBQUMsTUFBQUMsSUFBQUQsYUFBQUEsRUFBQUEsQ0FBVUYsSUFBVkUsQ0FBQUEsRUFBQUQsYUFBbUJHLEtBQW5CSCxFQUFBSTtBQUFBQTs7O2NBQW1CO2NBQ2pCQSxPQUFXQyxNQUFBQSxDQUFDTixJQUFaLEVBQW9CSSxLQUFURSxDQUFBQSxFQUFBQSxNQUFYQyxlQUFXRCxPQUFBQSxFQUFBQSxFQUFBQSxDQUFBQSxFQUFBQSxtQkFEYkwsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBQUMsRUFERkgsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBa0JEO1VBTWxCSyxJQUFBSyxlQUFBQSxDQUFXLFlBQVgsRUFBd0IsV0FBeEJBO1VBQ0FMLElBQUFLLGVBQUFBLENBQVcsVUFBWEE7VUFDQVgsT0FBQU0sSUFBQUssZUFBQUEsQ0FBVyxVQUFYQTtRQVRGWCxHQUFBQSxXQUFBQSxFQUFlTSxJQUFmTjtNQUZ3Q0QsR0FBQUEsV0FBQUEsRUFBZ0JhLGlCQUFoQmI7SUFBMUJELEdBQUFBLFdBQUFBLEVBQWFjLGlCQUFiZDtFQUFkRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQVZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6Mjc0MzIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwYWdnaW8vaHRtbC9lbGVtZW50L3RkLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMtLVxuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICAgICAgICAgICAgICAgICAgIFZlcnNpb24gMiwgRGVjZW1iZXIgMjAwNFxuI1xuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICBURVJNUyBBTkQgQ09ORElUSU9OUyBGT1IgQ09QWUlORywgRElTVFJJQlVUSU9OIEFORCBNT0RJRklDQVRJT05cbiNcbiMgIDAuIFlvdSBqdXN0IERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8uXG4jKytcblxuY2xhc3MgUGFnZ2lvOyBjbGFzcyBIVE1MIDwgQmFzaWNPYmplY3Q7IGNsYXNzIEVsZW1lbnQgPCBCYXNpY09iamVjdFxuXG5jbGFzcyBUZCA8IHNlbGZcbiAgZGVmaGVscGVyIDpjb2x1bW5zIGRvIHx2YWx1ZXxcbiAgICBAYXR0cmlidXRlc1s6Y29sc3Bhbl0gPSB2YWx1ZS50b19zXG4gIGVuZFxuXG4gIGRlZmhlbHBlciA6cm93cyBkbyB8dmFsdWV8XG4gICAgQGF0dHJpYnV0ZXNbOnJvd3NwYW5dID0gdmFsdWUudG9fc1xuICBlbmRcblxuICBkZWZoZWxwZXIgOmhlYWRlcnMgZG8gfCphcmdzfFxuICAgIEBhdHRyaWJ1dGVzWzpoZWFkZXJzXSA9IGFyZ3Muam9pbignICcpXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOlBhZ2dpbz4iLCI8Y2xhc3M6SFRNTD4iLCI8Y2xhc3M6RWxlbWVudD4iLCI8Y2xhc3M6VGQ+IiwiZGVmaGVscGVyIiwic2VsZiIsImJsb2NrIGluIDxjbGFzczpUZD4iLCJ2YWx1ZSIsImJsb2NrICgyIGxldmVscykgaW4gPGNsYXNzOlRkPiIsIltdPSIsInRvX3MiLCJAYXR0cmlidXRlcyIsImFyZ3MiLCJqb2luIiwiQmFzaWNPYmplY3QiXSwibWFwcGluZ3MiOiJBQUFBQSx5Q0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQVVBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWNBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFBMEJBLE9BQUFDO01BQUFBOztRQUFBQTs7UUFFeENBLE9BQUFDO1FBQUFBOzs7O1VBQ0VDLE1BQUFDLElBQUFELGFBQUFBLEVBQUFBLENBQVUsU0FBVkEsQ0FBQUEsRUFBQUUsZUFBdUJDLEtBQXZCRCxFQUFBRTtBQUFBQTs7O1lBQXVCO1lBQ3JCQSxPQUFXQyxNQUFBQSxDQUFDLFNBQVosRUFBd0JGLEtBQUtHLE1BQUFBLENBQUFBLENBQWxCRCxDQUFBQSxFQUFBQSxNQUFYRSxlQUFXRixPQUFBQSxFQUFBQSxFQUFBQSxDQUFBQSxFQUFBQSxtQkFEYkgsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBQUY7VUFJQUEsTUFBQUMsSUFBQUQsYUFBQUEsRUFBQUEsQ0FBVSxNQUFWQSxDQUFBQSxFQUFBRSxlQUFvQkMsS0FBcEJELEVBQUFFO0FBQUFBOzs7WUFBb0I7WUFDbEJBLE9BQVdDLE1BQUFBLENBQUMsU0FBWixFQUF3QkYsS0FBS0csTUFBQUEsQ0FBQUEsQ0FBbEJELENBQUFBLEVBQUFBLE1BQVhFLGVBQVdGLE9BQUFBLEVBQUFBLEVBQUFBLENBQUFBLEVBQUFBLG1CQURiSCxDQUFBQSxHQUFBQSxTQUFBQSxDQUFBRjtVQUlBRCxPQUFBQyxNQUFBQyxJQUFBRCxhQUFBQSxFQUFBQSxDQUFVLFNBQVZBLENBQUFBLEVBQUFFLGVBckJGLEVBcUJFQSxFQUFBRTtBQUFBQTs7O1lBckJGO1lBcUJ5QjtZQUNyQkEsT0FBV0MsTUFBQUEsQ0FBQyxTQUFaLEVBQXdCRyxJQUFJQyxNQUFBQSxDQUFNTCxHQUFOSyxDQUFqQkosQ0FBQUEsRUFBQUEsTUFBWEUsZUFBV0YsT0FBQUEsRUFBQUEsRUFBQUEsQ0FBQUEsRUFBQUEsbUJBRGJILENBQUFBLEdBQUFBLHNCQUFBQSxDQUFBRjtRQVRGRCxHQUFBQSxXQUFBQSxFQUFXRSxJQUFYRjtNQUZ3Q0QsR0FBQUEsV0FBQUEsRUFBZ0JZLGlCQUFoQlo7SUFBMUJELEdBQUFBLFdBQUFBLEVBQWFhLGlCQUFiYjtFQUFkRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQVZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6Mjc0ODEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwYWdnaW8vaHRtbC9lbGVtZW50LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMtLVxuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICAgICAgICAgICAgICAgICAgIFZlcnNpb24gMiwgRGVjZW1iZXIgMjAwNFxuI1xuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICBURVJNUyBBTkQgQ09ORElUSU9OUyBGT1IgQ09QWUlORywgRElTVFJJQlVUSU9OIEFORCBNT0RJRklDQVRJT05cbiNcbiMgIDAuIFlvdSBqdXN0IERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8uXG4jKytcblxucmVxdWlyZSAncGFnZ2lvL2h0bWwvZWxlbWVudC9hJ1xucmVxdWlyZSAncGFnZ2lvL2h0bWwvZWxlbWVudC9iYXNlJ1xucmVxdWlyZSAncGFnZ2lvL2h0bWwvZWxlbWVudC9ibG9ja3F1b3RlJ1xucmVxdWlyZSAncGFnZ2lvL2h0bWwvZWxlbWVudC9idXR0b24nXG5yZXF1aXJlICdwYWdnaW8vaHRtbC9lbGVtZW50L2NhbnZhcydcbnJlcXVpcmUgJ3BhZ2dpby9odG1sL2VsZW1lbnQvZW1iZWQnXG5yZXF1aXJlICdwYWdnaW8vaHRtbC9lbGVtZW50L2ltZydcbnJlcXVpcmUgJ3BhZ2dpby9odG1sL2VsZW1lbnQvaW5wdXQnXG5yZXF1aXJlICdwYWdnaW8vaHRtbC9lbGVtZW50L2xpbmsnXG5yZXF1aXJlICdwYWdnaW8vaHRtbC9lbGVtZW50L29iamVjdCdcbnJlcXVpcmUgJ3BhZ2dpby9odG1sL2VsZW1lbnQvb3B0aW9uJ1xucmVxdWlyZSAncGFnZ2lvL2h0bWwvZWxlbWVudC9vcHRncm91cCdcbnJlcXVpcmUgJ3BhZ2dpby9odG1sL2VsZW1lbnQvc2VsZWN0J1xucmVxdWlyZSAncGFnZ2lvL2h0bWwvZWxlbWVudC90ZCdcblxuY2xhc3MgUGFnZ2lvOyBjbGFzcyBIVE1MIDwgQmFzaWNPYmplY3RcblxuY2xhc3MgRWxlbWVudCA8IEJhc2ljT2JqZWN0XG4gIGRlZiBzZWxmLm5ldyhvd25lciwgbmFtZSwgYXR0cmlidXRlcyA9IHt9KVxuICAgIHJldHVybiBzdXBlciB1bmxlc3Mgc2VsZiA9PSBFbGVtZW50XG5cbiAgICBjb25zdCA9IG5hbWUuY2FwaXRhbGl6ZVxuXG4gICAgaWYgIWNvbnN0LnRvX3MuaW5jbHVkZT8oJy0nKSAmJiBjb25zdF9kZWZpbmVkPyhjb25zdClcbiAgICAgIGNvbnN0X2dldChjb25zdCkubmV3KG93bmVyLCBuYW1lLCBhdHRyaWJ1dGVzKVxuICAgIGVsc2VcbiAgICAgIHN1cGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKG93bmVyLCBuYW1lLCBhdHRyaWJ1dGVzID0ge30pXG4gICAgQG93bmVyICAgICAgID0gb3duZXJcbiAgICBAbmFtZSAgICAgICAgPSBuYW1lXG4gICAgQGF0dHJpYnV0ZXMgID0gYXR0cmlidXRlc1xuICAgIEBjaGlsZHJlbiAgICA9IFtdXG4gICAgQGNsYXNzX25hbWVzID0gW11cbiAgZW5kXG5cbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIEBjaGlsZHJlbi5lYWNoKCZibG9jaylcbiAgZW5kXG5cbiAgZGVmIDw8KHdoYXQpXG4gICAgQGNoaWxkcmVuIDw8IHdoYXRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF9taXNzaW5nKG5hbWUsIGNvbnRlbnQgPSBuaWwsICZibG9jaylcbiAgICBpZiBuYW1lLnRvX3MuZW5kX3dpdGg/ID8hXG4gICAgICBAYXR0cmlidXRlc1s6aWRdID0gbmFtZVswIC4uIC0yXVxuICAgIGVsc2VcbiAgICAgIEBjbGFzc19uYW1lcyA8PCBuYW1lXG4gICAgZW5kXG5cbiAgICBpZiA6Okhhc2ggPT09IGNvbnRlbnRcbiAgICAgIGlmIGNvbnRlbnQuaGFzX2tleT8oOmNsYXNzKSB8fCBjb250ZW50Lmhhc19rZXk/KDpjbGFzc2VzKVxuICAgICAgICBAY2xhc3NfbmFtZXMudW5zaGlmdCgqKGNvbnRlbnQuZGVsZXRlKDpjbGFzcykudG9fcy5zcGxpdCB8IGNvbnRlbnQuZGVsZXRlKDpjbGFzc2VzKS50b19hKSlcbiAgICAgIGVuZFxuXG4gICAgICA6OlBhZ2dpbzo6VXRpbHMuZGVlcF9tZXJnZSEoQGF0dHJpYnV0ZXMsIGNvbnRlbnQpXG4gICAgZWxzaWYgY29udGVudFxuICAgICAgc2VsZiA+PiBjb250ZW50XG4gICAgZW5kXG5cbiAgICBAb3duZXIuZXh0ZW5kIShzZWxmLCAmYmxvY2spIGlmIGJsb2NrXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBbXSgqbmFtZXMpXG4gICAgaWYgbGFzdCA9IEBjbGFzc19uYW1lcy5wb3BcbiAgICAgIEBjbGFzc19uYW1lcyA8PCBbbGFzdCwgKm5hbWVzXS5qb2luKCctJylcbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGRvKCZibG9jaylcbiAgICBAb3duZXIuZXh0ZW5kIShzZWxmLCAmYmxvY2spXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiA+Pihjb250ZW50KVxuICAgIHNlbGYgPDwgOjpQYWdnaW86OlV0aWxzLmhlcmVkb2MoY29udGVudC50b19zKVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmaGVscGVyIDpzdHlsZSBkbyB8aGFzaHxcbiAgICBAYXR0cmlidXRlc1s6c3R5bGVdID0gaGFzaC5tYXAge3xuYW1lLCB2YWx1ZXxcbiAgICAgIFwiI3tuYW1lfTogI3t2YWx1ZX1cIlxuICAgIH0uam9pbignOycpXG4gIGVuZFxuXG4gIGRlZmhlbHBlciA6ZGF0YSBkbyB8aGFzaHxcbiAgICBoYXNoLmVhY2gge3xuYW1lLCB2YWx1ZXxcbiAgICAgIEBhdHRyaWJ1dGVzW1wiZGF0YS0je25hbWV9XCJdID0gdmFsdWUudG9fc1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBpZiBAY2hpbGRyZW4uZW1wdHk/XG4gICAgICBcIiM8SFRNTDo6RWxlbWVudCgje0BuYW1lLnVwY2FzZX0pPlwiXG4gICAgZWxzZVxuICAgICAgXCIjPEhUTUw6OkVsZW1lbnQoI3tAbmFtZS51cGNhc2V9KTogI3tAY2hpbGRyZW4uaW5zcGVjdFsxIC4uIC0yXX0+XCJcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6UGFnZ2lvPiIsIjxjbGFzczpIVE1MPiIsIjxjbGFzczpFbGVtZW50PiIsIm5ldyIsIm93bmVyIiwibmFtZSIsImF0dHJpYnV0ZXMiLCJFbGVtZW50IiwiY29uc3QkIiwiY2FwaXRhbGl6ZSIsInRvX3MiLCJpbmNsdWRlPyIsImNvbnN0X2RlZmluZWQ/IiwiY29uc3RfZ2V0IiwiaW5pdGlhbGl6ZSIsIkBvd25lciIsIkBuYW1lIiwiQGF0dHJpYnV0ZXMiLCJAY2hpbGRyZW4iLCJAY2xhc3NfbmFtZXMiLCJlYWNoIiwiYmxvY2siLCJ0b19wcm9jIiwiPDwiLCJ3aGF0IiwibWV0aG9kX21pc3NpbmciLCJjb250ZW50IiwiZW5kX3dpdGg/IiwiW109IiwiW10iLCIwIiwiLTIiLCJIYXNoIiwiaGFzX2tleT8iLCJ1bnNoaWZ0IiwiZGVsZXRlIiwic3BsaXQiLCJ8IiwidG9fYSIsIlBhZ2dpbzo6VXRpbHMiLCJQYWdnaW8iLCJkZWVwX21lcmdlISIsIj4+IiwiZXh0ZW5kISIsImxhc3QiLCJwb3AiLCJuYW1lcyIsImpvaW4iLCJkbyIsImhlcmVkb2MiLCJkZWZoZWxwZXIiLCJibG9jayBpbiA8Y2xhc3M6RWxlbWVudD4iLCJoYXNoIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8Y2xhc3M6RWxlbWVudD4iLCJtYXAiLCJ2YWx1ZSIsImJsb2NrICgzIGxldmVscykgaW4gPGNsYXNzOkVsZW1lbnQ+IiwiaW5zcGVjdCIsImVtcHR5PyIsInVwY2FzZSIsIjEiLCJCYXNpY09iamVjdCJdLCJtYXBwaW5ncyI6IkFBQUFBLHNDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQVVBQyxJQUFBQyxTQUFBQSxDQUFRRix1QkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsMEJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLGdDQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRiw0QkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsNEJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLDJCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRix5QkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsMkJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLDBCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRiw0QkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsNEJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLDhCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRiw0QkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsd0JBQVJFO0VBRUFGLE9BQUFHO0VBQUFBOztJQUFBQTs7SUFBY0EsT0FBQUM7SUFBQUE7O01BQUFBOztNQUVkQSxPQUFBQztNQUFBQTs7UUFBQUE7O0FBQUFBOztRQUNFQyxNQUFJTCxJQUFKSyxVQUFBQSx3QkFBYUMsS0FBRCxFQUFRQyxJQUFSLEVBQWNDLFVBQTFCSDtBQUFBQSxVQUFBQTs7VUFBQUE7O1VBQTBCLHFDQUFhO1VBQ3JDLEtBQUEsTUFBb0JMLElBQXBCLEVBQTRCUyxhQUE1QixDQUFBO1lBQUEsT0FBTyxPQUFBVCxJQUFBLEVBQUEscURBQUEsT0FBQSxFQUFBLENBQUFNLEtBQUEsRUFBQUMsSUFBQSxFQUFBQyxVQUFBLENBQUEsRUFBQSxNQUFBO1VBQVA7VUFFQUUsU0FBUUgsSUFBSUksWUFBQUEsQ0FBQUE7VUFFWixJQUFHLENBQUEsS0FBQ0QsTUFBS0UsTUFBQUEsQ0FBQUEsQ0FBS0MsYUFBQUEsQ0FBVVIsR0FBVlEsQ0FBWCxDQUFBLElBQUEsQ0FBQSxRQUE2QmIsSUFBQWMsbUJBQUFBLENBQWVKLE1BQWZJLENBQTdCLENBQUEsQ0FBQSxDQUFIO1lBQ0VULE9BQUFMLElBQUFlLFdBQUFBLENBQVVMLE1BQVZLLENBQWdCVixLQUFBQSxDQUFLQyxLQUFyQixFQUE0QkMsSUFBNUIsRUFBa0NDLFVBQWxCSDtVQURsQjtZQUdFQSxPQUFBLE9BQUFMLElBQUEsRUFBQSxxREFBQSxPQUFBLEVBQUEsQ0FBQU0sS0FBQSxFQUFBQyxJQUFBLEVBQUFDLFVBQUEsQ0FBQSxFQUFBLE1BQUE7VUFIRjtRQUxGSCxDQUFBQSxJQUFBQTs7QUFZQVcsUUFBQUEsMEJBQUFBLHNCQUFlVixLQUFELEVBQVFDLElBQVIsRUFBY0MsVUFBNUJRO0FBQUFBLFVBQUFBOzs7VUFBNEIscUNBQWE7VUFDdkNDLGFBQWVYO1VBQ2ZZLFlBQWVYO1VBQ2ZZLGtCQUFlWDtVQUNmWSxnQkFBZTtVQUNmSixPQUFBSyxDQUFBQSxtQkFBZSxFQUFmQTtRQUxGTCxDQUFBQSxJQUFBQTs7QUFRQU0sUUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxVQUFBQTs7VUFBQUE7OztVQUNFQSxPQUFTQSxNQUFURixhQUFTRSxRQUFBQSxFQUFBQSxFQUFBQSxFQUFPQyxLQUFEQyxTQUFBQSxDQUFBQSxDQUFORjtRQURYQSxDQUFBQTs7QUFJQUcsUUFBQUEsa0JBQUFBLDJCQUFPQyxJQUFQRDtBQUFBQSxVQUFBQTs7O1VBQ0VMLGFBQVVLLE9BQUFBLENBQUdDLElBQUhEO1VBRVZBLE9BQUF6QjtRQUhGeUIsQ0FBQUE7O0FBTUFFLFFBQUFBLDhCQUFBQSwwQkFBbUJwQixJQUFELEVBQU9xQixPQUF6QkQ7QUFBQUEsVUFBQUE7O1VBQUFBOzs7VUFBeUIsK0JBQVU7VUFDakMsSUFBQSxRQUFHcEIsSUFBSUssTUFBQUEsQ0FBQUEsQ0FBS2lCLGNBQUFBLENBQVdGLEdBQVhFLENBQVosQ0FBQTtZQUNFVixlQUFXVyxRQUFBQSxDQUFDLElBQVosRUFBbUJ2QixJQUFJd0IsT0FBQUEsQ0FBQyxPQUFBQyxDQUFBLEVBQUtDLEVBQUwsUUFBREYsQ0FBWkQ7VUFEYjtZQUdFVCxnQkFBYUksT0FBQUEsQ0FBR2xCLElBQUhrQjtVQUhmO1VBTUEsSUFBQSxRQUFHUyxXQUFILEVBQWNOLE9BQWQsQ0FBQTs7WUFDRSxJQUFHLENBQUEsUUFBQUEsT0FBT08sYUFBQUEsQ0FBVSxPQUFWQSxDQUFQLENBQUEsSUFBQSxDQUFBLFFBQTRCUCxPQUFPTyxhQUFBQSxDQUFVLFNBQVZBLENBQW5DLENBQUEsQ0FBQSxDQUFIO2NBQ2NDLE1BQVpmLGdCQUFZZSxXQUFBQSxFQUFTLE1BQUVSLE9BQU9TLFFBQUFBLENBQVEsT0FBUkEsQ0FBZXpCLE1BQUFBLENBQUFBLENBQUswQixPQUFBQSxDQUFBQSxDQUFPQyxNQUFBQSxDQUFFWCxPQUFPUyxRQUFBQSxDQUFRLFNBQVJBLENBQWlCRyxNQUFBQSxDQUFBQSxDQUExQkQsQ0FBcEMsQ0FBVEg7WUFEZDtZQUlBSyxJQUFBQyxhQUFBRCxVQUFlRSxnQkFBQUEsQ0FBYXhCLGVBQTVCLEVBQXlDUyxPQUExQmU7VUFMakIsT0FNQSxJQUFBLFFBQU1mLE9BQU4sQ0FBQTtZQUNFNUIsSUFBSzRDLE9BQUFBLENBQUdoQixPQUFIZ0I7VUFEUDtVQUlBLElBQUEsUUFBZ0NyQixLQUFoQyxDQUFBO1lBQU1zQixNQUFONUIsVUFBTTRCLFdBQUFBLEVBQUFBLENBQVM3QyxJQUFUNkMsQ0FBQUEsRUFBZ0J0QixLQUFEQyxTQUFBQSxDQUFBQSxDQUFmcUI7VUFBTjtVQUVBbEIsT0FBQTNCO1FBbkJGMkIsQ0FBQUEsSUFBQUE7O0FBc0JBSSxRQUFBQSxrQkFBQUEsdUJBaEZGLEVBZ0ZFQTtBQUFBQSxVQUFBQTs7O1VBaEZGO1VBZ0ZTO1VBQ0wsSUFBQSxRQUFHZSxDQUFBQSxPQUFPekIsZ0JBQVkwQixLQUFBQSxDQUFBQSxDQUFuQkQsQ0FBSCxDQUFBO1lBQ0V6QixnQkFBYUksT0FBQUEsQ0FBRyxDQUFDcUIsSUFBRCxDQUFBLFFBQU8sTUFBQ0UsS0FBRCxDQUFQLENBQWNDLE1BQUFBLENBQU1sQixHQUFOa0IsQ0FBakJ4QjtVQURmO1VBSUFNLE9BQUEvQjtRQUxGK0IsQ0FBQUEsSUFBQUE7O0FBUUFtQixRQUFBQSxrQkFBQUEsdUJBQUFBO0FBQUFBLFVBQUFBOztVQUFBQTs7O1VBQ1FMLE1BQU41QixVQUFNNEIsV0FBQUEsRUFBQUEsQ0FBUzdDLElBQVQ2QyxDQUFBQSxFQUFnQnRCLEtBQURDLFNBQUFBLENBQUFBLENBQWZxQjtVQUVOSyxPQUFBbEQ7UUFIRmtELENBQUFBOztBQU1BTixRQUFBQSxrQkFBQUEsMkJBQU9oQixPQUFQZ0I7QUFBQUEsVUFBQUE7OztVQUNFNUMsSUFBS3lCLE9BQUFBLENBQUdnQixJQUFBQyxhQUFBRCxVQUFlVSxTQUFBQSxDQUFTdkIsT0FBT2hCLE1BQUFBLENBQUFBLENBQWhCdUMsQ0FBbEIxQjtVQUNMbUIsT0FBQTVDO1FBRkY0QyxDQUFBQTtRQUtBUSxNQUFBcEQsSUFBQW9ELGFBQUFBLEVBQUFBLENBQVUsT0FBVkEsQ0FBQUEsRUFBQUMsb0JBQXFCQyxJQUFyQkQsRUFBQUU7QUFBQUE7OztVQUFxQjtVQUNuQkEsT0FBV3pCLE1BQUFBLENBQUMsT0FBWixFQUEwQjBCLE1BQUpGLElBQUlFLE9BQUFBLEVBQUFBLEVBQUFBLEVBQUpELGFBQVdoRCxJQUFELEVBQU9rRCxLQUFqQkY7O1lBQVc7WUFBTTtZQUNyQ0csT0FBQSxFQUFBLEdBQUEsQ0FBR25ELElBQUgsQ0FBQSxHQUFRbUQsSUFBUixHQUFBLENBQVlELEtBQVosRUFEb0JGLENBQUlDLENBRXpCUCxNQUFBQSxDQUFNTSxHQUFOTixDQUZVbkIsQ0FBQUEsRUFBQUEsTUFBWFgsZUFBV1csT0FBQUEsRUFBQUEsRUFBQUEsQ0FBQUEsRUFBQUEsbUJBRGJ1QixDQUFBQSxHQUFBQSxTQUFBQSxDQUFBRDtRQU1BQSxNQUFBcEQsSUFBQW9ELGFBQUFBLEVBQUFBLENBQVUsTUFBVkEsQ0FBQUEsRUFBQUMsb0JBQW9CQyxJQUFwQkQsRUFBQUU7OztVQUFvQjtVQUNsQkEsT0FBSWpDLE1BQUpnQyxJQUFJaEMsUUFBQUEsRUFBQUEsRUFBQUEsRUFBSmlDLGFBQVloRCxJQUFELEVBQU9rRCxLQUFsQkYsRUFBQUc7QUFBQUE7OztZQUFZO1lBQU07WUFDaEJBLE9BQVc1QixNQUFBQSxDQUFFNEIsT0FBRCxHQUFBLENBQVFuRCxJQUFSLENBQVosRUFBOEJrRCxLQUFLN0MsTUFBQUEsQ0FBQUEsQ0FBeEJrQixDQUFBQSxFQUFBQSxNQUFYWCxlQUFXVyxPQUFBQSxFQUFBQSxFQUFBQSxDQUFBQSxFQUFBQSxtQkFEYnlCLENBQUFBLEdBQUFBLFNBQUFBLENBQUlqQyxFQUROK0IsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBQUQ7UUFNQWhELE9BQUF1RCx1QkFBQUEsbUJBQUFBO0FBQUFBLFVBQUFBOztVQUNFLElBQUEsUUFBR3ZDLGFBQVN3QyxXQUFBQSxDQUFBQSxDQUFaLENBQUE7WUFDRUQsT0FBQ0Esa0JBQUQsR0FBQSxDQUFtQnpDLFNBQUsyQyxRQUFBQSxDQUFBQSxDQUF4QixDQUFBLEdBQWdDRjtVQURsQztZQUdFQSxPQUFDQSxrQkFBRCxHQUFBLENBQW1CekMsU0FBSzJDLFFBQUFBLENBQUFBLENBQXhCLENBQUEsR0FBZ0NGLEtBQWhDLEdBQUEsQ0FBcUN2QyxhQUFTdUMsU0FBQUEsQ0FBQUEsQ0FBUTVCLE9BQUFBLENBQUMsT0FBQStCLENBQUEsRUFBSzdCLEVBQUwsUUFBREYsQ0FBdEQsQ0FBQSxHQUFnRTRCO1VBSGxFO1FBREZBLENBQUFBO01BcEZGdkQsR0FBQUEsV0FBQUEsRUFBZ0IyRCxpQkFBaEIzRDtJQUZjRCxHQUFBQSxXQUFBQSxFQUFhNEQsaUJBQWI1RDtFQUFkRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQXpCQUg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI3NjU0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGFnZ2lvL2h0bWwucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIy0tXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgICAgICAgICAgICAgICAgICAgVmVyc2lvbiAyLCBEZWNlbWJlciAyMDA0XG4jXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBDT1BZSU5HLCBESVNUUklCVVRJT04gQU5EIE1PRElGSUNBVElPTlxuI1xuIyAgMC4gWW91IGp1c3QgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTy5cbiMrK1xuXG5yZXF1aXJlICdwYWdnaW8vaHRtbC9oZWxwZXJzJ1xucmVxdWlyZSAncGFnZ2lvL2h0bWwvZWxlbWVudCdcblxuY2xhc3MgUGFnZ2lvXG5cbmNsYXNzIEhUTUwgPCBCYXNpY09iamVjdFxuICBhdHRyX3JlYWRlciA6dmVyc2lvblxuXG4gIGRlZiBpbml0aWFsaXplKHZlcnNpb24gPSA1LCBkZWZlcjogZmFsc2UsICZibG9jaylcbiAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICBAdmVyc2lvbiA9IHZlcnNpb25cbiAgICBAcm9vdHMgICA9IFtdXG4gICAgQGN1cnJlbnQgPSBuaWxcblxuICAgIEBibG9jayA9IGJsb2NrXG5cbiAgICBidWlsZCEgdW5sZXNzIGRlZmVyXG4gIGVuZFxuXG4gIGRlZiA8PCh3aGF0KVxuICAgIChAY3VycmVudCB8fCBAcm9vdHMpIDw8IHdoYXRcbiAgZW5kXG5cbiAgZGVmIGJ1aWxkIShmb3JjZV9jYWxsOiBmYWxzZSlcbiAgICBpZiAhZm9yY2VfY2FsbCAmJiBAYmxvY2suYXJpdHkgPT0gMFxuICAgICAgaW5zdGFuY2VfZXhlYygmQGJsb2NrKVxuICAgIGVsc2VcbiAgICAgIEBibG9jay5jYWxsKHNlbGYpXG4gICAgZW5kXG4gICAgQGJsb2NrID0gbmlsXG4gIGVuZFxuXG4gIGRlZiByb290IVxuICAgIEByb290cy5maXJzdFxuICBlbmRcblxuICBkZWYgcm9vdHMhXG4gICAgQHJvb3RzXG4gIGVuZFxuXG4gIGRlZiBlbGVtZW50IVxuICAgIEBjdXJyZW50XG4gIGVuZFxuXG4gIGRlZiBleHRlbmQhKGVsZW1lbnQgPSBuaWwsICZibG9jaylcbiAgICBvbGQsIEBjdXJyZW50ID0gQGN1cnJlbnQsIGVsZW1lbnRcblxuICAgIHJlc3VsdCA9IGJsb2NrLmNhbGwoc2VsZilcblxuICAgIGlmIDo6U3RyaW5nID09PSByZXN1bHRcbiAgICAgIEBjdXJyZW50Lmluc3RhbmNlX2V2YWwgeyBAaW5uZXJfaHRtbCA9IHJlc3VsdCB9XG4gICAgZW5kXG5cbiAgICBAY3VycmVudCA9IG9sZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZWFjaCgmYmxvY2spXG4gICAgQHJvb3RzLmVhY2goJmJsb2NrKVxuICBlbmRcblxuICBkZWYgdGV4dCgqZnJhZ21lbnRzLCAmYmxvY2spXG4gICAgZnJhZ21lbnRzIDw8IHlpZWxkIGlmIGJsb2NrXG4gICAgZnJhZ21lbnRzLmVhY2ggeyB8ZnJhZ21lbnR8IHNlbGYgPDwgZnJhZ21lbnQgfVxuICBlbmRcblxuICBkZWYgbWV0aG9kX21pc3NpbmcobmFtZSwgKmFyZ3MsICZibG9jaylcbiAgICBpZiBuYW1lLnRvX3MuZW5kX3dpdGg/ID8hXG4gICAgICByZXR1cm4gc3VwZXJcbiAgICBlbmRcblxuICAgIHVubGVzcyBhcmdzLmVtcHR5PyB8fCA6Okhhc2ggPT09IGFyZ3MuZmlyc3RcbiAgICAgIGNvbnRlbnQgPSA6OlBhZ2dpbzo6VXRpbHMuaGVyZWRvYyhhcmdzLnNoaWZ0LnRvX3MpXG4gICAgZW5kXG5cbiAgICBlbGVtZW50ID0gRWxlbWVudC5uZXcoc2VsZiwgbmFtZSwgKmFyZ3MpXG4gICAgZWxlbWVudCA8PCBjb250ZW50IGlmIGNvbnRlbnRcblxuICAgIGlmIGJsb2NrXG4gICAgICBwYXJlbnQgICA9IEBjdXJyZW50XG4gICAgICBAY3VycmVudCA9IGVsZW1lbnRcbiAgICAgIHJlc3VsdCAgID0gYmxvY2suY2FsbChzZWxmKVxuICAgICAgQGN1cnJlbnQgPSBwYXJlbnRcblxuICAgICAgaWYgOjpTdHJpbmcgPT09IHJlc3VsdFxuICAgICAgICBlbGVtZW50Lmluc3RhbmNlX2V2YWwgeyBAaW5uZXJfaHRtbCA9IHJlc3VsdCB9XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIHNlbGYgPDwgZWxlbWVudFxuXG4gICAgZWxlbWVudFxuICBlbmRcblxuICAjIFN1cHBvcnQgZm9yIGN1c3RvbSBlbGVtZW50c1xuICBhbGlhcyBlIG1ldGhvZF9taXNzaW5nXG5cbiAgZGVmIGluc3BlY3RcbiAgICBpZiBAcm9vdHMuZW1wdHk/XG4gICAgICBcIiM8SFRNTCgjQHZlcnNpb24pPlwiXG4gICAgZWxzZVxuICAgICAgXCIjPEhUTUwoI0B2ZXJzaW9uKTogI3tAcm9vdHMuaW5zcGVjdFsxIC4uIC0yXX0+XCJcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOlBhZ2dpbz4iLCI8Y2xhc3M6SFRNTD4iLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCI1IiwiYmxvY2siLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJAdmVyc2lvbiIsInZlcnNpb24iLCJAcm9vdHMiLCJAY3VycmVudCIsIkBibG9jayIsImRlZmVyIiwiYnVpbGQhIiwiPDwiLCJ3aGF0IiwiJHJldF9vcl8xIiwiJGt3YXJncyIsImZvcmNlX2NhbGwiLCJhcml0eSIsIjAiLCJpbnN0YW5jZV9leGVjIiwidG9fcHJvYyIsImNhbGwiLCJyb290ISIsImZpcnN0Iiwicm9vdHMhIiwiZWxlbWVudCEiLCJleHRlbmQhIiwiZWxlbWVudCIsIm9sZCIsInJlc3VsdCIsIlN0cmluZyIsImluc3RhbmNlX2V2YWwiLCJibG9jayBpbiBleHRlbmQhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBleHRlbmQhIiwiQGlubmVyX2h0bWwiLCJlYWNoIiwidGV4dCIsImZyYWdtZW50cyIsImJsb2NrIGluIHRleHQiLCJmcmFnbWVudCIsImJsb2NrICgyIGxldmVscykgaW4gdGV4dCIsIm1ldGhvZF9taXNzaW5nIiwibmFtZSIsInRvX3MiLCJlbmRfd2l0aD8iLCJhcmdzIiwiZW1wdHk/IiwiSGFzaCIsImNvbnRlbnQiLCJQYWdnaW86OlV0aWxzIiwiUGFnZ2lvIiwiaGVyZWRvYyIsInNoaWZ0IiwibmV3IiwiRWxlbWVudCIsInBhcmVudCIsImJsb2NrIGluIG1ldGhvZF9taXNzaW5nIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBtZXRob2RfbWlzc2luZyIsImluc3BlY3QiLCJbXSIsIjEiLCItMiIsIkJhc2ljT2JqZWN0Il0sIm1hcHBpbmdzIjoiQUFBQUEsOEJBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBVUFDLElBQUFDLFNBQUFBLENBQVFGLHFCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixxQkFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOztJQUVBQSxPQUFBQztJQUFBQTs7TUFBQUE7O0FBQUFBOztNQUNFSCxJQUFBSSxhQUFBQSxDQUFZLFNBQVpBOztBQUVBQyxNQUFBQSwwQkFBQUEsc0JBbEJGLEVBa0JnQixFQWxCaEIsRUFrQkVBO0FBQUFBLFFBQUFBOztRQUFBQTs7O1FBbEJGO1FBQUE7UUFBQTs7UUFrQmlCLHdEQUFBLCtCQUFVQzs7UUFBRyxvQ0FBQSwyQkFBTztRQUNqQyxLQUFBLFFBQXdEQyxLQUF4RCxDQUFBO1VBQUFDLE9BQVFDLE9BQUFBLENBQU9DLG9CQUFmLEVBQWdDTCxnQkFBeEJJO1FBQVI7UUFFQUUsZUFBV0M7UUFDWEMsYUFBVztRQUNYQyxlQUFXO1FBRVhDLGFBQVNSO1FBRVQsSUFBQSxRQUFjUyxLQUFkLENBQUE7VUEzQkpYLE9BQUE7UUEyQkk7VUFBQUEsT0FBQUwsSUFBQWlCLFdBQUFBLENBQUFBO1FBQUE7TUFURlosQ0FBQUEsSUFBQUE7O0FBWUFhLE1BQUFBLGtCQUFBQSx3QkFBT0MsSUFBUEQ7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUMsQ0FBQSxRQUFBRSxDQUFBQSxZQUFBTixZQUFBTSxDQUFBLENBQUEsR0FBQSxDQUFBLFNBQUEsSUFBQSxDQUFZUCxVQUFaLENBQUEsQ0FBb0JLLE9BQUFBLENBQUdDLElBQUhEO01BRHZCQSxDQUFBQTs7QUFJQUQsTUFBQUEsc0JBQUFBLDRCQWxDRkksT0FrQ0VKO0FBQUFBLFFBQUFBOzs7UUFsQ0Y7O1FBa0NhLDhDQUFBLHFDQUFZO1FBQ3JCLElBQUcsQ0FBQSxLQUFDSyxVQUFELENBQUEsSUFBQSxDQUFBLE1BQWVQLFVBQU1RLE9BQUFBLENBQUFBLENBQXJCLEVBQStCQyxDQUEvQixDQUFBLENBQUEsQ0FBSDtVQUNFQyxNQUFBekIsSUFBQXlCLGlCQUFBQSxFQUFBQSxFQUFBQSxFQUFlVixVQUFEVyxTQUFBQSxDQUFBQSxDQUFkRDtRQURGO1VBR0VWLFVBQU1ZLE1BQUFBLENBQU0zQixJQUFOMkI7UUFIUjtRQUtBVixPQUFBRixDQUFBQSxhQUFTLEdBQVRBO01BTkZFLENBQUFBLElBQUFBOztBQVNBVyxNQUFBQSxxQkFBQUEsMkJBQUFBO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFBZixVQUFNZ0IsT0FBQUEsQ0FBQUE7TUFEUkQsQ0FBQUE7O0FBSUFFLE1BQUFBLHNCQUFBQSxhQUNFLE9BREZBLENBQUFBOztBQUlBQyxNQUFBQSx3QkFBQUEsYUFDRSxTQURGQSxDQUFBQTs7QUFJQUMsTUFBQUEsdUJBQUFBLDZCQUFZQyxPQUFaRDtBQUFBQSxRQUFBQTs7UUFBQUE7OztRQUFZLCtCQUFVO1FBQ3BCLEtBQWdCLENBQUFsQixZQUFBLEVBQVVtQixPQUFWLENBQWhCLEVBQUFDLENBQUFBLE1BQUEsS0FBQUEsQ0FBQSxFQUFLcEIsQ0FBQUEsZUFBTCxLQUFLQSxDQUFMO1FBRUFxQixTQUFTNUIsS0FBS29CLE1BQUFBLENBQU0zQixJQUFOMkI7UUFFZCxJQUFBLFFBQUdTLGFBQUgsRUFBZ0JELE1BQWhCLENBQUE7VUFDVUUsTUFBUnZCLFlBQVF1QixpQkFBQUEsRUFBQUEsRUFBQUEsRUFBUkMsYUFBQUEsRUFBQUM7O1lBQXlCQSxPQUFBQyxDQUFBQSxrQkFBY0wsTUFBZEssQ0FBekJGLENBQUFBLEdBQUFBLFNBQUFBLENBQVFEO1FBRFY7UUFJQXZCLGVBQVdvQjtRQUVYRixPQUFBaEM7TUFYRmdDLENBQUFBLElBQUFBOztBQWNBUyxNQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLFFBQUFBOztRQUFBQTs7O1FBQ0VBLE9BQU1BLE1BQU41QixVQUFNNEIsUUFBQUEsRUFBQUEsRUFBQUEsRUFBT2xDLEtBQURtQixTQUFBQSxDQUFBQSxDQUFOZTtNQURSQSxDQUFBQTs7QUFJQUMsTUFBQUEsb0JBQUFBLGdCQXpFRixFQXlFRUE7QUFBQUEsUUFBQUE7O1FBQUFBOzs7UUF6RUY7UUF5RVc7UUFDUCxJQUFBLFFBQXNCbkMsS0FBdEIsQ0FBQTtVQUFBb0MsU0FBVXpCLE9BQUFBLENBQUcsb0JBQUEsRUFBSEE7UUFBVjtRQUNBd0IsT0FBU0QsTUFBVEUsU0FBU0YsUUFBQUEsRUFBQUEsRUFBQUEsRUFBVEcsYUFBa0JDLFFBQWxCRCxFQUFBRTs7O1VBQWtCO1VBQVVBLE9BQUE5QyxJQUFLa0IsT0FBQUEsQ0FBRzJCLFFBQUgzQixFQUFqQzBCLENBQUFBLEdBQUFBLFNBQUFBLENBQVNIO01BRlhDLENBQUFBLElBQUFBOztBQUtBSyxNQUFBQSw4QkFBQUEsMEJBQW1CQyxJQUFELEVBOUVwQixFQThFRUQ7QUFBQUEsUUFBQUE7O1FBQUFBOzs7UUE5RUY7UUE4RTJCO1FBQ3ZCLElBQUEsUUFBR0MsSUFBSUMsTUFBQUEsQ0FBQUEsQ0FBS0MsY0FBQUEsQ0FBV0gsR0FBWEcsQ0FBWixDQUFBO1VBQ0UsT0FBTyxPQUFBbEQsSUFBQSxFQUFBLGtFQUFBLGtCQUFBLEVBQUEsQ0FBQWdELElBQUEsQ0FBQSxRQUFBLE1BQUFHLElBQUEsQ0FBQSxDQUFBLEVBQUEsS0FBQTtRQURUO1FBSUEsS0FBTyxDQUFBLFFBQUFBLElBQUlDLFdBQUFBLENBQUFBLENBQUosQ0FBQSxJQUFBLENBQUEsUUFBZUMsV0FBZixFQUEwQkYsSUFBSXRCLE9BQUFBLENBQUFBLENBQTlCLENBQUEsQ0FBQSxDQUFQO1VBQ0V5QixVQUFVQyxJQUFBQyxhQUFBRCxVQUFlRSxTQUFBQSxDQUFTTixJQUFJTyxPQUFBQSxDQUFBQSxDQUFNVCxNQUFBQSxDQUFBQSxDQUFuQlE7UUFEM0I7UUFJQXhCLFVBQWlCMEIsTUFBUEMsYUFBT0QsT0FBQUEsRUFBUCxDQUFZM0QsSUFBWixFQUFrQmdELElBQWxCLENBQUEsUUFBd0IsTUFBQ0csSUFBRCxDQUF4QixDQUFPUTtRQUNqQixJQUFBLFFBQXNCTCxPQUF0QixDQUFBO1VBQUFyQixPQUFRZixPQUFBQSxDQUFHb0MsT0FBSHBDO1FBQVI7UUFFQSxJQUFBLFFBQUdYLEtBQUgsQ0FBQTs7VUFDRXNELFNBQVcvQztVQUNYQSxlQUFXbUI7VUFDWEUsU0FBVzVCLEtBQUtvQixNQUFBQSxDQUFNM0IsSUFBTjJCO1VBQ2hCYixlQUFXK0M7VUFFWCxJQUFBLFFBQUd6QixhQUFILEVBQWdCRCxNQUFoQixDQUFBO1lBQ1NFLE1BQVBKLE9BQU9JLGlCQUFBQSxFQUFBQSxFQUFBQSxFQUFQeUIsYUFBQUEsRUFBQUM7O2NBQXdCQSxPQUFBdkIsQ0FBQUEsa0JBQWNMLE1BQWRLLENBQXhCc0IsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBT3pCO1VBRFQ7UUFORjtRQVdBckMsSUFBS2tCLE9BQUFBLENBQUdlLE9BQUhmO1FBRUw2QixPQUFBZDtNQXpCRmMsQ0FBQUEsSUFBQUE7TUE2QkEsYUFBTSxHQUFOLEVBQVEsZ0JBQVI7TUFFQTVDLE9BQUE2RCx1QkFBQUEsbUJBQUFBO0FBQUFBLFFBQUFBOztRQUNFLElBQUEsUUFBR25ELFVBQU11QyxXQUFBQSxDQUFBQSxDQUFULENBQUE7VUFDRVksT0FBQ0EsU0FBRCxHQUFBLENBQVNyRCxZQUFULENBQUEsR0FBaUJxRDtRQURuQjtVQUdFQSxPQUFDQSxTQUFELEdBQUEsQ0FBU3JELFlBQVQsQ0FBQSxHQUFpQnFELEtBQWpCLEdBQUEsQ0FBc0JuRCxVQUFNbUQsU0FBQUEsQ0FBQUEsQ0FBUUMsT0FBQUEsQ0FBQyxPQUFBQyxDQUFBLEVBQUtDLEVBQUwsUUFBREYsQ0FBcEMsQ0FBQSxHQUE4Q0Q7UUFIaEQ7TUFERkEsQ0FBQUE7SUE5RkY3RCxHQUFBQSxXQUFBQSxFQUFhaUUsaUJBQWJqRTtFQUZBRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQWJBSDsifX0seyJvZmZzZXQiOnsibGluZSI6Mjc4MjUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwYWdnaW8vY3NzL3VuaXQucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIy0tXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgICAgICAgICAgICAgICAgICAgVmVyc2lvbiAyLCBEZWNlbWJlciAyMDA0XG4jXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBDT1BZSU5HLCBESVNUUklCVVRJT04gQU5EIE1PRElGSUNBVElPTlxuI1xuIyAgMC4gWW91IGp1c3QgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTy5cbiMrK1xuXG5jbGFzcyBQYWdnaW87IGNsYXNzIENTUyA8IEJhc2ljT2JqZWN0XG5cbmNsYXNzIFVuaXRcbiAgVFlQRVMgICAgICA9ICV3W2VtIGV4IGNoIHJlbSB2aCB2dyB2bWluIHZtYXggcHggbW0gY20gaW4gcHQgcGMgcyBkZWddLm1hcCgmOnRvX3N5bSlcbiAgQ09NUEFUSUJMRSA9ICV3W2luIHB0IG1tIGNtIHB4IHBjXS5tYXAoJjp0b19zeW0pXG5cbiAgYXR0cl9yZWFkZXIgOnR5cGUsIDpudW1iZXJcblxuICBkZWYgaW5pdGlhbGl6ZShudW1iZXIsIHR5cGUpXG4gICAgQG51bWJlciA9IG51bWJlclxuICAgIEB0eXBlICAgPSB0eXBlXG4gIGVuZFxuXG4gIGRlZiBjb2VyY2Uob3RoZXIpXG4gICAgcmV0dXJuIHNlbGYsIG90aGVyXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICB1bmxlc3MgVW5pdCA9PT0gb3RoZXJcbiAgICAgIHVubGVzcyBvdGhlci5yZXNwb25kX3RvPyA6dG9fdVxuICAgICAgICByYWlzZSBUeXBlRXJyb3IsIFwibm8gaW1wbGljaXQgY29udmVyc2lvbiBvZiAje290aGVyLmNsYXNzfSBpbnRvIFVuaXRcIlxuICAgICAgZW5kXG5cbiAgICAgIG90aGVyID0gb3RoZXIudG9fdVxuICAgIGVuZFxuXG4gICAgdW5sZXNzIFVuaXQgPT09IG90aGVyXG4gICAgICBvdGhlciA9IFVuaXQubmV3KG90aGVyLCBAdHlwZSlcbiAgICBlbmRcblxuICAgIEBudW1iZXIgPT0gY29udmVydChvdGhlciwgQHR5cGUpXG4gIGVuZFxuXG4gIGRlZiA9PT0ob3RoZXIpXG4gICAgQHR5cGUgPT0gb3RoZXIudHlwZSAmJiBAbnVtYmVyID09IG90aGVyLm51bWJlclxuICBlbmRcblxuICBhbGlhcyBlcWw/ID09XG5cbiAgZGVmIGhhc2hcbiAgICBbQG51bWJlciwgQHR5cGVdLmhhc2hcbiAgZW5kXG5cbiAgVFlQRVMuZWFjaCB7fG5hbWV8XG4gICAgZGVmaW5lX21ldGhvZCBuYW1lIGRvXG4gICAgICBVbml0Lm5ldyhjb252ZXJ0KHNlbGYsIG5hbWUpLCBuYW1lKVxuICAgIGVuZFxuICB9XG5cbiAgZGVmICsob3RoZXIpXG4gICAgcmV0dXJuIFVuaXQubmV3KEBudW1iZXIgKyBvdGhlciwgQHR5cGUpIHVubGVzcyBVbml0ID09PSBvdGhlclxuXG4gICAgaWYgQHR5cGUgPT0gb3RoZXIudHlwZVxuICAgICAgVW5pdC5uZXcoQG51bWJlciArIG90aGVyLm51bWJlciwgQHR5cGUpXG4gICAgZWxzaWYgY29tcGF0aWJsZT8oc2VsZikgYW5kIGNvbXBhdGlibGU/KG90aGVyKVxuICAgICAgVW5pdC5uZXcoQG51bWJlciArIGNvbnZlcnQob3RoZXIsIEB0eXBlKSwgQHR5cGUpXG4gICAgZWxzZVxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCIje290aGVyLnR5cGV9IGlzbid0IGNvbXBhdGlibGUgd2l0aCAje0B0eXBlfVwiXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAtKG90aGVyKVxuICAgIHJldHVybiBVbml0Lm5ldyhAbnVtYmVyIC0gb3RoZXIsIEB0eXBlKSB1bmxlc3MgVW5pdCA9PT0gb3RoZXJcblxuICAgIGlmIEB0eXBlID09IG90aGVyLnR5cGVcbiAgICAgIFVuaXQubmV3KEBudW1iZXIgLSBvdGhlci5udW1iZXIsIEB0eXBlKVxuICAgIGVsc2lmIGNvbXBhdGlibGU/KHNlbGYpIGFuZCBjb21wYXRpYmxlPyhvdGhlcilcbiAgICAgIFVuaXQubmV3KEBudW1iZXIgLSBjb252ZXJ0KG90aGVyLCBAdHlwZSksIEB0eXBlKVxuICAgIGVsc2VcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwiI3tvdGhlci50eXBlfSBpc24ndCBjb21wYXRpYmxlIHdpdGggI3tAdHlwZX1cIlxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgKihvdGhlcilcbiAgICByZXR1cm4gVW5pdC5uZXcoQG51bWJlciAqIG90aGVyLCBAdHlwZSkgdW5sZXNzIFVuaXQgPT09IG90aGVyXG5cbiAgICBpZiBAdHlwZSA9PSBvdGhlci50eXBlXG4gICAgICBVbml0Lm5ldyhAbnVtYmVyICogb3RoZXIubnVtYmVyLCBAdHlwZSlcbiAgICBlbHNpZiBjb21wYXRpYmxlPyhzZWxmKSBhbmQgY29tcGF0aWJsZT8ob3RoZXIpXG4gICAgICBVbml0Lm5ldyhAbnVtYmVyICogY29udmVydChvdGhlciwgQHR5cGUpLCBAdHlwZSlcbiAgICBlbHNlXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcIiN7b3RoZXIudHlwZX0gaXNuJ3QgY29tcGF0aWJsZSB3aXRoICN7QHR5cGV9XCJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIC8ob3RoZXIpXG4gICAgcmV0dXJuIFVuaXQubmV3KEBudW1iZXIgLyBvdGhlciwgQHR5cGUpIHVubGVzcyBVbml0ID09PSBvdGhlclxuXG4gICAgaWYgQHR5cGUgPT0gb3RoZXIudHlwZVxuICAgICAgVW5pdC5uZXcoQG51bWJlciAvIG90aGVyLm51bWJlciwgQHR5cGUpXG4gICAgZWxzaWYgY29tcGF0aWJsZT8oc2VsZikgYW5kIGNvbXBhdGlibGU/KG90aGVyKVxuICAgICAgVW5pdC5uZXcoQG51bWJlciAvIGNvbnZlcnQob3RoZXIsIEB0eXBlKSwgQHR5cGUpXG4gICAgZWxzZVxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCIje290aGVyLnR5cGV9IGlzbid0IGNvbXBhdGlibGUgd2l0aCAje0B0eXBlfVwiXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAtQFxuICAgIFVuaXQubmV3KEBudW1iZXIgKiAtMSwgQHR5cGUpXG4gIGVuZFxuXG4gIGRlZiArQFxuICAgIFVuaXQubmV3KEBudW1iZXIsIEB0eXBlKVxuICBlbmRcblxuICBkZWYgdG9faVxuICAgIEBudW1iZXIudG9faVxuICBlbmRcblxuICBkZWYgdG9fZlxuICAgIEBudW1iZXIudG9fZlxuICBlbmRcblxuICBkZWYgdG9fdVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBcIiNAbnVtYmVyI0B0eXBlXCJcbiAgZW5kXG5cbiAgYWxpYXMgdG9fc3RyIHRvX3NcbiAgYWxpYXMgaW5zcGVjdCB0b19zXG5cbnByaXZhdGVcbiAgZGVmIGNvbXBhdGlibGU/KHVuaXQpXG4gICAgQ09NUEFUSUJMRS5pbmNsdWRlPyh1bml0LnR5cGUpXG4gIGVuZFxuXG4gIGRlZiBjb252ZXJ0KHVuaXQsIHR5cGUpXG4gICAgdmFsdWUgPSB1bml0Lm51bWJlclxuXG4gICAgcmV0dXJuIHZhbHVlIGlmIHVuaXQudHlwZSA9PSB0eXBlXG5cbiAgICBweCA9IGNhc2UgdW5pdC50eXBlXG4gICAgd2hlbiA6aW4gdGhlbiB2YWx1ZSAqIDk2XG4gICAgd2hlbiA6cHQgdGhlbiB2YWx1ZSAqIDQuMCAvIDMuMFxuICAgIHdoZW4gOnBjIHRoZW4gdmFsdWUgLyAxMiAqIDQuMCAvIDMuMFxuICAgIHdoZW4gOm1tIHRoZW4gdmFsdWUgKiAzLjc3OTUzXG4gICAgd2hlbiA6Y20gdGhlbiB2YWx1ZSAqIDEwICogMy43Nzk1M1xuICAgIHdoZW4gOnB4IHRoZW4gdmFsdWVcbiAgICBlbmRcblxuICAgIGNhc2UgdHlwZVxuICAgIHdoZW4gOmluIHRoZW4gcHggLyA5Ni4wXG4gICAgd2hlbiA6cHQgdGhlbiBweCAvIDQuMCAvIDMuMFxuICAgIHdoZW4gOnBjIHRoZW4gcHggKiAxMiAvIDQuMCAvIDMuMFxuICAgIHdoZW4gOm1tIHRoZW4gcHggLyAzLjc3OTUzXG4gICAgd2hlbiA6Y20gdGhlbiBweCAvIDEwIC8gMy43Nzk1M1xuICAgIHdoZW4gOnB4IHRoZW4gcHhcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcblxuY2xhc3MgTnVtZXJpY1xuICBQYWdnaW86OkNTUzo6VW5pdDo6VFlQRVMuZWFjaCB7fG5hbWV8XG4gICAgZGVmaW5lX21ldGhvZCBuYW1lIGRvXG4gICAgICBQYWdnaW86OkNTUzo6VW5pdC5uZXcoc2VsZiwgbmFtZSlcbiAgICBlbmRcbiAgfVxuXG4gIGRlZiB0b191XG4gICAgc2VsZlxuICBlbmRcbmVuZFxuXG5bRml4bnVtLCBGbG9hdF0uZWFjaCB7fGtsYXNzfFxuICBrbGFzcy5jbGFzc19ldmFsIHtcbiAgICBhbGlhcyBvbGRfcGVyY2VudCAlXG5cbiAgICBkZWYgJShvdGhlciA9IG5pbClcbiAgICAgIGlmIG90aGVyXG4gICAgICAgIG9sZF9wZXJjZW50KG90aGVyKVxuICAgICAgZWxzZVxuICAgICAgICBQYWdnaW86OkNTUzo6VW5pdC5uZXcoc2VsZiwgOiUpXG4gICAgICBlbmRcbiAgICBlbmRcbiAgfVxufVxuXG5jbGFzcyBTdHJpbmdcbiAgZGVmIHRvX3VcbiAgICBpZiBtYXRjaGVzID0gbWF0Y2goL14oW1xcZCsuXSspKC4rKT8kLylcbiAgICAgIHZhbHVlID0gbWF0Y2hlc1sxXS50b19mXG5cbiAgICAgIGlmIHVuaXQgPSBtYXRjaGVzWzJdXG4gICAgICAgIHZhbHVlLl9fc2VuZF9fKHVuaXQuZG93bmNhc2UpXG4gICAgICBlbHNlXG4gICAgICAgIHZhbHVlXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICAwXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmNsYXNzIE5pbENsYXNzXG4gIGRlZiB0b191XG4gICAgMFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6UGFnZ2lvPiIsIjxjbGFzczpDU1M+IiwiPGNsYXNzOlVuaXQ+IiwibWFwIiwidG9fcHJvYyIsInNlbGYiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJudW1iZXIiLCJ0eXBlIiwiQG51bWJlciIsIkB0eXBlIiwiY29lcmNlIiwib3RoZXIiLCI9PSIsIlVuaXQiLCJyZXNwb25kX3RvPyIsInJhaXNlIiwiVHlwZUVycm9yIiwiY2xhc3MiLCJ0b191IiwibmV3IiwiY29udmVydCIsIj09PSIsIiRyZXRfb3JfMSIsImhhc2giLCJlYWNoIiwiVFlQRVMiLCJibG9jayBpbiA8Y2xhc3M6VW5pdD4iLCJuYW1lIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8Y2xhc3M6VW5pdD4iLCJkZWZpbmVfbWV0aG9kIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiA8Y2xhc3M6VW5pdD4iLCIrIiwiY29tcGF0aWJsZT8iLCJBcmd1bWVudEVycm9yIiwiLSIsIioiLCIvIiwiLUAiLCItMSIsIitAIiwidG9faSIsInRvX2YiLCJ0b19zIiwicHJpdmF0ZSIsInVuaXQiLCJDT01QQVRJQkxFIiwiaW5jbHVkZT8iLCJ2YWx1ZSIsInB4IiwiOTYiLCIxMiIsIjEwIiwiQmFzaWNPYmplY3QiLCI8Y2xhc3M6TnVtZXJpYz4iLCJQYWdnaW86OkNTUzo6VW5pdDo6VFlQRVMiLCJQYWdnaW86OkNTUzo6VW5pdCIsIlBhZ2dpbzo6Q1NTIiwiUGFnZ2lvIiwiYmxvY2sgaW4gPGNsYXNzOk51bWVyaWM+IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8Y2xhc3M6TnVtZXJpYz4iLCJibG9jayAoMyBsZXZlbHMpIGluIDxjbGFzczpOdW1lcmljPiIsIkZpeG51bSIsIkZsb2F0IiwiYmxvY2sgaW4gPHRvcCAocmVxdWlyZWQpPiIsImtsYXNzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8dG9wIChyZXF1aXJlZCk+IiwiY2xhc3NfZXZhbCIsImJsb2NrICgzIGxldmVscykgaW4gPHRvcCAocmVxdWlyZWQpPiIsIiUiLCJvbGRfcGVyY2VudCIsIjxjbGFzczpTdHJpbmc+IiwibWF0Y2hlcyIsIm1hdGNoIiwiW10iLCIxIiwiMiIsIl9fc2VuZF9fIiwiZG93bmNhc2UiLCIwIiwiPGNsYXNzOk5pbENsYXNzPiJdLCJtYXBwaW5ncyI6IkFBQUFBLGtDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQVVBQztFQUFBQTs7SUFBQUE7O0lBQWNBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFZEEsT0FBQUM7TUFBQUE7O1FBQUFBOztBQUFBQTs7UUFDRSxpQ0FBcUVDLE1BQXhELENBQUdELElBQUgsRUFBTUEsSUFBTixFQUFTQSxJQUFULEVBQVlBLEtBQVosRUFBZ0JBLElBQWhCLEVBQW1CQSxJQUFuQixFQUFzQkEsTUFBdEIsRUFBMkJBLE1BQTNCLEVBQWdDQSxJQUFoQyxFQUFtQ0EsSUFBbkMsRUFBc0NBLElBQXRDLEVBQXlDQSxJQUF6QyxFQUE0Q0EsSUFBNUMsRUFBK0NBLElBQS9DLEVBQWtEQSxHQUFsRCxFQUFvREEsS0FBcEQsQ0FBd0RDLE9BQUFBLEVBQUFBLEVBQUFBLEVBQU0sUUFBREMsU0FBQUEsQ0FBQUEsQ0FBTEQsQ0FBckU7UUFDQSxzQ0FBa0NBLE1BQXJCLENBQUdELElBQUgsRUFBTUEsSUFBTixFQUFTQSxJQUFULEVBQVlBLElBQVosRUFBZUEsSUFBZixFQUFrQkEsSUFBbEIsQ0FBcUJD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LElBQUFBLEVBSEZILENBQUFBLEdBQUFBLFNBQUFBLENBQUtDLEVBRFBILENBQUFBLEdBQUFBLFNBQUFBLENBQWV2QztFQWNmOEM7RUFBQUE7OztJQUNFQSxPQUFBcEQsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRSxJQUFBLFFBQUdxRCxDQUFBQSxVQUFVcEUsSUFBQXFFLE9BQUFBLENBQU0sa0JBQU5BLENBQVZELENBQUgsQ0FBQTs7UUFDRXhCLFFBQVF3QixPQUFPRSxPQUFBQSxDQUFDQyxDQUFERCxDQUFHaEMsTUFBQUEsQ0FBQUE7UUFFbEIsSUFBQSxRQUFHRyxDQUFBQSxPQUFPMkIsT0FBT0UsT0FBQUEsQ0FBQ0UsQ0FBREYsQ0FBZDdCLENBQUgsQ0FBQTtVQUNFMUIsT0FBQTZCLEtBQUs2QixVQUFBQSxDQUFVaEMsSUFBSWlDLFVBQUFBLENBQUFBLENBQWREO1FBRFA7VUFHRTFELE9BQUE2QjtRQUhGO01BSEY7UUFTRTdCLE9BQUE0RDtNQVRGO0lBREY1RCxDQUFBQTtFQURGb0QsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFnQkF6RSxPQUFBa0Y7RUFBQUE7OztJQUNFQSxPQUFBN0Qsb0JBQUFBLFlBQ0U0RCxDQURGNUQsQ0FBQUE7RUFERjZELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBaE5BbEY7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI4MTAxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGFnZ2lvL2Nzcy9jb2xvci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjLS1cbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgICAgICAgICAgICAgICAgICBWZXJzaW9uIDIsIERlY2VtYmVyIDIwMDRcbiNcbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgVEVSTVMgQU5EIENPTkRJVElPTlMgRk9SIENPUFlJTkcsIERJU1RSSUJVVElPTiBBTkQgTU9ESUZJQ0FUSU9OXG4jXG4jICAwLiBZb3UganVzdCBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPLlxuIysrXG5cbmNsYXNzIFBhZ2dpbzsgY2xhc3MgQ1NTIDwgQmFzaWNPYmplY3RcblxuY2xhc3MgQ29sb3JcbiAgZGVmIGluaXRpYWxpemUodmFsdWUsIHR5cGUpXG4gICAgQGludGVybmFsID0gdmFsdWVcbiAgICBAdHlwZSAgICAgPSB0eXBlXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG5cbmNsYXNzIFN0cmluZ1xuICAld1tyZ2IgcmdiYSBoc2wgaHNsYV0ubWFwKCY6dG9fc3ltKS5lYWNoIHt8bmFtZXxcbiAgICBkZWZpbmVfbWV0aG9kIG5hbWUgZG9cbiAgICAgIFBhZ2dpbzo6Q1NTOjpDb2xvci5uZXcoc2VsZiwgbmFtZSlcbiAgICBlbmRcbiAgfVxuZW5kXG5cbmNsYXNzIEFycmF5XG4gICV3W3JnYiByZ2JhIGhzbCBoc2xhXS5tYXAoJjp0b19zeW0pLmVhY2gge3xuYW1lfFxuICAgIGRlZmluZV9tZXRob2QgbmFtZSBkb1xuICAgICAgUGFnZ2lvOjpDU1M6OkNvbG9yLm5ldyhzZWxmLCBuYW1lKVxuICAgIGVuZFxuICB9XG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOlBhZ2dpbz4iLCI8Y2xhc3M6Q1NTPiIsIjxjbGFzczpDb2xvcj4iLCJpbml0aWFsaXplIiwidmFsdWUiLCJ0eXBlIiwiQGludGVybmFsIiwiQHR5cGUiLCJCYXNpY09iamVjdCIsIjxjbGFzczpTdHJpbmc+IiwiZWFjaCIsIm1hcCIsInRvX3Byb2MiLCJibG9jayBpbiA8Y2xhc3M6U3RyaW5nPiIsIm5hbWUiLCJibG9jayAoMiBsZXZlbHMpIGluIDxjbGFzczpTdHJpbmc+IiwiZGVmaW5lX21ldGhvZCIsInNlbGYiLCJibG9jayAoMyBsZXZlbHMpIGluIDxjbGFzczpTdHJpbmc+IiwiUGFnZ2lvOjpDU1M6OkNvbG9yIiwiUGFnZ2lvOjpDU1MiLCJQYWdnaW8iLCJuZXciLCI8Y2xhc3M6QXJyYXk+IiwiYmxvY2sgaW4gPGNsYXNzOkFycmF5PiIsImJsb2NrICgyIGxldmVscykgaW4gPGNsYXNzOkFycmF5PiIsImJsb2NrICgzIGxldmVscykgaW4gPGNsYXNzOkFycmF5PiJdLCJtYXBwaW5ncyI6IkFBQUFBLG1DQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQVVBQztFQUFBQTs7SUFBQUE7O0lBQWNBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFZEEsT0FBQUM7TUFBQUE7OztRQUNFQSxPQUFBQywwQkFBQUEsc0JBQWVDLEtBQUQsRUFBUUMsSUFBdEJGO0FBQUFBLFVBQUFBOzs7VUFDRUcsZ0JBQVlGO1VBQ1pELE9BQUFJLENBQUFBLFlBQVlGLElBQVpFO1FBRkZKLENBQUFBO01BREZELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0lBRmNELEdBQUFBLFdBQUFBLEVBQVlPLGlCQUFaUDtFQUFkRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQVdBUztFQUFBQTs7SUFBQUE7O0lBQ0VBLE9BQW1DQyxNQUFkQyxNQUFyQixDQUFHRixLQUFILEVBQU9BLE1BQVAsRUFBWUEsS0FBWixFQUFnQkEsTUFBaEIsQ0FBcUJFLE9BQUFBLEVBQUFBLEVBQUFBLEVBQU0sUUFBREMsU0FBQUEsQ0FBQUEsQ0FBTEQsQ0FBY0QsUUFBQUEsRUFBQUEsRUFBQUEsRUFBbkNHLG1CQUEyQ0MsSUFBM0NELEVBQUFFOzs7TUFBMkM7TUFDekNBLE9BQUFDLE1BQUFDLElBQUFELGlCQUFBQSxFQUFBQSxDQUFjRixJQUFkRSxDQUFBQSxFQUFBRCxhQUFBQSxFQUFBRzs7UUFDRUEsT0FBQUMsSUFBQUMsSUFBQUMsWUFBQUQsUUFBQUQsVUFBa0JHLEtBQUFBLENBQUtMLElBQXZCLEVBQTZCSCxJQUFYUSxDQURwQlAsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBQUMsRUFERkgsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBbUNIO0VBRHJDRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQVFBVixPQUFBd0I7RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFtQ2IsTUFBZEMsTUFBckIsQ0FBR1ksS0FBSCxFQUFPQSxNQUFQLEVBQVlBLEtBQVosRUFBZ0JBLE1BQWhCLENBQXFCWixPQUFBQSxFQUFBQSxFQUFBQSxFQUFNLFFBQURDLFNBQUFBLENBQUFBLENBQUxELENBQWNELFFBQUFBLEVBQUFBLEVBQUFBLEVBQW5DYyxrQkFBMkNWLElBQTNDVSxFQUFBQzs7O01BQTJDO01BQ3pDQSxPQUFBVCxNQUFBQyxJQUFBRCxpQkFBQUEsRUFBQUEsQ0FBY0YsSUFBZEUsQ0FBQUEsRUFBQVMsYUFBQUEsRUFBQUM7O1FBQ0VBLE9BQUFQLElBQUFDLElBQUFDLFlBQUFELFFBQUFELFVBQWtCRyxLQUFBQSxDQUFLTCxJQUF2QixFQUE2QkgsSUFBWFEsQ0FEcEJHLENBQUFBLEdBQUFBLFNBQUFBLENBQUFULEVBREZRLENBQUFBLEdBQUFBLFNBQUFBLENBQW1DZDtFQURyQ2EsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUE3QkF4QjsifX0seyJvZmZzZXQiOnsibGluZSI6MjgxNTgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwYWdnaW8vY3NzL2RlZmluaXRpb24ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIy0tXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgICAgICAgICAgICAgICAgICAgVmVyc2lvbiAyLCBEZWNlbWJlciAyMDA0XG4jXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBDT1BZSU5HLCBESVNUUklCVVRJT04gQU5EIE1PRElGSUNBVElPTlxuI1xuIyAgMC4gWW91IGp1c3QgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTy5cbiMrK1xuXG5jbGFzcyBQYWdnaW87IGNsYXNzIENTUyA8IEJhc2ljT2JqZWN0XG5cbmNsYXNzIERlZmluaXRpb24gPCBCYXNpY09iamVjdFxuICBTdHlsZSA9IDo6U3RydWN0Lm5ldyg6bmFtZSwgOnZhbHVlLCA6aW1wb3J0YW50KVxuXG4gIGRlZiBpbml0aWFsaXplKCZibG9jaylcbiAgICBAc3R5bGUgPSBbXVxuXG4gICAgaWYgYmxvY2suYXJpdHkgPT0gMFxuICAgICAgaW5zdGFuY2VfZXhlYygmYmxvY2spXG4gICAgZWxzZVxuICAgICAgYmxvY2suY2FsbChzZWxmKVxuICAgIGVuZCBpZiBibG9ja1xuICBlbmRcblxuICBkZWYgZW1wdHk/XG4gICAgQHN0eWxlLmVtcHR5P1xuICBlbmRcblxuICBkZWYgZWFjaCgmYmxvY2spXG4gICAgQHN0eWxlLmVhY2goJmJsb2NrKVxuICBlbmRcblxuICBkZWYgZ3JhZGllbnQoKmFyZ3MpXG4gICAgR3JhZGllbnQubmV3KCphcmdzKVxuICBlbmRcblxuICBkZWYgdXJsKHZhbHVlKVxuICAgIFwidXJsKCN7dmFsdWUudG9fcy5pbnNwZWN0fSlcIlxuICBlbmRcblxuICAld1tibHVyIGJyaWdodG5lc3Mgcm90YXRlIGNvbnRyYXN0IGdyYXlzY2FsZSBpbnZlcnQgb3BhY2l0eSBzYXR1cmF0ZSBzZXBpYV0uZWFjaCB7fG5hbWV8XG4gICAgZGVmaW5lX21ldGhvZCBuYW1lIGRvIHx2YWx1ZXxcbiAgICAgIFwiI3tuYW1lfSgje3ZhbHVlfSlcIlxuICAgIGVuZFxuICB9XG5cbiAgZGVmIHJnYihyLCBnLCBiKVxuICAgIFwicmdiKCN7cn0sICN7Z30sICN7Yn0sICN7YX0pXCJcbiAgZW5kXG5cbiAgZGVmIHJnYmEociwgZywgYiwgYSlcbiAgICBcInJnYmEoI3tyfSwgI3tnfSwgI3tifSwgI3thfSlcIlxuICBlbmRcblxuICAld1tzY2FsZSBza2V3IHRyYW5zbGF0ZV0uZWFjaCB7fG5hbWV8XG4gICAgZGVmaW5lX21ldGhvZCBuYW1lIGRvIHxhLCBiID0gbmlsfFxuICAgICAgaWYgYlxuICAgICAgICBcIiN7bmFtZX0oI3thfSwgI3tifSlcIlxuICAgICAgZWxzZVxuICAgICAgICBcIiN7bmFtZX0oI3thfSlcIlxuICAgICAgZW5kXG4gICAgZW5kXG4gIH1cblxuICAld1t0cmFuc2xhdGVYIHRyYW5zbGF0ZVkgdHJhbnNsYXRlWiByb3RhdGVYIHJvdGF0ZVkgcm90YXRlWiBza2V3WCBza2V3WSBzY2FsZVggc2NhbGVZXS5lYWNoIHt8bmFtZXxcbiAgICBkZWZpbmVfbWV0aG9kIG5hbWUgZG8gfHZhbHVlfFxuICAgICAgXCIje25hbWV9KCN7dmFsdWV9KVwiXG4gICAgZW5kXG4gIH1cblxuICBkZWYgYmFja2dyb3VuZCgqYXJncylcbiAgICBpZiBHcmFkaWVudCA9PT0gYXJncy5maXJzdFxuICAgICAgaWYgYXJncy5sZW5ndGggPiAxXG4gICAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIFwibXVsdGlwbGUgZ3JhZGllbnRzIG5vdCBpbXBsZW1lbnRlZCB5ZXRcIlxuICAgICAgZW5kXG5cbiAgICAgIGFyZ3MuZmlyc3QuZWFjaCB7fHN8XG4gICAgICAgIHN0eWxlIHMubmFtZSB8fCAnYmFja2dyb3VuZC1pbWFnZScsIHMudmFsdWVcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICBpZiA6Okhhc2ggPT09IGFyZ3MuZmlyc3RcbiAgICAgICAgYXJncy5maXJzdC5lYWNoIHt8c3ViLCB2YWx1ZXxcbiAgICAgICAgICBzdHlsZSBcImJhY2tncm91bmQtI3tzdWJ9XCIsIHZhbHVlXG4gICAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgc3R5bGUgOmJhY2tncm91bmQsIGFyZ3NcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgYm9yZGVyKCphcmdzKVxuICAgIGlmIDo6SGFzaCA9PT0gYXJncy5maXJzdFxuICAgICAgaWYgYXJncy5sZW5ndGggPT0gMVxuICAgICAgICBvcHRpb25zID0gYXJncy5maXJzdFxuICAgICAgZW5kXG5cbiAgICAgIG9wdGlvbnMuZWFjaCB7fG5hbWUsIHZhbHVlfFxuICAgICAgICBjYXNlIG5hbWVcbiAgICAgICAgd2hlbiA6dG9wLCA6Ym90dG9tLCA6bGVmdCwgOnJpZ2h0XG4gICAgICAgICAgaWYgOjpIYXNoID09PSB2YWx1ZVxuICAgICAgICAgICAgdmFsdWUuZWFjaCB7fG4sIHZ8XG4gICAgICAgICAgICAgIHN0eWxlIFwiYm9yZGVyLSN7bmFtZX0tI3tufVwiLCB2XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgc3R5bGUgXCJib3JkZXItI3tuYW1lfVwiLCB2YWx1ZVxuICAgICAgICAgIGVuZFxuXG4gICAgICAgIHdoZW4gOnJhZGl1c1xuICAgICAgICAgIGlmIDo6SGFzaCA9PT0gdmFsdWVcbiAgICAgICAgICAgIHZhbHVlLmVhY2gge3xob3Jpem9udGFsLCB2YWx1ZXxcbiAgICAgICAgICAgICAgdmFsdWUuZWFjaCB7fHZlcnRpY2FsLCB2YWx1ZXxcbiAgICAgICAgICAgICAgICBzdHlsZSBcIi1tb3otYm9yZGVyLXJhZGl1cy0je2hvcml6b250YWx9I3t2ZXJ0aWNhbH1cIiwgdmFsdWVcbiAgICAgICAgICAgICAgICBzdHlsZSBcIi13ZWJraXQtYm9yZGVyLSN7aG9yaXpvbnRhbH0tI3t2ZXJ0aWNhbH0tcmFkaXVzXCIsIHZhbHVlXG4gICAgICAgICAgICAgICAgc3R5bGUgXCJib3JkZXItI3tob3Jpem9udGFsfS0je3ZlcnRpY2FsfS1yYWRpdXNcIiwgdmFsdWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHN0eWxlICctbW96LWJvcmRlci1yYWRpdXMnLCB2YWx1ZVxuICAgICAgICAgICAgc3R5bGUgJy13ZWJraXQtYm9yZGVyLXJhZGl1cycsIHZhbHVlXG4gICAgICAgICAgICBzdHlsZSAnYm9yZGVyLXJhZGl1cycsIHZhbHVlXG4gICAgICAgICAgZW5kXG5cbiAgICAgICAgd2hlbiA6Y29sb3JcbiAgICAgICAgICBpZiA6Okhhc2ggPT09IHZhbHVlXG4gICAgICAgICAgICB2YWx1ZS5lYWNoIHt8bmFtZSwgdmFsdWV8XG4gICAgICAgICAgICAgIHN0eWxlIFwiYm9yZGVyLSN7bmFtZX0tY29sb3JcIiwgdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBzdHlsZSAnYm9yZGVyLWNvbG9yJywgdmFsdWVcbiAgICAgICAgICBlbmRcblxuICAgICAgICBlbHNlXG4gICAgICAgICAgc3R5bGUgXCJib3JkZXItI3tuYW1lfVwiLCB2YWx1ZVxuICAgICAgICBlbmRcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICBzdHlsZSA6Ym9yZGVyLCBhcmdzXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBib3gob3B0aW9ucylcbiAgICBpZiA6Okhhc2ggPT09IG9wdGlvbnNcbiAgICAgIG9wdGlvbnMuZWFjaCB7fG5hbWUsIHZhbHVlfFxuICAgICAgICBjYXNlIG5hbWVcbiAgICAgICAgd2hlbiA6c2hhZG93XG4gICAgICAgICAgaWYgOjpBcnJheSA9PT0gdmFsdWVcbiAgICAgICAgICAgIGlmIDo6QXJyYXkgPT09IHZhbHVlWzBdXG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUubWFwIHsgfHZ8IHYuam9pbiAnICcgfS5qb2luKCcsICcpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuam9pbiAnICdcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVuZFxuXG4gICAgICAgICAgc3R5bGUgJy1tb3otYm94LXNoYWRvdycsIHZhbHVlXG4gICAgICAgICAgc3R5bGUgJy13ZWJraXQtYm94LXNoYWRvdycsIHZhbHVlXG4gICAgICAgICAgc3R5bGUgJ2JveC1zaGFkb3cnLCB2YWx1ZVxuXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBzdHlsZSBcImJveC0je25hbWV9XCIsIHZhbHVlXG4gICAgICAgIGVuZFxuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIHN0eWxlIDpib3gsIG9wdGlvbnNcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIG9wYWNpdHkodmFsdWUpXG4gICAgc3R5bGUgJ29wYWNpdHknLCB2YWx1ZVxuICAgIHN0eWxlICctbW96LW9wYWNpdHknLCB2YWx1ZVxuXG4gICAgc3R5bGUgJy1tcy1maWx0ZXInLCAlUXtcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYShPcGFjaXR5PSN7KHZhbHVlICogMTAwKS50b19pfSlcIn1cbiAgICBzdHlsZSAnZmlsdGVyJywgXCJhbHBoYShvcGFjaXR5PSN7KHZhbHVlICogMTAwKS50b19pfSlcIlxuICBlbmRcblxuICBkZWYgYW5pbWF0aW9uKCphcmdzKVxuICAgIGlmIEhhc2ggPT09IGFyZ3MuZmlyc3RcbiAgICAgIGlmIGFyZ3MubGVuZ3RoID09IDFcbiAgICAgICAgb3B0aW9ucyA9IGFyZ3MuZmlyc3RcbiAgICAgIGVuZFxuXG4gICAgICBvcHRpb25zLmVhY2gge3xuYW1lLCB2YWx1ZXxcbiAgICAgICAgc3R5bGUgXCItd2Via2l0LWFuaW1hdGlvbi0je25hbWV9XCIsIHZhbHVlXG4gICAgICAgIHN0eWxlIFwiYW5pbWF0aW9uLSN7bmFtZX1cIiwgdmFsdWVcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICBzdHlsZSAnYW5pbWF0aW9uJywgYXJnc1xuICAgICAgc3R5bGUgJy13ZWJraXQtYW5pbWF0aW9uJywgYXJnc1xuICAgIGVuZFxuICBlbmRcblxuICBkZWYgdHJhbnNpdGlvbigqYXJncylcbiAgICBzdHlsZSAndHJhbnNpdGlvbicsIGFyZ3NcbiAgICBzdHlsZSAnLXdlYmtpdC10cmFuc2l0aW9uJywgYXJnc1xuICAgIHN0eWxlICctbW96LXRyYW5zaXRpb24nLCBhcmdzXG4gIGVuZFxuXG4gIGRlZiB1c2VyX3NlbGVjdCgqYXJncylcbiAgICBzdHlsZSAndXNlci1zZWxlY3QnLCBhcmdzXG4gICAgc3R5bGUgJy13ZWJraXQtdXNlci1zZWxlY3QnLCBhcmdzXG4gICAgc3R5bGUgJy1tb3otdXNlci1zZWxlY3QnLCBhcmdzXG4gICAgc3R5bGUgJy1tcy11c2VyLXNlbGVjdCcsIGFyZ3NcbiAgZW5kXG5cbiAgZGVmIHRyYW5zZm9ybSgqYXJncylcbiAgICBzdHlsZSAndHJhbnNmb3JtJywgYXJnc1xuICAgIHN0eWxlICctd2Via2l0LXRyYW5zZm9ybScsIGFyZ3NcbiAgICBzdHlsZSAnLW1vei10cmFuc2Zvcm0nLCBhcmdzXG4gICAgc3R5bGUgJy1tcy10cmFuc2Zvcm0nLCBhcmdzXG4gICAgc3R5bGUgJy1vLXRyYW5zZm9ybScsIGFyZ3NcbiAgZW5kXG5cbiAgZGVmIGZpbHRlcigqYXJncylcbiAgICBzdHlsZSAnZmlsdGVyJywgYXJnc1xuICAgIHN0eWxlICctd2Via2l0LWZpbHRlcicsIGFyZ3NcbiAgICBzdHlsZSAnLW1vei1maWx0ZXInLCBhcmdzXG4gICAgc3R5bGUgJy1tcy1maWx0ZXInLCBhcmdzXG4gICAgc3R5bGUgJy1vLWZpbHRlcicsIGFyZ3NcbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF9taXNzaW5nKG5hbWUsICphcmdzLCAmYmxvY2spXG4gICAgbmFtZSA9IG5hbWUudG9fc1xuXG4gICAgaWYgbmFtZS5lbmRfd2l0aD8gPyFcbiAgICAgIG5hbWUgPSBuYW1lWzAgLi4gLTJdXG5cbiAgICAgIEBpbXBvcnRhbnQgPSB0cnVlXG4gICAgICBfX3NlbmRfXyBuYW1lLCAqYXJncywgJmJsb2NrXG4gICAgICBAaW1wb3J0YW50ID0gZmFsc2VcblxuICAgICAgcmV0dXJuXG4gICAgZW5kXG5cbiAgICBpZiBhcmdzLmxlbmd0aCA9PSAxXG4gICAgICBhcmd1bWVudCA9IGFyZ3MuZmlyc3RcblxuICAgICAgaWYgOjpIYXNoID09PSBhcmd1bWVudFxuICAgICAgICBhcmd1bWVudC5lYWNoIHt8c3ViLCB2YWx1ZXxcbiAgICAgICAgICBzdHlsZSBcIiN7bmFtZX0tI3tzdWJ9XCIsIHZhbHVlXG4gICAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgc3R5bGUgbmFtZSwgYXJndW1lbnRcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIHN0eWxlIG5hbWUsIGFyZ3Muam9pbignICcpXG4gICAgZW5kXG5cbiAgICBAaW1wb3J0YW50ID0gZmFsc2VcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHN0eWxlKG5hbWUsIHZhbHVlID0gbmlsLCBpbXBvcnRhbnQgPSBAaW1wb3J0YW50KVxuICAgIGlmIDo6QXJyYXkgPT09IHZhbHVlXG4gICAgICB2YWx1ZSA9IHZhbHVlLmpvaW4gJyAnXG4gICAgZW5kXG5cbiAgICBpZiBTdHlsZSA9PT0gbmFtZVxuICAgICAgQHN0eWxlIDw8IG5hbWVcbiAgICBlbHNlXG4gICAgICBAc3R5bGUgPDwgU3R5bGUubmV3KG5hbWUsIHZhbHVlLCBpbXBvcnRhbnQpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzdHlsZSEobmFtZSwgdmFsdWUgPSBuaWwpXG4gICAgc3R5bGUobmFtZSwgdmFsdWUsIHRydWUpXG4gIGVuZFxuXG4gIGNsYXNzIEdyYWRpZW50XG4gICAgIyBUT0RPOiBhbGwgb2YgaXQsIHNlcmlvdXNseVxuICAgIGRlZiBpbml0aWFsaXplKCphcmdzKVxuICAgICAgb3B0aW9ucyA9IDo6SGFzaCA9PT0gYXJncy5sYXN0ID8gYXJncy5wb3AgOiB7fVxuXG4gICAgICBAdG8gICA9IG9wdGlvbnNbOnRvXVxuICAgICAgQGZyb20gPSBvcHRpb25zWzpmcm9tXVxuXG4gICAgICBpZiBAdG8gJiYgIUBmcm9tXG4gICAgICAgIEBmcm9tID0gb3RoZXIoQHRvKVxuICAgICAgZWxzaWYgQGZyb20gJiYgIUB0b1xuICAgICAgICBAdG8gPSBvdGhlcihAZnJvbSlcbiAgICAgIGVuZFxuXG4gICAgICBAc3RhcnQgPSBhcmdzLnNoaWZ0XG4gICAgICBAZW5kICAgPSBhcmdzLnNoaWZ0XG4gICAgZW5kXG5cbiAgICBkZWYgZWFjaCgmYmxvY2spXG4gICAgICBibG9jay5jYWxsIHN0eWxlKFwiLW1vei1saW5lYXItZ3JhZGllbnQoI0B0bywgI0BzdGFydCAwJSwgI0BlbmQgMTAwJSlcIilcblxuICAgICAgaWYgaG9yaXpvbnRhbD9cbiAgICAgICAgYmxvY2suY2FsbCBzdHlsZShcIi13ZWJraXQtZ3JhZGllbnQobGluZWFyLCAjQGZyb20gdG9wLCAjQHRvIHRvcCwgY29sb3Itc3RvcCgwJSwgI0BzdGFydCksIGNvbG9yLXN0b3AoMTAwJSwgI0BlbmQpKVwiKVxuICAgICAgZWxzZVxuICAgICAgICBibG9jay5jYWxsIHN0eWxlKFwiLXdlYmtpdC1ncmFkaWVudChsaW5lYXIsIGxlZnQgI0Bmcm9tLCBsZWZ0ICNAdG8sIGNvbG9yLXN0b3AoMCUsICNAc3RhcnQpLCBjb2xvci1zdG9wKDEwMCUsICNAZW5kKSlcIilcbiAgICAgIGVuZFxuXG4gICAgICBibG9jay5jYWxsIHN0eWxlKFwiLXdlYmtpdC1saW5lYXItZ3JhZGllbnQoI0B0bywgI0BzdGFydCAwJSwgI0BlbmQgMTAwJSlcIilcbiAgICAgIGJsb2NrLmNhbGwgc3R5bGUoXCItby1saW5lYXItZ3JhZGllbnQoI0B0bywgI0BzdGFydCAwJSwgI0BlbmQgMTAwJSlcIilcbiAgICAgIGJsb2NrLmNhbGwgc3R5bGUoXCItbXMtbGluZWFyLWdyYWRpZW50KCNAdG8sICNAc3RhcnQgMCUsICNAZW5kIDEwMCUpXCIpXG4gICAgICBibG9jay5jYWxsIHN0eWxlKFwibGluZWFyLWdyYWRpZW50KHRvICNAdG8sICNAc3RhcnQgMCUsICNAZW5kIDEwMCUpXCIpXG4gICAgZW5kXG5cbiAgICBkZWYgaG9yaXpvbnRhbD9cbiAgICAgIEB0byA9PSA6bGVmdCB8fCBAdG8gPT0gOnJpZ2h0XG4gICAgZW5kXG5cbiAgICBkZWYgdmVydGljYWw/XG4gICAgICBAdG8gPT0gOnRvcCB8fCBAdG8gPT0gOmJvdHRvbVxuICAgIGVuZFxuXG4gIHByaXZhdGVcbiAgICBkZWYgb3RoZXIoc2lkZSlcbiAgICAgIGNhc2Ugc2lkZVxuICAgICAgd2hlbiA6bGVmdCAgIHRoZW4gOnJpZ2h0XG4gICAgICB3aGVuIDpyaWdodCAgdGhlbiA6bGVmdFxuICAgICAgd2hlbiA6dG9wICAgIHRoZW4gOmJvdHRvbVxuICAgICAgd2hlbiA6Ym90dG9tIHRoZW4gOnRvcFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAjIEZJWE1FOiB1c2UgZGVmYXVsdCBhcmdzXG4gICAgZGVmIHN0eWxlKCphcmdzKVxuICAgICAgaWYgYXJncy5sZW5ndGggPT0gMVxuICAgICAgICBTdHlsZS5uZXcobmlsLCBhcmdzLmZpcnN0KVxuICAgICAgZWxzZVxuICAgICAgICBTdHlsZS5uZXcoKmFyZ3MpXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOlBhZ2dpbz4iLCI8Y2xhc3M6Q1NTPiIsIjxjbGFzczpEZWZpbml0aW9uPiIsIlN0cnVjdCIsIm5ldyIsImluaXRpYWxpemUiLCJAc3R5bGUiLCJibG9jayIsImFyaXR5IiwiMCIsImluc3RhbmNlX2V4ZWMiLCJzZWxmIiwidG9fcHJvYyIsImNhbGwiLCJlbXB0eT8iLCJlYWNoIiwiZ3JhZGllbnQiLCJHcmFkaWVudCIsImFyZ3MiLCJ1cmwiLCJ2YWx1ZSIsInRvX3MiLCJpbnNwZWN0IiwiYmxvY2sgaW4gPGNsYXNzOkRlZmluaXRpb24+IiwibmFtZSIsImJsb2NrICgyIGxldmVscykgaW4gPGNsYXNzOkRlZmluaXRpb24+IiwiZGVmaW5lX21ldGhvZCIsImJsb2NrICgzIGxldmVscykgaW4gPGNsYXNzOkRlZmluaXRpb24+IiwicmdiIiwiciIsImciLCJiIiwiYSIsInJnYmEiLCJiYWNrZ3JvdW5kIiwiZmlyc3QiLCI+IiwibGVuZ3RoIiwiMSIsInJhaXNlIiwiTm90SW1wbGVtZW50ZWRFcnJvciIsImJsb2NrIGluIGJhY2tncm91bmQiLCJzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBiYWNrZ3JvdW5kIiwic3R5bGUiLCIkcmV0X29yXzEiLCJIYXNoIiwic3ViIiwiYm9yZGVyIiwib3B0aW9ucyIsImJsb2NrIGluIGJvcmRlciIsImJsb2NrICgyIGxldmVscykgaW4gYm9yZGVyIiwibiIsInYiLCJibG9jayAoMyBsZXZlbHMpIGluIGJvcmRlciIsImhvcml6b250YWwiLCJ2ZXJ0aWNhbCIsImJsb2NrICg0IGxldmVscykgaW4gYm9yZGVyIiwiYm94IiwiYmxvY2sgaW4gYm94IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBib3giLCJBcnJheSIsIltdIiwibWFwIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiBib3giLCJqb2luIiwib3BhY2l0eSIsIioiLCIxMDAiLCJ0b19pIiwiYW5pbWF0aW9uIiwiYmxvY2sgaW4gYW5pbWF0aW9uIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBhbmltYXRpb24iLCJ0cmFuc2l0aW9uIiwidXNlcl9zZWxlY3QiLCJ0cmFuc2Zvcm0iLCJmaWx0ZXIiLCJtZXRob2RfbWlzc2luZyIsImVuZF93aXRoPyIsIi0yIiwiQGltcG9ydGFudCIsIl9fc2VuZF9fIiwiYXJndW1lbnQiLCJibG9jayBpbiBtZXRob2RfbWlzc2luZyIsImJsb2NrICgyIGxldmVscykgaW4gbWV0aG9kX21pc3NpbmciLCJpbXBvcnRhbnQiLCJTdHlsZSIsIjw8Iiwic3R5bGUhIiwiPGNsYXNzOkdyYWRpZW50PiIsImxhc3QiLCJwb3AiLCJAdG8iLCJAZnJvbSIsIm90aGVyIiwiQHN0YXJ0Iiwic2hpZnQiLCJAZW5kIiwiaG9yaXpvbnRhbD8iLCI9PSIsInZlcnRpY2FsPyIsInByaXZhdGUiLCJzaWRlIiwiQmFzaWNPYmplY3QiXSwibWFwcGluZ3MiOiJBQUFBQSx3Q0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQVVBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWNBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFZEEsT0FBQUM7TUFBQUE7O1FBQUFBOztBQUFBQTs7UUFDRSxpQ0FBUUMsYUFBUUMsS0FBQUEsQ0FBSyxNQUFiLEVBQW9CLE9BQXBCLEVBQTRCLFdBQXBCQSxDQUFoQjs7QUFFQUMsUUFBQUEsMEJBQUFBLHNCQUFBQTtBQUFBQSxVQUFBQTs7VUFBQUE7OztV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QkFBa0JSLE9BQUE7Y0FDbEIsS0FBSyxPQUFMO2dCQUFrQkEsT0FBQTtjQUNsQixLQUFLLEtBQUw7Z0JBQWtCQSxPQUFBO2NBQ2xCLEtBQUssUUFBTDtnQkFBa0JBLE9BQUE7Y0FBbEI7Z0JBSkFBLE9BQUE7WUFDQTtVQUZGQSxDQUFBQTtVQVVBTCxPQUFBN0MscUJBQUFBLGlCQWhVSixFQWdVSUE7QUFBQUEsWUFBQUE7OztZQWhVSjtZQWdVYztZQUNSLElBQUEsTUFBRzFCLElBQUltQixRQUFBQSxDQUFBQSxDQUFQLEVBQWtCQyxDQUFsQixDQUFBO2NBQ0VNLE9BQUEwQyxXQUFLbEYsS0FBQUEsQ0FBSyxHQUFWLEVBQWVjLElBQUlpQixPQUFBQSxDQUFBQSxDQUFkL0I7WUFEUDtjQUdFd0MsT0FBS3hDLE1BQUxrRixXQUFLbEYsT0FBQUEsRUFBSyxNQUFDYyxJQUFELENBQUxkO1lBSFA7VUFERndDLENBQUFBLElBQUFBO1FBcERGNkMsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7TUFoUUZ2RixHQUFBQSxXQUFBQSxFQUFtQnFHLGlCQUFuQnJHO0lBRmNELEdBQUFBLFdBQUFBLEVBQVlzRyxpQkFBWnRHO0VBQWRELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBVkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyODY0OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInBhZ2dpby9jc3MvcnVsZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjLS1cbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgICAgICAgICAgICAgICAgICBWZXJzaW9uIDIsIERlY2VtYmVyIDIwMDRcbiNcbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgVEVSTVMgQU5EIENPTkRJVElPTlMgRk9SIENPUFlJTkcsIERJU1RSSUJVVElPTiBBTkQgTU9ESUZJQ0FUSU9OXG4jXG4jICAwLiBZb3UganVzdCBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPLlxuIysrXG5cbmNsYXNzIFBhZ2dpbzsgY2xhc3MgQ1NTIDwgQmFzaWNPYmplY3RcblxuY2xhc3MgUnVsZSA8IEJhc2ljT2JqZWN0XG4gIGF0dHJfcmVhZGVyIDpzZWxlY3RvciwgOm1lZGlhXG5cbiAgZGVmIGluaXRpYWxpemUoc2VsZWN0b3IsIG1lZGlhKVxuICAgIEBzZWxlY3RvciAgID0gc2VsZWN0b3JcbiAgICBAbWVkaWEgICAgICA9IG1lZGlhXG4gICAgQGRlZmluaXRpb24gPSBEZWZpbml0aW9uLm5ld1xuICBlbmRcblxuICBkZWYgbWV0aG9kX21pc3NpbmcoKmFyZ3MsICZibG9jaylcbiAgICBAZGVmaW5pdGlvbi5fX3NlbmRfXygqYXJncywgJmJsb2NrKVxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6UGFnZ2lvPiIsIjxjbGFzczpDU1M+IiwiPGNsYXNzOlJ1bGU+Iiwic2VsZiIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsInNlbGVjdG9yIiwibWVkaWEiLCJAc2VsZWN0b3IiLCJAbWVkaWEiLCJAZGVmaW5pdGlvbiIsIkRlZmluaXRpb24iLCJuZXciLCJtZXRob2RfbWlzc2luZyIsIl9fc2VuZF9fIiwiYXJncyIsImJsb2NrIiwidG9fcHJvYyIsIkJhc2ljT2JqZWN0Il0sIm1hcHBpbmdzIjoiQUFBQUEsa0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFVQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFjQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWRBLE9BQUFDO01BQUFBOztRQUFBQTs7QUFBQUE7O1FBQ0VDLElBQUFDLGFBQUFBLENBQVksVUFBWixFQUF1QixPQUF2QkE7O0FBRUFDLFFBQUFBLDBCQUFBQSxzQkFBZUMsUUFBRCxFQUFXQyxLQUF6QkY7QUFBQUEsVUFBQUE7OztVQUNFRyxnQkFBY0Y7VUFDZEcsYUFBY0Y7VUFDZEYsT0FBQUssQ0FBQUEsa0JBQWNDLGdCQUFVQyxLQUFBQSxDQUFBQSxDQUF4QkY7UUFIRkwsQ0FBQUE7UUFNQUgsT0FBQVcsOEJBQUFBLDBCQXJCRixFQXFCRUE7QUFBQUEsVUFBQUE7O1VBQUFBOzs7VUFyQkY7VUFxQnFCO1VBQ2pCQSxPQUFXQyxNQUFYSixlQUFXSSxZQUFBQSxFQUFVLE1BQUNDLElBQUQsQ0FBVkQsRUFBa0JFLEtBQURDLFNBQUFBLENBQUFBLENBQWpCSDtRQURiRCxDQUFBQSxJQUFBQTtNQVRGWCxHQUFBQSxXQUFBQSxFQUFhZ0IsaUJBQWJoQjtJQUZjRCxHQUFBQSxXQUFBQSxFQUFZaUIsaUJBQVpqQjtFQUFkRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQVZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6Mjg2OTQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwYWdnaW8vY3NzL2ZvbnQucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIy0tXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgICAgICAgICAgICAgICAgICAgVmVyc2lvbiAyLCBEZWNlbWJlciAyMDA0XG4jXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBDT1BZSU5HLCBESVNUUklCVVRJT04gQU5EIE1PRElGSUNBVElPTlxuI1xuIyAgMC4gWW91IGp1c3QgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTy5cbiMrK1xuXG5jbGFzcyBQYWdnaW87IGNsYXNzIENTUyA8IEJhc2ljT2JqZWN0XG5cbmNsYXNzIEZvbnQgPCBCYXNpY09iamVjdFxuICBhdHRyX3JlYWRlciA6bmFtZVxuXG4gIGRlZiBpbml0aWFsaXplKG5hbWUpXG4gICAgQG5hbWUgICAgICAgPSBuYW1lXG4gICAgQGRlZmluaXRpb24gPSBEZWZpbml0aW9uLm5ld1xuXG4gICAgZm9udCBmYW1pbHk6IG5hbWVcbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF9taXNzaW5nKCphcmdzLCAmYmxvY2spXG4gICAgQGRlZmluaXRpb24uX19zZW5kX18oKmFyZ3MsICZibG9jaylcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOlBhZ2dpbz4iLCI8Y2xhc3M6Q1NTPiIsIjxjbGFzczpGb250PiIsInNlbGYiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJuYW1lIiwiQG5hbWUiLCJAZGVmaW5pdGlvbiIsIkRlZmluaXRpb24iLCJuZXciLCJmb250IiwibWV0aG9kX21pc3NpbmciLCJfX3NlbmRfXyIsImFyZ3MiLCJibG9jayIsInRvX3Byb2MiLCJCYXNpY09iamVjdCJdLCJtYXBwaW5ncyI6IkFBQUFBLGtDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBVUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBY0EsT0FBQUM7SUFBQUE7O01BQUFBOztNQUVkQSxPQUFBQztNQUFBQTs7UUFBQUE7O0FBQUFBOztRQUNFQyxJQUFBQyxhQUFBQSxDQUFZLE1BQVpBOztBQUVBQyxRQUFBQSwwQkFBQUEsc0JBQWVDLElBQWZEO0FBQUFBLFVBQUFBOzs7VUFDRUUsWUFBY0Q7VUFDZEUsa0JBQWNDLGdCQUFVQyxLQUFBQSxDQUFBQTtVQUV4QkwsT0FBQUYsSUFBQVEsTUFBQUEsQ0FBSyxVQUFBLFNBQUEsRUFBUUwsSUFBUixDQUFBLEdBQUxLO1FBSkZOLENBQUFBO1FBT0FILE9BQUFVLDhCQUFBQSwwQkF0QkYsRUFzQkVBO0FBQUFBLFVBQUFBOztVQUFBQTs7O1VBdEJGO1VBc0JxQjtVQUNqQkEsT0FBV0MsTUFBWEwsZUFBV0ssWUFBQUEsRUFBVSxNQUFDQyxJQUFELENBQVZELEVBQWtCRSxLQUFEQyxTQUFBQSxDQUFBQSxDQUFqQkg7UUFEYkQsQ0FBQUEsSUFBQUE7TUFWRlYsR0FBQUEsV0FBQUEsRUFBYWUsaUJBQWJmO0lBRmNELEdBQUFBLFdBQUFBLEVBQVlnQixpQkFBWmhCO0VBQWRELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBVkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyODc0MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInBhZ2dpby9jc3MvYW5pbWF0aW9uLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMtLVxuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICAgICAgICAgICAgICAgICAgIFZlcnNpb24gMiwgRGVjZW1iZXIgMjAwNFxuI1xuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICBURVJNUyBBTkQgQ09ORElUSU9OUyBGT1IgQ09QWUlORywgRElTVFJJQlVUSU9OIEFORCBNT0RJRklDQVRJT05cbiNcbiMgIDAuIFlvdSBqdXN0IERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8uXG4jKytcblxuY2xhc3MgUGFnZ2lvOyBjbGFzcyBDU1MgPCBCYXNpY09iamVjdFxuXG5jbGFzcyBBbmltYXRpb24gPCBCYXNpY09iamVjdFxuICBjbGFzcyBTdGVwIDwgQmFzaWNPYmplY3RcbiAgICBhdHRyX3JlYWRlciA6dmFsdWVcblxuICAgIGRlZiBpbml0aWFsaXplKHZhbHVlKVxuICAgICAgQHZhbHVlICAgICAgPSB2YWx1ZVxuICAgICAgQGRlZmluaXRpb24gPSBEZWZpbml0aW9uLm5ld1xuICAgIGVuZFxuXG4gICAgZGVmIG1ldGhvZF9taXNzaW5nKCphcmdzLCAmYmxvY2spXG4gICAgICBAZGVmaW5pdGlvbi5fX3NlbmRfXygqYXJncywgJmJsb2NrKVxuICAgIGVuZFxuICBlbmRcblxuICBhdHRyX3JlYWRlciA6bmFtZSwgOnN0ZXBzXG5cbiAgZGVmIGluaXRpYWxpemUobmFtZSlcbiAgICBAbmFtZSAgPSBuYW1lXG4gICAgQHN0ZXBzID0gW11cbiAgZW5kXG5cbiAgZGVmIHN0ZXAodmFsdWUsICZibG9jaylcbiAgICBAc3RlcHMgPDwgU3RlcC5uZXcodmFsdWUpXG4gICAgYmxvY2suY2FsbFxuICBlbmRcblxuICBkZWYgZnJvbSh2YWx1ZSwgJmJsb2NrKVxuICAgIEBzdGVwcyA8PCBTdGVwLm5ldygwLiUpXG4gICAgYmxvY2suY2FsbFxuICBlbmRcblxuICBkZWYgdG8odmFsdWUsICZibG9jaylcbiAgICBAc3RlcHMgPDwgU3RlcC5uZXcoMTAwLiUpXG4gICAgYmxvY2suY2FsbFxuICBlbmRcblxuICBkZWYgbWV0aG9kX21pc3NpbmcoKmFyZ3MsICZibG9jaylcbiAgICBAc3RlcHMubGFzdC5fX3NlbmRfXygqYXJncywgJmJsb2NrKVxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6UGFnZ2lvPiIsIjxjbGFzczpDU1M+IiwiPGNsYXNzOkFuaW1hdGlvbj4iLCI8Y2xhc3M6U3RlcD4iLCJzZWxmIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwidmFsdWUiLCJAdmFsdWUiLCJAZGVmaW5pdGlvbiIsIkRlZmluaXRpb24iLCJuZXciLCJtZXRob2RfbWlzc2luZyIsIl9fc2VuZF9fIiwiYXJncyIsImJsb2NrIiwidG9fcHJvYyIsIkJhc2ljT2JqZWN0IiwibmFtZSIsIkBuYW1lIiwiQHN0ZXBzIiwic3RlcCIsIjw8IiwiU3RlcCIsImNhbGwiLCJmcm9tIiwiMCIsIiUiLCJ0byIsIjEwMCIsImxhc3QiXSwibWFwcGluZ3MiOiJBQUFBQSx1Q0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQVVBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWNBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFZEEsT0FBQUM7TUFBQUE7O1FBQUFBOztBQUFBQTs7UUFDRUM7UUFBQUE7O1VBQUFBOztBQUFBQTs7VUFDRUMsSUFBQUMsYUFBQUEsQ0FBWSxPQUFaQTs7QUFFQUMsVUFBQUEsMEJBQUFBLHNCQUFlQyxLQUFmRDtBQUFBQSxZQUFBQTs7O1lBQ0VFLGFBQWNEO1lBQ2RELE9BQUFHLENBQUFBLGtCQUFjQyxnQkFBVUMsS0FBQUEsQ0FBQUEsQ0FBeEJGO1VBRkZILENBQUFBO1VBS0FILE9BQUFTLDhCQUFBQSwwQkFyQkosRUFxQklBO0FBQUFBLFlBQUFBOztZQUFBQTs7O1lBckJKO1lBcUJ1QjtZQUNqQkEsT0FBV0MsTUFBWEosZUFBV0ksWUFBQUEsRUFBVSxNQUFDQyxJQUFELENBQVZELEVBQWtCRSxLQUFEQyxTQUFBQSxDQUFBQSxDQUFqQkg7VUFEYkQsQ0FBQUEsSUFBQUE7UUFSRlQsR0FBQUEsV0FBQUEsRUFBYWMsaUJBQWJkO1FBYUFDLElBQUFDLGFBQUFBLENBQVksTUFBWixFQUFtQixPQUFuQkE7O0FBRUFDLFFBQUFBLDBCQUFBQSxzQkFBZVksSUFBZlo7QUFBQUEsVUFBQUE7OztVQUNFYSxZQUFTRDtVQUNUWixPQUFBYyxDQUFBQSxhQUFTLEVBQVRBO1FBRkZkLENBQUFBOztBQUtBZSxRQUFBQSxvQkFBQUEsZ0JBQVNkLEtBQVRjO0FBQUFBLFVBQUFBOztVQUFBQTs7O1VBQ0VELFVBQU9FLE9BQUFBLENBQUdDLFVBQUlaLEtBQUFBLENBQUtKLEtBQUxJLENBQVBXO1VBQ1BELE9BQUFOLEtBQUtTLE1BQUFBLENBQUFBO1FBRlBILENBQUFBOztBQUtBSSxRQUFBQSxvQkFBQUEsZ0JBQVNsQixLQUFUa0I7QUFBQUEsVUFBQUE7O1VBQUFBOzs7VUFDRUwsVUFBT0UsT0FBQUEsQ0FBR0MsVUFBSVosS0FBQUEsQ0FBS2UsQ0FBQUEsQ0FBQUEsQ0FBQ0MsTUFBQUEsQ0FBQUEsQ0FBTmhCLENBQVBXO1VBQ1BHLE9BQUFWLEtBQUtTLE1BQUFBLENBQUFBO1FBRlBDLENBQUFBOztBQUtBRyxRQUFBQSxrQkFBQUEsY0FBT3JCLEtBQVBxQjtBQUFBQSxVQUFBQTs7VUFBQUE7OztVQUNFUixVQUFPRSxPQUFBQSxDQUFHQyxVQUFJWixLQUFBQSxDQUFLa0IsQ0FBQUEsR0FBQUEsQ0FBR0YsTUFBQUEsQ0FBQUEsQ0FBUmhCLENBQVBXO1VBQ1BNLE9BQUFiLEtBQUtTLE1BQUFBLENBQUFBO1FBRlBJLENBQUFBO1FBS0ExQixPQUFBVSw4QkFBQUEsMEJBaERGLEVBZ0RFQTtBQUFBQSxVQUFBQTs7VUFBQUE7OztVQWhERjtVQWdEcUI7VUFDakJBLE9BQVdDLE1BQVhPLFVBQU1VLE1BQUFBLENBQUFBLENBQUtqQixZQUFBQSxFQUFVLE1BQUNDLElBQUQsQ0FBVkQsRUFBa0JFLEtBQURDLFNBQUFBLENBQUFBLENBQWpCSDtRQURiRCxDQUFBQSxJQUFBQTtNQXBDRlYsR0FBQUEsV0FBQUEsRUFBa0JlLGlCQUFsQmY7SUFGY0QsR0FBQUEsV0FBQUEsRUFBWWdCLGlCQUFaaEI7RUFBZEQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFWQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI4ODQyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGFnZ2lvL2Nzcy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjLS1cbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgICAgICAgICAgICAgICAgICBWZXJzaW9uIDIsIERlY2VtYmVyIDIwMDRcbiNcbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgVEVSTVMgQU5EIENPTkRJVElPTlMgRk9SIENPUFlJTkcsIERJU1RSSUJVVElPTiBBTkQgTU9ESUZJQ0FUSU9OXG4jXG4jICAwLiBZb3UganVzdCBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPLlxuIysrXG5cbnJlcXVpcmUgJ3BhZ2dpby9jc3MvdW5pdCdcbnJlcXVpcmUgJ3BhZ2dpby9jc3MvY29sb3InXG5yZXF1aXJlICdwYWdnaW8vY3NzL2RlZmluaXRpb24nXG5yZXF1aXJlICdwYWdnaW8vY3NzL3J1bGUnXG5yZXF1aXJlICdwYWdnaW8vY3NzL2ZvbnQnXG5yZXF1aXJlICdwYWdnaW8vY3NzL2FuaW1hdGlvbidcblxuY2xhc3MgUGFnZ2lvXG5cbmNsYXNzIENTUyA8IEJhc2ljT2JqZWN0XG4gIGRlZiBzZWxmLnNlbGVjdG9yKGxpc3QpXG4gICAgcmVzdWx0ID0gJydcblxuICAgIGxpc3QuZWFjaCB7fHBhcnR8XG4gICAgICBpZiBwYXJ0LnN0YXJ0X3dpdGg/KCcmJylcbiAgICAgICAgcmVzdWx0ICs9IHBhcnRbMSAuLiAtMV1cbiAgICAgIGVsc2VcbiAgICAgICAgcmVzdWx0ICs9IFwiIFwiICsgcGFydFxuICAgICAgZW5kXG4gICAgfVxuXG4gICAgaWYgcmVzdWx0WzBdID09IFwiIFwiXG4gICAgICByZXN1bHRbMSAuLiAtMV1cbiAgICBlbHNlXG4gICAgICByZXN1bHRcbiAgICBlbmRcbiAgZW5kXG5cbiAgYXR0cl9yZWFkZXIgOnJ1bGVzLCA6bWVkaWEsIDpmb250cywgOmFuaW1hdGlvbnNcblxuICBkZWYgaW5pdGlhbGl6ZShkZWZlcjogZmFsc2UsICZibG9jaylcbiAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICBAc2VsZWN0b3IgICA9IFtdXG4gICAgQGN1cnJlbnQgICAgPSBbXVxuICAgIEBydWxlcyAgICAgID0gW11cbiAgICBAZm9udHMgICAgICA9IFtdXG4gICAgQGFuaW1hdGlvbnMgPSBbXVxuICAgIFxuICAgIEBibG9jayAgICAgID0gYmxvY2tcblxuICAgIGJ1aWxkISB1bmxlc3MgZGVmZXJcbiAgZW5kXG5cbiAgZGVmIGJ1aWxkIShmb3JjZV9jYWxsOiBmYWxzZSlcbiAgICBpZiAhZm9yY2VfY2FsbCAmJiBAYmxvY2suYXJpdHkgPT0gMFxuICAgICAgaW5zdGFuY2VfZXhlYygmQGJsb2NrKVxuICAgIGVsc2VcbiAgICAgIEBibG9jay5jYWxsKHNlbGYpXG4gICAgZW5kXG4gICAgQGJsb2NrID0gbmlsXG4gIGVuZFxuXG4gIGRlZiBydWxlKCpuYW1lcywgJmJsb2NrKVxuICAgIHJldHVybiB1bmxlc3MgYmxvY2tcblxuICAgIGlmIG5hbWVzLmFueT8geyB8bnwgbi5pbmNsdWRlPyAnLCcgfVxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnc2VsZWN0b3JzIGNhbm5vdCBjb250YWluIGNvbW1hcydcbiAgICBlbmRcblxuICAgIG5hbWVzLmVhY2gge3xuYW1lfFxuICAgICAgQHNlbGVjdG9yIDw8IG5hbWVcbiAgICAgIEBjdXJyZW50ICA8PCBSdWxlLm5ldyhDU1Muc2VsZWN0b3IoQHNlbGVjdG9yKSwgQG1lZGlhKVxuXG4gICAgICBibG9jay5jYWxsXG5cbiAgICAgIEBzZWxlY3Rvci5wb3BcbiAgICAgIEBydWxlcyA8PCBAY3VycmVudC5wb3BcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtZWRpYShxdWVyeSwgKmFyZ3MsICZibG9jaylcbiAgICBpZiBibG9ja1xuICAgICAgb2xkLCBAbWVkaWEgPSBAbWVkaWEsIHF1ZXJ5XG4gICAgICBibG9jay5jYWxsXG4gICAgICBAbWVkaWEgPSBvbGRcbiAgICBlbHNlXG4gICAgICBtZXRob2RfbWlzc2luZyg6bWVkaWEsIHF1ZXJ5LCAqYXJncylcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGZvbnQobmFtZSwgKmFyZ3MsICZibG9jaylcbiAgICBpZiBibG9ja1xuICAgICAgQGN1cnJlbnQgPDwgRm9udC5uZXcobmFtZSlcbiAgICAgIGJsb2NrLmNhbGxcbiAgICAgIEBmb250cyA8PCBAY3VycmVudC5wb3BcbiAgICBlbHNlXG4gICAgICBtZXRob2RfbWlzc2luZyg6Zm9udCwgbmFtZSwgKmFyZ3MpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBhbmltYXRpb24obmFtZSwgKmFyZ3MsICZibG9jaylcbiAgICBpZiBibG9ja1xuICAgICAgQGN1cnJlbnQgPDwgQW5pbWF0aW9uLm5ldyhuYW1lKVxuICAgICAgYmxvY2suY2FsbFxuICAgICAgQGFuaW1hdGlvbnMgPDwgQGN1cnJlbnQucG9wXG4gICAgZWxzZVxuICAgICAgbWV0aG9kX21pc3NpbmcoOmFuaW1hdGlvbiwgbmFtZSwgKmFyZ3MpXG4gICAgZW5kXG4gIGVuZFxuXG4gICMgdGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgbWV0aG9kcyBpbnNpZGUgdGhlIHJ1bGUgYmxvY2tzIGFyZSBhY3R1YWxseVxuICAjIGNhbGxlZCBvbiB0aGUgQ1NTIG9iamVjdFxuICBkZWYgbWV0aG9kX21pc3NpbmcoKmFyZ3MsICZibG9jaylcbiAgICBAY3VycmVudC5sYXN0Ll9fc2VuZF9fKCphcmdzLCAmYmxvY2spXG4gIGVuZFxuZW5kXG5cbmNsYXNzIEhUTUwgPCBCYXNpY09iamVjdFxuICBkZWYgc3R5bGUoJmJsb2NrKVxuICAgIChAY3VycmVudCB8fCBAcm9vdHMpIDw8IENTUy5uZXcoJmJsb2NrKVxuICBlbmRcbmVuZFxuXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6UGFnZ2lvPiIsIjxjbGFzczpDU1M+Iiwic2VsZWN0b3IiLCJsaXN0IiwicmVzdWx0IiwiZWFjaCIsImJsb2NrIGluIHNlbGVjdG9yIiwicGFydCIsInN0YXJ0X3dpdGg/IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzZWxlY3RvciIsIisiLCJbXSIsIjEiLCItMSIsIjAiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCIka3dhcmdzIiwiYmxvY2siLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJAc2VsZWN0b3IiLCJAY3VycmVudCIsIkBydWxlcyIsIkBmb250cyIsIkBhbmltYXRpb25zIiwiQGJsb2NrIiwiZGVmZXIiLCJidWlsZCEiLCJmb3JjZV9jYWxsIiwiYXJpdHkiLCJpbnN0YW5jZV9leGVjIiwidG9fcHJvYyIsImNhbGwiLCJydWxlIiwiYW55PyIsIm5hbWVzIiwiYmxvY2sgaW4gcnVsZSIsIm4iLCJibG9jayAoMiBsZXZlbHMpIGluIHJ1bGUiLCJpbmNsdWRlPyIsIm5hbWUiLCI8PCIsIlJ1bGUiLCJuZXciLCJDU1MiLCJAbWVkaWEiLCJwb3AiLCJtZWRpYSIsInF1ZXJ5Iiwib2xkIiwibWV0aG9kX21pc3NpbmciLCJhcmdzIiwiZm9udCIsIkZvbnQiLCJhbmltYXRpb24iLCJBbmltYXRpb24iLCJfX3NlbmRfXyIsImxhc3QiLCJCYXNpY09iamVjdCIsIjxjbGFzczpIVE1MPiIsInN0eWxlIiwiJHJldF9vcl8xIiwiQHJvb3RzIl0sIm1hcHBpbmdzIjoiQUFBQUEsNkJBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBVUFDLElBQUFDLFNBQUFBLENBQVFGLGlCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixrQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsdUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLGlCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixpQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsc0JBQVJFO0VBRUFGLE9BQUFHO0VBQUFBOztJQUFBQTs7O0lBRUFDO0lBQUFBOztNQUFBQTs7QUFBQUE7O01BQ0VDLE1BQUlKLElBQUpJLGVBQUFBLG9CQUFrQkMsSUFBbEJEO0FBQUFBLFFBQUFBOzs7UUFDRUUsU0FBU0Y7UUFFTEcsTUFBSkYsSUFBSUUsUUFBQUEsRUFBQUEsRUFBQUEsRUFBSkMsYUFBWUMsSUFBWkQ7O1VBQVk7VUFDVixJQUFBLFFBQUdDLElBQUlDLGdCQUFBQSxDQUFhQyxHQUFiRCxDQUFQLENBQUE7WUFDRUMsT0FBQUwsQ0FBQUEsU0FBT00sU0FBUE4sTUFBT00sRUFBR0gsSUFBSUksT0FBQUEsQ0FBQyxPQUFBQyxDQUFBLEVBQUtDLEVBQUwsUUFBREYsQ0FBUEQsQ0FBUE47VUFERjtZQUdFSyxPQUFBTCxDQUFBQSxTQUFPTSxTQUFQTixNQUFPTSxFQUFPQSxTQUFKRCxHQUFJQyxFQUFFSCxJQUFGRyxDQUFQQSxDQUFQTjtVQUhGLEVBREZF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QUFBbUQsOEJBQUFBLDBCQWpIRixFQWlIRUE7QUFBQUEsUUFBQUE7O1FBQUFBOzs7UUFqSEY7UUFpSHFCO1FBQ2pCQSxPQUFhTSxNQUFibkMsWUFBUW9DLE1BQUFBLENBQUFBLENBQUtELFlBQUFBLEVBQVUsTUFBQ0wsSUFBRCxDQUFWSyxFQUFrQnhDLEtBQURlLFNBQUFBLENBQUFBLENBQWpCeUI7TUFEZk4sQ0FBQUEsSUFBQUE7SUE5RkZuRCxHQUFBQSxXQUFBQSxFQUFZMkQsaUJBQVozRDtJQW1HQUQsT0FBQTZEO0lBQUFBOztNQUFBQTs7QUFBQUE7TUFDRUEsT0FBQUMscUJBQUFBLGlCQUFBQTtBQUFBQSxRQUFBQTs7UUFBQUE7OztRQUNFQSxPQUFDLENBQUEsUUFBQUMsQ0FBQUEsWUFBQXhDLFlBQUF3QyxDQUFBLENBQUEsR0FBQSxDQUFBLFNBQUEsSUFBQSxDQUFZQyxVQUFaLENBQUEsQ0FBb0JyQixPQUFBQSxDQUFNRSxNQUFIQyxTQUFHRCxPQUFBQSxFQUFBQSxFQUFBQSxFQUFNM0IsS0FBRGUsU0FBQUEsQ0FBQUEsQ0FBTFksQ0FBTkY7TUFEdkJtQixDQUFBQTtJQURGRCxHQUFBQSxXQUFBQSxFQUFhRCxpQkFBYkM7RUFyR0E3RCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQWpCQUg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI5MDQxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9zdHJpbmdpby5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBTdHJpbmdJTyA8IElPXG4gIFZFUlNJT04gPSBcIjBcIlxuXG4gIGRlZiBzZWxmLm9wZW4oc3RyaW5nID0gXCJcIiwgbW9kZSA9IG5pbCwgJmJsb2NrKVxuICAgIGlvICA9IG5ldyhzdHJpbmcsIG1vZGUpXG4gICAgcmVzID0gYmxvY2suY2FsbChpbylcbiAgICBpby5jbG9zZVxuXG4gICAgcmVzXG4gIGVuZFxuXG4gIGF0dHJfYWNjZXNzb3IgOnN0cmluZ1xuXG4gIGRlZiBpbml0aWFsaXplKHN0cmluZyA9IFwiXCIsIG1vZGUgPSAncncnKVxuICAgIEBzdHJpbmcgICA9IHN0cmluZ1xuICAgIEBwb3NpdGlvbiA9IDBcblxuICAgIHN1cGVyKG5pbCwgbW9kZSlcbiAgZW5kXG5cbiAgZGVmIGVvZj9cbiAgICBjaGVja19yZWFkYWJsZVxuXG4gICAgQHBvc2l0aW9uID09IEBzdHJpbmcubGVuZ3RoXG4gIGVuZFxuXG4gIGRlZiBzZWVrKHBvcywgd2hlbmNlID0gSU86OlNFRUtfU0VUKVxuICAgICMgTGV0J3MgcmVzZXQgdGhlIHJlYWQgYnVmZmVyLCBiZWNhdXNlIGl0IHdpbGwgYmUgbW9zdCBsaWtlbHkgd3JvbmdcbiAgICBAcmVhZF9idWZmZXIgPSAnJ1xuXG4gICAgY2FzZSB3aGVuY2VcbiAgICB3aGVuIElPOjpTRUVLX1NFVFxuICAgICAgcmFpc2UgRXJybm86OkVJTlZBTCB1bmxlc3MgcG9zID49IDBcblxuICAgICAgQHBvc2l0aW9uID0gcG9zXG5cbiAgICB3aGVuIElPOjpTRUVLX0NVUlxuICAgICAgaWYgQHBvc2l0aW9uICsgcG9zID4gQHN0cmluZy5sZW5ndGhcbiAgICAgICAgQHBvc2l0aW9uID0gQHN0cmluZy5sZW5ndGhcbiAgICAgIGVsc2VcbiAgICAgICAgQHBvc2l0aW9uICs9IHBvc1xuICAgICAgZW5kXG5cbiAgICB3aGVuIElPOjpTRUVLX0VORFxuICAgICAgaWYgcG9zID4gQHN0cmluZy5sZW5ndGhcbiAgICAgICAgQHBvc2l0aW9uID0gMFxuICAgICAgZWxzZVxuICAgICAgICBAcG9zaXRpb24gLT0gcG9zXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIDBcbiAgZW5kXG5cbiAgZGVmIHRlbGxcbiAgICBAcG9zaXRpb25cbiAgZW5kXG5cbiAgZGVmIHJld2luZFxuICAgIHNlZWsgMFxuICBlbmRcblxuICBkZWYgd3JpdGUoc3RyaW5nKVxuICAgIGNoZWNrX3dyaXRhYmxlXG5cbiAgICAjIExldCdzIHJlc2V0IHRoZSByZWFkIGJ1ZmZlciwgYmVjYXVzZSBpdCB3aWxsIGJlIG1vc3QgbGlrZWx5IHdyb25nXG4gICAgQHJlYWRfYnVmZmVyID0gJydcblxuICAgIHN0cmluZyA9IFN0cmluZyhzdHJpbmcpXG5cbiAgICBpZiBAc3RyaW5nLmxlbmd0aCA9PSBAcG9zaXRpb25cbiAgICAgIEBzdHJpbmcgICArPSBzdHJpbmdcbiAgICAgIEBwb3NpdGlvbiArPSBzdHJpbmcubGVuZ3RoXG4gICAgZWxzZVxuICAgICAgYmVmb3JlID0gQHN0cmluZ1swIC4uIEBwb3NpdGlvbiAtIDFdXG4gICAgICBhZnRlciAgPSBAc3RyaW5nW0Bwb3NpdGlvbiArIHN0cmluZy5sZW5ndGggLi4gLTFdXG5cbiAgICAgIEBzdHJpbmcgICA9IGJlZm9yZSArIHN0cmluZyArIGFmdGVyXG4gICAgICBAcG9zaXRpb24gKz0gc3RyaW5nLmxlbmd0aFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgcmVhZChsZW5ndGggPSBuaWwsIG91dGJ1ZiA9IG5pbClcbiAgICBjaGVja19yZWFkYWJsZVxuXG4gICAgcmV0dXJuIGlmIGVvZj9cblxuICAgIHN0cmluZyA9IGlmIGxlbmd0aFxuICAgICAgc3RyID0gQHN0cmluZ1tAcG9zaXRpb24sIGxlbmd0aF1cbiAgICAgIEBwb3NpdGlvbiArPSBsZW5ndGhcbiAgICAgIEBwb3NpdGlvbiA9IEBzdHJpbmcubGVuZ3RoIGlmIEBwb3NpdGlvbiA+IEBzdHJpbmcubGVuZ3RoXG4gICAgICBzdHJcbiAgICBlbHNlXG4gICAgICBzdHIgPSBAc3RyaW5nW0Bwb3NpdGlvbiAuLiAtMV1cbiAgICAgIEBwb3NpdGlvbiA9IEBzdHJpbmcubGVuZ3RoXG4gICAgICBzdHJcbiAgICBlbmRcblxuICAgIGlmIG91dGJ1ZlxuICAgICAgb3V0YnVmLndyaXRlKHN0cmluZylcbiAgICBlbHNlXG4gICAgICBzdHJpbmdcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHN5c3JlYWQobGVuZ3RoKVxuICAgIGNoZWNrX3JlYWRhYmxlXG5cbiAgICByZWFkKGxlbmd0aClcbiAgZW5kXG5cbiAgYWxpYXMgZW9mIGVvZj9cbiAgYWxpYXMgcG9zIHRlbGxcbiAgYWxpYXMgcG9zPSBzZWVrXG4gIGFsaWFzIHJlYWRwYXJ0aWFsIHJlYWRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6U3RyaW5nSU8+Iiwib3BlbiIsInNlbGYiLCJzdHJpbmciLCJtb2RlIiwiaW8iLCJuZXciLCJyZXMiLCJibG9jayIsImNhbGwiLCJjbG9zZSIsImF0dHJfYWNjZXNzb3IiLCJpbml0aWFsaXplIiwiQHN0cmluZyIsIkBwb3NpdGlvbiIsIjAiLCJlb2Y/IiwiY2hlY2tfcmVhZGFibGUiLCI9PSIsImxlbmd0aCIsInNlZWsiLCJwb3MiLCJ3aGVuY2UiLCJJTzo6U0VFS19TRVQiLCJJTyIsIkByZWFkX2J1ZmZlciIsIiRyZXRfb3JfMSIsIj49IiwicmFpc2UiLCJFcnJubzo6RUlOVkFMIiwiRXJybm8iLCJJTzo6U0VFS19DVVIiLCI+IiwiKyIsIklPOjpTRUVLX0VORCIsIi0iLCJ0ZWxsIiwicmV3aW5kIiwid3JpdGUiLCJjaGVja193cml0YWJsZSIsIlN0cmluZyIsImJlZm9yZSIsIltdIiwiMSIsImFmdGVyIiwiLTEiLCJyZWFkIiwib3V0YnVmIiwic3RyIiwic3lzcmVhZCJdLCJtYXBwaW5ncyI6IkFBQUFBLDJCQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7QUFBQUE7O0lBQ0UsbUNBQVVBLEdBQVY7SUFFQUMsTUFBSUMsSUFBSkQsV0FBQUEsZ0JBQWNFLE1BQUQsRUFBY0MsSUFBM0JIO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQWMsNkJBQVNBO01BQUkseUJBQU87TUFDaENJLEtBQU1ILElBQUFJLEtBQUFBLENBQUlILE1BQUosRUFBWUMsSUFBWkU7TUFDTkMsTUFBTUMsS0FBS0MsTUFBQUEsQ0FBTUosRUFBTkk7TUFDWEosRUFBRUssT0FBQUEsQ0FBQUE7TUFFRlQsT0FBQU07SUFMRk4sQ0FBQUEsSUFBQUE7SUFRQUMsSUFB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QVo4QjtBQUFBQSxNQUFBQTs7O01BQ0UvQyxJQUFBZSxnQkFBQUEsQ0FBQUE7TUFFQWdDLE9BQUEvQyxJQUFBNEMsTUFBQUEsQ0FBSzNCLE1BQUwyQjtJQUhGRyxDQUFBQTtJQU1BLGFBQU0sS0FBTixFQUFVLE1BQVY7SUFDQSxhQUFNLEtBQU4sRUFBVSxNQUFWO0lBQ0EsYUFBTSxNQUFOLEVBQVcsTUFBWDtJQUNBakQsT0FBQSxhQUFNLGFBQU4sRUFBa0IsTUFBbEI7RUFsSEZBLEdBQUFBLFdBQUFBLEVBQWlCd0IsUUFBakJ4QjtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MjkxNzgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwYWdnaW8vZm9ybWF0dGVyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMtLVxuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICAgICAgICAgICAgICAgICAgIFZlcnNpb24gMiwgRGVjZW1iZXIgMjAwNFxuI1xuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICBURVJNUyBBTkQgQ09ORElUSU9OUyBGT1IgQ09QWUlORywgRElTVFJJQlVUSU9OIEFORCBNT0RJRklDQVRJT05cbiNcbiMgIDAuIFlvdSBqdXN0IERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8uXG4jKytcblxucmVxdWlyZSAnc3RyaW5naW8nXG5cbmNsYXNzIFBhZ2dpb1xuXG5jbGFzcyBGb3JtYXR0ZXJcbiAgZGVmIHNlbGYudG9faFxuICAgIEBmb3JtYXR0ZXJzIHx8PSB7fVxuICBlbmRcblxuICBkZWYgc2VsZi5mb3Ioa2xhc3MsICZibG9jaylcbiAgICBpZiBibG9ja1xuICAgICAgdG9faFtrbGFzc10gPSBibG9ja1xuICAgIGVsc2VcbiAgICAgIHRvX2hba2xhc3NdXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLm9wdGlvbnMob3B0aW9ucywgJmJsb2NrKVxuICAgIG9sZCA9IE9QVElPTlMuZHVwXG4gICAgVXRpbHMuZGVlcF9tZXJnZSEoT1BUSU9OUywgb3B0aW9ucylcblxuICAgIHJlc3VsdCA9IGJsb2NrLmNhbGxcblxuICAgIE9QVElPTlMucmVwbGFjZShvbGQpXG5cbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgT1BUSU9OUyA9IHtcbiAgICBpbmRlbnQ6IHtcbiAgICAgIGxldmVsOiAwLFxuICAgICAgd2l0aDogIFwiXFx0XCJcbiAgICB9XG4gIH1cblxuICBkZWYgaW5pdGlhbGl6ZShpbyA9IG5pbCwgb3B0aW9ucyA9IHt9KVxuICAgIGlmIEhhc2ggPT09IGlvXG4gICAgICBAaW8gICAgICA9IFN0cmluZ0lPLm5ld1xuICAgICAgQG9wdGlvbnMgPSBpb1xuICAgIGVsc2VcbiAgICAgIEBpbyAgICAgID0gaW8gfHwgU3RyaW5nSU8ubmV3XG4gICAgICBAb3B0aW9ucyA9IG9wdGlvbnNcbiAgICBlbmRcblxuICAgIEBvcHRpb25zID0gT1BUSU9OUy5tZXJnZShAb3B0aW9ucylcbiAgZW5kXG5cbiAgZGVmIGZvcm1hdChpdGVtKVxuICAgIEZvcm1hdHRlci50b19oLmVhY2gge3xrbGFzcywgYmxvY2t8XG4gICAgICBpZiBrbGFzcyA9PT0gaXRlbVxuICAgICAgICBibG9jay5jYWxsKHNlbGYsIGl0ZW0pXG4gICAgICAgIGJyZWFrXG4gICAgICBlbmRcbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgQGlvLnN0cmluZ1xuICBlbmRcblxuICBkZWYgaW5kZW50PygmYmxvY2spXG4gICAgQG9wdGlvbnNbOmluZGVudF1bOmxldmVsXVxuICByZXNjdWVcbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgaW5kZW50KCZibG9jaylcbiAgICBpZiBpbmRlbnQ/XG4gICAgICBpZiBibG9ja1xuICAgICAgICBAb3B0aW9uc1s6aW5kZW50XVs6bGV2ZWxdICs9IDFcbiAgICAgICAgYmxvY2suY2FsbFxuICAgICAgICBAb3B0aW9uc1s6aW5kZW50XVs6bGV2ZWxdIC09IDFcbiAgICAgIGVsc2VcbiAgICAgICAgQG9wdGlvbnNbOmluZGVudF1bOmxldmVsXSArPSAxXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBibG9jay5jYWxsIGlmIGJsb2NrXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBkZWluZGVudFxuICAgIGlmIGluZGVudD9cbiAgICAgIEBvcHRpb25zWzppbmRlbnRdWzpsZXZlbF0gLT0gMVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgcHJpbnQodGV4dClcbiAgICBpZiBsZXZlbCA9IGluZGVudD9cbiAgICAgIHRleHQubGluZXMuZWFjaCB7fGxpbmV8XG4gICAgICAgIEBpby5wdXRzIFwiI3tAb3B0aW9uc1s6aW5kZW50XVs6d2l0aF0gKiBsZXZlbH0je2xpbmUuY2hvbXB9XCJcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICBAaW8ucHJpbnQgdGV4dFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgZXNjYXBlKHN0cmluZylcbiAgICBzdHJpbmcudG9fcy5nc3ViKC9bXCI+PCddfCYoPyEoW2EtekEtWl0rfCgjXFxkKykpOykvLCB7XG4gICAgICAnJicgPT4gJyZhbXA7JyxcbiAgICAgICc+JyA9PiAnJmd0OycsXG4gICAgICAnPCcgPT4gJyZsdDsnLFxuICAgICAgJ1wiJyA9PiAnJnF1b3Q7JyxcbiAgICAgIFwiJ1wiID0+ICcmIzM5OycgfSlcbiAgZW5kXG5lbmRcblxuRm9ybWF0dGVyLmZvciBIVE1MIGRvIHxmLCBpdGVtfFxuICBjYXNlIGl0ZW0udmVyc2lvblxuICB3aGVuIDVcbiAgICBmLnByaW50ICc8IURPQ1RZUEUgaHRtbD4nXG4gIGVuZFxuXG4gIGYucHJpbnQgJzxodG1sPidcbiAgZi5pbmRlbnQge1xuICAgIGl0ZW0uZWFjaCB7fHJvb3R8XG4gICAgICBmLmZvcm1hdChyb290KVxuICAgIH1cbiAgfVxuICBmLnByaW50ICc8L2h0bWw+J1xuZW5kXG5cbkZvcm1hdHRlci5mb3IgSFRNTDo6RWxlbWVudCBkbyB8ZiwgaXRlbXxcbiAgbmFtZSwgYXR0cmlidXRlcywgY2xhc3NfbmFtZXMgPSBpdGVtLmluc3RhbmNlX2V2YWwge1xuICAgIFtAbmFtZSwgQGF0dHJpYnV0ZXMsIEBjbGFzc19uYW1lc11cbiAgfVxuXG4gIGlmIGF0dHJpYnV0ZXMuZW1wdHk/ICYmIGNsYXNzX25hbWVzLmVtcHR5P1xuICAgIGYucHJpbnQgXCI8I3tuYW1lfT5cIlxuICBlbHNlXG4gICAgYXR0cnMgPSBhdHRyaWJ1dGVzLm1hcCB7fGtleSwgdmFsdWV8XG4gICAgICAlUXsje2YuZXNjYXBlKGtleSl9PVwiI3tmLmVzY2FwZSh2YWx1ZSl9XCJ9XG4gICAgfVxuXG4gICAgdW5sZXNzIGNsYXNzX25hbWVzLmVtcHR5P1xuICAgICAgYXR0cnMgPDwgJVF7Y2xhc3M9XCIje2YuZXNjYXBlKGNsYXNzX25hbWVzLmpvaW4oJyAnKSl9XCJ9XG4gICAgZW5kXG5cbiAgICBmLnByaW50IFwiPCN7bmFtZX0gI3thdHRycy5qb2luKCcgJyl9PlwiXG4gIGVuZFxuXG4gIG5leHQgaWYgJXdbXG4gICAgYXJlYSBiYXNlIGJyIGNvbCBlbWJlZCBociBpbWcgaW5wdXQga2V5Z2VuIGxpbmtcbiAgICBtZW51aXRlbSBtZXRhIHBhcmFtIHNvdXJjZSB0cmFjayB3YnJcbiAgXS5pbmNsdWRlPyhuYW1lLnRvX3MuZG93bmNhc2UpXG5cbiAgZi5pbmRlbnQge1xuICAgIGlmIGlubmVyID0gaXRlbS5pbnN0YW5jZV9ldmFsIHsgQGlubmVyX2h0bWwgfVxuICAgICAgZi5wcmludCBpbm5lclxuICAgIGVsc2VcbiAgICAgIGl0ZW0uZWFjaCB7fGNoaWxkfFxuICAgICAgICBjYXNlIGNoaWxkXG4gICAgICAgIHdoZW4gU3RyaW5nXG4gICAgICAgICAgZi5wcmludCBmLmVzY2FwZShjaGlsZClcblxuICAgICAgICB3aGVuIENTU1xuICAgICAgICAgIGYucHJpbnQgJzxzdHlsZT4nXG4gICAgICAgICAgZi5pbmRlbnQge1xuICAgICAgICAgICAgZi5mb3JtYXQoY2hpbGQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGYucHJpbnQgJzwvc3R5bGU+J1xuXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmLmZvcm1hdChjaGlsZClcbiAgICAgICAgZW5kXG4gICAgICB9XG4gICAgZW5kXG4gIH1cblxuICBmLnByaW50IFwiPC8je25hbWV9PlwiXG5lbmRcblxuRm9ybWF0dGVyLmZvciBDU1M6OkRlZmluaXRpb246OlN0eWxlIGRvIHxmLCBzdHlsZXxcbiAgZi5wcmludCBcIiN7c3R5bGUubmFtZX06ICN7c3R5bGUudmFsdWV9I3snICFpbXBvcnRhbnQnIGlmIHN0eWxlLmltcG9ydGFudH07XCJcbmVuZFxuXG5Gb3JtYXR0ZXIuZm9yIENTUyBkbyB8ZiwgaXRlbXxcbiAgaXRlbS5mb250cy5lYWNoIHt8Zm9udHxcbiAgICBmLnByaW50ICdAZm9udC1mYWNlIHsnXG4gICAgZi5pbmRlbnQge1xuICAgICAgZm9udC5lYWNoIHt8c3R5bGV8XG4gICAgICAgIGYuZm9ybWF0IHN0eWxlXG4gICAgICB9XG4gICAgfVxuICAgIGYucHJpbnQgJ30nXG4gIH1cblxuICBpdGVtLmFuaW1hdGlvbnMuZWFjaCB7fGFuaW1hdGlvbnxcbiAgICBbJycsICctd2Via2l0LScsICctbW96LScsICctby0nXS5lYWNoIHt8cGxhdGZvcm18XG4gICAgICBmLnByaW50IFwiQCN7cGxhdGZvcm19a2V5ZnJhbWVzICN7YW5pbWF0aW9uLm5hbWV9IHtcIlxuICAgICAgYW5pbWF0aW9uLnN0ZXBzLmVhY2gge3xzdGVwfFxuICAgICAgICBmLnByaW50IFwiI3tzdGVwLnZhbHVlfSB7XCJcbiAgICAgICAgc3RlcC5lYWNoIHt8c3R5bGV8XG4gICAgICAgICAgZi5mb3JtYXQgc3R5bGVcbiAgICAgICAgfVxuICAgICAgICBmLnByaW50ICd9J1xuICAgICAgfVxuICAgICAgZi5wcmludCAnfSdcbiAgICB9XG4gIH1cblxuICBpdGVtLnJ1bGVzLnJldmVyc2UuZWFjaCB7fHJ1bGV8XG4gICAgbmV4dCBpZiBydWxlLmVtcHR5P1xuXG4gICAgaWYgbSA9IHJ1bGUubWVkaWFcbiAgICAgIGYucHJpbnQgXCJAbWVkaWEgI3ttfSB7XCJcbiAgICAgIGYuaW5kZW50XG4gICAgZW5kXG5cbiAgICBmLnByaW50IFwiI3tydWxlLnNlbGVjdG9yfSB7XCJcbiAgICBmLmluZGVudCB7XG4gICAgICBydWxlLmVhY2gge3xzdHlsZXxcbiAgICAgICAgZi5mb3JtYXQgc3R5bGVcbiAgICAgIH1cbiAgICB9XG4gICAgZi5wcmludCAnfSdcblxuICAgIGlmIHJ1bGUubWVkaWFcbiAgICAgIGYucHJpbnQgJ30nXG4gICAgICBmLmRlaW5kZW50XG4gICAgZW5kXG4gIH1cbmVuZFxuXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6UGFnZ2lvPiIsIjxjbGFzczpGb3JtYXR0ZXI+IiwidG9faCIsIkBmb3JtYXR0ZXJzIiwiJHJldF9vcl8xIiwiZm9yIiwia2xhc3MiLCJibG9jayIsIltdPSIsIltdIiwib3B0aW9ucyIsIm9sZCIsIk9QVElPTlMiLCJkdXAiLCJVdGlscyIsImRlZXBfbWVyZ2UhIiwicmVzdWx0IiwiY2FsbCIsInJlcGxhY2UiLCIwIiwiaW5pdGlhbGl6ZSIsImlvIiwiSGFzaCIsIkBpbyIsIlN0cmluZ0lPIiwibmV3IiwiQG9wdGlvbnMiLCJtZXJnZSIsImZvcm1hdCIsIml0ZW0iLCJlYWNoIiwiRm9ybWF0dGVyIiwiYmxvY2sgaW4gZm9ybWF0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBmb3JtYXQiLCJ0b19zIiwic3RyaW5nIiwiaW5kZW50PyIsIlN0YW5kYXJkRXJyb3IiLCJpbmRlbnQiLCIkYmluYXJ5X29wX3JlY3ZyX3RtcF8xIiwiKyIsIjEiLCIkYmluYXJ5X29wX3JlY3ZyX3RtcF8yIiwiLSIsIiRiaW5hcnlfb3BfcmVjdnJfdG1wXzMiLCJkZWluZGVudCIsIiRiaW5hcnlfb3BfcmVjdnJfdG1wXzQiLCJwcmludCIsInRleHQiLCJsZXZlbCIsImxpbmVzIiwiYmxvY2sgaW4gcHJpbnQiLCJsaW5lIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwcmludCIsInB1dHMiLCIqIiwiY2hvbXAiLCJlc2NhcGUiLCJnc3ViIiwiSFRNTCIsImJsb2NrIGluIDxjbGFzczpQYWdnaW8+IiwiZiIsInZlcnNpb24iLCI1IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8Y2xhc3M6UGFnZ2lvPiIsImJsb2NrICgzIGxldmVscykgaW4gPGNsYXNzOlBhZ2dpbz4iLCJyb290IiwiYmxvY2sgKDQgbGV2ZWxzKSBpbiA8Y2xhc3M6UGFnZ2lvPiIsIkhUTUw6OkVsZW1lbnQiLCJpbnN0YW5jZV9ldmFsIiwiQG5hbWUiLCJAYXR0cmlidXRlcyIsIkBjbGFzc19uYW1lcyIsIm5hbWUiLCJhdHRyaWJ1dGVzIiwiY2xhc3NfbmFtZXMiLCJlbXB0eT8iLCJhdHRycyIsIm1hcCIsImtleSIsInZhbHVlIiwiPDwiLCJqb2luIiwiaW5jbHVkZT8iLCJkb3duY2FzZSIsImlubmVyIiwiQGlubmVyX2h0bWwiLCJjaGlsZCIsIlN0cmluZyIsIkNTUyIsImJsb2NrICg1IGxldmVscykgaW4gPGNsYXNzOlBhZ2dpbz4iLCJDU1M6OkRlZmluaXRpb246OlN0eWxlIiwiQ1NTOjpEZWZpbml0aW9uIiwic3R5bGUiLCJpbXBvcnRhbnQiLCJmb250cyIsImZvbnQiLCJhbmltYXRpb25zIiwiYW5pbWF0aW9uIiwicGxhdGZvcm0iLCJzdGVwcyIsInN0ZXAiLCJibG9jayAoNiBsZXZlbHMpIGluIDxjbGFzczpQYWdnaW8+IiwicnVsZXMiLCJyZXZlcnNlIiwicnVsZSIsIm0iLCJtZWRpYSIsInNlbGVjdG9yIl0sIm1hcHBpbmdzIjoiQUFBQUEsbUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBVUFDLElBQUFDLFNBQUFBLENBQVFGLFVBQVJFO0VBRUFGLE9BQUFHO0VBQUFBOztJQUFBQTs7O0lBRUFDO0lBQUFBOztNQUFBQTs7QUFBQUE7O01BQ0VDLE1BQUlK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cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9wYWdnaW8ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIy0tXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgICAgICAgICAgICAgICAgICAgVmVyc2lvbiAyLCBEZWNlbWJlciAyMDA0XG4jXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBDT1BZSU5HLCBESVNUUklCVVRJT04gQU5EIE1PRElGSUNBVElPTlxuI1xuIyAgMC4gWW91IGp1c3QgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTy5cbiMrK1xuXG5yZXF1aXJlICdwYWdnaW8vdXRpbHMnXG5yZXF1aXJlICdwYWdnaW8vaHRtbCdcbnJlcXVpcmUgJ3BhZ2dpby9jc3MnXG5yZXF1aXJlICdwYWdnaW8vZm9ybWF0dGVyJ1xuXG5jbGFzcyBQYWdnaW9cbiAgZGVmIHNlbGYub3B0aW9ucyhvcHRpb25zLCAmYmxvY2spXG4gICAgRm9ybWF0dGVyLm9wdGlvbnMob3B0aW9ucywgJmJsb2NrKVxuICBlbmRcblxuICBkZWYgc2VsZi5pbmRlbnQob3B0aW9ucywgJmJsb2NrKVxuICAgIG9wdGlvbnMoaW5kZW50OiBvcHRpb25zLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNzcygqYXJncywgJmJsb2NrKVxuICAgIEZvcm1hdHRlci5uZXcuZm9ybWF0KENTUy5uZXcoKmFyZ3MsICZibG9jaykpLnRvX3NcbiAgZW5kXG5cbiAgZGVmIHNlbGYuaHRtbCgqYXJncywgJmJsb2NrKVxuICAgIEZvcm1hdHRlci5uZXcuZm9ybWF0KEhUTUwubmV3KCphcmdzLCAmYmxvY2spKS50b19zXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmh0bWwhKCZibG9jaylcbiAgICBGb3JtYXR0ZXIubmV3LnRhcCB7fGZ8XG4gICAgICBIVE1MLm5ldygmYmxvY2spLmVhY2gge3xyb290fFxuICAgICAgICBmLmZvcm1hdCByb290XG4gICAgICB9XG4gICAgfS50b19zXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOlBhZ2dpbz4iLCJvcHRpb25zIiwiRm9ybWF0dGVyIiwiYmxvY2siLCJ0b19wcm9jIiwiaW5kZW50IiwiY3NzIiwibmV3IiwiZm9ybWF0IiwiQ1NTIiwiYXJncyIsInRvX3MiLCJodG1sIiwiSFRNTCIsImh0bWwhIiwidGFwIiwiYmxvY2sgaW4gaHRtbCEiLCJmIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBodG1sISIsImVhY2giLCJyb290IiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiBodG1sISJdLCJtYXBwaW5ncyI6IkFBQUFBLHlCQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQVVBQyxJQUFBQyxTQUFBQSxDQUFRRixjQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixhQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixZQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixrQkFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOzs7SUFDRUMsTUFBSUgsSUFBSkcsY0FBQUEsbUJBQWlCQSxPQUFqQkE7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFDRUEsT0FBU0EsTUFBVEMsZUFBU0QsV0FBQUEsRUFBQUEsQ0FBU0EsT0FBVEEsQ0FBQUEsRUFBbUJFLEtBQURDLFNBQUFBLENBQUFBLENBQWxCSDtJQURYQSxDQUFBQTtJQUlBSSxNQUFJUCxJQUFKTyxhQUFBQSxrQkFBZ0JKLE9BQWhCSTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUNFQSxPQUFBSixNQUFBSCxJQUFBRyxXQUFBQSxFQUFBQSxDQUFRLFVBQUEsU0FBQSxFQUFRQSxPQUFSLENBQUEsR0FBUkEsQ0FBQUEsRUFBMEJFLEtBQURDLFNBQUFBLENBQUFBLENBQXpCSDtJQURGSSxDQUFBQTtJQUlBQyxNQUFJUixJQUFKUSxVQUFBQSxlQXhCRixFQXdCRUE7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUF4QkY7TUF3QmU7TUFDWEEsT0FBQUosZUFBU0ssS0FBQUEsQ0FBQUEsQ0FBSUMsUUFBQUEsQ0FBV0QsTUFBSEUsU0FBR0YsT0FBQUEsRUFBSyxNQUFDRyxJQUFELENBQUxILEVBQWFKLEtBQURDLFNBQUFBLENBQUFBLENBQVpHLENBQVhDLENBQStCRyxNQUFBQSxDQUFBQTtJQUQ5Q0wsQ0FBQUEsSUFBQUE7SUFJQU0sTUFBSWQsSUFBSmMsV0FBQUEsZ0JBNUJGLEVBNEJFQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQTVCRjtNQTRCZ0I7TUFDWkEsT0FBQVYsZUFBU0ssS0FBQUEsQ0FBQUEsQ0FBSUMsUUFBQUEsQ0FBWUQsTUFBSk0sVUFBSU4sT0FBQUEsRUFBSyxNQUFDRyxJQUFELENBQUxILEVBQWFKLEtBQURDLFNBQUFBLENBQUFBLENBQVpHLENBQVpDLENBQWdDRyxNQUFBQSxDQUFBQTtJQUQvQ0MsQ0FBQUEsSUFBQUE7SUFJQVosT0FBQWMsTUFBSWhCLElBQUpnQixZQUFBQSw2QkFBQUE7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFDRUEsT0FBYUMsTUFBYmIsZUFBU0ssS0FBQUEsQ0FBQUEsQ0FBSVEsT0FBQUEsRUFBQUEsRUFBQUEsRUFBYkMsYUFBb0JDLENBQXBCRDs7UUFBb0I7UUFDbEJFLE9BQWdCQyxNQUFaWixNQUFKTSxVQUFJTixPQUFBQSxFQUFBQSxFQUFBQSxFQUFNSixLQUFEQyxTQUFBQSxDQUFBQSxDQUFMRyxDQUFZWSxRQUFBQSxFQUFBQSxFQUFBQSxFQUFoQkQsYUFBd0JFLElBQXhCRjs7VUFBd0I7VUFDdEJHLE9BQUFKLENBQUNULFFBQUFBLENBQVFZLElBQVJaLEVBREhVLENBQWdCQyxFQURsQkgsQ0FBYUQsQ0FJWkosTUFBQUEsQ0FBQUE7SUFMSEcsQ0FBQUE7RUFqQkZkLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBZkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyOTU1NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvdmVyc2lvbi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlclxuICBWRVJTSU9OID0gJzAuMy4zJ1xuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iXSwibWFwcGluZ3MiOiJBQUFBQSxrQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQ0VBLE9BQUEsbUNBQVVBLE9BQVY7RUFERkEsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI5NTY5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci91dGlscy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlclxuICBQcm9taXNlID0gZGVmaW5lZD8oUHJvbWlzZVYyKSA/IFByb21pc2VWMiA6IDo6UHJvbWlzZVxuXG4gIFNpemUgICAgID0gU3RydWN0Lm5ldyg6d2lkdGgsIDpoZWlnaHQpXG4gIFBvc2l0aW9uID0gU3RydWN0Lm5ldyg6eCwgOnkpXG5cbiAgIyB7QnJvd3Nlcjo6TmF0aXZlQ2FjaGVkV3JhcHBlcn0gaXMgYSBzcGVjaWFsIGNhc2Ugb2Yge05hdGl2ZTo6V3JhcHBlcn0uXG4gICNcbiAgIyBXaGF0IHRoaXMgbW9kdWxlIGRvZXMgaXMgaXQgbWFrZXMgc3VyZSB0aGF0IHlvdXIgUnVieSBvYmplY3RzXG4gICMgYXJlIG1hcHBlZCAxOjEgdG8geW91ciBKYXZhc2NyaXB0IG9iamVjdHMuIFNvIHRoYXQgZm9yIGluc3RhbmNlXG4gICMgeW91ciBgJGRvY3VtZW50LmF0X2NzcygnYm9keScpYCBpcyBhbHdheXMgdGhlIHNhbWUgUnVieSBvYmplY3QuXG4gICNcbiAgIyBZb3UgY2FuIG9ubHkgdXNlIGl0IGlmIHlvdXIgZmluYWwgYC5uZXdgIGlzIG9mIHRoZSBzaWduYXR1cmVcbiAgIyBgLm5ldyhuYXRpdmUpYCBhbmQgeW91ciBuYXRpdmUgKHByb2JhYmx5IERPTSkgb2JqZWN0IHBlcnNpc3RzIGFuZFxuICAjIGRvZXNuJ3QgbWluZCBhcmJpdHJhcnkgcHJvcGVydGllcy5cbiAgI1xuICAjIFRoZSBydWxlIG9mIHRodW1iIGlzOiBpZiBpdCBkb2VzIG92ZXJsb2FkIGAjaW5pdGlhbGl6ZWAncyBzaWduYXR1cmVcbiAgIyBhbmQgbm90IGAubmV3YCdzIC0gaXQgd29uJ3Qgd29yay4gVXNlIHtOYXRpdmU6OldyYXBwZXJ9IGluIHRoaXMgY2FzZS5cbiAgbW9kdWxlIE5hdGl2ZUNhY2hlZFdyYXBwZXJcbiAgICBkZWYgc2VsZi5pbmNsdWRlZChrbGFzcylcbiAgICAgIGtsYXNzLmluY2x1ZGUgTmF0aXZlOjpXcmFwcGVyXG4gICAgICBrbGFzcy5leHRlbmQgTmF0aXZlQ2FjaGVkV3JhcHBlckNsYXNzTWV0aG9kc1xuICAgIGVuZFxuXG4gICAgZGVmIHJlc3RyaWN0ZWQ/XG4gICAgICAhIUByZXN0cmljdGVkXG4gICAgZW5kXG5cbiAgICAjIENoYW5nZSBhIG5hdGl2ZSByZWZlcmVuY2UgYW5kIG1ha2Ugc3VyZSB0aGUgY2hhbmdlIGlzIHJlZmxlY3RlZCBvbiBKU1xuICAgICMgc2lkZSBhcyB3ZWxsLiBUaGlzIG1ldGhvZCBpcyB1c2VkIGJ5IE5vZGUjaW5pdGlhbGl6ZV9jb3B5LiBQbGVhc2UgZG9uJ3RcbiAgICAjIHVzZSB0aGlzIG1ldGhvZCBvdXRzaWRlIG9mIHRoZSBjbG9uaW5nIHNlbWFudGljLlxuICAgIGRlZiBzZXRfbmF0aXZlX3JlZmVyZW5jZShuYXRpdmUpXG4gICAgICBgI3tuYXRpdmV9LiQkb3BhbF9uYXRpdmVfY2FjaGVkID0gI3tzZWxmfWBcbiAgICAgIEBuYXRpdmUgPSBuYXRpdmVcbiAgICBlbmRcbiAgZW5kXG5cbiAgbW9kdWxlIE5hdGl2ZUNhY2hlZFdyYXBwZXJDbGFzc01ldGhvZHNcbiAgICAjIENoZWNrIGlmIHdlIGRvbid0IGhhdmUgYWNjZXNzIHRvIGFyYml0cmFyeSBwcm9wZXJ0aWVzIG9mIGEgKHByZXN1bWFibHkpXG4gICAgIyBuYXRpdmUgb2JqZWN0LlxuICAgIHByaXZhdGUgZGVmIHJlc3RyaWN0ZWQ/KG5hdGl2ZSlcbiAgICAgICV4e1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHR5cGVvZigje25hdGl2ZX0uJCR0cnlfcmVzdHJpY3RlZF9hY2Nlc3MpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGUubmFtZSA9PSAnU2VjdXJpdHlFcnJvcicpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGRlZiBuZXcobmF0aXZlKVxuICAgICAgIyBXZSBjYW4ndCBhY2Nlc3MgYXJiaXRyYXJ5IHByb3BlcnRpZXMgaWYgYW4gZWxlbWVudCBpcyByZXN0cmljdGVkXG4gICAgICAjIGkuZS4gdGhlIERPTSBlbGVtZW50IGlzIGFuIGl0ZW0gd2UgY2FuJ3QgZnVsbHkgYWNjZXNzIGR1ZSB0byBDT1JTLlxuICAgICAgaWYgcmVzdHJpY3RlZD8obmF0aXZlKVxuICAgICAgICAjIExldCdzIHRyeSB0byBieXBhc3MgYW55IGZ1cnRoZXIgaW5pdGlhbGl6ZXJzLi4uIG1heSBiZSB1Z2x5LCBidXRcbiAgICAgICAgIyB3b3Jrcy5cbiAgICAgICAgb2JqID0gYWxsb2NhdGVcbiAgICAgICAgb2JqLmluc3RhbmNlX3ZhcmlhYmxlX3NldCA6QG5hdGl2ZSwgbmF0aXZlXG4gICAgICAgIG9iai5pbnN0YW5jZV92YXJpYWJsZV9zZXQgOkByZXN0cmljdGVkLCB0cnVlXG4gICAgICAgIHJldHVybiBvYmpcbiAgICAgIGVuZFxuXG4gICAgICAjIEl0J3Mgbm90IGEgbmF0aXZlIGVsZW1lbnQ/IFdlaXJkLCBiZXR0ZXIgdGhyb3cgYW4gZXhjZXB0aW9uLlxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciBpZiAhbmF0aXZlPyhuYXRpdmUpXG5cbiAgICAgIGlmIGRlZmluZWQ/IGAje25hdGl2ZX0uJCRvcGFsX25hdGl2ZV9jYWNoZWRgXG4gICAgICAgIGAje25hdGl2ZX0uJCRvcGFsX25hdGl2ZV9jYWNoZWRgXG4gICAgICBlbHNlXG4gICAgICAgIGAje25hdGl2ZX0uJCRvcGFsX25hdGl2ZV9jYWNoZWQgPSAje3N1cGVyKG5hdGl2ZSl9YFxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmNsYXNzIE9iamVjdFxuICAjIEVuY29kZSBhcyBVUkkuXG4gICNcbiAgIyBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIEZvcm1EYXRhLmVuY29kZV91cmlcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSB7T2JqZWN0I3RvX3N9IGVuY29kZWQgZm9yIHVzYWdlIGFzIFVSSVxuICBkZWYgZW5jb2RlX3VyaVxuICAgIHdhcm4gXCJvcGFsLWJyb3dzZXI6IE9iamVjdCNlbmNvZGVfdXJpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgRm9ybURhdGEuZW5jb2RlX3VyaVwiXG4gICAgRm9ybURhdGEuZW5jb2RlX3VyaSh0b19zKVxuICBlbmRcblxuICAjIEVuY29kZSBhcyBVUkkgY29tcG9uZW50LlxuICAjXG4gICMgQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBGb3JtRGF0YS5lbmNvZGVcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSB7T2JqZWN0I3RvX3N9IGVuY29kZWQgZm9yIHVzYWdlIGFzIFVSSSBjb21wb25lbnRcbiAgZGVmIGVuY29kZV91cmlfY29tcG9uZW50XG4gICAgd2FybiBcIm9wYWwtYnJvd3NlcjogT2JqZWN0I2VuY29kZV91cmlfY29tcG9uZW50IGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgRm9ybURhdGEuZW5jb2RlXCJcbiAgICBGb3JtRGF0YS5lbmNvZGUodG9fcylcbiAgZW5kXG5lbmRcblxuY2xhc3MgU3RyaW5nXG4gICMgRW5jb2RlIGFzIFVSSSBjb21wb25lbnQuXG4gICNcbiAgIyBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIEZvcm1EYXRhLmVuY29kZVxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIHN0cmluZyBlbmNvZGVkIGZvciB1c2FnZSBhcyBVUkkgY29tcG9uZW50XG4gIGRlZiBlbmNvZGVfdXJpX2NvbXBvbmVudFxuICAgIHdhcm4gXCJvcGFsLWJyb3dzZXI6IFN0cmluZyNlbmNvZGVfdXJpX2NvbXBvbmVudCBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIEZvcm1EYXRhLmVuY29kZVwiXG4gICAgRm9ybURhdGEuZW5jb2RlKHNlbGYpXG4gIGVuZFxuXG4gICMgRW5jb2RlIGFzIFVSSS5cbiAgI1xuICAjIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgRm9ybURhdGEuZW5jb2RlX3VyaVxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIHN0cmluZyBlbmNvZGVkIGFzIFVSSVxuICBkZWYgZW5jb2RlX3VyaVxuICAgIHdhcm4gXCJvcGFsLWJyb3dzZXI6IFN0cmluZyNlbmNvZGVfdXJpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgRm9ybURhdGEuZW5jb2RlX3VyaVwiXG4gICAgRm9ybURhdGEuZW5jb2RlX3VyaShzZWxmKVxuICBlbmRcblxuICAjIERlY29kZSBhcyBVUkkgY29tcG9uZW50LlxuICAjXG4gICMgQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBGb3JtRGF0YS5kZWNvZGVcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBzdHJpbmcgZGVjb2RlZCBhcyBVUkkgY29tcG9uZW50XG4gIGRlZiBkZWNvZGVfdXJpX2NvbXBvbmVudFxuICAgIHdhcm4gXCJvcGFsLWJyb3dzZXI6IFN0cmluZyNkZWNvZGVfdXJpX2NvbXBvbmVudCBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIEZvcm1EYXRhLmRlY29kZVwiXG4gICAgRm9ybURhdGEuZGVjb2RlKHNlbGYpXG4gIGVuZFxuXG4gICMgRGVjb2RlIGFzIFVSSS5cbiAgI1xuICAjIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgRm9ybURhdGEuZGVjb2RlX3VyaVxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIHN0cmluZyBkZWNvZGVkIGFzIFVSSVxuICBkZWYgZGVjb2RlX3VyaVxuICAgIHdhcm4gXCJvcGFsLWJyb3dzZXI6IFN0cmluZyNkZWNvZGVfdXJpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgRm9ybURhdGEuZGVjb2RlX3VyaVwiXG4gICAgRm9ybURhdGEuZGVjb2RlX3VyaShzZWxmKVxuICBlbmRcbmVuZFxuXG5jbGFzcyBIYXNoXG4gICMgRGVjb2RlIGFuIFVSTCBlbmNvZGVkIGZvcm0gdG8gYSB7SGFzaH0uXG4gICNcbiAgIyBAcGFyYW0gc3RyaW5nIFtTdHJpbmddIHRoZSBVUkwgZW5jb2RlZCBmb3JtXG4gICNcbiAgIyBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIEZvcm1EYXRhLnBhcnNlX3F1ZXJ5XG4gICMgQHJldHVybiBbSGFzaF1cbiAgZGVmIHNlbGYuZGVjb2RlX3VyaShzdHJpbmcpXG4gICAgd2FybiBcIm9wYWwtYnJvd3NlcjogSGFzaC5kZWNvZGVfdXJpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgRm9ybURhdGEucGFyc2VfcXVlcnlcIlxuICAgIEZvcm1EYXRhLnBhcnNlX3F1ZXJ5KHN0cmluZylcbiAgZW5kXG5cbiAgIyBFbmNvZGUgdGhlIEhhc2ggdG8gYW4gVVJMIGZvcm0uXG4gICNcbiAgIyBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIEZvcm1EYXRhLmJ1aWxkX3F1ZXJ5XG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgVVJMIGVuY29kZWQgZm9ybVxuICBkZWYgZW5jb2RlX3VyaVxuICAgIHdhcm4gXCJvcGFsLWJyb3dzZXI6IEhhc2gjZW5jb2RlX3VyaSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIEZvcm1EYXRhLmJ1aWxkX3F1ZXJ5XCJcbiAgICBGb3JtRGF0YS5idWlsZF9xdWVyeShzZWxmKVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiUHJvbWlzZVYyIiwiUHJvbWlzZSIsIlN0cnVjdCIsIm5ldyIsIjxtb2R1bGU6TmF0aXZlQ2FjaGVkV3JhcHBlcj4iLCJpbmNsdWRlZCIsInNlbGYiLCJrbGFzcyIsImluY2x1ZGUiLCJOYXRpdmU6OldyYXBwZXIiLCJOYXRpdmUiLCJleHRlbmQiLCJOYXRpdmVDYWNoZWRXcmFwcGVyQ2xhc3NNZXRob2RzIiwicmVzdHJpY3RlZD8iLCJAcmVzdHJpY3RlZCIsIiEiLCJzZXRfbmF0aXZlX3JlZmVyZW5jZSIsIm5hdGl2ZSQiLCJAbmF0aXZlIiwiPG1vZHVsZTpOYXRpdmVDYWNoZWRXcmFwcGVyQ2xhc3NNZXRob2RzPiIsInByaXZhdGUiLCJvYmoiLCJhbGxvY2F0ZSIsImluc3RhbmNlX3ZhcmlhYmxlX3NldCIsIm5hdGl2ZT8iLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCI8Y2xhc3M6T2JqZWN0PiIsImVuY29kZV91cmkiLCJ3YXJuIiwiRm9ybURhdGEiLCJ0b19zIiwiZW5jb2RlX3VyaV9jb21wb25lbnQiLCJlbmNvZGUiLCI8Y2xhc3M6U3RyaW5nPiIsImRlY29kZV91cmlfY29tcG9uZW50IiwiZGVjb2RlIiwiZGVjb2RlX3VyaSIsIjxjbGFzczpIYXNoPiIsInN0cmluZyIsInBhcnNlX3F1ZXJ5IiwiYnVpbGRfcXVlcnkiXSwibWFwcGluZ3MiOiJBQUFBQSxnQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUM7RUFBQUE7O0lBQUFBOzs7SUFDRSxtQ0FBVSxDQUFBLFFBQUEsQ0FBQSxvQ0FBQSxvQkFBQSxDQUFBLEdBQUEsQ0FBc0JDLGVBQXRCLElBQUEsQ0FBa0NDLGNBQWxDLENBQUEsQ0FBVjtJQUVBLGdDQUFXQyxZQUFNQyxLQUFBQSxDQUFLLE9BQVgsRUFBbUIsUUFBYkEsQ0FBakI7SUFDQSxvQ0FBV0QsWUFBTUMsS0FBQUEsQ0FBSyxHQUFYLEVBQWUsR0FBVEEsQ0FBakI7SUFjQUM7SUFBQUE7O01BQUFBOzs7TUFDRUMsTUFBSUMsSUFBSkQsZUFBQUEsb0JBQWtCRSxLQUFsQkY7QUFBQUE7O1FB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QUFBdUIsTUFBQUEsQ0FBS1EsK0VBQUxSO01BQ0FRLE9BQUFQLGNBQVFPLFlBQUFBLENBQVkvQixJQUFaK0I7SUFGVkEsQ0FBQUE7RUFoQ0ZILEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBc0NBcEMsT0FBQXdDO0VBQUFBOztJQUFBQTs7O0lBT0VELE1BQUkvQixJQUFKK0IsaUJBQUFBLHNCQUFvQkUsTUFBcEJGO0FBQUFBLE1BQUFBOzs7TUFDRS9CLElBQUF1QixNQUFBQSxDQUFLUSw4RUFBTFI7TUFDQVEsT0FBQVAsY0FBUVUsYUFBQUEsQ0FBYUQsTUFBYkM7SUFGVkgsQ0FBQUE7SUFTQUMsT0FBQVYsMEJBQUFBLHNCQUFBQTtBQUFBQSxNQUFBQTs7O01BQ0V0QixJQUFBdUIsTUFBQUEsQ0FBS0QsOEVBQUxDO01BQ0FELE9BQUFFLGNBQVFXLGFBQUFBLENBQWFuQyxJQUFibUM7SUFGVmIsQ0FBQUE7RUFoQkZVLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBcklBeEM7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI5NzMzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9mb3JtX2RhdGEucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXJcblxuY2xhc3MgRm9ybURhdGFcbiAgaW5jbHVkZSBOYXRpdmVDYWNoZWRXcmFwcGVyXG5cbiAgbW9kdWxlIENvbnZlcnRlclxuICAgICMgRW5jb2RlIGFzIFVSSSBjb21wb25lbnQuXG4gICAgI1xuICAgICMgQHJldHVybiBbU3RyaW5nXSB0aGUgc3RyaW5nIGVuY29kZWQgZm9yIHVzYWdlIGFzIFVSSSBjb21wb25lbnRcbiAgICBkZWYgZW5jb2RlKHN0cmluZylcbiAgICAgIGBlbmNvZGVVUklDb21wb25lbnQoI3tzdHJpbmd9KWBcbiAgICBlbmRcblxuICAgICMgRGVjb2RlIGFzIFVSSSBjb21wb25lbnQuXG4gICAgI1xuICAgICMgQHJldHVybiBbU3RyaW5nXSB0aGUgc3RyaW5nIGRlY29kZWQgYXMgVVJJIGNvbXBvbmVudFxuICAgIGRlZiBkZWNvZGUoc3RyaW5nKVxuICAgICAgYGRlY29kZVVSSUNvbXBvbmVudCgje3N0cmluZ30pYFxuICAgIGVuZFxuXG4gICAgIyBFbmNvZGUgYXMgVVJJLlxuICAgICNcbiAgICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIHN0cmluZyBlbmNvZGVkIGFzIFVSSVxuICAgIGRlZiBlbmNvZGVfdXJpKHN0cmluZylcbiAgICAgIGBlbmNvZGVVUkkoI3tzdHJpbmd9KWBcbiAgICBlbmRcblxuICAgICMgRGVjb2RlIGFzIFVSSS5cbiAgICAjXG4gICAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBzdHJpbmcgZGVjb2RlZCBhcyBVUklcbiAgICBkZWYgZGVjb2RlX3VyaShzdHJpbmcpXG4gICAgICBgZGVjb2RlVVJJKCN7c3RyaW5nfSlgXG4gICAgZW5kXG5cbiAgICAjIEZsYXR0ZW5zIGEgaGFzaCB0byBidWlsZCBhIGZsYXQgYXJyYXksIGxhdGVyIHRvIGJlIGZvcm1hdHRlZCB0b1xuICAgICMgcHJvZHVjZSBhIG5lc3RlZCBxdWVyeS5cbiAgICAjXG4gICAgIyBUaGlzIGNvZGUgc2hvdWxkIGJlIGNvbXBhdGlibGUgd2l0aCB3aGF0IFJhY2s6OlV0aWxzI2J1aWxkX25lc3RlZF9xdWVyeSBbMV1cbiAgICAjIGRvZXMuXG4gICAgI1xuICAgICMgWzFdIGh0dHBzOi8vZ2l0aHViLmNvbS9yYWNrL3JhY2svYmxvYi9tYXN0ZXIvbGliL3JhY2svdXRpbHMucmJcbiAgICBkZWYgZmxhdHRlbih2YWx1ZSwga2V5PVwiXCIpXG4gICAgICBjYXNlIHZhbHVlXG4gICAgICB3aGVuIEhhc2hcbiAgICAgICAgb3V0ID0gW11cbiAgICAgICAgdmFsdWUuZWFjaCBkbyB8ayx2fFxuICAgICAgICAgIGsgPSBcIiN7a2V5fVsje2t9XVwiIGlmIGtleSAhPSAnJ1xuICAgICAgICAgIG91dCArPSBmbGF0dGVuKHYsaylcbiAgICAgICAgZW5kXG4gICAgICAgIG91dFxuICAgICAgd2hlbiBBcnJheVxuICAgICAgICBvdXQgPSBbXVxuICAgICAgICB2YWx1ZS5lYWNoIGRvIHx2fFxuICAgICAgICAgIGsgPSBcIiN7a2V5fVtdXCJcbiAgICAgICAgICBvdXQgKz0gZmxhdHRlbih2LGspXG4gICAgICAgIGVuZFxuICAgICAgICBvdXRcbiAgICAgIGVsc2VcbiAgICAgICAgW1trZXksdmFsdWVdXVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAjIENvbnZlcnRzIGEgZmxhdCBhcnJheSB0byBhIEhhc2guXG4gICAgI1xuICAgICMgVGhpcyBjb2RlIHNob3VsZCBiZSBjb21wYXRpYmxlIHdpdGggd2hhdCBSYWNrOjpVdGlscyNwYXJzZV9uZXN0ZWRfcXVlcnkgWzFdXG4gICAgIyBkb2VzLlxuICAgICNcbiAgICAjIFsxXSBodHRwczovL2dpdGh1Yi5jb20vcmFjay9yYWNrL2Jsb2IvbWFzdGVyL2xpYi9yYWNrL3V0aWxzLnJiXG4gICAgZGVmIHVuZmxhdHRlbihhcnJheSlcbiAgICAgIG91dCA9IHt9XG4gICAgICBhcnJheS5lYWNoIGRvIHxrLHZ8XG4gICAgICAgIHBhdGggPSBbay5zcGxpdChcIltcIikuZmlyc3RdICsgay5zY2FuKC9cXFsoLio/KVxcXS8pLmZsYXR0ZW5cbiAgICAgICAgYyA9IG91dFxuXG4gICAgICAgIHNldCA9IHByb2MgeyB8dix3ZWFrfCB9ICMgRG8gbm90aGluZyBmb3IgdGhlIGZpcnN0IGxldmVsXG5cbiAgICAgICAgcGF0aC5lYWNoIGRvIHxpfFxuICAgICAgICAgIGNhc2UgaVxuICAgICAgICAgIHdoZW4gXCJcIiAjIEFycmF5XG4gICAgICAgICAgICBzZXQuKFtdLCB0cnVlKVxuICAgICAgICAgICAgc2V0ID0gcHJvYyBkbyB8dix3ZWFrfFxuICAgICAgICAgICAgICBjIDw8IHZcbiAgICAgICAgICAgICAgYyA9IGMubGFzdFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZSAjIEhhc2hcbiAgICAgICAgICAgIHNldC4oe30sIHRydWUpXG4gICAgICAgICAgICBzZXQgPSBwcm9jIGRvIHx2LHdlYWt8XG4gICAgICAgICAgICAgIGNbaV0gfHw9IHZcbiAgICAgICAgICAgICAgY1tpXSA9IHYgaWYgIXdlYWtcbiAgICAgICAgICAgICAgYyA9IGNbaV1cbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgICAgc2V0Lih2LCBmYWxzZSlcblxuICAgICAgZW5kXG4gICAgICBvdXRcbiAgICBlbmRcblxuICAgICMgQ2hlY2tzIGlmIGEgcXVlcnkgSGFzaCBjb250YWlucyBhbnkgZmlsZXMuXG4gICAgZGVmIGNvbnRhaW5fZmlsZXM/KGhhc2gpXG4gICAgICBmbGF0dGVuKGhhc2gpLmFueT8geyB8ayx2fCBbRmlsZSwgQmxvYl0uaW5jbHVkZT8odi5jbGFzcykgfVxuICAgIGVuZFxuXG4gICAgIyBDb252ZXJ0IGEgcXVlcnkgSGFzaCB0byBhIHF1ZXJ5IHN0cmluZ1xuICAgICNcbiAgICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIHN0cmluZyBlbmNvZGVkIGFzIFVSSVxuICAgIGRlZiBidWlsZF9xdWVyeShoYXNoLCBzZXA9PyYpXG4gICAgICBmbGF0dGVuKGhhc2gpLm1hcCB7IHxrLHZ8IGVuY29kZShrKSArID89ICsgZW5jb2RlKHYudG9fcykgfS5qb2luKHNlcClcbiAgICBlbmRcblxuICAgICMgQ29udmVydCBhIHF1ZXJ5IEhhc2ggdG8gYSBGb3JtRGF0YSBpbnN0YW5jZVxuICAgICNcbiAgICAjIEByZXR1cm4gW0Zvcm1EYXRhXSB0aGUgaW5zdGFuY2Ugb2YgRm9ybURhdGFcbiAgICBkZWYgYnVpbGRfZm9ybV9kYXRhKGhhc2gpXG4gICAgICBmZCA9IEZvcm1EYXRhLmNyZWF0ZVxuICAgICAgZmxhdHRlbihoYXNoKS5lYWNoIHsgfGssdnwgZmQgPDwgW2ssdl0gfVxuICAgICAgZmRcbiAgICBlbmRcblxuICAgICMgQ29udmVydCBhIHF1ZXJ5IHN0cmluZyB0byBhIHF1ZXJ5IEhhc2hcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtIYXNoXSB0aGUgcXVlcnkgaGFzaFxuICAgIGRlZiBwYXJzZV9xdWVyeShzdHJpbmcsIHNlcD0/JilcbiAgICAgIHVuZmxhdHRlbihzdHJpbmcuc3BsaXQoc2VwKS5tYXAgeyB8c3wgcy5zcGxpdCg/PSkubWFwKCZtZXRob2QoOmRlY29kZSkpIH0pXG4gICAgZW5kXG5cbiAgICAjIENvbnZlcnRzIGEgSlMgbmF0aXZlIHZhbHVlIHRvIGEgd3JhcHBlZCBvbmUgaWYgcG9zc2libGUuXG4gICAgI1xuICAgICMgQHJldHVybiBbU3RyaW5nLCBGaWxlLCBCbG9iXVxuICAgIGRlZiBmcm9tX25hdGl2ZShuKVxuICAgICAgJXh7XG4gICAgICAgIHZhciBjID0gI3tufS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgaWYgKGMgPT09IEZpbGUpIHtcbiAgICAgICAgICAje24gPSBGaWxlLm5ldyhuKX1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjID09PSBCbG9iKSB7XG4gICAgICAgICAgI3tuID0gQmxvYi5uZXcobil9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5cbiAgICBlbmRcbiAgZW5kXG5cbiAgZXh0ZW5kIENvbnZlcnRlclxuICBpbmNsdWRlIEVudW1lcmFibGVcblxuICAjIENyZWF0ZSBhIG5ldyBGb3JtRGF0YSBpbnN0YW5jZVxuICBkZWYgc2VsZi5jcmVhdGUoaGFzaD1uaWwpXG4gICAgaWYgSGFzaCA9PT0gaGFzaFxuICAgICAgRm9ybURhdGEuYnVpbGRfZm9ybV9kYXRhKGhhc2gpXG4gICAgZWxzaWYgRE9NOjpFbGVtZW50OjpGb3JtID09PSBoYXNoXG4gICAgICBuZXcoYG5ldyBGb3JtRGF0YSgje2hhc2gudG9fbn0pYClcbiAgICBlbHNlXG4gICAgICBuZXcoYG5ldyBGb3JtRGF0YSgpYClcbiAgICBlbmRcbiAgZW5kXG5cbiAgIyBBcHBlbmQgYSB0dXBsZSB0byB0aGlzIEZvcm1EYXRhIGluc3RhbmNlXG4gICNcbiAgIyBAcGFyYW0gdHVwbGUgW0FycmF5KFN0cmluZywgU3RyaW5nKSwgQXJyYXkoU3RyaW5nLCBCbG9iKSwgQXJyYXkoU3RyaW5nLCBGaWxlKSxcbiAgIyAgICAgICAgICAgICAgIEFycmF5KFN0cmluZywgQmxvYiwgU3RyaW5nKSwgQXJyYXkoU3RyaW5nLCBGaWxlLCBTdHJpbmcpXVxuICAjICAgICAgICBhIHR1cGxlIG9mIGEga2V5LCB2YWx1ZSBhbmQgcG9zc2libHkgYSBmaWxlbmFtZVxuICBkZWYgPDwodHVwbGUpXG4gICAga2V5LCB2YWx1ZSwgZmlsZW5hbWUgPSB0dXBsZVxuXG4gICAgdW5sZXNzIGZpbGVuYW1lXG4gICAgICBgI0BuYXRpdmUuYXBwZW5kKCN7a2V5fSwgI3tOYXRpdmUuY29udmVydCh2YWx1ZSl9KWBcbiAgICBlbHNlXG4gICAgICBgI0BuYXRpdmUuYXBwZW5kKCN7a2V5fSwgI3tOYXRpdmUuY29udmVydCh2YWx1ZSl9LCAje2ZpbGVuYW1lfSlgXG4gICAgZW5kXG4gIGVuZFxuXG4gICMgR2V0IGEgZmllbGQgZnJvbSB0aGlzIEZvcm1EYXRhIGluc3RhbmNlIHdpdGggYSBnaXZlbiBuYW1lXG4gIGRlZiBbXShrZXkpXG4gICAgRm9ybURhdGEuZnJvbV9uYXRpdmUoYCNAbmF0aXZlLmdldCgje2tleX0pYClcbiAgZW5kXG5cbiAgIyBTZXQgYSBmaWVsZCBpbiB0aGlzIEZvcm1EYXRhIGluc3RhbmNlIHdpdGggYSBnaXZlbiBuYW1lXG4gIGRlZiBzZXQoa2V5LCB2YWx1ZSwgZmlsZW5hbWUgPSBuaWwpXG4gICAgdW5sZXNzIGZpbGVuYW1lXG4gICAgICBgI0BuYXRpdmUuc2V0KCN7a2V5fSwgI3tOYXRpdmUuY29udmVydCh2YWx1ZSl9KWBcbiAgICBlbHNlXG4gICAgICBgI0BuYXRpdmUuc2V0KCN7a2V5fSwgI3tOYXRpdmUuY29udmVydCh2YWx1ZSl9LCAje2ZpbGVuYW1lfSlgXG4gICAgZW5kXG4gIGVuZFxuICBhbGlhcyBbXT0gc2V0XG5cbiAgIyBDb252ZXJ0IHRvIGhhc2hcbiAgZGVmIHRvX2hcbiAgICBoYXNoID0ge31cbiAgICAleHtcbiAgICAgIHZhciBwYWlyLCB2LCBlID0gI0BuYXRpdmUuZW50cmllcygpO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdiA9IGUubmV4dCgpO1xuICAgICAgICBpZiAodi5kb25lKSBicmVhaztcbiAgICAgICAgcGFpciA9IHYudmFsdWU7XG4gICAgICAgICN7aGFzaFtgcGFpclswXWBdID0gRm9ybURhdGEuZnJvbV9uYXRpdmUoYHBhaXJbMV1gKX1cbiAgICAgIH1cbiAgICB9XG4gICAgaGFzaFxuICBlbmRcblxuICAjIENvbnZlcnQgdG8gYXJyYXlcbiAgZGVmIHRvX2FcbiAgICB0b19oLnRvX2FcbiAgZW5kXG5cbiAgIyBJdGVyYXRlIG92ZXIgYWxsIGVsZW1lbnRzIG9mIHRoaXMgRm9ybURhdGFcbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIHRvX2guZWFjaCgmYmxvY2spXG4gIGVuZFxuXG4gICMgQ2hlY2tzIGlmIGEgZmllbGQgb2YgdGhpcyBuYW1lIGV4aXN0cyBpbiB0aGlzIEZvcm1EYXRhIGluc3RhbmNlXG4gIGRlZiBpbmNsdWRlPyhrZXkpXG4gICAgYCNAbmF0aXZlLmhhcygje2tleX0pYFxuICBlbmRcblxuICAjIERlbGV0ZSBhIGZpZWxkIGZyb20gdGhpcyBGb3JtRGF0YSBpbnN0YW5jZVxuICBkZWYgZGVsZXRlKGtleSlcbiAgICBgI0BuYXRpdmUuZGVsZXRlKCN7a2V5fSlgXG4gIGVuZFxuZW5kXG5cbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkZvcm1EYXRhPiIsInNlbGYiLCJpbmNsdWRlIiwiTmF0aXZlQ2FjaGVkV3JhcHBlciIsIjxtb2R1bGU6Q29udmVydGVyPiIsImVuY29kZSIsInN0cmluZyIsImRlY29kZSIsImVuY29kZV91cmkiLCJkZWNvZGVfdXJpIiwiZmxhdHRlbiIsInZhbHVlIiwia2V5IiwiSGFzaCIsIiRyZXRfb3JfMSIsIm91dCIsImVhY2giLCJibG9jayBpbiBmbGF0dGVuIiwiayIsInYiLCJibG9jayAoMiBsZXZlbHMpIGluIGZsYXR0ZW4iLCIrIiwiQXJyYXkiLCJ1bmZsYXR0ZW4iLCJhcnJheSIsImJsb2NrIGluIHVuZmxhdHRlbiIsImJsb2NrICgyIGxldmVscykgaW4gdW5mbGF0dGVuIiwicGF0aCIsInNwbGl0IiwiZmlyc3QiLCJzY2FuIiwiYyIsInNldCIsInByb2MiLCJ3ZWFrIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiB1bmZsYXR0ZW4iLCJpIiwiY2FsbCIsIjw8IiwiYmxvY2sgKDQgbGV2ZWxzKSBpbiB1bmZsYXR0ZW4iLCJsYXN0IiwiJHJldF9vcl8yIiwiW10iLCJbXT0iLCJjb250YWluX2ZpbGVzPyIsImhhc2giLCJhbnk/IiwiYmxvY2sgaW4gY29udGFpbl9maWxlcz8iLCJibG9jayAoMiBsZXZlbHMpIGluIGNvbnRhaW5fZmlsZXM/IiwiRmlsZSIsIkJsb2IiLCJpbmNsdWRlPyIsImNsYXNzIiwiYnVpbGRfcXVlcnkiLCJzZXAiLCJtYXAiLCJibG9jayBpbiBidWlsZF9xdWVyeSIsImJsb2NrICgyIGxldmVscykgaW4gYnVpbGRfcXVlcnkiLCJ0b19zIiwiam9pbiIsImJ1aWxkX2Zvcm1fZGF0YSIsImZkIiwiRm9ybURhdGEiLCJjcmVhdGUiLCJibG9jayBpbiBidWlsZF9mb3JtX2RhdGEiLCJibG9jayAoMiBsZXZlbHMpIGluIGJ1aWxkX2Zvcm1fZGF0YSIsInBhcnNlX3F1ZXJ5IiwiYmxvY2sgaW4gcGFyc2VfcXVlcnkiLCJzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwYXJzZV9xdWVyeSIsIm1ldGhvZCIsInRvX3Byb2MiLCJmcm9tX25hdGl2ZSIsIm4iLCJuZXciLCJleHRlbmQiLCJDb252ZXJ0ZXIiLCJFbnVtZXJhYmxlIiwiRE9NOjpFbGVtZW50OjpGb3JtIiwiRE9NOjpFbGVtZW50IiwiRE9NIiwidG9fbiIsInR1cGxlIiwiZmlsZW5hbWUiLCJAbmF0aXZlIiwiTmF0aXZlIiwiY29udmVydCIsInRvX2giLCJ0b19h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dCI6eyJsaW5lIjozMDAxOSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvc3VwcG9ydC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIFRoZSBlbmdpbmUgdGhlIGJyb3dzZXIgaXMgcnVubmluZyBvbi5cbiNcbiMgS2VlcCBpbiBtaW5kIGl0IHVzZXMgdGhlIHVzZXIgYWdlbnQgdG8ga25vdywgc28gaXQncyBub3QgcmVsaWFibGUgaW4gY2FzZSBvZlxuIyBzcG9vZmluZy5cbkJST1dTRVJfRU5HSU5FID0gYC9NU0lFfFdlYktpdHxQcmVzdG98R2Vja28vLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudClbMF1gLmRvd25jYXNlIHJlc2N1ZSA6dW5rbm93blxuXG5tb2R1bGUgQnJvd3NlclxuICAjIEBwcml2YXRlXG4gIEBzdXBwb3J0ID0gYHt9YFxuXG4gICMgQ2hlY2sgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIGdpdmVuIGZlYXR1cmUuXG4gIGRlZiBzZWxmLnN1cHBvcnRzPyhmZWF0dXJlKVxuICAgIGlmIGRlZmluZWQ/KGAjQHN1cHBvcnRbI3tmZWF0dXJlfV1gKVxuICAgICAgcmV0dXJuIGAjQHN1cHBvcnRbI3tmZWF0dXJlfV1gXG4gICAgZW5kXG5cbiAgICBzdXBwb3J0ID0gY2FzZSBmZWF0dXJlXG4gICAgICB3aGVuICdNdXRhdGlvbk9ic2VydmVyJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXJgKVxuXG4gICAgICB3aGVuICdXZWJTb2NrZXQnXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cuV2ViU29ja2V0YClcblxuICAgICAgd2hlbiAnRXZlbnRTb3VyY2UnXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cuRXZlbnRTb3VyY2VgKVxuXG4gICAgICB3aGVuICdYSFInXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cuWE1MSHR0cFJlcXVlc3RgKVxuXG4gICAgICB3aGVuICdBY3RpdmVYJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93LkFjdGl2ZVhPYmplY3RgKVxuXG4gICAgICB3aGVuICdXZWJTUUwnXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cub3BlbkRhdGFiYXNlYClcblxuICAgICAgd2hlbiAnUXVlcnkuY3NzJ1xuICAgICAgICBkZWZpbmVkPyhgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbGApXG5cbiAgICAgIHdoZW4gJ1F1ZXJ5LnhwYXRoJ1xuICAgICAgICBkZWZpbmVkPyhgZG9jdW1lbnQuZXZhbHVhdGVgKVxuXG4gICAgICB3aGVuICdTdG9yYWdlLmxvY2FsJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93LmxvY2FsU3RvcmFnZWApXG5cbiAgICAgIHdoZW4gJ1N0b3JhZ2UuZ2xvYmFsJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93Lmdsb2JhbFN0b3JhZ2VgKVxuXG4gICAgICB3aGVuICdTdG9yYWdlLnNlc3Npb24nXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cuc2Vzc2lvblN0b3JhZ2VgKVxuXG4gICAgICB3aGVuICdJbW1lZGlhdGUnXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cuc2V0SW1tZWRpYXRlYClcblxuICAgICAgd2hlbiAnSW1tZWRpYXRlIChJbnRlcm5ldCBFeHBsb3JlciknXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cubXNTZXRJbW1lZGlhdGVgKVxuXG4gICAgICB3aGVuICdJbW1lZGlhdGUgKEZpcmVmb3gpJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93Lm1velNldEltbWVkaWF0ZWApXG5cbiAgICAgIHdoZW4gJ0ltbWVkaWF0ZSAoT3BlcmEpJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93Lm9TZXRJbW1lZGlhdGVgKVxuXG4gICAgICB3aGVuICdJbW1lZGlhdGUgKENocm9tZSknLCAnc2V0SW1tZWRpYXRlIChTYWZhcmkpJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93LndlYmtpdFNldEltbWVkaWF0ZWApXG5cbiAgICAgIHdoZW4gJ0NTUy5jb21wdXRlZCdcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlYClcblxuICAgICAgd2hlbiAnQ1NTLmN1cnJlbnQnXG4gICAgICAgIGRlZmluZWQ/KGBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY3VycmVudFN0eWxlYClcblxuICAgICAgd2hlbiAnV2luZG93LnNlbmQnXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cucG9zdE1lc3NhZ2VgKVxuXG4gICAgICB3aGVuICdXaW5kb3cuc2VuZCAoQXN5bmNocm9ub3VzKSdcbiAgICAgICAgaWYgZGVmaW5lZD8oYHdpbmRvdy5wb3N0TWVzc2FnZWApICYmICFkZWZpbmVkPyhgd2luZG93LmltcG9ydFNjcmlwdHNgKVxuICAgICAgICAgICV4e1xuICAgICAgICAgICAgdmFyIG9rICA9IHRydWUsXG4gICAgICAgICAgICAgICAgb2xkID0gd2luZG93Lm9ubWVzc2FnZTtcblxuICAgICAgICAgICAgd2luZG93Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkgeyBvayA9IGZhbHNlOyB9O1xuICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKVxuICAgICAgICAgICAgd2luZG93Lm9ubWVzc2FnZSA9IG9sZDtcblxuICAgICAgICAgICAgcmV0dXJuIG9rO1xuICAgICAgICAgIH1cbiAgICAgICAgZW5kXG5cbiAgICAgIHdoZW4gJ1dpbmRvdy5zZW5kIChTeW5jaHJvbm91cyknXG4gICAgICAgICFzdXBwb3J0cz8oJ1dpbmRvdy5zZW5kIChBc3luY2hyb25vdXMpJylcblxuICAgICAgd2hlbiAnV2luZG93LmlubmVyU2l6ZSdcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy5pbm5lckhlaWdodGApXG5cbiAgICAgIHdoZW4gJ1dpbmRvdy5vdXRlclNpemUnXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cub3V0ZXJIZWlnaHRgKVxuXG4gICAgICB3aGVuICdXaW5kb3cuc2Nyb2xsJ1xuICAgICAgICBkZWZpbmVkPyhgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnRgKVxuXG4gICAgICB3aGVuICdXaW5kb3cuc2Nyb2xsQnknXG4gICAgICAgIGRlZmluZWQ/KGBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsQnlgKVxuXG4gICAgICB3aGVuICdXaW5kb3cucGFnZU9mZnNldCdcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy5wYWdlWE9mZnNldGApXG5cbiAgICAgIHdoZW4gJ0F0dHIuaXNJZCdcbiAgICAgICAgJXh7XG4gICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKCdpZCcsICd4eHh4eHh4eHh4eHh4Jyk7XG5cbiAgICAgICAgICByZXR1cm4gdHlwZW9mKGRpdi5hdHRyaWJ1dGVzWydpZCddLmlzSWQpICE9PSBcInVuZGVmaW5lZFwiO1xuICAgICAgICB9XG5cbiAgICAgIHdoZW4gJ0VsZW1lbnQuYWRkQmVoYXZpb3InXG4gICAgICAgIGRlZmluZWQ/KGBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkQmVoYXZpb3JgKVxuXG4gICAgICB3aGVuICdFbGVtZW50LmNsYXNzTmFtZSdcbiAgICAgICAgJXh7XG4gICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2NsYXNzTmFtZScsICd4Jyk7XG5cbiAgICAgICAgICByZXR1cm4gZGl2LmNsYXNzTmFtZSA9PT0gJ3gnO1xuICAgICAgICB9XG5cbiAgICAgIHdoZW4gJ0VsZW1lbnQuY2xhc3MnXG4gICAgICAgICV4e1xuICAgICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKCdjbGFzcycsICd4Jyk7XG5cbiAgICAgICAgICByZXR1cm4gZGl2LmNsYXNzTmFtZSA9PT0gJ3gnO1xuICAgICAgICB9XG5cbiAgICAgIHdoZW4gJ0VsZW1lbnQuZm9yJ1xuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIik7XG4gICAgICAgICAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZSgnZm9yJywgJ3gnKTtcblxuICAgICAgICAgIHJldHVybiBsYWJlbC5odG1sRm9yID09PSAneCc7XG4gICAgICAgIH1cblxuICAgICAgd2hlbiAnRWxlbWVudC5odG1sRm9yJ1xuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIik7XG4gICAgICAgICAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZSgnaHRtbEZvcicsICd4Jyk7XG5cbiAgICAgICAgICByZXR1cm4gbGFiZWwuaHRtbEZvciA9PT0gJ3gnO1xuICAgICAgICB9XG5cbiAgICAgIHdoZW4gJ0VsZW1lbnQuY2xpZW50U2l6ZSdcbiAgICAgICAgZGVmaW5lZD8oYGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRgKVxuXG4gICAgICB3aGVuICdFbGVtZW50LnNjcm9sbCdcbiAgICAgICAgZGVmaW5lZD8oYGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0YClcblxuICAgICAgd2hlbiAnRWxlbWVudC50ZXh0Q29udGVudCdcbiAgICAgICAgZGVmaW5lZD8oYGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC50ZXh0Q29udGVudGApXG5cbiAgICAgIHdoZW4gJ0VsZW1lbnQuaW5uZXJUZXh0J1xuICAgICAgICBkZWZpbmVkPyhgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmlubmVyVGV4dGApXG5cbiAgICAgIHdoZW4gJ0VsZW1lbnQubWF0Y2hlcydcbiAgICAgICAgZGVmaW5lZD8oYGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5tYXRjaGVzYClcblxuICAgICAgd2hlbiAnRWxlbWVudC5tYXRjaGVzIChJbnRlcm5ldCBFeHBsb3JlciknXG4gICAgICAgIGRlZmluZWQ/KGBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubXNNYXRjaGVzU2VsZWN0b3JgKVxuXG4gICAgICB3aGVuICdFbGVtZW50Lm1hdGNoZXMgKEZpcmVmb3gpJ1xuICAgICAgICBkZWZpbmVkPyhgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm1vek1hdGNoZXNTZWxlY3RvcmApXG5cbiAgICAgIHdoZW4gJ0VsZW1lbnQubWF0Y2hlcyAoT3BlcmEpJ1xuICAgICAgICBkZWZpbmVkPyhgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9NYXRjaGVzU2VsZWN0b3JgKVxuXG4gICAgICB3aGVuICdFbGVtZW50Lm1hdGNoZXMgKENocm9tZSknLCAnRWxlbWVudC5tYXRjaGVzIChTYWZhcmkpJ1xuICAgICAgICBkZWZpbmVkPyhgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LndlYmtpdE1hdGNoZXNTZWxlY3RvcmApXG5cbiAgICAgIHdoZW4gJ0VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0J1xuICAgICAgICBkZWZpbmVkPyhgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdGApXG5cbiAgICAgIHdoZW4gJ0V2ZW50LnJlYWR5c3RhdGVjaGFuZ2UnXG4gICAgICAgIGBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpYFxuXG4gICAgICB3aGVuICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICAgICAgYmVnaW5cbiAgICAgICAgICBgbmV3IE1vdXNlRXZlbnQoXCJjbGlja1wiKWBcblxuICAgICAgICAgIHRydWVcbiAgICAgICAgcmVzY3VlIFN0YW5kYXJkRXJyb3IsIEpTOjpFcnJvclxuICAgICAgICAgIGZhbHNlXG4gICAgICAgIGVuZFxuXG4gICAgICB3aGVuICdFdmVudC5jcmVhdGUnXG4gICAgICAgIGRlZmluZWQ/KGBkb2N1bWVudC5jcmVhdGVFdmVudGApXG5cbiAgICAgIHdoZW4gJ0V2ZW50LmNyZWF0ZU9iamVjdCdcbiAgICAgICAgZGVmaW5lZD8oYGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0YClcblxuICAgICAgd2hlbiAnRXZlbnQuYWRkTGlzdGVuZXInXG4gICAgICAgIGRlZmluZWQ/KGBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyYClcblxuICAgICAgd2hlbiAnRXZlbnQuYXR0YWNoJ1xuICAgICAgICBkZWZpbmVkPyhgZG9jdW1lbnQuYXR0YWNoRXZlbnRgKVxuXG4gICAgICB3aGVuICdFdmVudC5yZW1vdmVMaXN0ZW5lcidcbiAgICAgICAgZGVmaW5lZD8oYGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXJgKVxuXG4gICAgICB3aGVuICdFdmVudC5kZXRhY2gnXG4gICAgICAgIGRlZmluZWQ/KGBkb2N1bWVudC5kZXRhY2hFdmVudGApXG5cbiAgICAgIHdoZW4gJ0V2ZW50LmRpc3BhdGNoJ1xuICAgICAgICBkZWZpbmVkPyhgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudGApXG5cbiAgICAgIHdoZW4gJ0V2ZW50LmZpcmUnXG4gICAgICAgIGRlZmluZWQ/KGBkb2N1bWVudC5maXJlRXZlbnRgKVxuXG4gICAgICB3aGVuIC9eRXZlbnRcXC4oW0EtWl0uKj8pJC9cbiAgICAgICAgYCgjeyQxfSArIFwiRXZlbnRcIikgaW4gd2luZG93YFxuXG4gICAgICB3aGVuICdEb2N1bWVudC52aWV3J1xuICAgICAgICBkZWZpbmVkPyhgZG9jdW1lbnQuZGVmYXVsdFZpZXdgKVxuXG4gICAgICB3aGVuICdEb2N1bWVudC53aW5kb3cnXG4gICAgICAgIGRlZmluZWQ/KGBkb2N1bWVudC5wYXJlbnRXaW5kb3dgKVxuXG4gICAgICB3aGVuICdIaXN0b3J5J1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlYClcblxuICAgICAgd2hlbiAnSGlzdG9yeS5zdGF0ZSdcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy5oaXN0b3J5LnN0YXRlYClcblxuICAgICAgd2hlbiAnQW5pbWF0aW9uLnJlcXVlc3QnXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lYClcblxuICAgICAgd2hlbiAnQW5pbWF0aW9uLnJlcXVlc3QgKEludGVybmV0IEV4cGxvcmVyKSdcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZWApXG5cbiAgICAgIHdoZW4gJ0FuaW1hdGlvbi5yZXF1ZXN0IChGaXJlZm94KSdcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWVgKVxuXG4gICAgICB3aGVuICdBbmltYXRpb24ucmVxdWVzdCAoT3BlcmEpJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWVgKVxuXG4gICAgICB3aGVuICdBbmltYXRpb24ucmVxdWVzdCAoQ2hyb21lKScsICdBbmltYXRpb24ucmVxdWVzdCAoU2FmYXJpKSdcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVgKVxuXG4gICAgICB3aGVuICdBbmltYXRpb24uY2FuY2VsJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lYClcblxuICAgICAgd2hlbiAnQW5pbWF0aW9uLmNhbmNlbCAoSW50ZXJuZXQgRXhwbG9yZXIpJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93Lm1zQ2FuY2VsQW5pbWF0aW9uRnJhbWVgKVxuXG4gICAgICB3aGVuICdBbmltYXRpb24uY2FuY2VsIChGaXJlZm94KSdcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZWApXG5cbiAgICAgIHdoZW4gJ0FuaW1hdGlvbi5jYW5jZWwgKE9wZXJhKSdcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy5vQ2FuY2VsQW5pbWF0aW9uRnJhbWVgKVxuXG4gICAgICB3aGVuICdBbmltYXRpb24uY2FuY2VsIChDaHJvbWUpJywgJ0FuaW1hdGlvbi5jYW5jZWwgKFNhZmFyaSknXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWVgKVxuXG4gICAgICB3aGVuICdBbmltYXRpb24uY2FuY2VsUmVxdWVzdCdcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy5jYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWVgKVxuXG4gICAgICB3aGVuICdBbmltYXRpb24uY2FuY2VsUmVxdWVzdCAoSW50ZXJuZXQgRXhwbG9yZXIpJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93Lm1zQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lYClcblxuICAgICAgd2hlbiAnQW5pbWF0aW9uLmNhbmNlbFJlcXVlc3QgKEZpcmVmb3gpJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93Lm1vekNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZWApXG5cbiAgICAgIHdoZW4gJ0FuaW1hdGlvbi5jYW5jZWxSZXF1ZXN0IChPcGVyYSknXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cub0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZWApXG5cbiAgICAgIHdoZW4gJ0FuaW1hdGlvbi5jYW5jZWxSZXF1ZXN0IChDaHJvbWUpJywgJ0FuaW1hdGlvbi5jYW5jZWxSZXF1ZXN0IChTYWZhcmkpJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93LndlYmtpdENhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZWApXG5cbiAgICAgIHdoZW4gJ0F1ZGlvJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93LkF1ZGlvQ29udGV4dGApXG5cbiAgICAgIHdoZW4gJ0F1ZGlvIChTYWZhcmkpJywgJ0F1ZGlvIChDaHJvbWUpJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dGApXG4gICAgICBcbiAgICAgIHdoZW4gJ0N1c3RvbSBFbGVtZW50cydcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy5jdXN0b21FbGVtZW50c2ApXG4gICAgZW5kXG5cbiAgICBgI0BzdXBwb3J0WyN7ZmVhdHVyZX1dID0gI3tzdXBwb3J0fWBcbiAgZW5kXG5cbiAgIyBDaGVjayBpZiB0aGUgZ2l2ZW4gcG9seWZpbGwgaXMgbG9hZGVkLlxuICBkZWYgc2VsZi5sb2FkZWQ/KG5hbWUpXG4gICAgY2FzZSBuYW1lXG4gICAgd2hlbiAnU2l6emxlJ1xuICAgICAgZGVmaW5lZD8oYHdpbmRvdy5TaXp6bGVgKVxuXG4gICAgd2hlbiAnd2lja2VkLWdvb2QteHBhdGgnXG4gICAgICBkZWZpbmVkPyhgd2luZG93LndneHBhdGhgKVxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJkb3duY2FzZSIsIlN0YW5kYXJkRXJyb3IiLCI8bW9kdWxlOkJyb3dzZXI+IiwiQHN1cHBvcnQiLCJzdXBwb3J0cz8iLCJzZWxmIiwiZmVhdHVyZSIsInN1cHBvcnQiLCIkcmV0X29yXzEiLCIhIiwiSlM6OkVycm9yIiwiSlMiLCJsb2FkZWQ/IiwibmFtZSJdLCJtYXBwaW5ncyI6IkFBQUFBLGtDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUlBLDBDQUFpQixjQUFBO0lBQUFBLE9BQUFBLENBQUNBLHVEQUFEQSxDQUF5REMsVUFBQUEsQ0FBQUE7RUFBekQ7SUFBbUUsc0JBQUEsQ0FBQUMsbUJBQUEsQ0FBQTtNQUFBO1FBQU9GLE9BQUE7TUFBUDtJQUFBLENBQW5FO0VBQUEsQ0FBQSxJQUFqQjtFQUVBQSxPQUFBRztFQUFBQTs7SUFBQUE7OztJQUVFQyxlQUFZRDtJQUdaRSxNQUFJQyxJQUFKRCxnQkFBQUEsa0NBQW1CRSxPQUFuQkY7QUFBQUEsTUFBQUE7QUFBQUE7OztNQUNFLElBQUEsUUFBRyxRQUFXRCxZQUFRQyxDQUFHRSxPQUFRRixDQUE5QixrQkFBSCxDQUFBO1FBQ0UsT0FBU0QsWUFBUUMsQ0FBR0UsT0FB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RixPQUdBLElBQUEsUUFBS0EsT0FBTCxFQW5STixTQW1STSxDQUFBO1FBQ0VBLE9BQUEsUUFBVUEsbUJBQVY7TUFERixPQUdBLElBdFJOLENBQUEsUUFzUldBLGdCQXRSWCxFQUFBLFNBQUEsQ0FBQSxJQUFBLENBQUEsUUFzUjZCQSxnQkF0UjdCLEVBQUEsU0FBQSxDQUFBLENBQUEsQ0FzUk07UUFDRUEsT0FBQSxRQUFVQSx5QkFBVjtNQURGLE9BR0EsSUFBQSxRQUFLQSxpQkFBTCxFQXpSTixTQXlSTSxDQUFBO1FBQ0VBLE9BQUEsUUFBVUEscUJBQVY7TUFERjtRQXpRUUEsT0FBQTtNQXlRUixDQXhRQTtNQTRRRkEsT0FBRUQsWUFBUUMsQ0FBR0UsT0FBUUYsSUFBTUc7SUFsUjdCSCxDQUFBQTtJQXNSQUYsT0FBQVUsTUFBSVAsSUFBSk8sY0FBQUEsZ0NBQWlCQyxJQUFqQkQ7QUFBQUE7O01BRUUsUUFES0MsSUFDTDtRQUFBLEtBQUtELFFBQUw7VUFDRUEsT0FBQSxRQUFVQSxhQUFWO1FBRUYsS0FBS0EsbUJBQUw7VUFDRUEsT0FBQSxRQUFVQSxjQUFWO1FBREY7VUFKQUEsT0FBQTtNQUNBO0lBRkZBLENBQUFBO0VBM1JGVixHQUFBQSxXQUFBQTtBQU5BSDsifX0seyJvZmZzZXQiOnsibGluZSI6MzAyNjcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL3NldHVwL2Jhc2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBicm93c2VyL3NldHVwL2Jhc2U6IFNldHVwIG9ubHkgdGhlIGJhc2UgcmVxdWlyZXNcblxucmVxdWlyZSAnYnJvd3Nlci92ZXJzaW9uJ1xucmVxdWlyZSAnYnJvd3Nlci91dGlscydcbnJlcXVpcmUgJ2Jyb3dzZXIvZm9ybV9kYXRhJ1xucmVxdWlyZSAnYnJvd3Nlci9zdXBwb3J0J1xuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSJdLCJtYXBwaW5ncyI6IkFBQUFBLHFDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQyxJQUFBQyxTQUFBQSxDQUFRRixpQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsZUFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsbUJBQVJFO0VBQ0FGLE9BQUFDLElBQUFDLFNBQUFBLENBQVFGLGlCQUFSRTtBQUxBRjsifX0seyJvZmZzZXQiOnsibGluZSI6MzAyNzgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L2Jhc2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXJcblxuY2xhc3MgRXZlbnRcbiAgaW5jbHVkZSBOYXRpdmU6OldyYXBwZXJcblxuICAjIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvR3VpZGUvRXZlbnRzL0NyZWF0aW5nX2FuZF90cmlnZ2VyaW5nX2V2ZW50c1xuICBjbGFzcyBEZWZpbml0aW9uXG4gICAgaW5jbHVkZSBOYXRpdmU6OldyYXBwZXJcblxuICAgICMgQHByaXZhdGVcbiAgICBkZWYgc2VsZi5uZXcoJmJsb2NrKVxuICAgICAgZGF0YSA9IHN1cGVyKGB7IGJ1YmJsZXM6IHRydWUsIGNhbmNlbGFibGU6IHRydWUgfWApXG4gICAgICBibG9jay5jYWxsKGRhdGEpIGlmIGJsb2NrXG5cbiAgICAgIGRhdGEudG9fblxuICAgIGVuZFxuXG4gICAgIyBTZXQgdGhlIGV2ZW50IGFzIGJ1YmJsaW5nLlxuICAgIGRlZiBidWJibGVzPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5idWJibGVzID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICAjIFNldCB0aGUgZXZlbnQgYXMgY2FuY2VsYWJsZS5cbiAgICBkZWYgY2FuY2VsYWJsZT0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuY2FuY2VsYWJsZSA9ICN7dmFsdWV9YFxuICAgIGVuZFxuICBlbmRcblxuICBtb2R1bGUgVGFyZ2V0XG4gICAgIyBAcHJpdmF0ZVxuICAgIGRlZiBzZWxmLmNvbnZlcnRlcnNcbiAgICAgIEBjb252ZXJ0ZXJzIHx8PSBbXVxuICAgIGVuZFxuXG4gICAgIyBAcHJpdmF0ZVxuICAgIGRlZiBzZWxmLnJlZ2lzdGVyKCZibG9jaylcbiAgICAgIGNvbnZlcnRlcnMgPDwgYmxvY2tcbiAgICBlbmRcblxuICAgICMgQHByaXZhdGVcbiAgICBkZWYgc2VsZi5jb252ZXJ0KHZhbHVlKVxuICAgICAgcmV0dXJuIHZhbHVlIHVubGVzcyBuYXRpdmU/KHZhbHVlKVxuXG4gICAgICBjb252ZXJ0ZXJzLmVhY2gge3xibG9ja3xcbiAgICAgICAgaWYgcmVzdWx0ID0gYmxvY2suY2FsbCh2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgIGVuZFxuICAgICAgfVxuXG4gICAgICBuaWxcbiAgICBlbmRcblxuICAgIGRlZiBzZWxmLmluY2x1ZGVkKGtsYXNzKVxuICAgICAga2xhc3MuaW5zdGFuY2VfZXZhbCB7XG4gICAgICAgIGRlZiBzZWxmLnRhcmdldCgmYmxvY2spXG4gICAgICAgICAgRXZlbnQ6OlRhcmdldC5yZWdpc3RlcigmYmxvY2spXG4gICAgICAgIGVuZFxuICAgICAgfVxuICAgIGVuZFxuXG4gICAgY2xhc3MgQ2FsbGJhY2tcbiAgICAgIGF0dHJfcmVhZGVyIDp0YXJnZXQsIDpuYW1lLCA6c2VsZWN0b3JcblxuICAgICAgIyBAcHJpdmF0ZVxuICAgICAgZGVmIGluaXRpYWxpemUodGFyZ2V0LCBuYW1lLCBzZWxlY3RvciA9IG5pbCwgJmJsb2NrKVxuICAgICAgICBAdGFyZ2V0ICAgPSB0YXJnZXRcbiAgICAgICAgQG5hbWUgICAgID0gbmFtZVxuICAgICAgICBAc2VsZWN0b3IgPSBzZWxlY3RvclxuICAgICAgICBAYmxvY2sgICAgPSBibG9ja1xuICAgICAgZW5kXG5cbiAgICAgICMgQ2FsbCB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgZ2l2ZW4gZXZlbnQuXG4gICAgICAjXG4gICAgICAjIEBwYXJhbSBldmVudCBbbmF0aXZlXSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuICAgICAgZGVmIGNhbGwoZXZlbnQpXG4gICAgICAgIHRvX3Byb2MuY2FsbChldmVudClcbiAgICAgIGVuZFxuXG4gICAgICAjIEdldCB0aGUgbmF0aXZlIGZ1bmN0aW9uIGxpbmtlZCB0byB0aGUgY2FsbGJhY2suXG4gICAgICBkZWYgdG9fcHJvY1xuICAgICAgICBAcHJvYyB8fD0gLT4gZXZlbnQge1xuICAgICAgICAgICV4e1xuICAgICAgICAgICAgaWYgKCFldmVudC5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBzZWxmLnRhcmdldC5uYXRpdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXZlbnQgPSBFdmVudC5uZXcoZXZlbnQsIHNlbGYpXG5cbiAgICAgICAgICB1bmxlc3MgZXZlbnQuc3RvcHBlZD9cbiAgICAgICAgICAgIEBibG9jay5jYWxsKGV2ZW50LCAqZXZlbnQuYXJndW1lbnRzKVxuICAgICAgICAgIGVuZFxuXG4gICAgICAgICAgIWV2ZW50LnByZXZlbnRlZD9cbiAgICAgICAgfVxuICAgICAgZW5kXG5cbiAgICAgICMgQCFhdHRyaWJ1dGUgW3JdIGV2ZW50XG4gICAgICAjIEByZXR1cm4gW0NsYXNzXSB0aGUgY2xhc3MgZm9yIHRoZSBldmVudFxuICAgICAgZGVmIGV2ZW50XG4gICAgICAgIEV2ZW50LmNsYXNzX2ZvcihAbmFtZSlcbiAgICAgIGVuZFxuXG4gICAgICAjIFN0b3AgbGlzdGVuaW5nIGZvciB0aGUgZXZlbnQgbGlua2VkIHRvIHRoZSBjYWxsYmFjay5cbiAgICAgIGRlZiBvZmZcbiAgICAgICAgdGFyZ2V0Lm9mZihzZWxmKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBjbGFzcyBEZWxlZ2F0ZVxuICAgICAgZGVmIGluaXRpYWxpemUodGFyZ2V0LCBuYW1lLCBwYWlyKVxuICAgICAgICBAdGFyZ2V0ID0gdGFyZ2V0XG4gICAgICAgIEBuYW1lICAgPSBuYW1lXG4gICAgICAgIEBwYWlyICAgPSBwYWlyXG4gICAgICBlbmRcblxuICAgICAgIyBTdG9wIGxpc3RlbmluZyBmb3IgdGhlIGV2ZW50IGxpbmtlZCB0byB0aGUgZGVsZWdhdGUuXG4gICAgICBkZWYgb2ZmXG4gICAgICAgIGRlbGVnYXRlID0gQHRhcmdldC5kZWxlZ2F0ZWRbQG5hbWVdXG4gICAgICAgIGRlbGVnYXRlLmxhc3QuZGVsZXRlKEBwYWlyKVxuXG4gICAgICAgIGlmIGRlbGVnYXRlLmxhc3QuZW1wdHk/XG4gICAgICAgICAgZGVsZWdhdGUuZmlyc3Qub2ZmXG4gICAgICAgICAgZGVsZWdhdGUuZGVsZXRlKEBuYW1lKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgRGVsZWdhdGVzID0gU3RydWN0Lm5ldyg6Y2FsbGJhY2ssIDpoYW5kbGVycylcblxuICAgICMgQG92ZXJsb2FkIG9uKG5hbWUsICZibG9jaylcbiAgICAjXG4gICAgIyAgIFN0YXJ0IGxpc3RlbmluZyBmb3IgYW4gZXZlbnQgb24gdGhlIHRhcmdldC5cbiAgICAjXG4gICAgIyAgIEBwYXJhbSBuYW1lIFtTdHJpbmddIHRoZSBldmVudCBuYW1lXG4gICAgI1xuICAgICMgICBAeWllbGRwYXJhbSBldmVudCBbRXZlbnRdIHRoZSBldmVudFxuICAgICNcbiAgICAjICAgQHJldHVybiBbQ2FsbGJhY2tdXG4gICAgI1xuICAgICMgQG92ZXJsb2FkIG9uKG5hbWUsIHNlbGVjdG9yLCAmYmxvY2spXG4gICAgI1xuICAgICMgICBTdGFydCBsaXN0ZW5pbmcgZm9yIGFuIGV2ZW50IG9uIHRoZSB0YXJnZXQgY2hpbGRyZW4uXG4gICAgI1xuICAgICMgICBAcGFyYW0gbmFtZSBbU3RyaW5nXSB0aGUgZXZlbnQgbmFtZVxuICAgICMgICBAcGFyYW0gc2VsZWN0b3IgW1N0cmluZ10gdGhlIENTUyBzZWxlY3RvciB0byB0cmlnZ2VyIHRoZSBldmVudCBvblxuICAgICNcbiAgICAjICAgQHlpZWxkcGFyYW0gZXZlbnQgW0V2ZW50XSB0aGUgZXZlbnRcbiAgICAjXG4gICAgIyAgIEByZXR1cm4gW0RlbGVnYXRlXVxuICAgIGRlZiBvbihuYW1lLCBzZWxlY3RvciA9IG5pbCwgJmJsb2NrKVxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ25vIGJsb2NrIGhhcyBiZWVuIGdpdmVuJyB1bmxlc3MgYmxvY2tcblxuICAgICAgbmFtZSA9IEV2ZW50Lm5hbWVfZm9yKG5hbWUpXG5cbiAgICAgIGlmIHNlbGVjdG9yXG4gICAgICAgIHVubGVzcyBkZWxlZ2F0ZSA9IGRlbGVnYXRlZFtuYW1lXVxuICAgICAgICAgIGRlbGVnYXRlID0gZGVsZWdhdGVkW25hbWVdID0gRGVsZWdhdGVzLm5ld1xuXG4gICAgICAgICAgaWYgJXdbYmx1ciBmb2N1c10uaW5jbHVkZT8obmFtZSlcbiAgICAgICAgICAgIGRlbGVnYXRlLmNhbGxiYWNrID0gb24hIG5hbWUgZG8gfGV8XG4gICAgICAgICAgICAgIGRlbGVnYXRlKGRlbGVnYXRlLCBlKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZWdhdGUuY2FsbGJhY2sgPSBvbiBuYW1lIGRvIHxlfFxuICAgICAgICAgICAgICBkZWxlZ2F0ZShkZWxlZ2F0ZSwgZSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVuZFxuXG4gICAgICAgICAgcGFpciA9IFtzZWxlY3RvciwgYmxvY2tdXG4gICAgICAgICAgZGVsZWdhdGUuaGFuZGxlcnMgPSBbcGFpcl1cblxuICAgICAgICAgIERlbGVnYXRlLm5ldyhzZWxmLCBuYW1lLCBwYWlyKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgcGFpciA9IFtzZWxlY3RvciwgYmxvY2tdXG4gICAgICAgICAgZGVsZWdhdGUuaGFuZGxlcnMgPDwgcGFpclxuXG4gICAgICAgICAgRGVsZWdhdGUubmV3KHNlbGYsIG5hbWUsIHBhaXIpXG4gICAgICAgIGVuZFxuICAgICAgZWxzZVxuICAgICAgICBjYWxsYmFjayA9IENhbGxiYWNrLm5ldyhzZWxmLCBuYW1lLCBzZWxlY3RvciwgJmJsb2NrKVxuICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjaylcblxuICAgICAgICBhdHRhY2goY2FsbGJhY2spXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICMgU3RhcnQgbGlzdGVuaW5nIGZvciBhbiBldmVudCBpbiB0aGUgY2FwdHVyaW5nIHBoYXNlLlxuICAgICNcbiAgICAjIEBwYXJhbSBuYW1lIFtTdHJpbmddIHRoZSBldmVudCBuYW1lXG4gICAgI1xuICAgICMgQHlpZWxkcGFyYW0gZXZlbnQgW0V2ZW50XSB0aGUgZXZlbnRcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtDYWxsYmFja11cbiAgICBkZWYgb24hKG5hbWUsICZibG9jaylcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdubyBibG9jayBoYXMgYmVlbiBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICAgIG5hbWUgICAgID0gRXZlbnQubmFtZV9mb3IobmFtZSlcbiAgICAgIGNhbGxiYWNrID0gQ2FsbGJhY2submV3KHNlbGYsIG5hbWUsICZibG9jaylcbiAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKVxuXG4gICAgICBhdHRhY2ghKGNhbGxiYWNrKVxuICAgIGVuZFxuXG4gICAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmFkZExpc3RlbmVyJ1xuICAgICAgZGVmIGF0dGFjaChjYWxsYmFjaylcbiAgICAgICAgYCNAbmF0aXZlLmFkZEV2ZW50TGlzdGVuZXIoI3tjYWxsYmFjay5uYW1lfSwgI3tjYWxsYmFjay50b19wcm9jfSlgXG5cbiAgICAgICAgY2FsbGJhY2tcbiAgICAgIGVuZFxuXG4gICAgICBkZWYgYXR0YWNoIShjYWxsYmFjaylcbiAgICAgICAgYCNAbmF0aXZlLmFkZEV2ZW50TGlzdGVuZXIoI3tjYWxsYmFjay5uYW1lfSwgI3tjYWxsYmFjay50b19wcm9jfSwgdHJ1ZSlgXG5cbiAgICAgICAgY2FsbGJhY2tcbiAgICAgIGVuZFxuICAgIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5hdHRhY2gnXG4gICAgICBkZWYgYXR0YWNoKGNhbGxiYWNrKVxuICAgICAgICBpZiBjYWxsYmFjay5ldmVudCA9PSBDdXN0b21cbiAgICAgICAgICAleHtcbiAgICAgICAgICAgIGlmICghI0BuYXRpdmUuJGN1c3RvbSkge1xuICAgICAgICAgICAgICAjQG5hdGl2ZS4kY3VzdG9tID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gI0BuYXRpdmUuJGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gI0BuYXRpdmUuJGNhbGxiYWNrc1tpXTtcblxuICAgICAgICAgICAgICAgICAgaWYgKCN7YGNhbGxiYWNrYC5ldmVudCA9PSBDdXN0b219KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgPSBjYWxsYmFjay5uYW1lO1xuXG4gICAgICAgICAgICAgICAgICAgICN7YGNhbGxiYWNrYC5jYWxsKGBldmVudGApfTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgI0BuYXRpdmUuYXR0YWNoRXZlbnQoXCJvbmRhdGFhdmFpbGFibGVcIiwgI0BuYXRpdmUuJGN1c3RvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgYCNAbmF0aXZlLmF0dGFjaEV2ZW50KFwib25cIiArICN7Y2FsbGJhY2submFtZX0sICN7Y2FsbGJhY2sudG9fcHJvY30pYFxuICAgICAgICBlbmRcblxuICAgICAgICBjYWxsYmFja1xuICAgICAgZW5kXG5cbiAgICAgIGRlZiBhdHRhY2ghKGNhbGxiYWNrKVxuICAgICAgICBjYXNlIGNhbGxiYWNrLm5hbWVcbiAgICAgICAgd2hlbiA6Ymx1clxuICAgICAgICAgIGAjQG5hdGl2ZS5hdHRhY2hFdmVudChcIm9uZm9jdXNvdXRcIiwgI3tjYWxsYmFjay50b19wcm9jfSlgXG5cbiAgICAgICAgd2hlbiA6Zm9jdXNcbiAgICAgICAgICBgI0BuYXRpdmUuYXR0YWNoRXZlbnQoXCJvbmZvY3VzaW5cIiwgI3tjYWxsYmFjay50b19wcm9jfSlgXG5cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHdhcm4gXCJhdHRhY2g6IGNhcHR1cmUgZG9lc24ndCB3b3JrIG9uIHRoaXMgYnJvd3NlclwiXG4gICAgICAgICAgYXR0YWNoKGNhbGxiYWNrKVxuICAgICAgICBlbmRcblxuICAgICAgICBjYWxsYmFja1xuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgIyBAdG9kbyBpbXBsZW1lbnQgcG9seWZpbGxcbiAgICAgICMgQHByaXZhdGVcbiAgICAgIGRlZiBhdHRhY2goKilcbiAgICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvclxuICAgICAgZW5kXG5cbiAgICAgICMgQHRvZG8gaW1wbGVtZW50IHBvbHlmaWxsXG4gICAgICAjIEBwcml2YXRlXG4gICAgICBkZWYgYXR0YWNoISgqKVxuICAgICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICMgQG92ZXJsb2FkIG9uZShuYW1lLCAmYmxvY2spXG4gICAgI1xuICAgICMgICBTdGFydCBsaXN0ZW5pbmcgZm9yIGFuIGV2ZW50IG9uIHRoZSB0YXJnZXQuIFJlbW92ZSB0aGUgZXZlbnQgYWZ0ZXIgZmlyaW5nXG4gICAgIyAgIHNvIHRoYXQgaXQgaXMgZmlyZWQgYXQgbW9zdCBvbmNlLlxuICAgICNcbiAgICAjICAgQHBhcmFtIG5hbWUgW1N0cmluZ10gdGhlIGV2ZW50IG5hbWVcbiAgICAjXG4gICAgIyAgIEB5aWVsZHBhcmFtIGV2ZW50IFtFdmVudF0gdGhlIGV2ZW50XG4gICAgI1xuICAgICMgICBAcmV0dXJuIFtDYWxsYmFja11cbiAgICAjXG4gICAgIyBAb3ZlcmxvYWQgb25lKG5hbWUsIHNlbGVjdG9yLCAmYmxvY2spXG4gICAgI1xuICAgICMgICBTdGFydCBsaXN0ZW5pbmcgZm9yIGFuIGV2ZW50IG9uIHRoZSB0YXJnZXQgY2hpbGRyZW4uIFJlbW92ZSB0aGUgZXZlbnQgYWZ0ZXJcbiAgICAjICAgZmlyaW5nIHNvIHRoYXQgaXQgaXMgZmlyZWQgYXQgbW9zdCBvbmNlLlxuICAgICNcbiAgICAjICAgQHBhcmFtIG5hbWUgW1N0cmluZ10gdGhlIGV2ZW50IG5hbWVcbiAgICAjICAgQHBhcmFtIHNlbGVjdG9yIFtTdHJpbmddIHRoZSBDU1Mgc2VsZWN0b3IgdG8gdHJpZ2dlciB0aGUgZXZlbnQgb25cbiAgICAjXG4gICAgIyAgIEB5aWVsZHBhcmFtIGV2ZW50IFtFdmVudF0gdGhlIGV2ZW50XG4gICAgI1xuICAgICMgICBAcmV0dXJuIFtEZWxlZ2F0ZV1cbiAgICBkZWYgb25lIChuYW1lLCBzZWxlY3RvciA9IG5pbCwgJmJsb2NrKVxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ25vIGJsb2NrIGhhcyBiZWVuIGdpdmVuJyB1bmxlc3MgYmxvY2tcblxuICAgICAgY2IgPSBvbiBuYW1lLCBzZWxlY3RvciBkbyB8KmFyZ3N8XG4gICAgICAgIG91dCA9IGJsb2NrLmNhbGwoKmFyZ3MpXG4gICAgICAgIGNiLm9mZlxuICAgICAgICBvdXRcbiAgICAgIGVuZFxuICAgIGVuZFxuICAgICMgQG92ZXJsb2FkIG9mZigpXG4gICAgIyAgIFN0b3AgbGlzdGVuaW5nIGZvciBhbnkgZXZlbnQuXG4gICAgI1xuICAgICMgQG92ZXJsb2FkIG9mZih3aGF0KVxuICAgICMgICBTdG9wIGxpc3RlbmluZyBmb3IgYW4gZXZlbnQuXG4gICAgI1xuICAgICMgICBAcGFyYW0gd2hhdCBbQ2FsbGJhY2ssIFN0cmluZywgUmVnZXhwXSB3aGF0IHRvIHN0b3AgbGlzdGVuaW5nIGZvclxuICAgIGRlZiBvZmYod2hhdCA9IG5pbClcbiAgICAgIGNhc2Ugd2hhdFxuICAgICAgd2hlbiBDYWxsYmFja1xuICAgICAgICBjYWxsYmFja3MuZGVsZXRlKHdoYXQpXG4gICAgICAgIGRldGFjaCh3aGF0KVxuXG4gICAgICB3aGVuIFN0cmluZ1xuICAgICAgICBpZiB3aGF0LmluY2x1ZGU/KD8qKSBvciB3aGF0LmluY2x1ZGU/KD8/KVxuICAgICAgICAgIG9mZihSZWdleHAubmV3KHdoYXQuZ3N1YigvXFwqLywgJy4qPycpLmdzdWIoL1xcPy8sID8uKSkpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3aGF0ID0gRXZlbnQubmFtZV9mb3Iod2hhdClcblxuICAgICAgICAgIGNhbGxiYWNrcy5kZWxldGVfaWYge3xjYWxsYmFja3xcbiAgICAgICAgICAgIGlmIGNhbGxiYWNrLm5hbWUgPT0gd2hhdFxuICAgICAgICAgICAgICBkZXRhY2goY2FsbGJhY2spXG5cbiAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfVxuICAgICAgICBlbmRcblxuICAgICAgd2hlbiBSZWdleHBcbiAgICAgICAgY2FsbGJhY2tzLmRlbGV0ZV9pZiB7fGNhbGxiYWNrfFxuICAgICAgICAgIGlmIGNhbGxiYWNrLm5hbWUgPX4gd2hhdFxuICAgICAgICAgICAgZGV0YWNoKGNhbGxiYWNrKVxuXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgZW5kXG4gICAgICAgIH1cblxuICAgICAgZWxzZVxuICAgICAgICBjYWxsYmFja3MuZWFjaCB7fGNhbGxiYWNrfFxuICAgICAgICAgIGRldGFjaChjYWxsYmFjaylcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrcy5jbGVhclxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQucmVtb3ZlTGlzdGVuZXInXG4gICAgICBkZWYgZGV0YWNoKGNhbGxiYWNrKVxuICAgICAgICBgI0BuYXRpdmUucmVtb3ZlRXZlbnRMaXN0ZW5lcigje2NhbGxiYWNrLm5hbWV9LCAje2NhbGxiYWNrLnRvX3Byb2N9LCBmYWxzZSlgXG4gICAgICBlbmRcbiAgICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuZGV0YWNoJ1xuICAgICAgZGVmIGRldGFjaChjYWxsYmFjaylcbiAgICAgICAgaWYgY2FsbGJhY2suZXZlbnQgPT0gQ3VzdG9tXG4gICAgICAgICAgaWYgY2FsbGJhY2tzLm5vbmU/IHsgfGN8IGMuZXZlbnQgPT0gQ3VzdG9tIH1cbiAgICAgICAgICAgICV4e1xuICAgICAgICAgICAgICAjQG5hdGl2ZS5kZXRhY2hFdmVudChcIm9uZGF0YWF2YWlsYWJsZVwiLCAjQG5hdGl2ZS4kY3VzdG9tKTtcblxuICAgICAgICAgICAgICBkZWxldGUgI0BuYXRpdmUuJGN1c3RvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBlbmRcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGAjQG5hdGl2ZS5kZXRhY2hFdmVudChcIm9uXCIgKyAje2NhbGxiYWNrLm5hbWV9LCAje2NhbGxiYWNrLnRvX3Byb2N9KWBcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICAjIEB0b2RvIGltcGxlbWVudCBpbnRlcm5hbCBoYW5kbGVyIHRoaW5nXG4gICAgICAjIEBwcml2YXRlXG4gICAgICBkZWYgZGV0YWNoKGNhbGxiYWNrKVxuICAgICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICMgVHJpZ2dlciBhbiBldmVudCBvbiB0aGUgdGFyZ2V0LlxuICAgICNcbiAgICAjIEBwYXJhbSBldmVudCBbU3RyaW5nXSB0aGUgZXZlbnQgbmFtZVxuICAgICMgQHBhcmFtIGFyZ3MgW0FycmF5XSBvcHRpb25hbCBhcmd1bWVudHMgdG8gdGhlIGV2ZW50IGNhbGxiYWNrXG4gICAgI1xuICAgICMgQHlpZWxkcGFyYW0gZGVmaW5pdGlvbiBbRGVmaW5pdGlvbl0gZGVmaW5pdGlvbiB0byBjdXN0b21pemUgdGhlIGV2ZW50XG4gICAgZGVmIHRyaWdnZXIoZXZlbnQsICphcmdzLCAmYmxvY2spXG4gICAgICBpZiBldmVudC5pc19hPyBTdHJpbmdcbiAgICAgICAgZXZlbnQgPSBFdmVudC5jcmVhdGUoZXZlbnQsICphcmdzLCAmYmxvY2spXG4gICAgICBlbmRcblxuICAgICAgZGlzcGF0Y2goZXZlbnQpXG4gICAgZW5kXG5cbiAgICAjIFRyaWdnZXIgYW4gZXZlbnQgb24gdGhlIHRhcmdldCB3aXRob3V0IGJ1YmJsaW5nLlxuICAgICNcbiAgICAjIEBwYXJhbSBldmVudCBbU3RyaW5nXSB0aGUgZXZlbnQgbmFtZVxuICAgICMgQHBhcmFtIGFyZ3MgW0FycmF5XSBvcHRpb25hbCBhcmd1bWVudHMgdG8gdGhlIGV2ZW50IGNhbGxiYWNrXG4gICAgI1xuICAgICMgQHlpZWxkcGFyYW0gZGVmaW5pdGlvbiBbRGVmaW5pdGlvbl0gZGVmaW5pdGlvbiB0byBjdXN0b21pemUgdGhlIGV2ZW50XG4gICAgZGVmIHRyaWdnZXIhKGV2ZW50LCAqYXJncywgJmJsb2NrKVxuICAgICAgdHJpZ2dlciBldmVudCwgKmFyZ3MgZG8gfGV8XG4gICAgICAgIGJsb2NrLmNhbGwoZSkgaWYgYmxvY2tcbiAgICAgICAgZS5idWJibGVzID0gZmFsc2VcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmRpc3BhdGNoJ1xuICAgICAgZGVmIGRpc3BhdGNoKGV2ZW50KVxuICAgICAgICBgI0BuYXRpdmUuZGlzcGF0Y2hFdmVudCgje2V2ZW50LnRvX259KWBcbiAgICAgIGVuZFxuICAgIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5maXJlJ1xuICAgICAgZGVmIGRpc3BhdGNoKGV2ZW50KVxuICAgICAgICBpZiBDdXN0b20gPT09IGV2ZW50XG4gICAgICAgICAgYCNAbmF0aXZlLmZpcmVFdmVudChcIm9uZGF0YWF2YWlsYWJsZVwiLCAje2V2ZW50LnRvX259KWBcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGAjQG5hdGl2ZS5maXJlRXZlbnQoXCJvblwiICsgI3tldmVudC5uYW1lfSwgI3tldmVudC50b19ufSlgXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgIyBAdG9kbyBpbXBsZW1lbnQgcG9seWZpbGxcbiAgICAgICMgQHByaXZhdGVcbiAgICAgIGRlZiBkaXNwYXRjaCgqKVxuICAgICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBwcml2YXRlXG4gICAgZGVmIGNhbGxiYWNrc1xuICAgICAgJXh7XG4gICAgICAgIGlmICghI0BuYXRpdmUuJGNhbGxiYWNrcykge1xuICAgICAgICAgICNAbmF0aXZlLiRjYWxsYmFja3MgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAjQG5hdGl2ZS4kY2FsbGJhY2tzO1xuICAgICAgfVxuICAgIGVuZFxuXG4gICAgZGVmIGRlbGVnYXRlZFxuICAgICAgJXh7XG4gICAgICAgIGlmICghI0BuYXRpdmUuJGRlbGVnYXRlZCkge1xuICAgICAgICAgICNAbmF0aXZlLiRkZWxlZ2F0ZWQgPSAje3t9fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAjQG5hdGl2ZS4kZGVsZWdhdGVkO1xuICAgICAgfVxuICAgIGVuZFxuXG4gICAgZGVmIGRlbGVnYXRlKGRlbGVnYXRlcywgZXZlbnQsIGVsZW1lbnQgPSBldmVudC50YXJnZXQpXG4gICAgICByZXR1cm4gaWYgZWxlbWVudC5uaWw/IHx8IGVsZW1lbnQgPT0gZXZlbnQub25cblxuICAgICAgZGVsZWdhdGVzLmhhbmRsZXJzLmVhY2gge3xzZWxlY3RvciwgYmxvY2t8XG4gICAgICAgIGlmIGVsZW1lbnQgPX4gc2VsZWN0b3JcbiAgICAgICAgICBuZXcgICAgPSBldmVudC5kdXBcbiAgICAgICAgICBuZXcub24gPSBlbGVtZW50XG5cbiAgICAgICAgICBibG9jay5jYWxsIG5ldywgKm5ldy5hcmd1bWVudHNcbiAgICAgICAgZW5kXG4gICAgICB9XG5cbiAgICAgIGRlbGVnYXRlKGRlbGVnYXRlcywgZXZlbnQsIGVsZW1lbnQucGFyZW50KVxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpFdmVudD4iLCJzZWxmIiwiaW5jbHVkZSIsIk5hdGl2ZTo6V3JhcHBlciIsIk5hdGl2ZSIsIjxjbGFzczpEZWZpbml0aW9uPiIsIm5ldyIsImRhdGEiLCJibG9jayIsImNhbGwiLCJ0b19uIiwiYnViYmxlcz0iLCJ2YWx1ZSIsIkBuYXRpdmUiLCJjYW5jZWxhYmxlPSIsIjxtb2R1bGU6VGFyZ2V0PiIsImNvbnZlcnRlcnMiLCJAY29udmVydGVycyIsIiRyZXRfb3JfMSIsInJlZ2lzdGVyIiwiPDwiLCJjb252ZXJ0IiwibmF0aXZlPyIsImVhY2giLCJibG9jayBpbiBjb252ZXJ0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb252ZXJ0IiwicmVzdWx0IiwiaW5jbHVkZWQiLCJrbGFzcyIsImluc3RhbmNlX2V2YWwiLCJibG9jayBpbiBpbmNsdWRlZCIsImJsb2NrICgyIGxldmVscykgaW4gaW5jbHVkZWQiLCJ0YXJnZXQiLCJFdmVudDo6VGFyZ2V0IiwiRXZlbnQiLCJ0b19wcm9jIiwiPGNsYXNzOkNhbGxiYWNrPiIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsIm5hbWUiLCJzZWxlY3RvciIsIkB0YXJnZXQiLCJAbmFtZSIsIkBzZWxlY3RvciIsIkBibG9jayIsImV2ZW50IiwiQHByb2MiLCJibG9jayBpbiB0b19wcm9jIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0b19wcm9jIiwic3RvcHBlZD8iLCJhcmd1bWVudHMiLCJwcmV2ZW50ZWQ/IiwiISIsImNsYXNzX2ZvciIsIm9mZiIsIjxjbGFzczpEZWxlZ2F0ZT4iLCJwYWlyIiwiQHBhaXIiLCJkZWxlZ2F0ZSIsImRlbGVnYXRlZCIsIltdIiwibGFzdCIsImRlbGV0ZSIsImVtcHR5PyIsImZpcnN0IiwiU3RydWN0Iiwib24iLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJuYW1lX2ZvciIsImhhbmRsZXJzIiwiRGVsZWdhdGUiLCJbXT0iLCJEZWxlZ2F0ZXMiLCJpbmNsdWRlPyIsImNhbGxiYWNrPSIsIm9uISIsImJsb2NrIGluIG9uIiwiZSIsImJsb2NrICgyIGxldmVscykgaW4gb24iLCJoYW5kbGVycz0iLCJjYWxsYmFjayIsIkNhbGxiYWNrIiwiY2FsbGJhY2tzIiwicHVzaCIsImF0dGFjaCIsImF0dGFjaCEiLCJCcm93c2VyIiwic3VwcG9ydHM/IiwiQ3VzdG9tIiwiPT0iLCJ3YXJuIiwiTm90SW1wbGVtZW50ZWRFcnJvciIsIm9uZSIsImNiIiwiYmxvY2sgaW4gb25lIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBvbmUiLCJvdXQiLCJhcmdzIiwid2hhdCIsImRldGFjaCIsIlN0cmluZyIsIlJlZ2V4cCIsImdzdWIiLCJkZWxldGVfaWYiLCJibG9jayBpbiBvZmYiLCJibG9jayAoMiBsZXZlbHMpIGluIG9mZiIsIj1+IiwiY2xlYXIiLCJub25lPyIsImJsb2NrIGluIGRldGFjaCIsImMiLCJibG9jayAoMiBsZXZlbHMpIGluIGRldGFjaCIsInRyaWdnZXIiLCJpc19hPyIsImNyZWF0ZSIsImRpc3BhdGNoIiwidHJpZ2dlciEiLCJibG9jayBpbiB0cmlnZ2VyISIsImJsb2NrICgyIGxldmVscykgaW4gdHJpZ2dlciEiLCJwcml2YXRlIiwiZGVsZWdhdGVzIiwiZWxlbWVudCIsIm5pbD8iLCJibG9jayBpbiBkZWxlZ2F0ZSIsImJsb2NrICgyIGxldmVscykgaW4gZGVsZWdhdGUiLCJuZXckIiwiZHVwIiwib249IiwicGFyZW50Il0sIm1hcHBpbmdzIjoiQUFBQUEscUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUVBQSxPQUFBQztJQUFBQTs7TUFBQUE7OztNQUNFQyxJQUFBQyxTQUFBQSxDQUFRQyxJQUFBQyxZ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YlJvSCxPQUFBO1lBK2JRLEVBREZELENBQWtCckc7VUFTbEJtQyxPQUFBekQsSUFBQXlELFVBQUFBLENBQVMrRCxTQUFULEVBQW9CNUUsS0FBcEIsRUFBMkI2RSxPQUFPTyxRQUFBQSxDQUFBQSxDQUFsQ3ZFO1FBWkZBLENBQUFBLElBQUFBO01BL1pGM0MsR0FBQUEsV0FBQUE7SUExQkZmLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBRkFELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMDg1NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQvdWkucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IGNsYXNzIEV2ZW50XG5cbmNsYXNzIFVJIDwgRXZlbnRcbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5VSSdcbiAgZW5kXG5cbiAgY2xhc3MgRGVmaW5pdGlvbiA8IERlZmluaXRpb25cbiAgICBkZWYgZGV0YWlsPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5kZXRhaWwgPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiB2aWV3PSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS52aWV3ID0gI3t2YWx1ZX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgVUlFdmVudCgje25hbWV9LCAje2Rlc2N9KWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNyZWF0ZSdcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgICV4e1xuICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIlVJRXZlbnRcIik7XG4gICAgICAgICAgICBldmVudC5pbml0VUlFdmVudChuYW1lLCBkZXNjLmJ1YmJsZXMsIGRlc2MuY2FuY2VsYWJsZSxcbiAgICAgICAgICAgICAgZGVzYy52aWV3IHx8IHdpbmRvdywgZGVzYy5kZXRhaWwgfHwgMCk7XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIGVuZFxuICBlbmQgaWYgc3VwcG9ydGVkP1xuXG4gIGFsaWFzX25hdGl2ZSA6ZGV0YWlsXG4gIGFsaWFzX25hdGl2ZSA6dmlld1xuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8Y2xhc3M6RXZlbnQ+IiwiPGNsYXNzOlVJPiIsInN1cHBvcnRlZD8iLCJzZWxmIiwiQnJvd3NlciIsInN1cHBvcnRzPyIsIjxjbGFzczpEZWZpbml0aW9uPiIsImRldGFpbD0iLCJ2YWx1ZSIsIkBuYXRpdmUiLCJ2aWV3PSIsIkRlZmluaXRpb24iLCJjb25zdHJ1Y3QiLCJuYW1lIiwiZGVzYyIsImFsaWFzX25hdGl2ZSIsIkV2ZW50Il0sIm1hcHBpbmdzIjoiQUFBQUEsbUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUVoQkEsT0FBQUM7TUFBQUE7O1FBQUFBOzs7UUFDRUMsTUFBSUMsSUFBSkQsaUJBQUFBLDhCQUFBQTtBQUFBQTtVQUNFQSxPQUFBRSxhQUFPQyxjQUFBQSxDQUFXSCxVQUFYRztRQURUSCxDQUFBQTtRQUlBSTtRQUFBQTs7VUFBQUE7O0FBQUFBOzs7QUFDRUMsVUFBQUEsdUJBQUFBLGlDQUFZQyxLQUFaRDtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUUsY0FBT0YsVUFBWUM7VUFEdkJELENBQUFBO1VBSUFELE9BQUFJLHFCQUFBQSwrQkFBVUYsS0FBVkU7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVELGNBQU9DLFFBQVVGO1VBRHJCRSxDQUFBQTtRQUxGSixHQUFBQSxXQUFBQSxFQUFtQkssZ0JBQW5CTDtRQVVBLElBQUEsUUFjT0gsSUFBQUQsZUFBQUEsQ0FBQUEsQ0FkUCxDQUFBO1VBQUEsSUFBQSxRQUFHRSxhQUFPQyxjQUFBQSxDQUFXSixtQkFBWEksQ0FBVixDQUFBO1lBQ0VPLE1BQUlULElBQUpTLGdCQUFBQSxxQkFBbUJDLElBQUQsRUFBT0MsSUFBekJGO0FBQUFBO2NBQ0VBLE9BQUNBLFlBQWNDLElBQUtELEVBQUlFLElBQUtGO1lBRC9CQSxDQUFBQTtVQURGLE9BSUEsSUFBQSxRQUFNUixhQUFPQyxjQUFBQSxDQUFXSixjQUFYSSxDQUFiLENBQUE7WUFDRU8sTUFBSVQsSUFBSlMsZ0JBQUFBLHFCQUFtQkMsSUFBRCxFQUFPQyxJQUF6QkY7QUFBQUE7O0FBRUpBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtZQVBJQSxDQUFBQTtVQURGO1FBSkE7UUFnQkFULElBQUFZLGNBQUFBLENBQWEsUUFBYkE7UUFDQWQsT0FBQUUsSUFBQVksY0FBQUEsQ0FBYSxNQUFiQTtNQWhDRmQsR0FBQUEsV0FBQUEsRUFBV2UsV0FBWGY7SUFGZ0JELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzA5MjUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L21vdXNlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBjbGFzcyBFdmVudFxuXG5jbGFzcyBNb3VzZSA8IFVJXG4gIGhhbmRsZXMgJ2NsaWNrJywgJ2NvbnRleHRtZW51JywgJ2RibGNsaWNrJywgJ21vdXNlZG93bicsICdtb3VzZWVudGVyJyxcbiAgICAgICAgICAnbW91c2VsZWF2ZScsICdtb3VzZW1vdmUnLCAnbW91c2VvdXQnLCAnbW91c2VvdmVyJywgJ21vdXNldXAnLFxuICAgICAgICAgICdzaG93J1xuXG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBub3QgJCRbOk1vdXNlRXZlbnRdLm5pbD9cbiAgZW5kXG5cbiAgY2xhc3MgRGVmaW5pdGlvbiA8IFVJOjpEZWZpbml0aW9uXG4gICAgY2xhc3MgQ2xpZW50XG4gICAgICBpbmNsdWRlIE5hdGl2ZTo6V3JhcHBlclxuXG4gICAgICBkZWYgeD0odmFsdWUpXG4gICAgICAgIGAjQG5hdGl2ZS5jbGllbnRYID0gI3t2YWx1ZX1gXG4gICAgICBlbmRcblxuICAgICAgZGVmIHk9KHZhbHVlKVxuICAgICAgICBgI0BuYXRpdmUuY2xpZW50WSA9ICN7dmFsdWV9YFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBjbGFzcyBMYXllclxuICAgICAgaW5jbHVkZSBOYXRpdmU6OldyYXBwZXJcblxuICAgICAgZGVmIHg9KHZhbHVlKVxuICAgICAgICBgI0BuYXRpdmUubGF5ZXJYID0gI3t2YWx1ZX1gXG4gICAgICBlbmRcblxuICAgICAgZGVmIHk9KHZhbHVlKVxuICAgICAgICBgI0BuYXRpdmUubGF5ZXJZID0gI3t2YWx1ZX1gXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGNsYXNzIE9mZnNldFxuICAgICAgaW5jbHVkZSBOYXRpdmU6OldyYXBwZXJcblxuICAgICAgZGVmIHg9KHZhbHVlKVxuICAgICAgICBgI0BuYXRpdmUub2Zmc2V0WCA9ICN7dmFsdWV9YFxuICAgICAgZW5kXG5cbiAgICAgIGRlZiB5PSh2YWx1ZSlcbiAgICAgICAgYCNAbmF0aXZlLm9mZnNldFk9ICN7dmFsdWV9YFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBjbGFzcyBQYWdlXG4gICAgICBpbmNsdWRlIE5hdGl2ZTo6V3JhcHBlclxuXG4gICAgICBkZWYgeD0odmFsdWUpXG4gICAgICAgIGAjQG5hdGl2ZS5wYWdlWCA9ICN7dmFsdWV9YFxuICAgICAgZW5kXG5cbiAgICAgIGRlZiB5PSh2YWx1ZSlcbiAgICAgICAgYCNAbmF0aXZlLnBhZ2VZID0gI3t2YWx1ZX1gXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGNsYXNzIFNjcmVlblxuICAgICAgaW5jbHVkZSBOYXRpdmU6OldyYXBwZXJcblxuICAgICAgZGVmIHg9KHZhbHVlKVxuICAgICAgICBgI0BuYXRpdmUuc2NyZWVuWCA9ICN7dmFsdWV9YFxuICAgICAgZW5kXG5cbiAgICAgIGRlZiB5PSh2YWx1ZSlcbiAgICAgICAgYCNAbmF0aXZlLnNjcmVlblkgPSAje3ZhbHVlfWBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgY2xhc3MgQW5jZXN0b3JcbiAgICAgIGluY2x1ZGUgTmF0aXZlOjpXcmFwcGVyXG5cbiAgICAgIGRlZiB4PSh2YWx1ZSlcbiAgICAgICAgYCNAbmF0aXZlLnggPSAje3ZhbHVlfWBcbiAgICAgIGVuZFxuXG4gICAgICBkZWYgeT0odmFsdWUpXG4gICAgICAgIGAjQG5hdGl2ZS55ID0gI3t2YWx1ZX1gXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiB4PSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5zY3JlZW5YID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgeT0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuc2NyZWVuWSA9ICN7dmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIGFsdCFcbiAgICAgIGAjQG5hdGl2ZS5hbHRLZXkgPSB0cnVlYFxuICAgIGVuZFxuXG4gICAgZGVmIGN0cmwhXG4gICAgICBgI0BuYXRpdmUuY3RybEtleSA9IHRydWVgXG4gICAgZW5kXG5cbiAgICBkZWYgbWV0YSFcbiAgICAgIGAjQG5hdGl2ZS5tZXRhS2V5ID0gdHJ1ZWBcbiAgICBlbmRcblxuICAgIGRlZiBidXR0b249KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmJ1dHRvbiA9ICN7dmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIGNsaWVudFxuICAgICAgQ2xpZW50Lm5ldyhAbmF0aXZlKVxuICAgIGVuZFxuXG4gICAgZGVmIGxheWVyXG4gICAgICBMYXllci5uZXcoQG5hdGl2ZSlcbiAgICBlbmRcblxuICAgIGRlZiBvZmZzZXRcbiAgICAgIE9mZnNldC5uZXcoQG5hdGl2ZSlcbiAgICBlbmRcblxuICAgIGRlZiBwYWdlXG4gICAgICBQYWdlLm5ldyhAbmF0aXZlKVxuICAgIGVuZFxuXG4gICAgZGVmIHNjcmVlblxuICAgICAgU2NyZWVuLm5ldyhAbmF0aXZlKVxuICAgIGVuZFxuXG4gICAgZGVmIGFuY2VzdG9yXG4gICAgICBBbmNlc3Rvci5uZXcoQG5hdGl2ZSlcbiAgICBlbmRcblxuICAgIGRlZiByZWxhdGVkPShlbGVtKVxuICAgICAgYCNAbmF0aXZlLnJlbGF0ZWRUYXJnZXQgPSAje05hdGl2ZS50cnlfY29udmVydChlbGVtKX1gXG4gICAgZW5kXG5cbiAgICBkZWYgZnJvbT0oZWxlbSlcbiAgICAgIGAjQG5hdGl2ZS5mcm9tRWxlbWVudCA9ICN7TmF0aXZlLnRyeV9jb252ZXJ0KGVsZW0pfWBcbiAgICBlbmRcblxuICAgIGRlZiB0bz0oZWxlbSlcbiAgICAgIGAjQG5hdGl2ZS50b0VsZW1lbnQgPSAje05hdGl2ZS50cnlfY29udmVydChlbGVtKX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgTW91c2VFdmVudCgje25hbWV9LCAje2Rlc2N9KWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNyZWF0ZSdcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgICV4e1xuICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRcIik7XG4gICAgICAgICAgICBldmVudC5pbml0TW91c2VFdmVudChuYW1lLCBkZXNjLmJ1YmJsZXMsIGRlc2MuY2FuY2VsYWJsZSxcbiAgICAgICAgICAgICAgZGVzYy52aWV3IHx8IHdpbmRvdywgZGVzYy5kZXRhaWwgfHwgMCxcbiAgICAgICAgICAgICAgZGVzYy5zY3JlZW5YIHx8IDAsIGRlc2Muc2NyZWVuWSB8fCAwLFxuICAgICAgICAgICAgICBkZXNjLmNsaWVudFggfHwgMCwgZGVzYy5jbGllbnRZIHx8IDAsXG4gICAgICAgICAgICAgIGRlc2MuY3RybEtleSB8fCBmYWxzZSwgZGVzYy5hbHRLZXkgfHwgZmFsc2UsXG4gICAgICAgICAgICAgIGRlc2Muc2hpZnRLZXkgfHwgZmFsc2UsIGRlc2MubWV0YUtleSB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgZGVzYy5idXR0b24gfHwgMCwgZGVzYy5yZWxhdGVkVGFyZ2V0IHx8IG51bGwpO1xuXG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kIGlmIHN1cHBvcnRlZD9cblxuICBhbGlhc19uYXRpdmUgOmFsdD8sIDphbHRLZXlcbiAgYWxpYXNfbmF0aXZlIDpjdHJsPywgOmN0cmxLZXlcbiAgYWxpYXNfbmF0aXZlIDptZXRhPywgOm1ldGFLZXlcbiAgYWxpYXNfbmF0aXZlIDpzaGlmdD8sIDpzaGlmdEtleVxuICBhbGlhc19uYXRpdmUgOmJ1dHRvblxuXG4gIGRlZiBjbGllbnRcbiAgICBQb3NpdGlvbi5uZXcoYCNAbmF0aXZlLmNsaWVudFhgLCBgI0BuYXRpdmUuY2xpZW50WWApXG4gIGVuZFxuXG4gIGRlZiBsYXllclxuICAgIFBvc2l0aW9uLm5ldyhgI0BuYXRpdmUubGF5ZXJYYCwgYCNAbmF0aXZlLmxheWVyWWApIHVubGVzcyBgI0BuYXRpdmUubGF5ZXJYID09IG51bGxgXG4gIGVuZFxuXG4gIGRlZiBvZmZzZXRcbiAgICBQb3NpdGlvbi5uZXcoYCNAbmF0aXZlLm9mZnNldFhgLCBgI0BuYXRpdmUub2Zmc2V0WWApIHVubGVzcyBgI0BuYXRpdmUub2Zmc2V0WCA9PSBudWxsYFxuICBlbmRcblxuICBkZWYgcGFnZVxuICAgIFBvc2l0aW9uLm5ldyhgI0BuYXRpdmUucGFnZVhgLCBgI0BuYXRpdmUucGFnZVlgKSB1bmxlc3MgYCNAbmF0aXZlLnBhZ2VYID09IG51bGxgXG4gIGVuZFxuXG4gIGRlZiBzY3JlZW5cbiAgICBQb3NpdGlvbi5uZXcoYCNAbmF0aXZlLnNjcmVlblhgLCBgI0BuYXRpdmUuc2NyZWVuWWApIHVubGVzcyBgI0BuYXRpdmUuc2NyZWVuWCA9PSBudWxsYFxuICBlbmRcblxuICBkZWYgYW5jZXN0b3JcbiAgICBQb3NpdGlvbi5uZXcoYCNAbmF0aXZlLnhgLCBgI0BuYXRpdmUueWApIHVubGVzcyBgI0BuYXRpdmUueCA9PSBudWxsYFxuICBlbmRcblxuICBkZWYgeFxuICAgIHNjcmVlbi54XG4gIGVuZFxuXG4gIGRlZiB5XG4gICAgc2NyZWVuLnlcbiAgZW5kXG5cbiAgZGVmIHJlbGF0ZWRcbiAgICBET00oYCNAbmF0aXZlLnJlbGF0ZWRUYXJnZXRgKSB1bmxlc3MgYCNAbmF0aXZlLnJlbGF0ZWRUYXJnZXQgPT0gbnVsbGBcbiAgZW5kXG5cbiAgZGVmIGZyb21cbiAgICBET00oYCNAbmF0aXZlLmZyb21FbGVtZW50YCkgdW5sZXNzIGAjQG5hdGl2ZS5mcm9tRWxlbWVudCA9PSBudWxsYFxuICBlbmRcblxuICBkZWYgdG9cbiAgICBET00oYCNAbmF0aXZlLnRvRWxlbWVudGApIHVubGVzcyBgI0BuYXRpdmUudG9FbGVtZW50ID09IG51bGxgXG4gIGVuZFxuXG4gIGRlZiBjbGljaz9cbiAgICBuYW1lLmRvd25jYXNlID09ICdjbGljaydcbiAgZW5kXG5cbiAgZGVmIGRvdWJsZV9jbGljaz9cbiAgICBuYW1lLmRvd25jYXNlID09ICdkYmxjbGljaydcbiAgZW5kXG5cbiAgZGVmIGRvd24/XG4gICAgbmFtZS5kb3duY2FzZSA9PSAnbW91c2Vkb3duJ1xuICBlbmRcblxuICBkZWYgZW50ZXI/XG4gICAgbmFtZS5kb3duY2FzZSA9PSAnbW91c2VlbnRlcidcbiAgZW5kXG5cbiAgZGVmIGxlYXZlP1xuICAgIG5hbWUuZG93bmNhc2UgPT0gJ21vdXNlbGVhdmUnXG4gIGVuZFxuXG4gIGRlZiBtb3ZlP1xuICAgIG5hbWUuZG93bmNhc2UgPT0gJ21vdXNlbW92ZSdcbiAgZW5kXG5cbiAgZGVmIG91dD9cbiAgICBuYW1lLmRvd25jYXNlID09ICdtb3VzZW91dCdcbiAgZW5kXG5cbiAgZGVmIG92ZXI/XG4gICAgbmFtZS5kb3duY2FzZSA9PSAnbW91c2VvdmVyJ1xuICBlbmRcblxuICBkZWYgdXA/XG4gICAgbmFtZS5kb3duY2FzZSA9PSAnbW91c2V1cCdcbiAgZW5kXG5cbiAgZGVmIHNob3c/XG4gICAgbmFtZS5kb3duY2FzZSA9PSAnc2hvdydcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpFdmVudD4iLCI8Y2xhc3M6TW91c2U+Iiwic2VsZiIsImhhbmRsZXMiLCJzdXBwb3J0ZWQ/IiwiJCQiLCJbXSIsIm5pbD8iLCIhIiwiPGNsYXNzOkRlZmluaXRpb24+IiwiPGNsYXNzOkNsaWVudD4iLCJpbmNsdWRlIiwiTmF0aXZlOjpXcmFwcGVyIiwiTmF0aXZlIiwieD0iLCJ2YWx1ZSIsIkBuYXRpdmUiLCJ5PSIsIjxjbGFzczpMYXllcj4iLCI8Y2xhc3M6T2Zmc2V0PiIsIjxjbGFzczpQYWdlPiIsIjxjbGFzczpTY3JlZW4+IiwiPGNsYXNzOkFuY2VzdG9yPiIsImFsdCEiLCJjdHJsISIsIm1ldGEhIiwiYnV0dG9uPSIsImNsaWVudCIsIkNsaWVudCIsIm5ldyIsImxheWVyIiwiTGF5ZXIiLCJvZmZzZXQiLCJPZmZzZXQiLCJwYWdlIiwiUGFnZSIsInNjcmVlbiIsIlNjcmVlbiIsImFuY2VzdG9yIiwiQW5jZXN0b3IiLCJyZWxhdGVkPSIsImVsZW0iLCJ0cnlfY29udmVydCIsImZyb209IiwidG89IiwiVUk6OkRlZmluaXRpb24iLCJVSSIsIkJyb3dzZXIiLCJzdXBwb3J0cz8iLCJjb25zdHJ1Y3QiLCJuYW1lIiwiZGVzYyIsImFsaWFzX25hdGl2ZSIsIlBvc2l0aW9uIiwieCIsInkiLCJyZWxhdGVkIiwiRE9NIiwiZnJvbSIsInRvIiwiY2xpY2s/IiwiZG93bmNhc2UiLCI9PSIsImRvdWJsZV9jbGljaz8iLCJkb3duPyIsImVudGVyPyIsImxlYXZlPyIsIm1vdmU/Iiwib3V0PyIsIm92ZXI/IiwidXA/Iiwic2hvdz8iXSwibWFwcGluZ3MiOiJBQUFBQSxzQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWhCQSxPQUFBQztNQUFBQTs7UUFBQUE7O0FBQUFBOztRQUNFQyxJQUFBQyxTQUFBQSxDQUFRRixPQUFSLEVBQWlCQSxhQUFqQixFQUFnQ0EsVUFBaEMsRUFBNENBLFdBQTVDLEVBQXlEQSxZQUF6RCxFQUNRQSxZQURSLEVBQ3NCQSxXQUR0QixFQUNtQ0EsVUFEbkMsRUFDK0NBLFdBRC9DLEVBQzREQSxTQUQ1RCxFQUVRQSxNQUZSRTtRQUlBQyxNQUFJRixJQUFKRSxpQkFBQUEsaUNBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFJQyxRQUFFQyxPQUFBQSxDQUFDLFlBQURBLENBQWFDLFNBQUFBLENBQUFBLENBQW5CQyxNQUFBQSxDQUFBQTtRQURGSixDQUFBQTtRQUlBSztRQUFBQTs7VUFBQUE7O0FBQUFBOztVQUNFQztVQUFBQTs7WUFBQUE7O0FBQUFBOztZQUNFUixJQUFBUyxTQUFBQSxDQUFRQyxJQUFBQyxZQUFBRCxZQUFSRDs7QUFFQUcsWUFBQUEsa0JBQUFBLHdCQUFPQyxLQUFQRDtBQUFBQSxjQUFBQTs7Y0FDRUEsT0FBRUUsY0FBT0YsV0FBYUM7WUFEeEJELENBQUFBO1lBSUFKLE9BQUFPLGtCQUFBQSx3QkFBT0YsS0FBUEU7QUFBQUEsY0FBQUE7O2NBQ0VBLE9BQUVELGNBQU9DLFdBQWFGO1lBRHhCRSxDQUFBQTtVQVBGUCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtVQVlBUTtVQUFBQTs7WUFBQUE7O0FBQUFBOztZQUNFaEIsSUFBQVMsU0FBQUEsQ0FBUUMsSUFBQUMsWUFBQUQsWUFBUkQ7O0FBRUFHLFlBQUFB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Y29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQva2V5Ym9hcmQucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IGNsYXNzIEV2ZW50XG5cbmNsYXNzIEtleWJvYXJkIDwgVUlcbiAgaGFuZGxlcyAna2V5ZG93bicsICdrZXlwcmVzcycsICdrZXl1cCdcblxuICBkZWYgc2VsZi5zdXBwb3J0ZWQ/XG4gICAgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LktleWJvYXJkJ1xuICBlbmRcblxuICBjbGFzcyBEZWZpbml0aW9uIDwgVUk6OkRlZmluaXRpb25cbiAgICBkZWYgYWx0IVxuICAgICAgYCNAbmF0aXZlLmFsdEtleSA9IHRydWVgXG4gICAgZW5kXG5cbiAgICBkZWYgY3RybCFcbiAgICAgIGAjQG5hdGl2ZS5jdHJsS2V5ID0gdHJ1ZWBcbiAgICBlbmRcblxuICAgIGRlZiBtZXRhIVxuICAgICAgYCNAbmF0aXZlLm1ldGFLZXkgPSB0cnVlYFxuICAgIGVuZFxuXG4gICAgZGVmIHNoaWZ0IVxuICAgICAgYCNAbmF0aXZlLnNoaWZ0S2V5ID0gdHJ1ZWBcbiAgICBlbmRcblxuICAgIGRlZiBjb2RlPShjb2RlKVxuICAgICAgYCNAbmF0aXZlLmtleUNvZGUgPSAjQG5hdGl2ZS53aGljaCA9ICN7Y29kZX1gXG4gICAgZW5kXG5cbiAgICBkZWYga2V5PShrZXkpXG4gICAgICBgI0BuYXRpdmUua2V5ID0gI3trZXl9YFxuICAgIGVuZFxuXG4gICAgZGVmIGNoYXI9KGNoYXIpXG4gICAgICBgI0BuYXRpdmUuY2hhciA9ICNAbmF0aXZlLmNoYXJDb2RlID0gI3tjaGFyfWBcbiAgICBlbmRcblxuICAgIGRlZiByZXBlYXQhXG4gICAgICBgI0BuYXRpdmUucmVwZWF0ID0gdHJ1ZWBcbiAgICBlbmRcblxuICAgIGRlZiBsb2NhbGU9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmxvY2FsZSA9IHZhbHVlYFxuICAgIGVuZFxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY29uc3RydWN0b3InXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICBgbmV3IEtleWJvYXJkRXZlbnQoI3tuYW1lfSwgI3tkZXNjfSlgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jcmVhdGUnXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICAleHtcbiAgICAgICAgdmFyIG1vZGlmaWVycyA9IFwiXCI7XG5cbiAgICAgICAgaWYgKGRlc2MuYWx0S2V5KSB7XG4gICAgICAgICAgbW9kaWZpZXJzICs9IFwiQWx0IFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc2MuY3RybEtleSkge1xuICAgICAgICAgIG1vZGlmaWVycyArPSBcIkN0cmwgXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVzYy5zaGlmdEtleSkge1xuICAgICAgICAgIG1vZGlmaWVycyArPSBcIlNoaWZ0XCIgO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc2MubWV0YUtleSkge1xuICAgICAgICAgIG1vZGlmaWVycyArPSBcIk1ldGEgXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIktleWJvYXJkRXZlbnRcIik7XG4gICAgICAgICAgICBldmVudC5pbml0S2V5Ym9hcmRFdmVudChuYW1lLCBkZXNjLmJ1YmJsZXMsIGRlc2MuY2FuY2VsYWJsZSxcbiAgICAgICAgICAgICAgZGVzYy52aWV3IHx8IHdpbmRvdywgZGVzYy53aGljaCwgMCxcbiAgICAgICAgICAgICAgbW9kaWZpZXJzLCBkZXNjLnJlcGVhdCwgZGVzYy5sb2NhbGUpO1xuXG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kIGlmIHN1cHBvcnRlZD9cblxuICBhbGlhc19uYXRpdmUgOmFsdD8sIDphbHRLZXlcbiAgYWxpYXNfbmF0aXZlIDpjdHJsPywgOmN0cmxLZXlcbiAgYWxpYXNfbmF0aXZlIDptZXRhPywgOm1ldGFLZXlcbiAgYWxpYXNfbmF0aXZlIDpzaGlmdD8sIDpzaGlmdEtleVxuICBhbGlhc19uYXRpdmUgOmxvY2FsZVxuICBhbGlhc19uYXRpdmUgOnJlcGVhdD8sIDpyZXBlYXRcblxuICAjIElFIDExIGF0IGxlYXN0IGhhcyBkaWZmZXJlbnQgbmFtZXMgZm9yIHRob3NlIGtleXMuXG4gIElFX01BUCA9IHtcbiAgICAnRG93bicgPT4gJ0Fycm93RG93bicsXG4gICAgJ1VwJyA9PiAnQXJyb3dVcCcsXG4gICAgJ0xlZnQnID0+ICdBcnJvd0xlZnQnLFxuICAgICdSaWdodCcgPT4gJ0Fycm93UmlnaHQnLFxuICAgICdFc2MnID0+ICdFc2NhcGUnLFxuICAgICdEZWwnID0+ICdEZWxldGUnXG4gIH1cblxuICBkZWYga2V5XG4gICAga2V5ID0gYCNAbmF0aXZlLmtleSB8fCAjQG5hdGl2ZS5rZXlJZGVudGlmaWVyIHx8IG5pbGBcbiAgICBJRV9NQVBba2V5XSB8fCBrZXlcbiAgZW5kXG5cbiAgZGVmIGNvZGVcbiAgICBgI0BuYXRpdmUua2V5Q29kZSB8fCAjQG5hdGl2ZS53aGljaCB8fCBuaWxgXG4gIGVuZFxuXG4gIGRlZiBjaGFyXG4gICAgYCNAbmF0aXZlLmNoYXIgfHwgI0BuYXRpdmUuY2hhckNvZGUgfHwgI3tjb2RlID8gY29kZS5jaHIgOiBuaWx9YFxuICBlbmRcblxuICBhbGlhcyB0b19pIGtleVxuXG4gIGRlZiBkb3duP1xuICAgIG5hbWUuZG93bmNhc2UgPT0gJ2tleWRvd24nXG4gIGVuZFxuXG4gIGRlZiBwcmVzcz9cbiAgICBuYW1lLmRvd25jYXNlID09ICdrZXlwcmVzcydcbiAgZW5kXG5cbiAgZGVmIHVwP1xuICAgIG5hbWUuZG93bmNhc2UgPT0gJ2tleXVwJ1xuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkV2ZW50PiIsIjxjbGFzczpLZXlib2FyZD4iLCJzZWxmIiwiaGFuZGxlcyIsInN1cHBvcnRlZD8iLCJCcm93c2VyIiwic3VwcG9ydHM/IiwiPGNsYXNzOkRlZmluaXRpb24+IiwiYWx0ISIsIkBuYXRpdmUiLCJjdHJsISIsIm1ldGEhIiwic2hpZnQhIiwiY29kZT0iLCJjb2RlIiwia2V5PSIsImtleSIsImNoYXI9IiwiY2hhciQiLCJyZXBlYXQhIiwibG9jYWxlPSIsInZhbHVlIiwiVUk6OkRlZmluaXRpb24iLCJVSSIsImNvbnN0cnVjdCIsIm5hbWUiLCJkZXNjIiwiYWxpYXNfbmF0aXZlIiwiJHJldF9vcl8xIiwiSUVfTUFQIiwiW10iLCJjaGFyIiwiY2hyIiwiZG93bj8iLCJkb3duY2FzZSIsIj09IiwicHJlc3M/IiwidXA/Il0sIm1hcHBpbmdzIjoiQUFBQUEseUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUVoQkEsT0FBQUM7TUFBQUE7O1FBQUFBOztBQUFBQTs7UUFDRUMsSUFBQUMsU0FBQUEsQ0FBUUYsU0FBUixFQUFtQkEsVUFBbkIsRUFBK0JBLE9BQS9CRTtRQUVBQyxNQUFJRixJQUFKRSxpQkFBQUEsb0NBQUFBO0FBQUFBO1VBQ0VBLE9BQUFDLGFBQU9DLGNBQUFBLENBQVdGLGdCQUFYRTtRQURURixDQUFBQTtRQUlBRztRQUFBQTs7VUFBQUE7O0FBQUFBOzs7QUFDRUMsVUFBQUEsb0JBQUFBLGdDQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUMsY0FBT0Q7VUFEWEEsQ0FBQUE7O0FBSUFFLFVBQUFBLHFCQUFBQSxpQ0FBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVELGNBQU9DO1VBRFhBLENBQUFBOztBQUlBQyxVQUFBQSxxQkFBQUEsaUNBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRixjQUFPRTtVQURYQSxDQUFBQTs7QUFJQUMs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QSxHQUFBLENBQU9aLElBQUFZLE1BQUFBLENBQUFBLENBQUlrQixLQUFBQSxDQUFBQSxDQUFYLElBQUEsQ0FBa0IsR0FBbEIsQ0FBQTtRQUQzQ0QsQ0FBQUE7UUFJQSxhQUFNLE1BQU4sRUFBVyxLQUFYOztBQUVBRSxRQUFBQSxxQkFBQUEsZ0NBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBL0IsSUFBQXVCLE1BQUFBLENBQUFBLENBQUlTLFVBQUFBLENBQUFBLENBQVVDLE9BQUFBLENBQUdGLFNBQUhFO1FBRGhCRixDQUFBQTs7QUFJQUcsUUFBQUEsc0JBQUFBLGlDQUFBQTtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBQWxDLElBQUF1QixNQUFBQSxDQUFBQSxDQUFJUyxVQUFBQSxDQUFBQSxDQUFVQyxPQUFBQSxDQUFHQyxVQUFIRDtRQURoQkMsQ0FBQUE7UUFJQW5DLE9BQUFvQyxtQkFBQUEsOEJBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBbkMsSUFBQXVCLE1BQUFBLENBQUFBLENBQUlTLFVBQUFBLENBQUFBLENBQVVDLE9BQUFBLENBQUdFLE9BQUhGO1FBRGhCRSxDQUFBQTtNQXhIRnBDLEdBQUFBLFdBQUFBLEVBQWlCc0IsUUFBakJ0QjtJQUZnQkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMTUzOSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4vb3N0cnVjdC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGJhY2t0aWNrX2phdmFzY3JpcHQ6IHRydWVcblxuY2xhc3MgT3BlblN0cnVjdFxuICBkZWYgaW5pdGlhbGl6ZShoYXNoID0gbmlsKVxuICAgIEB0YWJsZSA9IHt9XG5cbiAgICBpZiBoYXNoXG4gICAgICBoYXNoLmVhY2hfcGFpciBkbyB8a2V5LCB2YWx1ZXxcbiAgICAgICAgQHRhYmxlW25ld19vc3RydWN0X21lbWJlcihrZXkpXSA9IHZhbHVlXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIFtdKG5hbWUpXG4gICAgQHRhYmxlW25hbWUudG9fc3ltXVxuICBlbmRcblxuICBkZWYgW109KG5hbWUsIHZhbHVlKVxuICAgIEB0YWJsZVtuZXdfb3N0cnVjdF9tZW1iZXIobmFtZSldID0gdmFsdWVcbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF9taXNzaW5nKG5hbWUsICphcmdzKVxuICAgIGlmIGFyZ3MubGVuZ3RoID4gMlxuICAgICAgcmFpc2UgTm9NZXRob2RFcnJvci5uZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGAje25hbWV9JyBmb3IgIzxPcGVuU3RydWN0PlwiLCBuYW1lKVxuICAgIGVuZFxuICAgIGlmIG5hbWUuZW5kX3dpdGg/ICc9J1xuICAgICAgaWYgYXJncy5sZW5ndGggIT0gMVxuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMCBmb3IgMSknXG4gICAgICBlbmRcbiAgICAgIEB0YWJsZVtuZXdfb3N0cnVjdF9tZW1iZXIobmFtZVswLi4tMl0pXSA9IGFyZ3NbMF1cbiAgICBlbHNlXG4gICAgICBAdGFibGVbbmFtZS50b19zeW1dXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiByZXNwb25kX3RvX21pc3Npbmc/KG1pZCwgaW5jbHVkZV9wcml2YXRlID0gZmFsc2UpICMgOm5vZG9jOlxuICAgIG1uYW1lID0gbWlkLnRvX3MuY2hvbXAoJz0nKS50b19zeW1cbiAgICBAdGFibGUmLmtleT8obW5hbWUpIHx8IHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBlYWNoX3BhaXJcbiAgICByZXR1cm4gZW51bV9mb3IgOmVhY2hfcGFpciB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBAdGFibGUuZWFjaF9wYWlyIGRvIHxwYWlyfFxuICAgICAgeWllbGQgcGFpclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyBvdGhlci5pc19hPyhPcGVuU3RydWN0KVxuXG4gICAgQHRhYmxlID09IG90aGVyLmluc3RhbmNlX3ZhcmlhYmxlX2dldCg6QHRhYmxlKVxuICBlbmRcblxuICBkZWYgPT09KG90aGVyKVxuICAgIHJldHVybiBmYWxzZSB1bmxlc3Mgb3RoZXIuaXNfYT8oT3BlblN0cnVjdClcblxuICAgIEB0YWJsZSA9PT0gb3RoZXIuaW5zdGFuY2VfdmFyaWFibGVfZ2V0KDpAdGFibGUpXG4gIGVuZFxuXG4gIGRlZiBlcWw/KG90aGVyKVxuICAgIHJldHVybiBmYWxzZSB1bmxlc3Mgb3RoZXIuaXNfYT8oT3BlblN0cnVjdClcblxuICAgIEB0YWJsZS5lcWw/IG90aGVyLmluc3RhbmNlX3ZhcmlhYmxlX2dldCg6QHRhYmxlKVxuICBlbmRcblxuICBkZWYgdG9faCgmYmxvY2spXG4gICAgYmxvY2tfZ2l2ZW4/ID8gQHRhYmxlLnRvX2goJmJsb2NrKSA6IEB0YWJsZS5kdXBcbiAgZW5kXG5cbiAgZGVmIHRvX25cbiAgICBAdGFibGUudG9fblxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIEB0YWJsZS5oYXNoXG4gIGVuZFxuXG4gIGF0dHJfcmVhZGVyIDp0YWJsZVxuXG4gIGRlZiBkZWxldGVfZmllbGQobmFtZSlcbiAgICBzeW0gPSBuYW1lLnRvX3N5bVxuICAgIGJlZ2luXG4gICAgICBzaW5nbGV0b25fY2xhc3MuX19zZW5kX18oOnJlbW92ZV9tZXRob2QsIHN5bSwgXCIje3N5bX09XCIpXG4gICAgcmVzY3VlIE5hbWVFcnJvclxuICAgIGVuZFxuICAgIEB0YWJsZS5kZWxldGUgc3ltXG4gIGVuZFxuXG4gIGRlZiBuZXdfb3N0cnVjdF9tZW1iZXIobmFtZSlcbiAgICBuYW1lID0gbmFtZS50b19zeW1cbiAgICB1bmxlc3MgcmVzcG9uZF90bz8obmFtZSlcbiAgICAgIGRlZmluZV9zaW5nbGV0b25fbWV0aG9kKG5hbWUpIHsgQHRhYmxlW25hbWVdIH1cbiAgICAgIGRlZmluZV9zaW5nbGV0b25fbWV0aG9kKFwiI3tuYW1lfT1cIikgeyB8eHwgQHRhYmxlW25hbWVdID0geCB9XG4gICAgZW5kXG4gICAgbmFtZVxuICBlbmRcblxuICBgdmFyIG9zdHJ1Y3RfaWRzO2BcblxuICBkZWYgaW5zcGVjdFxuICAgICV4e1xuICAgICAgdmFyIHRvcCA9IChvc3RydWN0X2lkcyA9PT0gdW5kZWZpbmVkKSxcbiAgICAgICAgICBvc3RydWN0X2lkID0gI3tfX2lkX199O1xuICAgIH1cbiAgICBiZWdpblxuICAgICAgcmVzdWx0ID0gXCIjPCN7c2VsZi5jbGFzc31cIlxuICAgICAgJXh7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICBvc3RydWN0X2lkcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvc3RydWN0X2lkcy5oYXNPd25Qcm9wZXJ0eShvc3RydWN0X2lkKSkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnIC4uLj4nO1xuICAgICAgICB9XG4gICAgICAgIG9zdHJ1Y3RfaWRzW29zdHJ1Y3RfaWRdID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0ICs9ICcgJyBpZiBAdGFibGUuYW55P1xuXG4gICAgICByZXN1bHQgKz0gZWFjaF9wYWlyLm1hcCBkbyB8bmFtZSwgdmFsdWV8XG4gICAgICAgIFwiI3tuYW1lfT0je3ZhbHVlLmluc3BlY3R9XCJcbiAgICAgIGVuZC5qb2luICcsICdcblxuICAgICAgcmVzdWx0ICs9ICc+J1xuXG4gICAgICByZXN1bHRcbiAgICBlbnN1cmVcbiAgICAgICV4e1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgb3N0cnVjdF9pZHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXMgdG9fcyBpbnNwZWN0XG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOk9wZW5TdHJ1Y3Q+IiwiaW5pdGlhbGl6ZSIsImhhc2giLCJAdGFibGUiLCJlYWNoX3BhaXIiLCJibG9jayBpbiBpbml0aWFsaXplIiwia2V5IiwidmFsdWUiLCJibG9jayAoMiBsZXZlbHMpIGluIGluaXRpYWxpemUiLCJbXT0iLCJzZWxmIiwibmV3X29zdHJ1Y3RfbWVtYmVyIiwiW10iLCJuYW1lIiwidG9fc3ltIiwibWV0aG9kX21pc3NpbmciLCI+IiwiYXJncyIsImxlbmd0aCIsIjIiLCJyYWlzZSIsIk5vTWV0aG9kRXJyb3IiLCJuZXciLCJlbmRfd2l0aD8iLCIxIiwiQXJndW1lbnRFcnJvciIsIjAiLCItMiIsInJlc3BvbmRfdG9fbWlzc2luZz8iLCJtaWQiLCJpbmNsdWRlX3ByaXZhdGUiLCJtbmFtZSIsInRvX3MiLCJjaG9tcCIsIiRyZXRfb3JfMSIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwiYmxvY2sgaW4gZWFjaF9wYWlyIiwicGFpciIsIj09Iiwib3RoZXIiLCJpc19hPyIsIk9wZW5TdHJ1Y3QiLCJpbnN0YW5jZV92YXJpYWJsZV9nZXQiLCI9PT0iLCJlcWw/IiwidG9faCIsImJsb2NrIiwidG9fcHJvYyIsImR1cCIsInRvX24iLCJhdHRyX3JlYWRlciIsImRlbGV0ZV9maWVsZCIsInN5bSIsInNpbmdsZXRvbl9jbGFzcyIsIl9fc2VuZF9fIiwiTmFtZUVycm9yIiwiZGVsZXRlIiwicmVzcG9uZF90bz8iLCJkZWZpbmVfc2luZ2xldG9uX21ldGhvZCIsImJsb2NrIGluIG5ld19vc3RydWN0X21lbWJlciIsImJsb2NrICgyIGxldmVscykgaW4gbmV3X29zdHJ1Y3RfbWVtYmVyIiwieCIsImluc3BlY3QiLCJfX2lkX18iLCJyZXN1bHQiLCJjbGFzcyIsImFueT8iLCIrIiwibWFwIiwiYmxvY2sgaW4gaW5zcGVjdCIsImJsb2NrICgyIGxldmVscykgaW4gaW5zcGVjdCIsImpvaW4iXSwibWFwcGluZ3MiOiJBQUFBQSwwQkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUVBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0FBQUFBOzs7QUFDRUMsSUFBQUEsMEJBQUFBLHNCQUFlQyxJQUFmRDtBQUFBQSxNQUFBQTs7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QSxXQUFBQSxFQUFBQSxJQUFBQTtBQUZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzE3NjksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L2N1c3RvbS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdvc3RydWN0J1xuXG5tb2R1bGUgQnJvd3NlcjsgY2xhc3MgRXZlbnRcblxuY2xhc3MgQ3VzdG9tIDwgRXZlbnRcbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5DdXN0b20nXG4gIGVuZFxuXG4gIGNsYXNzIERlZmluaXRpb24gPCBEZWZpbml0aW9uXG4gICAgZGVmIG1ldGhvZF9taXNzaW5nKG5hbWUsIHZhbHVlKVxuICAgICAgaWYgbmFtZS5lbmRfd2l0aD8gPz1cbiAgICAgICAgYCNAbmF0aXZlWyN7bmFtZVswIC4uIC0yXX1dID0gdmFsdWVgXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5cbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNvbnN0cnVjdG9yJ1xuICAgIGRlZiBzZWxmLmNvbnN0cnVjdChuYW1lLCBkZXNjKVxuICAgICAgYHJldHVybiBuZXcgQ3VzdG9tRXZlbnQobmFtZSwge1xuICAgICAgICBidWJibGVzOiAgICBkZXNjLmJ1YmJsZXMsXG4gICAgICAgIGNhbmNlbGFibGU6IGRlc2MuY2FuY2VsYWJsZSxcbiAgICAgICAgZGV0YWlsOiAgICAgZGVzYyB9KWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNyZWF0ZSdcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgICV4e1xuICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuICAgICAgICAgICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KG5hbWUsIGRlc2MuYnViYmxlcywgZGVzYy5jYW5jZWxhYmxlLCBkZXNjKTtcblxuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jcmVhdGVPYmplY3QnXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICBOYXRpdmUoYGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KClgKS5tZXJnZSEoYHtcbiAgICAgICAgdHlwZTogICAgICAgbmFtZSxcbiAgICAgICAgYnViYmxlczogICAgZGVzYy5idWJibGVzLFxuICAgICAgICBjYW5jZWxhYmxlOiBkZXNjLmNhbmNlbGFibGUsXG4gICAgICAgIGRldGFpbDogICAgIGRlc2MgfWApLnRvX25cbiAgICBlbmRcbiAgZWxzZVxuICAgIGRlZiBzZWxmLmNvbnN0cnVjdChuYW1lLCBkZXNjKVxuICAgICAgTmF0aXZlKGRlc2MpLm1lcmdlIShge1xuICAgICAgICB0eXBlOiAgICAgICBuYW1lLFxuICAgICAgICBidWJibGVzOiAgICBkZXNjLmJ1YmJsZXMsXG4gICAgICAgIGNhbmNlbGFibGU6IGRlc2MuY2FuY2VsYWJsZSxcbiAgICAgICAgZGV0YWlsOiAgICAgZGVzYyB9YCkudG9fblxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZShldmVudCwgY2FsbGJhY2sgPSBuaWwpXG4gICAgc3VwZXIoZXZlbnQsIGNhbGxiYWNrKVxuXG4gICAgQGRldGFpbCA9IEhhc2gubmV3KGAje2V2ZW50fS5kZXRhaWxgKVxuICBlbmRcblxuICBkZWYgbWV0aG9kX21pc3NpbmcoaWQsICopXG4gICAgcmV0dXJuIEBkZXRhaWxbaWRdIGlmIEBkZXRhaWwuaGFzX2tleT8oaWQpXG5cbiAgICBzdXBlclxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8Y2xhc3M6RXZlbnQ+IiwiPGNsYXNzOkN1c3RvbT4iLCJzdXBwb3J0ZWQ/IiwiQnJvd3NlciIsInN1cHBvcnRzPyIsIjxjbGFzczpEZWZpbml0aW9uPiIsIm1ldGhvZF9taXNzaW5nIiwibmFtZSIsInZhbHVlIiwiZW5kX3dpdGg/IiwiQG5hdGl2ZSIsIltdIiwiMCIsIi0yIiwiRGVmaW5pdGlvbiIsImNvbnN0cnVjdCIsImRlc2MiLCJOYXRpdmUiLCJtZXJnZSEiLCJ0b19uIiwiaW5pdGlhbGl6ZSIsImV2ZW50IiwiY2FsbGJhY2siLCJAZGV0YWlsIiwiSGFzaCIsIm5ldyIsImlkIiwiaGFzX2tleT8iLCIkZndkX3Jlc3QiLCJFdmVudCJdLCJtYXBwaW5ncyI6IkFBQUFBLHVDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixTQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWhCQSxPQUFBQztNQUFBQTs7UUFBQUE7O0FBQUFBOztRQUNFQyxNQUFJTCxJQUFKSyxpQkFBQUEsa0NBQUFBO0FBQUFBO1VBQ0VBLE9BQUFDLGFBQU9DLGNBQUFBLENBQVdGLGNBQVhFO1FBRFRGLENBQUFBO1FBSUFHO1FBQUFBOztVQUFBQTs7QUFBQUE7VUFDRUEsT0FBQUMsOEJBQUFBLDBCQUFtQkMsSUFBRCxFQUFPQyxLQUF6QkY7QUFBQUEsWUFBQUE7O1lBQ0UsSUFBQSxRQUFHQyxJQUFJRSxjQUFBQSxDQUFXSCxHQUFYRyxDQUFQLENBQUE7Y0FDRUgsT0FBRUksY0FBT0osQ0FBR0MsSUFBSUksT0FBQUEsQ0FBQyxPQUFBQyxDQUFBLEVBQUtDLEVBQUwsUUFBREYsQ0FBVUw7WUFENUI7Y0FYTkEsT0FBQTtZQVdNO1VBREZBLENBQUFBO1FBREZELEdBQUFBLFdBQUFBLEVBQW1CUyxnQkFBbkJUO1FBUUEsSUFBQSxRQUFHRixhQUFPQyxjQUFBQSxDQUFXSCxtQkFBWEcsQ0FBVixDQUFBO1VBQ0VXLE1BQUlsQixJQUFKa0IsZ0JBQUFBLHFCQUFtQlIsSUFBRCxFQUFPUyxJQUF6QkQ7QUFBQUE7WUFDR0E7QUFDUEE7QUFDQUE7QUFDQUE7VUFKSUEsQ0FBQUE7UUFERixPQU9BLElBQUEsUUFBTVosYUFBT0MsY0FBQUEsQ0FBV0gsY0FBWEcsQ0FBYixDQUFBO1VBQ0VXLE1BQUlsQixJQUFKa0IsZ0JBQUFBLHFCQUFtQlIsSUFBRCxFQUFPUyxJQUF6QkQ7QUFBQUE7O0FBRUpBO0FBQ0FBOztBQUVBQTtBQUNBQTtVQU5JQSxDQUFBQTtRQURGLE9BU0EsSUFBQSxRQUFNWixhQUFPQyxjQUFBQSxDQUFXSCxvQkFBWEcsQ0FBYixDQUFBO1VBQ0VXLE1BQUlsQixJQUFKa0IsZ0JBQUFBLHFCQUFtQlIsSUFBRCxFQUFPUyxJQUF6QkQ7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUFsQixJQUFBb0IsUUFBQUEsQ0FBUUYsNEJBQVJFLENBQXNDQyxXQUFBQSxDQUFTSDtBQUNyREE7QUFDQUE7QUFDQUE7QUFDQUEsMEJBSjRDRyxDQUloQkMsTUFBQUEsQ0FBQUE7VUFMeEJKLENBQUFBO1FBREY7VUFTRUEsTUFBSWxCLElBQUprQixnQkFBQUEscUJBQW1CUixJQUFELEVBQU9TLElBQXpCRDtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBQWxCLElBQUFvQixRQUFBQSxDQUFPRCxJQUFQQyxDQUFZQyxXQUFBQSxDQUFTSDtBQUMzQkE7QUFDQUE7QUFDQUE7QUFDQUEsMEJBSmtCRyxDQUlVQyxNQUFBQSxDQUFBQTtVQUx4QkosQ0FBQUE7UUFURjs7QUFrQkFLLFFBQUFBLDBCQUFBQSxzQkFBZUMsS0FBRCxFQUFRQyxRQUF0QkY7QUFBQUEsVUFBQUE7O1VBQUFBOztVQUFzQixpQ0FBVztVQUMvQixPQUFBdkIsSUFBQSxFQUFBLDBEQUFBLGNBQUEsRUFBQSxDQUFNd0IsS0FBTixFQUFhQyxRQUFiLENBQUEsRUFBQSxJQUFBO1VBRUFGLE9BQUFHLENBQUFBLGNBQVVDLFVBQUlDLEtBQUFBLENBQVFKLEtBQU1ELE9BQWRLLENBQWRGO1FBSEZILENBQUFBLElBQUFBO1FBTUFuQixPQUFBSyw4QkFBQUEsMEJBQW1Cb0IsRUFBRCxFQXpEcEIsRUF5REVwQjtBQUFBQSxVQUFBQTs7VUFBQUE7O1VBekRGO1VBeUR5QjtVQUNyQixJQUFBLFFBQXNCaUIsV0FBT0ksYUFBQUEsQ0FBVUQsRUFBVkMsQ0FBN0IsQ0FBQTtZQUFBLE9BQU9KLFdBQU9aLE9BQUFBLENBQUNlLEVBQURmO1VBQWQ7VUFFQUwsT0FBQSxPQUFBVCxJQUFBLEVBQUEsa0VBQUEsa0JBQUEsRUFBQSxDQUFBNkIsRUFBQSxDQUFBLFFBQUEsTUFBQUUsU0FBQSxDQUFBLENBQUEsRUFBQSxNQUFBO1FBSEZ0QixDQUFBQSxJQUFBQTtNQXJERkwsR0FBQUEsV0FBQUEsRUFBZTRCLFdBQWY1QjtJQUZnQkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBRkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMTg3OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnYnJvd3Nlci9ldmVudC9iYXNlJ1xuXG5tb2R1bGUgQnJvd3NlclxuXG5jbGFzcyBFdmVudFxuICBkZWYgc2VsZi5hbGlhc2VzXG4gICAgQGFsaWFzZXMgfHw9IHtcbiAgICAgICdkb206bG9hZCcgPT4gJ0RPTUNvbnRlbnRMb2FkZWQnLFxuICAgICAgJ2hvdmVyJyAgICA9PiAnbW91c2U6b3ZlcidcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLm5hbWVfZm9yKG5hbWUpXG4gICAgKGFsaWFzZXNbbmFtZV0gfHwgbmFtZSkuZ3N1Yig/OiwgJycpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmhhbmRsZXJzXG4gICAgQGhhbmRsZXJzIHx8PSB7fVxuICBlbmRcblxuICBkZWYgc2VsZi5oYW5kbGVzKCpldmVudHMpXG4gICAgZXZlbnRzLmVhY2ggeyB8ZXZlbnR8IEV2ZW50LmhhbmRsZXJzW2V2ZW50XSA9IHNlbGYgfVxuICBlbmRcblxuICAjIFRob3NlIGV2ZW50cyBkb24ndCBoYXZlIGludGVyZXN0aW5nIHByb3BlcnRpZXMgdG8gd2FycmFudCBhIGN1c3RvbSBjbGFzc1xuICAjIG9yIGFyZSBub3QgY3VycmVudGx5IGltcGxlbWVudGVkLlxuICBoYW5kbGVzICdhYm9ydCcsICdhZnRlcnByaW50JywgJ2JlZm9yZXByaW50JywgJ2NhY2hlZCcsICdjYW5wbGF5JyxcbiAgICAgICAgICAnY2FucGxheXRocm91Z2gnLCAnY2hhbmdlJywgJ2NoYXJnaW5nY2hhbmdlJywgJ2NoYXJnaW5ndGltZWNoYW5nZScsXG4gICAgICAgICAgJ2NoZWNraW5nJywgJ2Nsb3NlJywgJ2Rpc2NoYXJnaW5ndGltZWNoYW5nZScsICdET01Db250ZW50TG9hZGVkJyxcbiAgICAgICAgICAnZG93bmxvYWRpbmcnLCAnZHVyYXRpb25jaGFuZ2UnLCAnZW1wdGllZCcsICdlbmRlZCcsICdlcnJvcicsXG4gICAgICAgICAgJ2Z1bGxzY3JlZW5jaGFuZ2UnLCAnZnVsbHNjcmVlbmVycm9yJywgJ2lucHV0JywgJ2ludmFsaWQnLFxuICAgICAgICAgICdsZXZlbGNoYW5nZScsICdsb2FkZWRkYXRhJywgJ2xvYWRlZG1ldGFkYXRhJywgJ25vdXBkYXRlJywgJ29ic29sZXRlJyxcbiAgICAgICAgICAnb2ZmbGluZScsICdvbmxpbmUnLCAnb3BlbicsICdvcmllbnRhdGlvbmNoYW5nZScsICdwYXVzZScsXG4gICAgICAgICAgJ3BvaW50ZXJsb2NrY2hhbmdlJywgJ3BvaW50ZXJsb2NrZXJyb3InLCAncGxheScsICdwbGF5aW5nJyxcbiAgICAgICAgICAncmF0ZWNoYW5nZScsICdyZWFkeXN0YXRlY2hhbmdlJywgJ3Jlc2V0JywgJ3NlZWtlZCcsICdzZWVraW5nJyxcbiAgICAgICAgICAnc3RhbGxlZCcsICdzdWJtaXQnLCAnc3VjY2VzcycsICdzdXNwZW5kJywgJ3RpbWV1cGRhdGUnLCAndXBkYXRlcmVhZHknLFxuICAgICAgICAgICd2aXNpYmlsaXR5Y2hhbmdlJywgJ3ZvbHVtZWNoYW5nZScsICd3YWl0aW5nJ1xuXG4gIGRlZiBzZWxmLmNsYXNzX2ZvcihuYW1lKVxuICAgIEBoYW5kbGVyc1tuYW1lX2ZvcihuYW1lKV0gfHwgQ3VzdG9tXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICB0cnVlXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNyZWF0ZShuYW1lLCAqYXJncywgJmJsb2NrKVxuICAgIG5hbWUgID0gbmFtZV9mb3IobmFtZSlcbiAgICBrbGFzcyA9IGNsYXNzX2ZvcihuYW1lKVxuXG4gICAgZXZlbnQgPSBrbGFzcy5uZXcoa2xhc3MuY29uc3RydWN0KG5hbWUsIGtsYXNzLmNvbnN0X2dldCg6RGVmaW5pdGlvbikubmV3KCZibG9jaykpKVxuICAgIGV2ZW50LmFyZ3VtZW50cyA9IGFyZ3NcblxuICAgIGV2ZW50XG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgRXZlbnQoI3tuYW1lfSwgI3tkZXNjfSlgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jcmVhdGUnXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICAleHtcbiAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJIVE1MRXZlbnRzXCIpO1xuICAgICAgICAgICAgZXZlbnQuaW5pdEV2ZW50KG5hbWUsIGRlc2MuYnViYmxlcywgZGVzYy5jYW5jZWxhYmxlKTtcblxuICAgICAgICAje3JldHVybiBOYXRpdmUoYGV2ZW50YCkubWVyZ2UhKGRlc2MpfTtcbiAgICAgIH1cbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNyZWF0ZU9iamVjdCdcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIE5hdGl2ZShgZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKWApIFxcXG4gICAgICAgIC5tZXJnZSEoZGVzYykgXFxcbiAgICAgICAgLm1lcmdlIShgeyB0eXBlOiBuYW1lIH1gKSBcXFxuICAgICAgICAudG9fblxuICAgIGVuZFxuICBlbHNlXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICBOYXRpdmUoZGVzYykubWVyZ2UhKGB7IHR5cGU6IG5hbWUgfWApLnRvX25cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNlbGYubmV3KHZhbHVlLCBjYWxsYmFjayA9IG5pbClcbiAgICByZXR1cm4gc3VwZXIgdW5sZXNzIHNlbGYgPT0gRXZlbnRcblxuICAgIGtsYXNzID0gY2xhc3NfZm9yKGNhbGxiYWNrID8gY2FsbGJhY2submFtZSA6IGB2YWx1ZS50eXBlYClcblxuICAgIGlmIGtsYXNzID09IEV2ZW50XG4gICAgICBzdXBlclxuICAgIGVsc2VcbiAgICAgIGtsYXNzLm5ldyh2YWx1ZSwgY2FsbGJhY2spXG4gICAgZW5kXG4gIGVuZFxuXG4gIGF0dHJfcmVhZGVyIDpjYWxsYmFja1xuICBhdHRyX3dyaXRlciA6b25cblxuICBkZWYgaW5pdGlhbGl6ZShldmVudCwgY2FsbGJhY2sgPSBuaWwpXG4gICAgc3VwZXIoZXZlbnQpXG5cbiAgICBAY2FsbGJhY2sgPSBjYWxsYmFja1xuICBlbmRcblxuICBkZWYgbmFtZVxuICAgIGAjQG5hdGl2ZS50eXBlYFxuICBlbmRcblxuICBkZWYgb25cbiAgICBAb24gfHwgVGFyZ2V0LmNvbnZlcnQoYCNAbmF0aXZlLmN1cnJlbnRUYXJnZXRgKVxuICBlbmRcblxuICBkZWYgdGFyZ2V0XG4gICAgVGFyZ2V0LmNvbnZlcnQoYCNAbmF0aXZlLnNyY0VsZW1lbnQgfHwgI0BuYXRpdmUudGFyZ2V0YClcbiAgZW5kXG5cbiAgZGVmIGFyZ3VtZW50c1xuICAgIGAjQG5hdGl2ZS5hcmd1bWVudHMgfHwgW11gXG4gIGVuZFxuXG4gIGRlZiBhcmd1bWVudHM9KGFyZ3MpXG4gICAgYCNAbmF0aXZlLmFyZ3VtZW50cyA9ICN7YXJnc31gXG4gIGVuZFxuXG4gIGFsaWFzX25hdGl2ZSA6YnViYmxlcz8sIDpidWJibGVzXG4gIGFsaWFzX25hdGl2ZSA6Y2FuY2VsYWJsZT8sIDpjYW5jZWxhYmxlXG4gIGFsaWFzX25hdGl2ZSA6ZGF0YVxuICBhbGlhc19uYXRpdmUgOnBoYXNlLCA6ZXZlbnRQaGFzZVxuICBhbGlhc19uYXRpdmUgOmF0LCA6dGltZVN0YW1wXG5cbiAgZGVmIG9mZlxuICAgIEBjYWxsYmFjay5vZmYgaWYgQGNhbGxiYWNrXG4gIGVuZFxuXG4gIGRlZiBzdG9wcGVkP1xuICAgIGAhISNAbmF0aXZlLnN0b3BwZWRgXG4gIGVuZFxuXG4gIGRlZiBzdG9wXG4gICAgYCNAbmF0aXZlLnN0b3BQcm9wYWdhdGlvbigpYCBpZiBkZWZpbmVkPyhgI0BuYXRpdmUuc3RvcFByb3BhZ2F0aW9uYClcbiAgICBgI0BuYXRpdmUuc3RvcHBlZCA9IHRydWVgXG4gIGVuZFxuXG4gIGRlZiBwcmV2ZW50XG4gICAgYCNAbmF0aXZlLnByZXZlbnREZWZhdWx0KClgIGlmIGRlZmluZWQ/KGAjQG5hdGl2ZS5wcmV2ZW50RGVmYXVsdGApXG4gICAgYCNAbmF0aXZlLnByZXZlbnRlZCA9IHRydWVgXG4gIGVuZFxuXG4gIGRlZiBwcmV2ZW50ZWQ/XG4gICAgYCEhI0BuYXRpdmUucHJldmVudGVkYFxuICBlbmRcblxuICBkZWYgc3RvcCFcbiAgICBwcmV2ZW50XG4gICAgc3RvcFxuICBlbmRcbmVuZFxuXG5lbmRcblxucmVxdWlyZSAnYnJvd3Nlci9ldmVudC91aSdcbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQvbW91c2UnXG5yZXF1aXJlICdicm93c2VyL2V2ZW50L2tleWJvYXJkJ1xucmVxdWlyZSAnYnJvd3Nlci9ldmVudC9jdXN0b20nXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpFdmVudD4iLCJhbGlhc2VzIiwiQGFsaWFzZXMiLCIkcmV0X29yXzEiLCJuYW1lX2ZvciIsIm5hbWUiLCJbXSIsImdzdWIiLCJoYW5kbGVycyIsIkBoYW5kbGVycyIsImhhbmRsZXMiLCJlYWNoIiwiZXZlbnRzIiwiYmxvY2sgaW4gaGFuZGxlcyIsImV2ZW50IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBoYW5kbGVzIiwiW109IiwiRXZlbnQiLCJjbGFzc19mb3IiLCJDdXN0b20iLCJzdXBwb3J0ZWQ/IiwiY3JlYXRlIiwia2xhc3MiLCJuZXciLCJjb25zdHJ1Y3QiLCJjb25zdF9nZXQiLCJibG9jayIsInRvX3Byb2MiLCJhcmd1bWVudHM9IiwiYXJncyIsIkJyb3dzZXIiLCJzdXBwb3J0cz8iLCJkZXNjIiwiTmF0aXZlIiwibWVyZ2UhIiwidG9fbiIsInZhbHVlIiwiY2FsbGJhY2siLCJhdHRyX3JlYWRlciIsImF0dHJfd3JpdGVyIiwiaW5pdGlhbGl6ZSIsIkBjYWxsYmFjayIsIkBuYXRpdmUiLCJvbiIsIkBvbiIsIlRhcmdldCIsImNvbnZlcnQiLCJ0YXJnZXQiLCJhcmd1bWVudHMiLCJhbGlhc19uYXRpdmUiLCJvZmYiLCJzdG9wcGVkPyIsInN0b3AiLCJwcmV2ZW50IiwicHJldmVudGVkPyIsInN0b3AhIl0sIm1hcHBpbmdzIjoiQUFBQUEsZ0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLG9CQUFSRTtFQUVBQztFQUFBQTs7SUFBQUE7O0lBRUFBLE9BQUFDO0lBQUFBOztNQUFBQTs7QUFBQUE7O01BQ0VDLE1BQUlKLElBQUpJLGNBQUFBLG1CQUFBQTtBQUFBQSxRQUFBQTtBQUFBQTs7UUFDRUEsT0FBQUMsQ0FBQUEsZUFOSixDQUFBLFFBQUFDLENBQUFBLFlBTUlELFlBTkpDLENBQUEsQ0FBQSxHQUFBLENBQUEsU0FBQSxJQUFBLENBTWlCLFVBQUEsV0FBQSxFQUNHRixrQkFESCxDQUFBLEVBQUEsUUFBQSxFQUVHQSxZQUZILENBQUEsR0FOakIsQ0FBQSxD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LEVBQUdULGNBQU9TO01BRGJBLENBQUFBOztBQUlBQyxNQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLFFBQUFBOzs7UUFDRSxJQUFBLFFBQWdDLFFBQVdWLGNBQU9VLGdCQUFsQixrQkFBaEMsQ0FBQTtVQUFFVixjQUFPVTtRQUFUO1FBQ0FBLE9BQUVWLGNBQU9VO01BRlhBLENBQUFBOztBQUtBQyxNQUFBQSx1QkFBQUEsbUJBQUFBO0FBQUFBLFFBQUFBOzs7UUFDRSxJQUFBLFFBQStCLFFBQVdYLGNBQU9XLGVBQWxCLGtCQUEvQixDQUFBO1VBQUVYLGNBQU9XO1FBQVQ7UUFDQUEsT0FBRVgsY0FBT1c7TUFGWEEsQ0FBQUE7O0FBS0FDLE1BQUFBLDBCQUFBQSxpQ0FBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUNBLEVBQUdaLGNBQU9ZO01BRGJBLENBQUFBO01BSUF0RCxPQUFBdUQscUJBQUFBLDRCQUFBQTtBQUFBQSxRQUFBQTs7O1FBQ0UxRCxJQUFBd0QsU0FBQUEsQ0FBQUE7UUFDQUUsT0FBQTFELElBQUF1RCxNQUFBQSxDQUFBQTtNQUZGRyxDQUFBQTtJQW5KRnZELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBRkFELEdBQUFBLFdBQUFBO0VBNkpBRixJQUFBQyxTQUFBQSxDQUFRRixrQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYscUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLHdCQUFSRTtFQUNBRixPQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixzQkFBUkU7QUFsS0FGOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMjEwNCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvd2luZG93L3ZpZXcucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IGNsYXNzIFdpbmRvd1xuXG5jbGFzcyBWaWV3XG4gIGRlZiBpbml0aWFsaXplKHdpbmRvdylcbiAgICBAd2luZG93ID0gd2luZG93XG4gICAgQG5hdGl2ZSA9IHdpbmRvdy50b19uXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdXaW5kb3cuaW5uZXJTaXplJ1xuICAgIGRlZiB3aWR0aFxuICAgICAgYCNAbmF0aXZlLmlubmVyV2lkdGhgXG4gICAgZW5kXG5cbiAgICBkZWYgaGVpZ2h0XG4gICAgICBgI0BuYXRpdmUuaW5uZXJIZWlnaHRgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFbGVtZW50LmNsaWVudFNpemUnXG4gICAgZGVmIGhlaWdodFxuICAgICAgYCNAbmF0aXZlLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRgXG4gICAgZW5kXG5cbiAgICBkZWYgd2lkdGhcbiAgICAgIGAjQG5hdGl2ZS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGhgXG4gICAgZW5kXG4gIGVsc2VcbiAgICBkZWYgd2lkdGhcbiAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsICd3aW5kb3cgc2l6ZSB1bnN1cHBvcnRlZCdcbiAgICBlbmRcblxuICAgIGRlZiBoZWlnaHRcbiAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsICd3aW5kb3cgc2l6ZSB1bnN1cHBvcnRlZCdcbiAgICBlbmRcbiAgZW5kXG5cbiAgIyBHZXQgYSBkZXZpY2UgcGl4ZWwgcmF0aW8uIENhbiBiZSB1c2VkIHRvIGhhbmRsZSBkZXNrdG9wIGJyb3dzZXJcbiAgIyB6b29tLCByZXRpbmEgZGV2aWNlcyBhbmQgY3VzdG9tIHNjcmVlbiBzY2FsZSBmb3IgbW9iaWxlIGRldmljZXMuXG4gICMgVXNlICR3aW5kb3cudmlzdWFsX3ZpZXdwb3J0LnNjYWxlIHRvIGhhbmRsZSBtb2JpbGUgem9vbS5cbiAgZGVmIHpvb21cbiAgICBgI0BuYXRpdmUuZGV2aWNlUGl4ZWxSYXRpb2BcbiAgZW5kXG5cbiAgIyBIYW5kbGUgI3BpeGVsX3JhdGlvIGNoYW5nZXMuIFRoaXMgd2lsbCB0cmlnZ2VyIGEgYmxvY2sgb24gem9vbS5cbiAgZGVmIG9uX3pvb20gJmJsb2NrXG4gICAgJXh7XG4gICAgICB2YXIgbXFTdHJpbmcgPSBcIihyZXNvbHV0aW9uOiBcIiArICNAbmF0aXZlLmRldmljZVBpeGVsUmF0aW8gKyBcImRwcHgpXCI7XG4gICAgICAjQG5hdGl2ZS5tYXRjaE1lZGlhKG1xU3RyaW5nKS5hZGRMaXN0ZW5lcigje2Jsb2NrLnRvX259KTtcbiAgICB9XG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8Y2xhc3M6V2luZG93PiIsIjxjbGFzczpWaWV3PiIsImluaXRpYWxpemUiLCJ3aW5kb3ciLCJAd2luZG93IiwiQG5hdGl2ZSIsInRvX24iLCJCcm93c2VyIiwic3VwcG9ydHM/Iiwid2lkdGgiLCJoZWlnaHQiLCJzZWxmIiwicmFpc2UiLCJOb3RJbXBsZW1lbnRlZEVycm9yIiwiem9vbSIsIm9uX3pvb20iLCJibG9jayJdLCJtYXBwaW5ncyI6IkFBQUFBLHNDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7QUFBQUE7OztBQUNFQyxRQUFBQSwwQkFBQUEsc0JBQWVDLE1BQWZEO0FBQUFBLFVBQUFBOzs7VUFDRUUsY0FBVUQ7VUFDVkQsT0FBQUcsQ0FBQUEsaUJBQVVGLE1BQU1HLE1BQUFBLENBQUFBLENBQWhCRDtRQUZGSCxDQUFBQTtRQUtBLElBQUEsUUFBR0ssYUFBT0MsY0FBQUEsQ0FBV1Asa0JBQVhPLENBQVYsQ0FBQTs7O0FBQ0VDLFVBQUFBLHFCQUFBQSxpQkFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVKLGNBQU9JO1VBRFhBLENBQUFBOztBQUlBQyxVQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFTCxjQUFPSztVQURYQSxDQUFBQTtRQUxGLE9BUUEsSUFBQSxRQUFNSCxhQUFPQyxjQUFBQSxDQUFXUCxvQkFBWE8sQ0FBYixDQUFBOzs7QUFDRUUsVUFBQUEsc0JBQUFBLGtCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUwsY0FBT0s7VUFEWEEsQ0FBQUE7O0FBSUFELFVBQUFBLHFCQUFBQSxpQkFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVKLGNBQU9JO1VBRFhBLENBQUFBO1FBTEY7OztBQVNFQSxVQUFBQSxxQkFBQUEsaUJBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFBRSxJQUFBQyxPQUFBQSxDQUFNQyx5QkFBTixFQUEyQkoseUJBQTNCRztVQURGSCxDQUFBQTs7QUFJQUMsVUFBQUEsc0JBQUFBLGtCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBQUMsSUFBQUMsT0FBQUEsQ0FBTUMseUJBQU4sRUFBMkJILHlCQUEzQkU7VUFERkYsQ0FBQUE7UUFiRjs7QUFxQkFJLFFBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUVULGNBQU9TO1FBRFhBLENBQUFBO1FBS0FiLE9BQUFjLHVCQUFBQSxtQkFBQUE7QUFBQUEsVUFBQUE7O1VBQUFBOzs7O0FBRUZBLHVDQUF3Q1YsY0FBT1U7QUFDL0NBLE1BQU9WLGNBQU9VLGtDQUFvQ0MsS0FBS1YsTUFBQUEsQ0FBQUEsQ0FBTVM7QUFDN0RBO1FBSkVBLENBQUFBO01BeENGZCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtJQUZnQkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMjE5OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvd2luZG93L3NpemUucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IGNsYXNzIFdpbmRvd1xuXG4jIEFsbG93cyBhY2Nlc3MgYW5kIG1hbmlwdWxhdGlvbiBvZiB0aGUge1dpbmRvd30gc2l6ZS5cbmNsYXNzIFNpemVcbiAgIyBAcHJpdmF0ZVxuICBkZWYgaW5pdGlhbGl6ZSh3aW5kb3cpXG4gICAgQHdpbmRvdyA9IHdpbmRvd1xuICAgIEBuYXRpdmUgPSB3aW5kb3cudG9fblxuICBlbmRcblxuICBkZWYgc2V0KCphcmdzKVxuICAgIGlmIEhhc2ggPT09IGFyZ3MuZmlyc3RcbiAgICAgIHdpZHRoLCBoZWlnaHQgPSBhcmdzLmZpcnN0LnZhbHVlc19hdCg6d2lkdGgsIDpoZWlnaHQpXG4gICAgZWxzZVxuICAgICAgd2lkdGgsIGhlaWdodCA9IGFyZ3NcbiAgICBlbmRcblxuICAgIHdpZHRoICB8fD0gc2VsZi53aWR0aFxuICAgIGhlaWdodCB8fD0gc2VsZi5oZWlnaHRcblxuICAgIGAjQG5hdGl2ZS5yZXNpemVUbygje3dpZHRofSwgI3toZWlnaHR9KWBcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSB3aWR0aFxuICAjIEByZXR1cm4gW0ludGVnZXJdIHRoZSB3aWR0aCBvZiB0aGUgd2luZG93XG5cbiAgIyBAIWF0dHJpYnV0ZSBoZWlnaHRcbiAgIyBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgaGVpZ2h0IG9mIHRoZSB3aW5kb3dcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnV2luZG93Lm91dGVyU2l6ZSdcbiAgICBkZWYgd2lkdGhcbiAgICAgIGAjQG5hdGl2ZS5vdXRlcldpZHRoYFxuICAgIGVuZFxuXG4gICAgZGVmIGhlaWdodFxuICAgICAgYCNAbmF0aXZlLm91dGVySGVpZ2h0YFxuICAgIGVuZFxuICBlbHNlXG4gICAgZGVmIHdpZHRoXG4gICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCAnd2luZG93IG91dGVyIHNpemUgbm90IHN1cHBvcnRlZCdcbiAgICBlbmRcblxuICAgIGRlZiBoZWlnaHRcbiAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsICd3aW5kb3cgb3V0ZXIgc2l6ZSBub3Qgc3VwcG9ydGVkJ1xuICAgIGVuZFxuICBlbmRcblxuICBkZWYgd2lkdGg9KHZhbHVlKVxuICAgIHNldCh3aWR0aDogdmFsdWUpXG4gIGVuZFxuXG4gIGRlZiBoZWlnaHQ9KHZhbHVlKVxuICAgIHNldChoZWlnaHQ6IHZhbHVlKVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIGlubmVyX3dpZHRoXG4gICMgQHJldHVybiBbSW50ZWdlcl0gdGhlIGlubmVyIHdpZHRoIG9mIHRoZSB3aW5kb3dcblxuICBkZWYgaW5uZXJfd2lkdGhcbiAgICBgI0BuYXRpdmUuaW5uZXJXaWR0aGBcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBpbm5lcl9oZWlnaHRcbiAgIyBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgaW5uZXIgaGVpZ2h0IG9mIHRoZSB3aW5kb3dcblxuICBkZWYgaW5uZXJfaGVpZ2h0XG4gICAgYCNAbmF0aXZlLmlubmVySGVpZ2h0YFxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOldpbmRvdz4iLCI8Y2xhc3M6U2l6ZT4iLCJpbml0aWFsaXplIiwid2luZG93IiwiQHdpbmRvdyIsIkBuYXRpdmUiLCJ0b19uIiwic2V0IiwiSGFzaCIsImFyZ3MiLCJmaXJzdCIsInZhbHVlc19hdCIsIndpZHRoIiwiaGVpZ2h0IiwiJHJldF9vcl8xIiwic2VsZiIsIkJyb3dzZXIiLCJzdXBwb3J0cz8iLCJyYWlzZSIsIk5vdEltcGxlbWVudGVkRXJyb3IiLCJ3aWR0aD0iLCJ2YWx1ZSIsImhlaWdodD0iLCJpbm5lcl93aWR0aCIsImlubmVyX2hlaWdodCJdLCJtYXBwaW5ncyI6IkFBQUFBLHNDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFHaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7QUFBQUE7OztBQUVFQyxRQUFBQSwwQkFBQUEsc0JBQWVDLE1BQWZEO0FBQUFBLFVBQUFBOzs7VUFDRUUsY0FBVUQ7VUFDVkQsT0FBQUcsQ0FBQUEsaUJBQVVGLE1BQU1HLE1BQUFBLENBQUFBLENBQWhCRDtRQUZGSCxDQUFBQTs7QUFLQUssUUFBQUEsbUJBQUFBLGVBVkYsRUFVRUE7QUFBQUEsVUFBQUE7OztVQVZGO1VBVVU7VUFDTixJQUFBLFFBQUdDLFVBQUgsRUFBWUMsSUFBSUMsT0FBQUEsQ0FBQUEsQ0FBaEIsQ0FBQTtZQUNFLEtBQWdCRCxJQUFJQyxPQUFBQSxDQUFBQSxDQUFNQyxXQUFBQSxDQUFXLE9BQXJCLEVBQTZCLFFBQW5CQSxDQUExQixrQkFBQSxFQUFBQyxDQUFBQSxRQUFBLDZCQUFBQSxDQUFBLEVBQU9DLENBQUFBLFNBQVAsNkJBQU9BLENBQVA7VUFERjtZQUdFLEtBQWdCSixJQUFoQixrQkFBQSxFQUFBRyxDQUFBQSxRQUFBLDZCQUFBQSxDQUFBLEVBQU9DLENBQUFBLFNBQVAsNkJBQU9BLENBQVA7VUFIRjtVQU1BRCxRQWpCSixDQUFBLFFBQUFFLENBQUFBLFlBaUJJRixLQWpCSkUsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxTQUFBLElBQUEsQ0FpQmVDLElBQUlILE9BQUFBLENBQUFBLENBakJuQixDQUFBO1VBa0JJQyxTQWxCSixDQUFBLFFBQUFDLENBQUFBLFlBa0JJRCxNQWxCSkMsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxTQUFBLElBQUEsQ0FrQmVDLElBQUlGLFFBQUFBLENBQUFBLENBbEJuQixDQUFBO1VBb0JNUixjQUFPRSxVQUFZSyxLQUFNTCxFQUFJTSxNQUFPTjtVQUV0Q0EsT0FBQVE7UUFaRlIsQ0FBQUEsSUFBQUE7UUFxQkEsSUFBQSxRQUFHUyxhQUFPQyxjQUFBQSxDQUFXaEIsa0JBQVhnQixDQUFWLENBQUE7OztBQUNFTCxVQUFBQSxxQkFBQUEsaUJBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFUCxjQUFPTztVQURYQSxDQUFBQTs7QUFJQUMsVUFBQUEsc0JBQUFBLGtCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRVIsY0FBT1E7VUFEWEEsQ0FBQUE7UUFMRjs7O0FBU0VELFVBQUFBLHFCQUFBQSxpQkFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUFHLElBQUFHLE9BQUFBLENBQU1DLHlCQUFOLEVBQTJCUCxpQ0FBM0JNO1VBREZOLENBQUFBOztBQUlBQyxVQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFBRSxJQUFBRyxPQUFBQSxDQUFNQyx5QkFBTixFQUEyQk4saUNBQTNCSztVQURGTCxDQUFBQTtRQWJGOztBQWtCQU8sUUFBQUEsc0JBQUFBLDBCQUFXQyxLQUFYRDtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBQUwsSUFBQVIsS0FBQUEsQ0FBSSxVQUFBLFFBQUEsRUFBT2MsS0FBUCxDQUFBLEdBQUpkO1FBREZhLENBQUFBOztBQUlBRSxRQUFBQSx1QkFBQUEsMkJBQVlELEtBQVpDO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBUCxJQUFBUixLQUFBQSxDQUFJLFVBQUEsU0FBQSxFQUFRYyxLQUFSLENBQUEsR0FBSmQ7UUFERmUsQ0FBQUE7O0FBT0FDLFFBQUFBLDJCQUFBQSx1QkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUVsQixjQUFPa0I7UUFEWEEsQ0FBQUE7UUFPQXRCLE9BQUF1Qiw0QkFBQUEsd0JBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFFbkIsY0FBT21CO1FBRFhBLENBQUFBO01BaEVGdkIsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7SUFIZ0JELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzIzMDEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL3dpbmRvdy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdicm93c2VyL3dpbmRvdy92aWV3J1xucmVxdWlyZSAnYnJvd3Nlci93aW5kb3cvc2l6ZSdcblxubW9kdWxlIEJyb3dzZXJcblxuIyBXcmFwcGVyIGNsYXNzIGZvciB0aGUgYHdpbmRvd2Agb2JqZWN0LCBhbiBpbnN0YW5jZSBvZiBpdCBnZXRzXG4jIHNldCB0byBgJHdpbmRvd2AuXG5jbGFzcyBXaW5kb3dcbiAgZGVmIHNlbGYub3Blbih1cmwsIG9wdGlvbnMpXG4gICAgbmFtZSAgICAgPSBvcHRpb25zLmRlbGV0ZSg6bmFtZSlcbiAgICBmZWF0dXJlcyA9IG9wdGlvbnMubWFwIHt8a2V5LCB2YWx1ZXxcbiAgICAgIHZhbHVlID0gY2FzZSB2YWx1ZVxuICAgICAgICAgICAgICB3aGVuIHRydWUgIHRoZW4gOnllc1xuICAgICAgICAgICAgICB3aGVuIGZhbHNlIHRoZW4gOm5vXG4gICAgICAgICAgICAgIGVsc2UgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICBlbmRcblxuICAgICAgXCIje2tleX09I3t2YWx1ZX1cIlxuICAgIH0uam9pbig/LClcblxuICAgICV4e1xuICAgICAgdmFyIHdpbiA9IHdpbmRvdy5vcGVuKCN7dXJsfSwgI3tuYW1lfSwgI3tmZWF0dXJlc30pO1xuXG4gICAgICBpZiAod2luID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7bmV3KGB3aW5gKX07XG4gICAgfVxuICBlbmRcblxuICBpbmNsdWRlIEJyb3dzZXI6Ok5hdGl2ZUNhY2hlZFdyYXBwZXJcbiAgaW5jbHVkZSBFdmVudDo6VGFyZ2V0XG5cbiAgdGFyZ2V0IHt8dmFsdWV8XG4gICAgJHdpbmRvdyBpZiBgI3t2YWx1ZX0gPT0gd2luZG93YFxuICB9XG5cbiAgIyBBbGVydCB0aGUgcGFzc2VkIHN0cmluZy5cbiAgZGVmIGFsZXJ0KHZhbHVlKVxuICAgIGAjQG5hdGl2ZS5hbGVydCh2YWx1ZSlgXG5cbiAgICB2YWx1ZVxuICBlbmRcblxuICAjIERpc3BsYXkgYSBwcm9tcHQgZGlhbG9nIHdpdGggdGhlIHBhc3NlZCBzdHJpbmcgYXMgdGV4dC5cbiAgZGVmIHByb21wdCh2YWx1ZSwgZGVmYXVsdD1uaWwpXG4gICAgYCNAbmF0aXZlLnByb21wdCh2YWx1ZSwgI3tkZWZhdWx0IHx8IFwiXCJ9KSB8fCBuaWxgXG4gIGVuZFxuXG4gICMgRGlzcGxheSBhIGNvbmZpcm1hdGlvbiBkaWFsb2cgd2l0aCB0aGUgcGFzc2VkIHN0cmluZyBhcyB0ZXh0LlxuICBkZWYgY29uZmlybSh2YWx1ZSlcbiAgICBgI0BuYXRpdmUuY29uZmlybSh2YWx1ZSkgfHwgZmFsc2VgXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIHBhcmVudFxuICAjIEByZXR1cm4gW1dpbmRvd10gcGFyZW50IG9mIHRoZSBjdXJyZW50IHdpbmRvdyBvciBzdWJmcmFtZVxuICBkZWYgcGFyZW50XG4gICAgQHBhcmVudCB8fD0gQnJvd3Nlcjo6V2luZG93Lm5ldyhgI0BuYXRpdmUucGFyZW50YClcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gdG9wXG4gICMgQHJldHVybiBbV2luZG93XSByZWZlcmVuY2UgdG8gdGhlIHRvcG1vc3Qgd2luZG93IGluIHRoZSB3aW5kb3cgaGllcmFyY2h5XG4gIGRlZiB0b3BcbiAgICBAdG9wIHx8PSBCcm93c2VyOjpXaW5kb3cubmV3KGAjQG5hdGl2ZS50b3BgKVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBvcGVuZXJcbiAgIyBAcmV0dXJuIFtXaW5kb3ddIHJlZmVyZW5jZSB0byB0aGUgd2luZG93IHRoYXQgb3BlbmVkIHRoZSB3aW5kb3cgdXNpbmcgYG9wZW5gXG4gIGRlZiBvcGVuZXJcbiAgICBAb3BlbmVyIHx8PSBCcm93c2VyOjpXaW5kb3cubmV3KGAjQG5hdGl2ZS5vcGVuZXJgKVxuICBlbmRcblxuICAjIEdldCB0aGUge1ZpZXd9IGZvciB0aGUgd2luZG93LlxuICAjXG4gICMgQHJldHVybiBbVmlld11cbiAgZGVmIHZpZXdcbiAgICBAdmlldyB8fD0gVmlldy5uZXcoc2VsZilcbiAgZW5kXG5cbiAgIyBHZXQgdGhlIHtTaXplfSBmb3IgdGhpcyB3aW5kb3cuXG4gICNcbiAgIyBAcmV0dXJuIFtTaXplXVxuICBkZWYgc2l6ZVxuICAgIEBzaXplIHx8PSBTaXplLm5ldyhzZWxmKVxuICBlbmRcblxuICAjIEdldCB0aGUge0RPTTo6RWxlbWVudDo6U2Nyb2xsfSBmb3IgdGhpcyB3aW5kb3cuXG4gICNcbiAgIyBAcmV0dXJuIFtET006OkVsZW1lbnQ6OlNjcm9sbF1cbiAgZGVmIHNjcm9sbFxuICAgIEBzY3JvbGwgfHw9IERPTTo6RWxlbWVudDo6U2Nyb2xsLm5ldyhzZWxmKVxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnV2luZG93LnNlbmQnXG4gICAgZGVmIHNlbmQobWVzc2FnZSwgb3B0aW9ucyA9IHt9KVxuICAgICAgYCNAbmF0aXZlLnBvc3RNZXNzYWdlKCN7bWVzc2FnZX0sICN7b3B0aW9uc1s6dG9dIHx8ICcqJ30pYFxuICAgIGVuZFxuICBlbHNlXG4gICAgIyBTZW5kIGEgbWVzc2FnZSB0byB0aGUgd2luZG93LlxuICAgICNcbiAgICAjIEBwYXJhbSBtZXNzYWdlIFtTdHJpbmddIHRoZSBtZXNzYWdlXG4gICAgIyBAcGFyYW0gb3B0aW9ucyBbSGFzaF0gb3B0aW9uYWwgYHRvOiB0YXJnZXRgXG4gICAgZGVmIHNlbmQobWVzc2FnZSwgb3B0aW9ucyA9IHt9KVxuICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgJ21lc3NhZ2Ugc2VuZGluZyB1bnN1cHBvcnRlZCdcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGNsb3NlXG4gICAgYCN7QG5hdGl2ZX0uY2xvc2UoKWBcbiAgZW5kXG5lbmRcblxuZW5kXG5cbiR3aW5kb3cgPSBCcm93c2VyOjpXaW5kb3cubmV3KGB3aW5kb3dgKVxuXG5tb2R1bGUgS2VybmVsXG4gICMgKHNlZSBCcm93c2VyOjpXaW5kb3cjYWxlcnQpXG4gIGRlZiBhbGVydCh2YWx1ZSlcbiAgICAkd2luZG93LmFsZXJ0KHZhbHVlKVxuICBlbmRcblxuICAjIChzZWUgQnJvd3Nlcjo6V2luZG93I3Byb21wdClcbiAgZGVmIHByb21wdCh2YWx1ZSwgZGVmYXVsdD1uaWwpXG4gICAgJHdpbmRvdy5wcm9tcHQodmFsdWUsIGRlZmF1bHQpXG4gIGVuZFxuXG4gICMgKHNlZSBCcm93c2VyOjpXaW5kb3cjY29uZmlybSlcbiAgZGVmIGNvbmZpcm0odmFsdWUpXG4gICAgJHdpbmRvdy5jb25maXJtKHZhbHVlKVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8Y2xhc3M6V2luZG93PiIsIm9wZW4iLCJ1cmwiLCJvcHRpb25zIiwibmFtZSIsImRlbGV0ZSIsImZlYXR1cmVzIiwibWFwIiwiYmxvY2sgaW4gb3BlbiIsImtleSIsInZhbHVlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBvcGVuIiwiJHJldF9vcl8xIiwiam9pbiIsIm5ldyIsImluY2x1ZGUiLCJCcm93c2VyOjpOYXRpdmVDYWNoZWRXcmFwcGVyIiwiQnJvd3NlciIsIkV2ZW50OjpUYXJnZXQiLCJFdmVudCIsInRhcmdldCIsImJsb2NrIGluIDxjbGFzczpXaW5kb3c+IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8Y2xhc3M6V2luZG93PiIsIiR3aW5kb3ciLCJhbGVydCIsIkBuYXRpdmUiLCJwcm9tcHQiLCJkZWZhdWx0JCIsImNvbmZpcm0iLCJwYXJlbnQiLCJAcGFyZW50IiwiQnJvd3Nlcjo6V2luZG93IiwidG9wIiwiQHRvcCIsIm9wZW5lciIsIkBvcGVuZXIiLCJ2aWV3IiwiQHZpZXciLCJWaWV3Iiwic2l6ZSIsIkBzaXplIiwiU2l6ZSIsInNjcm9sbCIsIkBzY3JvbGwiLCJET006OkVsZW1lbnQ6OlNjcm9sbCIsIkRPTTo6RWxlbWVudCIsIkRPTSIsInN1cHBvcnRzPyIsInNlbmQiLCJtZXNzYWdlIiwiW10iLCJyYWlzZSIsIk5vdEltcGxlbWVudGVkRXJyb3IiLCJjbG9zZSIsIjxtb2R1bGU6S2VybmVsPiJdLCJtYXBwaW5ncyI6IkFBQUFBLGlDQUFBQSxnQkFBQUE7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biI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9ub2RlX3NldC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgbW9kdWxlIERPTVxuXG4jIEFsbG93cyBtYW5pcHVsYXRpb24gb2YgYSBzZXQgb2Yge05vZGV9cy5cbmNsYXNzIE5vZGVTZXRcbiAgIyBDcmVhdGUgYSBuZXcge05vZGVTZXR9IGZyb20gdGhlIGdpdmVuIG5vZGVzLlxuICAjXG4gICMgTm90ZSB0aGF0IHRoZSBub2RlcyBhcmUgZmxhdHRlbmVkIGFuZCBjb252ZXJ0ZWQgd2l0aCBET00gYXV0b21hdGljYWxseSxcbiAgIyB0aGlzIG1lYW5zIHlvdSBjYW4gcGFzcyB7Tm9kZVNldH1zIGFuZCB7TmF0aXZlOjpBcnJheX1zIGFzIHdlbGwuXG4gIGRlZiBzZWxmLltdKCpub2RlcylcbiAgICBuZXcobm9kZXMuZmxhdHRlbi5tYXAgeyB8eHwgRE9NKE5hdGl2ZS5jb252ZXJ0KHgpKSB9LnVuaXEpXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKGxpdGVyYWwpXG4gICAgQGxpdGVyYWwgPSBsaXRlcmFsXG4gIGVuZFxuXG4gICMgQW55IG90aGVyIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBvbiBldmVyeSBub2RlIGluIHRoZSBzZXQuXG4gIGRlZiBtZXRob2RfbWlzc2luZyhuYW1lLCAqYXJncywgJmJsb2NrKVxuICAgIHVubGVzcyBAbGl0ZXJhbC5yZXNwb25kX3RvPyBuYW1lXG4gICAgICBlYWNoIHt8ZWx8XG4gICAgICAgIGVsLl9fc2VuZF9fKG5hbWUsICphcmdzLCAmYmxvY2spXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmXG4gICAgZW5kXG5cbiAgICByZXN1bHQgPSBAbGl0ZXJhbC5fX3NlbmRfXyBuYW1lLCAqYXJncywgJmJsb2NrXG5cbiAgICBpZiBgcmVzdWx0ID09PSAjQGxpdGVyYWxgXG4gICAgICBzZWxmXG4gICAgZWxzaWYgQXJyYXkgPT09IHJlc3VsdFxuICAgICAgTm9kZVNldC5uZXcocmVzdWx0KVxuICAgIGVsc2VcbiAgICAgIHJlc3VsdFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgcmVzcG9uZF90b19taXNzaW5nPyhuYW1lLCAqKVxuICAgIEBsaXRlcmFsLnJlc3BvbmRfdG8/KG5hbWUpXG4gIGVuZFxuXG4gICMgR2V0IHRoZSBmaXJzdCBub2RlIG1hdGNoaW5nIHRoZSBnaXZlbiBDU1Mgc2VsZWN0b3JzLlxuICAjXG4gICMgQHBhcmFtIHJ1bGVzIFtBcnJheTxTdHJpbmc+XSB0aGUgQ1NTIHNlbGVjdG9ycyB0byBtYXRjaCB3aXRoXG4gICNcbiAgIyBAcmV0dXJuIFtOb2RlP11cbiAgZGVmIGF0X2NzcygqcnVsZXMpXG4gICAgZWFjaCB7fG5vZGV8XG4gICAgICBpZiBub2RlID0gbm9kZS5hdF9jc3MoKnJ1bGVzKVxuICAgICAgICByZXR1cm4gbm9kZVxuICAgICAgZW5kXG4gICAgfVxuXG4gICAgbmlsXG4gIGVuZFxuXG4gICMgR2V0IHRoZSBmaXJzdCBub2RlIG1hdGNoaW5nIHRoZSBnaXZlbiBYUGF0aC5cbiAgI1xuICAjIEBwYXJhbSBwYXRocyBbQXJyYXk8U3RyaW5nPl0gdGhlIFhQYXRoIHRvIG1hdGNoIHdpdGhcbiAgI1xuICAjIEByZXR1cm4gW05vZGU/XVxuICBkZWYgYXRfeHBhdGgoKnBhdGhzKVxuICAgIGVhY2gge3xub2RlfFxuICAgICAgaWYgbm9kZSA9IG5vZGUuYXRfeHBhdGgoKnBhdGhzKVxuICAgICAgICByZXR1cm4gbm9kZVxuICAgICAgZW5kXG4gICAgfVxuXG4gICAgbmlsXG4gIGVuZFxuXG4gICMgUXVlcnkgZm9yIGNoaWxkcmVuIG1hdGNoaW5nIHRoZSBnaXZlbiBDU1Mgc2VsZWN0b3IuXG4gICNcbiAgIyBAcGFyYW0gcGF0aCBbU3RyaW5nXSB0aGUgQ1NTIHNlbGVjdG9yXG4gICNcbiAgIyBAcmV0dXJuIFtOb2RlU2V0XVxuICBkZWYgY3NzKHBhdGgpXG4gICAgTm9kZVNldFtAbGl0ZXJhbC5tYXAge3xub2RlfFxuICAgICAgbm9kZS5jc3MocGF0aClcbiAgICB9XVxuICBlbmRcblxuICAjIENyZWF0ZSBhbm90aGVyIHtOb2RlU2V0fSB3aXRoIGFsbCB0aGUgbm9kZXMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW5cbiAgIyBleHByZXNzaW9uLlxuICAjXG4gICMgQHBhcmFtIGV4cHJlc3Npb24gW1N0cmluZ10gYSBDU1Mgc2VsZWN0b3JcbiAgI1xuICAjIEByZXR1cm4gW05vZGVTZXRdIHRoZSBuZXcge05vZGVTZXR9IHdpdGggdGhlIG1hdGNoaW5nIG5vZGVzXG4gIGRlZiBmaWx0ZXIoZXhwcmVzc2lvbilcbiAgICBOb2RlU2V0W0BsaXRlcmFsLnNlbGVjdCB7IHxub2RlfCBub2RlID1+IGV4cHJlc3Npb24gfV1cbiAgZW5kXG5cbiAgIyBTZWFyY2ggZm9yIG11bHRpcGxlIHNlbGVjdG9yc1xuICBkZWYgc2VhcmNoKCp3aGF0KVxuICAgIE5vZGVTZXRbQGxpdGVyYWwubWFwIHsgfG5vZGV8IG5vZGUuc2VhcmNoKCp3aGF0KSB9XVxuICBlbmRcblxuICAjIE91dGVyIEhUTUwgb2YgdGhlIGVudGlyZSBub2Rlc2V0XG4gIGRlZiBvdXRlcl9odG1sXG4gICAgQGxpdGVyYWwubWFwKCY6b3V0ZXJfaHRtbCkuam9pblxuICBlbmRcblxuICAjIFF1ZXJ5IGZvciBjaGlsZHJlbiBtYXRjaGluZyB0aGUgZ2l2ZW4gWFBhdGguXG4gICNcbiAgIyBAcGFyYW0gcGF0aCBbU3RyaW5nXSB0aGUgWFBhdGhcbiAgI1xuICAjIEByZXR1cm4gW05vZGVTZXRdXG4gIGRlZiB4cGF0aChwYXRoKVxuICAgIE5vZGVTZXRbQGxpdGVyYWwubWFwIHt8bm9kZXxcbiAgICAgIG5vZGUueHBhdGgocGF0aClcbiAgICB9XVxuICBlbmRcblxuICBkZWYgdG9fYXJ5XG4gICAgQGxpdGVyYWxcbiAgZW5kXG5cbiAgYWxpYXMgdG9fYSB0b19hcnlcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPG1vZHVsZTpET00+IiwiPGNsYXNzOk5vZGVTZXQ+IiwiW10iLCJzZWxmIiwibmV3IiwibWFwIiwibm9kZXMiLCJmbGF0dGVuIiwiYmxvY2sgaW4gW10iLCJ4IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBbXSIsIkRPTSIsIk5hdGl2ZSIsImNvbnZlcnQiLCJ1bmlxIiwiaW5pdGlhbGl6ZSIsIm1ldGhvZF9taXNzaW5nIiwibmFtZSIsIkBsaXRlcmFsIiwicmVzcG9uZF90bz8iLCJlYWNoIiwiYmxvY2sgaW4gbWV0aG9kX21pc3NpbmciLCJlbCIsImJsb2NrICgyIGxldmVscykgaW4gbWV0aG9kX21pc3NpbmciLCJfX3NlbmRfXyIsImFyZ3MiLCJibG9jayIsInRvX3Byb2MiLCJyZXN1bHQiLCJBcnJheSIsIk5vZGVTZXQiLCJyZXNwb25kX3RvX21pc3Npbmc/IiwiYXRfY3NzIiwiYmxvY2sgaW4gYXRfY3NzIiwibm9kZSIsInJ1bGVzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBhdF9jc3MiLCJhdF94cGF0aCIsImJsb2NrIGluIGF0X3hwYXRoIiwicGF0aHMiLCJibG9jayAoMiBsZXZlbHMpIGluIGF0X3hwYXRoIiwiY3NzIiwicGF0aCIsImJsb2NrIGluIGNzcyIsImJsb2NrICgyIGxldmVscykgaW4gY3NzIiwiZmlsdGVyIiwiZXhwcmVzc2lvbiIsInNlbGVjdCIsImJsb2NrIGluIGZpbHRlciIsImJsb2NrICgyIGxldmVscykgaW4gZmlsdGVyIiwiPX4iLCJzZWFyY2giLCJibG9jayBpbiBzZWFyY2giLCJibG9jayAoMiBsZXZlbHMpIGluIHNlYXJjaCIsIndoYXQiLCJvdXRlcl9odG1sIiwiam9pbiIsInhwYXRoIiwiYmxvY2sgaW4geHBhdGgiLCJibG9jayAoMiBsZXZlbHMpIGluIHhwYXRoIiwidG9fYXJ5Il0sIm1hcHBpbmdzIjoiQUFBQUEsdUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7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LE1BQUFBLENBQUFBO1FBRDVCRCxDQUFBQTs7QUFTQUUsUUFBQUEscUJBQUFBLGlCQUFVZixJQUFWZTtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBQTNCLGFBQU81QixPQUFBQSxDQUFTRyxNQUFSYSxZQUFRYixPQUFBQSxFQUFBQSxFQUFBQSxFQUFScUQsY0FBZXhCLElBQWZ3Qjs7WUFBZTtZQUNyQkMsT0FBQXpCLElBQUl1QixPQUFBQSxDQUFPZixJQUFQZSxFQURFQyxDQUFRckQsQ0FBVEg7UUFEVHVELENBQUFBOztBQU1BRyxRQUFBQSxzQkFBQUEsYUFDRSxTQURGQSxDQUFBQTtRQUlBM0QsT0FBQSxhQUFNLE1BQU4sRUFBVyxRQUFYO01BbEhGQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtJQUhnQkQsR0FBQUEsV0FBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMjYyOCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZG9tL25vZGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBET01cblxuIyBBYnN0cmFjdCBjbGFzcyBmb3IgYWxsIERPTSBub2RlIHR5cGVzLlxuI1xuIyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob2RlXG5jbGFzcyBOb2RlXG4gIGluY2x1ZGUgQnJvd3Nlcjo6TmF0aXZlQ2FjaGVkV3JhcHBlclxuXG4gIEVMRU1FTlRfTk9ERSAgICAgICAgICAgICAgICA9IDFcbiAgQVRUUklCVVRFX05PREUgICAgICAgICAgICAgID0gMlxuICBURVhUX05PREUgICAgICAgICAgICAgICAgICAgPSAzXG4gIENEQVRBX1NFQ1RJT05fTk9ERSAgICAgICAgICA9IDRcbiAgRU5USVRZX1JFRkVSRU5DRV9OT0NFICAgICAgID0gNVxuICBFTlRJVFlfTk9ERSAgICAgICAgICAgICAgICAgPSA2XG4gIFBST0NFU1NJTkdfSU5TVFJVQ1RJT05fTk9ERSA9IDdcbiAgQ09NTUVOVF9OT0RFICAgICAgICAgICAgICAgID0gOFxuICBET0NVTUVOVF9OT0RFICAgICAgICAgICAgICAgPSA5XG4gIERPQ1VNRU5UX1RZUEVfTk9ERSAgICAgICAgICA9IDEwXG4gIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgICAgICA9IDExXG4gIE5PVEFUSU9OX05PREUgICAgICAgICAgICAgICA9IDEyXG5cbiAgIyBXcmFwIGEgbmF0aXZlIERPTSBub2RlLlxuICAjXG4gICMgQHBhcmFtIHZhbHVlIFtuYXRpdmVdIHRoZSBuYXRpdmUgRE9NIG5vZGVcbiAgI1xuICAjIEByZXR1cm4gW05vZGVdXG4gIGRlZiBzZWxmLm5ldyh2YWx1ZSlcbiAgICBpZiBzZWxmID09IE5vZGVcbiAgICAgIEBjbGFzc2VzIHx8PSBbbmlsLCBFbGVtZW50LCBBdHRyaWJ1dGUsIFRleHQsIENEQVRBLCBuaWwsIG5pbCwgbmlsLCBDb21tZW50LCBEb2N1bWVudCwgbmlsLCBEb2N1bWVudEZyYWdtZW50XVxuXG4gICAgICBpZiBrbGFzcyA9IEBjbGFzc2VzW2B2YWx1ZS5ub2RlVHlwZWBdXG4gICAgICAgIGtsYXNzLm5ldyh2YWx1ZSlcbiAgICAgIGVsc2VcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2Nhbm5vdCBpbnN0YW50aWF0ZSBhIG5vbiBkZXJpdmVkIE5vZGUgb2JqZWN0J1xuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgc3VwZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUobm9kZSlcbiAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcIlBsZWFzZSBlbnN1cmUgdGhhdCAjaW5pdGlhbGl6ZSBvZiAje3NlbGYuY2xhc3N9IGFjY2VwdHMgb25lIGFyZ3VtZW50XCIgdW5sZXNzIG5vZGVcbiAgICBzdXBlclxuICBlbmRcblxuICAjIFJldHVybiB0cnVlIG9mIHRoZSBvdGhlciBlbGVtZW50IGlzIHRoZSBzYW1lIHVuZGVybHlpbmcgRE9NIG5vZGUuXG4gICNcbiAgIyBAcmV0dXJuIFtCb29sZWFuXVxuICBkZWYgPT0ob3RoZXIpXG4gICAgYCNAbmF0aXZlID09PSAje05hdGl2ZS5jb252ZXJ0KG90aGVyKX1gXG4gIGVuZFxuXG4gICMgSW5pdGlhbGl6ZSBhIG5ldyBub2RlIGFmdGVyIGAjZHVwYCBvciBgI2Nsb25lYC5cbiAgI1xuICAjIFRoaXMgbWV0aG9kIGlzIG5vdCB0byBiZSBjYWxsZWQgZGlyZWN0bHkuIFVzZSBgTm9kZSNkdXBgIG9yXG4gICMgYE5vZGUjY2xvbmVgLlxuICAjXG4gICMgVGhpcyBtZXRob2QgY3JlYXRlcyBhIGRlZXAgZGV0YWNoZWQgY2xvbmUgb2YgYSBET00gc3VidHJlZSB0byBiZSB1c2VkXG4gICMgaW4gdGhlIHNhbWUgZG9jdW1lbnQuIFRoZSBuZXcgbm9kZSB3aWxsIGhhdmUgYWxsIGV2ZW50cyBkZXRhY2hlZC5cbiAgZGVmIGluaXRpYWxpemVfY29weShvbGQpXG4gICAgc2V0X25hdGl2ZV9yZWZlcmVuY2UgYCN7b2xkLnRvX259LmNsb25lTm9kZSh0cnVlKWBcbiAgZW5kXG5cbiAgIyBBcHBlbmQgYSBjaGlsZCB0byB0aGUgbm9kZS5cbiAgI1xuICAjIFdoZW4gcGFzc2luZyBhIHtTdHJpbmd9IGEgdGV4dCBub2RlIHdpbGwgYmUgY3JlYXRlZC5cbiAgI1xuICAjIFdoZW4gcGFzc2luZyBhbiBPYmplY3QgdGhhdCByZXNwb25kcyB0byAjZWFjaCwgZXZlcnkgeWllbGRlZCBlbGVtZW50XG4gICMgd2lsbCBiZSBhZGRlZCBmb2xsb3dpbmcgdGhlIHNhbWUgbG9naWMuXG4gICNcbiAgIyBAcGFyYW0gbm9kZSBbU3RyaW5nLCBOb2RlLCAjZWFjaCwgI3RvX25dIHRoZSBub2RlIHRvIGFwcGVuZFxuICAjXG4gICMgQHJldHVybiBbc2VsZl1cbiAgZGVmIDw8KG5vZGUpXG4gICAgaWYgT3BhbC5yZXNwb25kX3RvPyBub2RlLCA6ZWFjaFxuICAgICAgbm9kZS5lYWNoIHsgfG58IHNlbGYgPDwgbiB9XG4gICAgICByZXR1cm4gc2VsZlxuICAgIGVsc2lmIE9wYWwucmVzcG9uZF90bz8gbm9kZSwgOnRvX2RvbVxuICAgICAgbm9kZSA9IG5vZGUudG9fZG9tKGRvY3VtZW50KVxuICAgIGVuZFxuXG4gICAgdW5sZXNzIG5hdGl2ZT8obm9kZSlcbiAgICAgIGlmIFN0cmluZyA9PT0gbm9kZVxuICAgICAgICBub2RlID0gYCNAbmF0aXZlLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobm9kZSlgXG4gICAgICBlbHNlXG4gICAgICAgIG5vZGUgPSBOYXRpdmUuY29udmVydChub2RlKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBgI0BuYXRpdmUuYXBwZW5kQ2hpbGQobm9kZSlgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiA+Pihub2RlKVxuICAgIGlmIE9wYWwucmVzcG9uZF90bz8gbm9kZSwgOmVhY2hcbiAgICAgIG5vZGUuZWFjaCB7IHxufCBzZWxmID4+IG4gfVxuICAgICAgcmV0dXJuIHNlbGZcbiAgICBlbHNpZiBPcGFsLnJlc3BvbmRfdG8/IG5vZGUsIDp0b19kb21cbiAgICAgIG5vZGUgPSBub2RlLnRvX2RvbShkb2N1bWVudClcbiAgICBlbmRcblxuICAgIHVubGVzcyBuYXRpdmU/KG5vZGUpXG4gICAgICBpZiBTdHJpbmcgPT09IG5vZGVcbiAgICAgICAgbm9kZSA9IGAjQG5hdGl2ZS5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUpYFxuICAgICAgZWxzZVxuICAgICAgICBub2RlID0gTmF0aXZlLmNvbnZlcnQobm9kZSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgaWYgYCNAbmF0aXZlLmZpcnN0Q2hpbGQgPT0gbnVsbGBcbiAgICAgIGAjQG5hdGl2ZS5hcHBlbmRDaGlsZChub2RlKWBcbiAgICBlbHNlXG4gICAgICBgI0BuYXRpdmUuaW5zZXJ0QmVmb3JlKG5vZGUsICNAbmF0aXZlLmZpcnN0Q2hpbGQpYFxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgYWRkX2NoaWxkKG5vZGUgPSBuaWwsICZibG9jaylcbiAgICB1bmxlc3Mgbm9kZVxuICAgICAgbm9kZSA9IERPTSgmYmxvY2spXG4gICAgZW5kXG5cbiAgICBzZWxmIDw8IG5vZGVcbiAgZW5kXG5cbiAgIyBBZGQgdGhlIHBhc3NlZCBub2RlIGFmdGVyIHRoaXMgb25lLlxuICAjXG4gICMgV2hlbiBwYXNzaW5nIGEge1N0cmluZ30gYSB0ZXh0IG5vZGUgd2lsbCBiZSBjcmVhdGVkLlxuICAjXG4gICMgQHBhcmFtIG5vZGUgW1N0cmluZywgTm9kZSwgI3RvX25dIHRoZSBub2RlIHRvIGFkZFxuICBkZWYgYWRkX25leHRfc2libGluZyhub2RlID0gbmlsLCAmYmxvY2spXG4gICAgdW5sZXNzIG5vZGVcbiAgICAgIG5vZGUgPSBET00oJmJsb2NrKVxuICAgIGVuZFxuICAgIG5vZGUgPSBub2RlLnRvX2RvbShkb2N1bWVudCkgaWYgT3BhbC5yZXNwb25kX3RvPyBub2RlLCA6dG9fZG9tXG5cbiAgICB1bmxlc3MgbmF0aXZlPyhub2RlKVxuICAgICAgaWYgU3RyaW5nID09PSBub2RlXG4gICAgICAgIG5vZGUgPSBgI0BuYXRpdmUub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShub2RlKWBcbiAgICAgIGVsc2VcbiAgICAgICAgbm9kZSA9IE5hdGl2ZS5jb252ZXJ0KG5vZGUpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGAjQG5hdGl2ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCAjQG5hdGl2ZS5uZXh0U2libGluZylgXG4gIGVuZFxuXG4gICMgQWRkIHRoZSBwYXNzZWQgbm9kZSBiZWZvcmUgdGhpcyBvbmUuXG4gICNcbiAgIyBXaGVuIHBhc3NpbmcgYSB7U3RyaW5nfSBhIHRleHQgbm9kZSB3aWxsIGJlIGNyZWF0ZWQuXG4gICNcbiAgIyBAcGFyYW0gbm9kZSBbU3RyaW5nLCBOb2RlLCAjdG9fbl0gdGhlIG5vZGUgdG8gYWRkXG4gIGRlZiBhZGRfcHJldmlvdXNfc2libGluZyhub2RlID0gbmlsLCAmYmxvY2spXG4gICAgdW5sZXNzIG5vZGVcbiAgICAgIG5vZGUgPSBET00oJmJsb2NrKVxuICAgIGVuZFxuICAgIG5vZGUgPSBub2RlLnRvX2RvbShkb2N1bWVudCkgaWYgT3BhbC5yZXNwb25kX3RvPyBub2RlLCA6dG9fZG9tXG5cbiAgICB1bmxlc3MgbmF0aXZlPyhub2RlKVxuICAgICAgaWYgU3RyaW5nID09PSBub2RlXG4gICAgICAgIG5vZGUgPSBgI0BuYXRpdmUub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShub2RlKWBcbiAgICAgIGVsc2VcbiAgICAgICAgbm9kZSA9IE5hdGl2ZS5jb252ZXJ0KG5vZGUpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGAjQG5hdGl2ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCAjQG5hdGl2ZSlgXG4gIGVuZFxuXG4gIGFsaWFzIGFmdGVyIGFkZF9uZXh0X3NpYmxpbmdcblxuICAjIEFwcGVuZCB0aGUgbm9kZSB0byB0aGUgcGFzc2VkIG9uZS5cbiAgI1xuICAjIEBwYXJhbSBub2RlIFtOb2RlXSB0aGUgbm9kZSB0byBhcHBlbmQgdG9cbiAgZGVmIGFwcGVuZF90byhub2RlKVxuICAgIG5vZGUgPDwgc2VsZlxuICAgIHNlbGZcbiAgZW5kXG5cbiAgIyBHZXQgYW4gYXJyYXkgb2YgYW5jZXN0b3JzLlxuICAjXG4gICMgUGFzc2luZyBhIHNlbGVjdG9yIHdpbGwgc2VsZWN0IHRoZSBhbmNlc3RvcnMgbWF0Y2hpbmcgaXQuXG4gICNcbiAgIyBAcGFyYW0gZXhwcmVzc2lvbiBbU3RyaW5nXSB0aGUgc2VsZWN0b3IgdG8gdXNlIGFzIGZpbHRlclxuICAjXG4gICMgQHJldHVybiBbTm9kZVNldF1cbiAgZGVmIGFuY2VzdG9ycyhleHByZXNzaW9uID0gbmlsKVxuICAgIHJldHVybiBOb2RlU2V0W10gdW5sZXNzIHBhcmVudFxuXG4gICAgcGFyZW50cyA9IFtwYXJlbnRdXG5cbiAgICB3aGlsZSBwYXJlbnQgPSBwYXJlbnRzLmxhc3QucGFyZW50XG4gICAgICBwYXJlbnRzIDw8IHBhcmVudFxuICAgIGVuZFxuXG4gICAgaWYgRG9jdW1lbnQgPT09IHBhcmVudHMubGFzdFxuICAgICAgcGFyZW50cy5wb3BcbiAgICBlbmRcblxuICAgIGlmIGV4cHJlc3Npb25cbiAgICAgIHBhcmVudHMuc2VsZWN0ISB7IHxwfCBwID1+IGV4cHJlc3Npb24gfVxuICAgIGVuZFxuXG4gICAgTm9kZVNldC5uZXcocGFyZW50cylcbiAgZW5kXG5cbiAgZGVmIGF0dGFjaGVkP1xuICAgIGAjQG5hdGl2ZS5pc0Nvbm5lY3RlZGBcbiAgZW5kXG5cbiAgYWxpYXMgYmVmb3JlIGFkZF9wcmV2aW91c19zaWJsaW5nXG5cbiAgIyBSZW1vdmUgdGhlIG5vZGUgZnJvbSBpdHMgcGFyZW50LlxuICBkZWYgcmVtb3ZlXG4gICAgcGFyZW50LnJlbW92ZV9jaGlsZChzZWxmKSBpZiBwYXJlbnRcbiAgICBzZWxmXG4gIGVuZFxuXG4gICMgUmVtb3ZlIGFsbCB0aGUgY2hpbGRyZW4gb2YgdGhlIG5vZGUuXG4gIGRlZiBjbGVhclxuICAgIGNoaWxkcmVuLnJlbW92ZVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIGNvbnRlbnRcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBpbm5lciB0ZXh0IGNvbnRlbnQgb2YgdGhlIG5vZGVcbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0VsZW1lbnQudGV4dENvbnRlbnQnXG4gICAgZGVmIGNvbnRlbnRcbiAgICAgIGAjQG5hdGl2ZS50ZXh0Q29udGVudGBcbiAgICBlbmRcblxuICAgIGRlZiBjb250ZW50PSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS50ZXh0Q29udGVudCA9ICN7dmFsdWV9YFxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnRWxlbWVudC5pbm5lclRleHQnXG4gICAgZGVmIGNvbnRlbnRcbiAgICAgIGAjQG5hdGl2ZS5pbm5lclRleHRgXG4gICAgZW5kXG5cbiAgICBkZWYgY29udGVudD0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuaW5uZXJUZXh0ID0gI3t2YWx1ZX1gXG4gICAgZW5kXG4gIGVsc2VcbiAgICBkZWYgY29udGVudFxuICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgJ25vZGUgdGV4dCBjb250ZW50IHVuc3VwcG9ydGVkJ1xuICAgIGVuZFxuXG4gICAgZGVmIGNvbnRlbnQ9KHZhbHVlKVxuICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgJ25vZGUgdGV4dCBjb250ZW50IHVuc3VwcG9ydGVkJ1xuICAgIGVuZFxuICBlbmRcblxuICBkZWYgYmxhbms/XG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvclxuICBlbmRcblxuICAjIFJldHVybiB0cnVlIGlmIHRoZSBub2RlIGlzIGEgQ0RBVEEgc2VjdGlvbi5cbiAgZGVmIGNkYXRhP1xuICAgIG5vZGVfdHlwZSA9PSBDREFUQV9TRUNUSU9OX05PREVcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gY2hpbGRcbiAgIyBAcmV0dXJuIFtOb2RlP10gdGhlIGZpcnN0IGNoaWxkIG9mIHRoZSBub2RlXG4gIGRlZiBjaGlsZFxuICAgIGNoaWxkcmVuLmZpcnN0XG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgY2hpbGRyZW5cbiAgIyBAcmV0dXJuIFtOb2RlU2V0XSB0aGUgY2hpbGRyZW4gb2YgdGhlIG5vZGVcbiAgZGVmIGNoaWxkcmVuXG4gICAgTm9kZVNldFtOYXRpdmU6OkFycmF5Lm5ldyhgI0BuYXRpdmUuY2hpbGROb2Rlc2ApXVxuICBlbmRcblxuICBkZWYgY2hpbGRyZW49KG5vZGUpXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvclxuICBlbmRcblxuICAjIFJldHVybiB0cnVlIGlmIHRoZSBub2RlIGlzIGEgY29tbWVudC5cbiAgZGVmIGNvbW1lbnQ/XG4gICAgbm9kZV90eXBlID09IENPTU1FTlRfTk9ERVxuICBlbmRcblxuICAjIFJldHVybiB0cnVlIGlmIHRoZSBub2RlIGlzIGEgY3VzdG9tIGVsZW1lbnQuXG4gIGRlZiBjdXN0b20/XG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcnddIGRvY3VtZW50XG4gICMgQHJldHVybiBbRG9jdW1lbnQ/XSB0aGUgZG9jdW1lbnQgdGhlIG5vZGUgaXMgYXR0YWNoZWQgdG9cbiAgZGVmIGRvY3VtZW50XG4gICAgRE9NKGAjQG5hdGl2ZS5vd25lckRvY3VtZW50YCkgaWYgZGVmaW5lZD8oYCNAbmF0aXZlLm93bmVyRG9jdW1lbnRgKVxuICBlbmRcblxuICAjIERldGFjaCBhIG5vZGUgYW5kIHRyYW5zZmVyIGl0IHRvIGFub3RoZXIgZG9jdW1lbnQuXG4gIGRlZiBkb2N1bWVudD0obmV3X2RvY3VtZW50KVxuICAgIGAje05hdGl2ZS50cnlfY29udmVydChuZXdfZG9jdW1lbnQsIG5ld19kb2N1bWVudCl9LmFkb3B0Tm9kZSgjQG5hdGl2ZSlgXG4gIGVuZFxuXG4gICMgUmV0dXJuIHRydWUgaWYgdGhlIG5vZGUgaXMgYSBkb2N1bWVudC5cbiAgZGVmIGRvY3VtZW50P1xuICAgIG5vZGVfdHlwZSA9PSBET0NVTUVOVF9OT0RFXG4gIGVuZFxuXG4gICMgUmV0dXJuIHRydWUgaWYgdGhlIG5vZGUgaXMgYW4gZWxlbWVudC5cbiAgZGVmIGVsZW0/XG4gICAgbm9kZV90eXBlID09IEVMRU1FTlRfTk9ERVxuICBlbmRcblxuICBhbGlhcyBlbGVtZW50PyBlbGVtP1xuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIGVsZW1lbnRfY2hpbGRyZW5cbiAgIyBAcmV0dXJuIFtOb2RlU2V0XSBhbGwgdGhlIGNoaWxkcmVuIHdoaWNoIGFyZSBlbGVtZW50c1xuICBkZWYgZWxlbWVudF9jaGlsZHJlblxuICAgIGNoaWxkcmVuLnNlbGVjdCgmOmVsZW1lbnQ/KVxuICBlbmRcblxuICBhbGlhcyBlbGVtZW50cyBlbGVtZW50X2NoaWxkcmVuXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gZmlyc3RfZWxlbWVudF9jaGlsZFxuICAjIEByZXR1cm4gW0VsZW1lbnQ/XSB0aGUgZmlyc3QgZWxlbWVudCBjaGlsZFxuICBkZWYgZmlyc3RfZWxlbWVudF9jaGlsZFxuICAgIGVsZW1lbnRfY2hpbGRyZW4uZmlyc3RcbiAgZW5kXG5cbiAgIyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbm9kZSBpcyBhIGRvY3VtZW50IGZyYWdtZW50LlxuICBkZWYgZnJhZ21lbnQ/XG4gICAgbm9kZV90eXBlID09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREVcbiAgZW5kXG5cbiAgYWxpYXMgaW5uZXJfdGV4dCBjb250ZW50XG4gIGFsaWFzIGlubmVyX3RleHQ9IGNvbnRlbnQ9XG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gbGFzdF9lbGVtZW50X2NoaWxkXG4gICMgQHJldHVybiBbRWxlbWVudD9dIHRoZSBsYXN0IGVsZW1lbnQgY2hpbGRcbiAgZGVmIGxhc3RfZWxlbWVudF9jaGlsZFxuICAgIGVsZW1lbnRfY2hpbGRyZW4ubGFzdFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIG5hbWVcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBuYW1lIG9mIHRoZSBub2RlXG4gIGRlZiBuYW1lXG4gICAgYCNAbmF0aXZlLm5vZGVOYW1lIHx8IG5pbGBcbiAgZW5kXG5cbiAgZGVmIG5hbWU9KHZhbHVlKVxuICAgIGAjQG5hdGl2ZS5ub2RlTmFtZSA9ICN7dmFsdWUudG9fc31gXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIG5hbWVzcGFjZVxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIG5hbWVzcGFjZSBvZiB0aGUgbm9kZVxuICBkZWYgbmFtZXNwYWNlXG4gICAgYCNAbmF0aXZlLm5hbWVzcGFjZVVSSSB8fCBuaWxgXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgbmV4dFxuICAjIEByZXR1cm4gW05vZGU/XSB0aGUgbmV4dCBzaWJsaW5nIG9mIHRoZSBub2RlXG4gIGRlZiBuZXh0XG4gICAgRE9NKGAjQG5hdGl2ZS5uZXh0U2libGluZ2ApIGlmIGAjQG5hdGl2ZS5uZXh0U2libGluZyAhPSBudWxsYFxuICBlbmRcblxuICBhbGlhcyBuZXh0PSBhZGRfbmV4dF9zaWJsaW5nXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gbmV4dF9lbGVtZW50XG4gICMgQHJldHVybiBbRWxlbWVudD9dIHRoZSBuZXh0IGVsZW1lbnQgc2libGluZyBvZiB0aGUgbm9kZVxuICBkZWYgbmV4dF9lbGVtZW50XG4gICAgY3VycmVudCA9IHNlbGYubmV4dFxuXG4gICAgd2hpbGUgY3VycmVudCAmJiAhY3VycmVudC5lbGVtZW50P1xuICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dFxuICAgIGVuZFxuXG4gICAgY3VycmVudFxuICBlbmRcblxuICBhbGlhcyBuZXh0X3NpYmxpbmcgbmV4dFxuXG4gIGFsaWFzIG5vZGVfbmFtZSBuYW1lXG5cbiAgYWxpYXMgbm9kZV9uYW1lPSBuYW1lPVxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIG5vZGVfdHlwZVxuICAjIEByZXR1cm4gW1N5bWJvbF0gdGhlIHR5cGUgb2YgdGhlIG5vZGVcbiAgZGVmIG5vZGVfdHlwZVxuICAgIGAjQG5hdGl2ZS5ub2RlVHlwZWBcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBvdXRlcl9odG1sXG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgc2ltdWxhdGVkIG91dGVyIGh0bWwgb2YgdGhlIG5vZGVcbiAgZGVmIG91dGVyX2h0bWxcbiAgICBkaXYgPSAkZG9jdW1lbnQuY3JlYXRlX2VsZW1lbnQoXCJESVZcIilcbiAgICBkaXYgPDwgc2VsZi5kdXBcbiAgICBkaXYuaW5uZXJfaHRtbFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIHBhcmVudFxuICAjIEByZXR1cm4gW0VsZW1lbnQ/XSB0aGUgcGFyZW50IG9mIHRoZSBub2RlXG4gIGRlZiBwYXJlbnRcbiAgICBET00oYCNAbmF0aXZlLnBhcmVudE5vZGVgKSBpZiBgI0BuYXRpdmUucGFyZW50Tm9kZSAhPSBudWxsYFxuICBlbmRcblxuICBkZWYgcGFyZW50PShub2RlKVxuICAgIGAjQG5hdGl2ZS5wYXJlbnROb2RlID0gI3tOYXRpdmUuY29udmVydChub2RlKX1gXG4gIGVuZFxuXG4gIGRlZiBwYXJzZSh0ZXh0LCBvcHRpb25zID0ge30pXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvclxuICBlbmRcblxuICBkZWYgcGF0aFxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3JcbiAgZW5kXG5cbiAgIyBQcmVwZW5kIHRoZSBub2RlIHRvIHRoZSBwYXNzZWQgb25lLlxuICAjXG4gICMgQHBhcmFtIG5vZGUgW05vZGVdIHRoZSBub2RlIHRvIHByZXBlbmQgdG9cbiAgZGVmIHByZXBlbmRfdG8obm9kZSlcbiAgICBub2RlID4+IHNlbGZcbiAgICBzZWxmXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgcHJldmlvdXNcbiAgIyBAcmV0dXJuIFtOb2RlP10gdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgdGhlIG5vZGVcbiAgZGVmIHByZXZpb3VzXG4gICAgRE9NKGAjQG5hdGl2ZS5wcmV2aW91c1NpYmxpbmdgKSBpZiBgI0BuYXRpdmUucHJldmlvdXNTaWJsaW5nICE9IG51bGxgXG4gIGVuZFxuXG4gIGFsaWFzIHByZXZpb3VzPSBhZGRfcHJldmlvdXNfc2libGluZ1xuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIHByZXZpb3VzX2VsZW1lbnRcbiAgIyBAcmV0dXJuIFtFbGVtZW50P10gdGhlIHByZXZpb3VzIGVsZW1lbnQgc2libGluZyBvZiB0aGUgbm9kZVxuICBkZWYgcHJldmlvdXNfZWxlbWVudFxuICAgIGN1cnJlbnQgPSBzZWxmLnByZXZpb3VzXG5cbiAgICB3aGlsZSBjdXJyZW50ICYmICFjdXJyZW50LmVsZW1lbnQ/XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wcmV2aW91c1xuICAgIGVuZFxuXG4gICAgY3VycmVudFxuICBlbmRcblxuICBhbGlhcyBwcmV2aW91c19zaWJsaW5nIHByZXZpb3VzXG5cbiAgIyBSZW1vdmUgdGhlIGdpdmVuIG5vZGUgZnJvbSB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlLlxuICBkZWYgcmVtb3ZlX2NoaWxkKG5vZGUpXG4gICAgYCNAbmF0aXZlLnJlbW92ZUNoaWxkKCN7TmF0aXZlLnRyeV9jb252ZXJ0KG5vZGUpfSlgXG4gICAgc2VsZlxuICBlbmRcblxuICAjIFJlcGxhY2UgdGhlIG5vZGUgd2l0aCB0aGUgZ2l2ZW4gb25lLlxuICAjXG4gICMgQHRvZG8gaW1wbGVtZW50IGZvciBOb2RlU2V0XG4gICNcbiAgIyBAcGFyYW0gbm9kZSBbTm9kZV0gdGhlIG5vZGUgdG8gcmVwbGFjZSB3aXRoXG4gICMgQHJldHVybiBbTm9kZV0gdGhlIHBhc3NlZCBub2RlXG4gIGRlZiByZXBsYWNlKG5vZGUpXG4gICAgbm9kZSA9IG5vZGUudG9fZG9tKGRvY3VtZW50KSBpZiBPcGFsLnJlc3BvbmRfdG8/IG5vZGUsIDp0b19kb21cblxuICAgIHVubGVzcyBuYXRpdmU/KG5vZGUpXG4gICAgICBpZiBTdHJpbmcgPT09IG5vZGVcbiAgICAgICAgbm9kZSA9IGAjQG5hdGl2ZS5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUpYFxuICAgICAgZWxzZVxuICAgICAgICBub2RlID0gTmF0aXZlLmNvbnZlcnQobm9kZSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgYCNAbmF0aXZlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5vZGUsICNAbmF0aXZlKWBcblxuICAgIERPTShub2RlKVxuICBlbmRcblxuICBhbGlhcyByZXBsYWNlX3dpdGggcmVwbGFjZVxuXG4gIGFsaWFzIHRleHQgY29udGVudFxuICBhbGlhcyB0ZXh0PSBjb250ZW50PVxuXG4gICMgUmV0dXJuIHRydWUgaWYgdGhlIG5vZGUgaXMgYSB0ZXh0IG5vZGUuXG4gIGRlZiB0ZXh0P1xuICAgIG5vZGVfdHlwZSA9PSBURVhUX05PREVcbiAgZW5kXG5cbiAgZGVmIHRyYXZlcnNlKCZibG9jaylcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yXG4gIGVuZFxuXG4gIGFsaWFzIHR5cGUgbm9kZV90eXBlXG5cbiAgIyBAIWF0dHJpYnV0ZSB2YWx1ZVxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIHZhbHVlIG9mIHRoZSBub2RlXG4gIGRlZiB2YWx1ZVxuICAgIGAjQG5hdGl2ZS5ub2RlVmFsdWUgfHwgbmlsYFxuICBlbmRcblxuICBkZWYgdmFsdWU9KHZhbHVlKVxuICAgIGAjQG5hdGl2ZS5ub2RlVmFsdWUgPSB2YWx1ZWBcbiAgZW5kXG5cbiAgIyBAcHJpdmF0ZVxuICBkZWYgaW5zcGVjdFxuICAgIFwiIzxET006Ok5vZGU6ICN7bmFtZX0+XCJcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxtb2R1bGU6RE9NPiIsIjxjbGFzczpOb2RlPiIsInNlbGYiLCJpbmNsdWRlIiwiQnJvd3Nlcjo6TmF0aXZlQ2FjaGVkV3JhcHBlciIsIkJyb3dzZXIiLCIxIiwiMiIsIjMiLCI0IiwiNSIsIjYiLCI3IiwiOCIsIjkiLCIxMCIsIjExIiwiMTIiLCJuZXciLCJ2YWx1ZSIsIk5vZGUiLCJAY2xhc3NlcyIsIiRyZXRfb3JfMSIsIkVsZW1lbnQiLCJBdHRyaWJ1dGUiLCJUZXh0IiwiQ0RBVEEiLCJDb21tZW50IiwiRG9jdW1lbnQiLCJEb2N1bWVudEZyYWdtZW50Iiwia2xhc3MiLCJbXSIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsImluaXRpYWxpemUiLCJub2RlIiwiY2xhc3MiLCI9PSIsIm90aGVyIiwiQG5hdGl2ZSIsIk5hdGl2ZSIsImNvbnZlcnQiLCJpbml0aWFsaXplX2NvcHkiLCJvbGQiLCJzZXRfbmF0aXZlX3JlZmVyZW5jZSIsInRvX24iLCI8PCIsIk9wYWwiLCJyZXNwb25kX3RvPyIsImVhY2giLCJibG9jayBpbiA8PCIsIm4iLCJibG9jayAoMiBsZXZlbHMpIGluIDw8IiwidG9fZG9tIiwiZG9jdW1lbnQiLCJuYXRpdmU/IiwiU3RyaW5nIiwiPj4iLCJibG9jayBpbiA+PiIsImJsb2NrICgyIGxldmVscykgaW4gPj4iLCJhZGRfY2hpbGQiLCJET00iLCJibG9jayIsInRvX3Byb2MiLCJhZGRfbmV4dF9zaWJsaW5nIiwiYWRkX3ByZXZpb3VzX3NpYmxpbmciLCJhcHBlbmRfdG8iLCJhbmNlc3RvcnMiLCJleHByZXNzaW9uIiwicGFyZW50IiwiTm9kZVNldCIsInBhcmVudHMiLCJsYXN0IiwicG9wIiwic2VsZWN0ISIsImJsb2NrIGluIGFuY2VzdG9ycyIsInAiLCJibG9jayAoMiBsZXZlbHMpIGluIGFuY2VzdG9ycyIsIj1+IiwiYXR0YWNoZWQ/IiwicmVtb3ZlIiwicmVtb3ZlX2NoaWxkIiwiY2xlYXIiLCJjaGlsZHJlbiIsInN1cHBvcnRzPyIsImNvbnRlbnQiLCJjb250ZW50PSIsIk5vdEltcGxlbWVudGVkRXJyb3IiLCJibGFuaz8iLCJjZGF0YT8iLCJub2RlX3R5cGUiLCJDREFUQV9TRUNUSU9OX05PREUiLCJjaGlsZCIsImZpcnN0IiwiTmF0aXZlOjpBcnJheSIsImNoaWxkcmVuPSIsImNvbW1lbnQ/IiwiQ09NTUVOVF9OT0RFIiwiY3VzdG9tPyIsImRvY3VtZW50PSIsIm5ld19kb2N1bWVudCIsInRyeV9jb252ZXJ0IiwiZG9jdW1lbnQ/IiwiRE9DVU1FTlRfTk9ERSIsImVsZW0/IiwiRUxFTUVOVF9OT0RFIiwiZWxlbWVudF9jaGlsZHJlbiIsInNlbGVjdCIsImZpcnN0X2VsZW1lbnRfY2hpbGQiLCJmcmFnbWVudD8iLCJET0NVTUVOVF9GUkFHTUVOVF9OT0RFIiwibGFzdF9lbGVtZW50X2NoaWxkIiwibmFtZSIsIm5hbWU9IiwidG9fcyIsIm5hbWVzcGFjZSIsIm5leHQiLCJuZXh0X2VsZW1lbnQiLCJjdXJyZW50IiwiZWxlbWVudD8iLCIhIiwib3V0ZXJfaHRtbCIsImRpdiIsIiRkb2N1bWVudCIsImNyZWF0ZV9lbGVtZW50IiwiZHVwIiwiaW5uZXJfaHRtbCIsInBhcmVudD0iLCJwYXJzZSIsInRleHQiLCJvcHRpb25zIiwicGF0aCIsInByZXBlbmRfdG8iLCJwcmV2aW91cyIsInByZXZpb3VzX2VsZW1lbnQiLCJyZXBsYWNlIiwidGV4dD8iLCJURVhUX05PREUiLCJ0cmF2ZXJzZSIsInZhbHVlPSIsImluc3BlY3QiXSwibWFwcGluZ3MiOiJBQUFBQSxtQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BS2hCQSxPQUFBQztNQUFBQTs7UUFBQUE7O0FBQUFBOztRQUNFQyxJQUFBQyxTQUFBQSxDQUFRQyxJQUFBQyxhQUFBRCx3QkFBUkQ7UUFFQSx3Q0FBOEJHLENBQTlCO1FBQ0EsMENBQThCQyxDQUE5QjtRQUNBLHFDQUE4QkMsQ0FBOUI7UUFDQSw4Q0FBOEJDLENBQTlCO1FBQ0EsaURBQThCQyxDQUE5QjtRQUNBLHVDQUE4QkMsQ0FBOUI7UUFDQSx1REFBOEJDLENBQTlCO1FBQ0Esd0NBQThCQyxDQUE5QjtRQUNBLHlDQUE4QkMsQ0FBOUI7UUFDQSw4Q0FBOEJDLEVBQTlCO1FBQ0Esa0RBQThCQyxFQUE5QjtRQUNBLHlDQUE4QkMsRUFBOUI7UUFPQUMsTUFBSWhCLElBQUpnQixVQUFBQSxxQkFBYUMsS0FBYkQ7QUFBQUEsVUFBQUE7QUFBQUE7O1VBQUFBO1VBQ0UsSUFBQSxNQUFHaEIsSUFBSCxFQUFXa0IsVUFBWCxDQUFBOztZQUNFQyxlQTVCTixDQUFBLFFBQUFDLENBQUFBLFlBNEJNRCxZQTVCTkMsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxTQUFBLElBQUEsQ0E0Qm1CLENBQUMsR0FBRCxFQUFNQyxhQUFOLEVBQWVDLGVBQWYsRUFBMEJDLFVBQTFCLEVBQWdDQyxXQUFoQyxFQUF1QyxHQUF2QyxFQUE0QyxHQUE1QyxFQUFpRCxHQUFqRCxFQUFzREMsYUFBdEQsRUFBK0RDLGNBQS9ELEVBQXlFLEdBQXpFLEVBQThFQyxzQkFBOUUsQ0E1Qm5CLENBQUE7WUE4Qk0sSUFBQSxRQUFHQyxDQUFBQSxRQUFRVCxZQUFRVSxPQUFBQSxDQUFFYixjQUFGYSxDQUFoQkQsQ0FBSCxDQUFBO2NBQ0VaLE9BQUFZLEtB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QUFPcEI7UUFEWEEsQ0FBQUE7O0FBSUF3SCxRQUFBQSxzQkFBQUEsMkJBQVd4SCxLQUFYd0g7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUVwRyxjQUFPb0c7UUFEWEEsQ0FBQUE7UUFLQTFJLE9BQUEySSx1QkFBQUEsbUJBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFDQSxlQUFELEdBQUEsQ0FBZ0IxSSxJQUFBOEcsTUFBQUEsQ0FBQUEsQ0FBaEIsQ0FBQSxHQUFxQjRCO1FBRHZCQSxDQUFBQTtNQTdlRjNJLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0lBTGdCRCxHQUFBQSxXQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMzMTk3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9kb20vYXR0cmlidXRlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NXG5cbiMgRW5jYXBzdWxhdGVzIGFuIHtFbGVtZW50fSBhdHRyaWJ1dGUuXG5jbGFzcyBBdHRyaWJ1dGVcbiAgaW5jbHVkZSBCcm93c2VyOjpOYXRpdmVDYWNoZWRXcmFwcGVyXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gbmFtZVxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICBhbGlhc19uYXRpdmUgOm5hbWVcblxuICAjIEAhYXR0cmlidXRlIHZhbHVlXG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZVxuICBhbGlhc19uYXRpdmUgOnZhbHVlXG4gIGFsaWFzX25hdGl2ZSA6dmFsdWU9XG5cbiAgIyBSZXR1cm5zIHRydWUgaWYgdGhlIGF0dHJpYnV0ZSBpcyBhbiBpZC5cbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0F0dHIuaXNJZCdcbiAgICBhbGlhc19uYXRpdmUgOmlkPywgOmlzSWRcbiAgZWxzZVxuICAgIGRlZiBpZD9cbiAgICAgIG5hbWUgPT0gOmlkXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8bW9kdWxlOkRPTT4iLCI8Y2xhc3M6QXR0cmlidXRlPiIsInNlbGYiLCJpbmNsdWRlIiwiQnJvd3Nlcjo6TmF0aXZlQ2FjaGVkV3JhcHBlciIsIkJyb3dzZXIiLCJhbGlhc19uYXRpdmUiLCJzdXBwb3J0cz8iLCJpZD8iLCJuYW1lIiwiPT0iXSwibWFwcGluZ3MiOiJBQUFBQSx3Q0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BR2hCQSxPQUFBQztNQUFBQTs7UUFBQUE7OztRQUNFQyxJQUFBQyxTQUFBQSxDQUFRQyxJQUFBQyxhQUFBRCx3QkFBUkQ7UUFJQUQsSUFBQUksY0FBQUEsQ0FBYSxNQUFiQTtRQUlBSixJQUFBSSxjQUFBQSxDQUFhLE9BQWJBO1FBQ0FKLElBQUFJLGNBQUFBLENBQWEsUUFBYkE7UUFHQSxJQUFBLFFBQUdELGFBQU9FLGNBQUFBLENBQVdOLFdBQVhNLENBQVYsQ0FBQTtVQUNFTixPQUFBQyxJQUFBSSxjQUFBQSxDQUFhLEtBQWIsRUFBbUIsTUFBbkJBO1FBREY7VUFHRUwsT0FBQU8sbUJBQUFBLDhCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBQU4sSUFBQU8sTUFBQUEsQ0FBQUEsQ0FBS0MsT0FBQUEsQ0FBRyxJQUFIQTtVQURQRixDQUFBQTtRQUhGO01BYkZQLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0lBSGdCRCxHQUFBQSxXQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMzMjM1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9kb20vY2hhcmFjdGVyX2RhdGEucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBET01cblxuY2xhc3MgQ2hhcmFjdGVyRGF0YSA8IE5vZGVcbiAgIyBBcHBlbmQgZGF0YSB0byB0aGUgbm9kZS5cbiAgI1xuICAjIEBwYXJhbSBzdHJpbmcgW1N0cmluZ10gdGhlIGRhdGEgdG8gYWRkXG4gICNcbiAgIyBAcmV0dXJuIFtzZWxmXVxuICBkZWYgYXBwZW5kKHN0cmluZylcbiAgICBgI0BuYXRpdmUuYXBwZW5kRGF0YShzdHJpbmcpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBkYXRhXG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgZGF0YSBvZiB0aGUgbm9kZVxuICBkZWYgZGF0YVxuICAgIGAjQG5hdGl2ZS5kYXRhYFxuICBlbmRcblxuICAjIERlbGV0ZSBkYXRhIGZyb20gdGhlIG5vZGUuXG4gICNcbiAgIyBAcGFyYW0gY291bnQgW0ludGVnZXJdIGhvdyBtdWNoIGRhdGEgdG8gZGVsZXRlXG4gICMgQHBhcmFtIG9mZnNldCBbSW50ZWdlcl0gdGhlIG9mZnNldCB0byBzdGFydCBhdFxuICAjXG4gICMgQHJldHVybiBbc2VsZl1cbiAgZGVmIGRlbGV0ZShjb3VudCwgb2Zmc2V0ID0gMClcbiAgICBgI0BuYXRpdmUuZGVsZXRlRGF0YShvZmZzZXQsIGNvdW50KWBcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgIyBJbnNlcnQgZGF0YSBpbiB0aGUgbm9kZS5cbiAgI1xuICAjIEBwYXJhbSBzdHJpbmcgW1N0cmluZ10gdGhlIGRhdGEgdG8gaW5zZXJ0XG4gICMgQHBhcmFtIG9mZnNldCBbSW50ZWdlcl0gdGhlIG9mZnNldCB0byBzdGFydCBhdFxuICAjXG4gICMgQHJldHVybiBbc2VsZl1cbiAgZGVmIGluc2VydChzdHJpbmcsIG9mZnNldCA9IDApXG4gICAgYCNAbmF0aXZlLmluc2VydERhdGEob2Zmc2V0LCBzdHJpbmcpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBsZW5ndGhcbiAgIyBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgbGVuZ3RoIG9mIHRoZSBub2RlXG4gIGFsaWFzX25hdGl2ZSA6bGVuZ3RoXG5cbiAgIyBSZXBsYWNlIGRhdGEgaW4gdGhlIG5vZGUuXG4gICNcbiAgIyBAcGFyYW0gc3RyaW5nIFtTdHJpbmddIHRoZSBkYXRhIHRvIHJlcGxhY2Ugd2l0aFxuICAjIEBwYXJhbSBvZmZzZXQgW0ludGVnZXJdIHRoZSBvZmZzZXQgdG8gc3RhcnQgYXRcbiAgIyBAcGFyYW0gY291bnQgW0ludGVnZXJdIGhvdyBtdWNoIGRhdGEgdG8gcmVwbGFjZVxuICAjXG4gICMgQHJldHVybiBbc2VsZl1cbiAgZGVmIHJlcGxhY2Uoc3RyaW5nLCBvZmZzZXQgPSAwLCBjb3VudCA9IGAjQG5hdGl2ZS5sZW5ndGhgKVxuICAgIGAjQG5hdGl2ZS5yZXBsYWNlRGF0YShvZmZzZXQsIGNvdW50LCBzdHJpbmcpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICAjIEdldCBhIHN1YnN0cmluZyBvZiB0aGUgZGF0YS5cbiAgI1xuICAjIEBwYXJhbSBjb3VudCBbSW50ZWdlcl0gaG93IG11Y2ggZGF0YSB0byBsaWNlXG4gICMgQHBhcmFtIG9mZnNldCBbSW50ZWdlcl0gdGhlIG9mZnNldCB0byBzdGFydCBhdFxuICAjXG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgc3Vic3RyaW5nXG4gIGRlZiBzdWJzdHJpbmcoY291bnQsIG9mZnNldCA9IDApXG4gICAgYCNAbmF0aXZlLnN1YnN0cmluZ0RhdGEob2Zmc2V0LCBjb3VudClgXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8bW9kdWxlOkRPTT4iLCI8Y2xhc3M6Q2hhcmFjdGVyRGF0YT4iLCJhcHBlbmQiLCJzdHJpbmciLCJAbmF0aXZlIiwic2VsZiIsImRhdGEiLCJkZWxldGUiLCJjb3VudCIsIm9mZnNldCIsIjAiLCJpbnNlcnQiLCJhbGlhc19uYXRpdmUiLCJyZXBsYWNlIiwic3Vic3RyaW5nIiwiTm9kZSJdLCJtYXBwaW5ncyI6IkFBQUFBLDZDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7QUFBQUE7OztBQU1FQyxRQUFBQSxzQkFBQUEsa0JBQVdDLE1BQVhEO0FBQUFBLFVBQUFBOzs7VUFDSUUsY0FBT0Y7VUFFVEEsT0FBQUc7UUFIRkgsQ0FBQUE7O0FBUUFJLFFBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUVGLGNBQU9FO1FBRFhBLENBQUFBOztBQVVBQyxRQUFBQSxzQkFBQUEsaUNBQVdDLEtBQUQsRUFBUUMsTUFBbEJGO0FBQUFBLFVBQUFBOzs7VUFBa0IsNkJBQVNHO1VBQ3ZCTixjQUFPRztVQUVUQSxPQUFBRjtRQUhGRSxDQUFBQSxJQUFBQTs7QUFZQUksUUFBQUEsc0JBQUFBLGtCQUFXUixNQUFELEVBQVNNLE1BQW5CRTtBQUFBQSxVQUFBQTs7O1VBQW1CLDZCQUFTRDtVQUN4Qk4sY0FBT087VUFFVEEsT0FBQU47UUFIRk0sQ0FBQUEsSUFBQUE7UUFRQU4sSUFBQU8sY0FBQUEsQ0FBYSxRQUFiQTs7QUFTQUMsUUFBQUEsdUJBQUFBLG1CQUFZVixNQUFELEVBQVNNLE1BQVQsRUFBcUJELEtBQWhDSztBQUFBQSxVQUFBQTs7O1VBQW9CLDZCQUFTSDtVQUFHLDJCQUFVTixjQUFPUztVQUM3Q1QsY0FBT1M7VUFFVEEsT0FBQVI7UUFIRlEsQ0FBQUEsSUFBQUE7UUFZQVosT0FBQWEseUJBQUFBLHFCQUFjTixLQUFELEVBQVFDLE1BQXJCSztBQUFBQSxVQUFBQTs7O1VBQXFCLDZCQUFTSjtVQUM1QkksT0FBRVYsY0FBT1U7UUFEWEEsQ0FBQUEsSUFBQUE7TUFqRUZiLEdBQUFBLFdBQUFBLEVBQXNCYyxVQUF0QmQ7SUFGZ0JELEdBQUFBLFdBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzMzMTEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS90ZXh0LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NXG5cbiMgRW5jYXBzdWxhdGVzIGEgdGV4dCBub2RlLlxuI1xuIyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UZXh0XG5jbGFzcyBUZXh0IDwgQ2hhcmFjdGVyRGF0YVxuICAjIChzZWUgRG9jdW1lbnQjY3JlYXRlX3RleHQpXG4gIGRlZiBzZWxmLmNyZWF0ZShjb250ZW50KVxuICAgICRkb2N1bWVudC5jcmVhdGVfdGV4dChjb250ZW50KVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSB3aG9sZVxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIHdob2xlIHRleHRcbiAgI1xuICAjIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RleHQud2hvbGVUZXh0XG4gIGRlZiB3aG9sZVxuICAgIGAjQG5hdGl2ZS53aG9sZVRleHRgXG4gIGVuZFxuXG4gICMgU3BsaXQgdGhlIHRleHQgbm9kZSBhdCBhIGdpdmVuIG9mZnNldC5cbiAgI1xuICAjIEBwYXJhbSBvZmZzZXQgW0ludGVnZXJdIHRoZSBvZmZzZXQgd2hlcmUgdG8gc3BsaXQgdGhlIHRleHQgbm9kZVxuICAjXG4gICMgQHJldHVybiBbVGV4dF0gdGhlIG5ld2x5IGNyZWF0ZWQgdGV4dCBub2RlXG4gICNcbiAgIyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UZXh0LnNwbGl0VGV4dFxuICBkZWYgc3BsaXQob2Zmc2V0KVxuICAgIERPTShgI0BuYXRpdmUuc3BsaXRUZXh0KG9mZnNldClgKVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIFwiIzxET006OlRleHQ6ICN7ZGF0YX0+XCJcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxtb2R1bGU6RE9NPiIsIjxjbGFzczpUZXh0PiIsImNyZWF0ZSIsInNlbGYiLCJjb250ZW50IiwiJGRvY3VtZW50IiwiY3JlYXRlX3RleHQiLCJ3aG9sZSIsIkBuYXRpdmUiLCJzcGxpdCIsIm9mZnNldCIsIkRPTSIsImluc3BlY3QiLCJkYXRhIiwiQ2hhcmFjdGVyRGF0YSJdLCJtYXBwaW5ncyI6IkFBQUFBLG1DQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFLaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7QUFBQUE7O1FBRUVDLE1BQUlDLElBQUpELGFBQUFBLGtCQUFnQkUsT0FBaEJGO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBRyxlQUFTQyxhQUFBQSxDQUFhRixPQUFiRTtRQURYSixDQUFBQTs7QUFRQUssUUFBQUEscUJBQUFBLGlCQUFBQTtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBRUMsY0FBT0Q7UUFEWEEsQ0FBQUE7O0FBV0FFLFFBQUFBLHFCQUFBQSxpQkFBVUMsTUFBVkQ7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUFOLElBQUFRLEtBQUFBLENBQU1ILGNBQU9DLGtCQUFiRTtRQURGRixDQUFBQTtRQUlBUixPQUFBVyx1QkFBQUEsbUJBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFDQSxlQUFELEdBQUEsQ0FBZ0JULElBQUFVLE1BQUFBLENBQUFBLENBQWhCLENBQUEsR0FBcUJEO1FBRHZCQSxDQUFBQTtNQXpCRlgsR0FBQUEsV0FBQUEsRUFBYWEsbUJBQWJiO0lBTGdCRCxHQUFBQSxXQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMzMzU5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9kb20vY2RhdGEucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBET01cblxuY2xhc3MgQ0RBVEEgPCBUZXh0XG4gIGRlZiBpbnNwZWN0XG4gICAgXCIjPERPTTo6Q0RBVEE6ICN7dmFsdWV9PlwiXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8bW9kdWxlOkRPTT4iLCI8Y2xhc3M6Q0RBVEE+IiwiaW5zcGVjdCIsInNlbGYiLCJ2YWx1ZSIsIlRleHQiXSwibWFwcGluZ3MiOiJBQUFBQSxvQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWhCQSxPQUFBQztNQUFBQTs7O1FBQ0VBLE9BQUFDLHVCQUFBQSxtQkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUNBLGdCQUFELEdBQUEsQ0FBaUJDLElBQUFDLE9BQUFBLENBQUFBLENBQWpCLENBQUEsR0FBdUJGO1FBRHpCQSxDQUFBQTtNQURGRCxHQUFBQSxXQUFBQSxFQUFjSSxVQUFkSjtJQUZnQkQsR0FBQUEsV0FBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMzM4NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZG9tL2NvbW1lbnQucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBET01cblxuY2xhc3MgQ29tbWVudCA8IENoYXJhY3RlckRhdGFcbiAgZGVmIGluc3BlY3RcbiAgICBcIiM8RE9NOjpDb21tZW50OiAje3ZhbHVlfT5cIlxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPG1vZHVsZTpET00+IiwiPGNsYXNzOkNvbW1lbnQ+IiwiaW5zcGVjdCIsInNlbGYiLCJ2YWx1ZSIsIkNoYXJhY3RlckRhdGEiXSwibWFwcGluZ3MiOiJBQUFBQSxzQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWhCQSxPQUFBQztNQUFBQTs7O1FBQ0VBLE9BQUFDLHVCQUFBQSxtQkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUNBLGtCQUFELEdBQUEsQ0FBbUJDLElBQUFDLE9BQUFBLENBQUFBLENBQW5CLENBQUEsR0FBeUJGO1FBRDNCQSxDQUFBQTtNQURGRCxHQUFBQSxXQUFBQSxFQUFnQkksbUJBQWhCSjtJQUZnQkQsR0FBQUEsV0FBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMzQxNSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZG9tL2VsZW1lbnQvYXR0cmlidXRlcy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgbW9kdWxlIERPTTsgY2xhc3MgRWxlbWVudCA8IE5vZGVcblxuY2xhc3MgQXR0cmlidXRlc1xuICBhdHRyX3JlYWRlciA6bmFtZXNwYWNlXG5cbiAgZGVmIGluaXRpYWxpemUoZWxlbWVudCwgb3B0aW9ucylcbiAgICBAZWxlbWVudCAgID0gZWxlbWVudFxuICAgIEBuYXRpdmUgICAgPSBlbGVtZW50LnRvX25cbiAgICBAbmFtZXNwYWNlID0gb3B0aW9uc1s6bmFtZXNwYWNlXVxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPygnRWxlbWVudC5jbGFzc05hbWUnKSB8fCBCcm93c2VyLnN1cHBvcnRzPygnRWxlbWVudC5odG1sRm9yJylcbiAgICBkZWYgW10obmFtZSwgb3B0aW9ucyA9IHt9KVxuICAgICAgaWYgbmFtZSA9PSA6Y2xhc3MgJiYgQnJvd3Nlci5zdXBwb3J0cz8oJ0VsZW1lbnQuY2xhc3NOYW1lJylcbiAgICAgICAgbmFtZSA9IDpjbGFzc05hbWVcbiAgICAgIGVsc2lmIG5hbWUgPT0gOmZvciAmJiBCcm93c2VyLnN1cHBvcnRzPygnRWxlbWVudC5odG1sRm9yJylcbiAgICAgICAgbmFtZSA9IDpodG1sRm9yXG4gICAgICBlbmRcblxuICAgICAgaWYgbmFtZXNwYWNlID0gb3B0aW9uc1s6bmFtZXNwYWNlXSB8fCBAbmFtZXNwYWNlXG4gICAgICAgIGAjQG5hdGl2ZS5nZXRBdHRyaWJ1dGVOUygje25hbWVzcGFjZS50b19zfSwgI3tuYW1lLnRvX3N9KSB8fCBuaWxgXG4gICAgICBlbHNlXG4gICAgICAgIGAjQG5hdGl2ZS5nZXRBdHRyaWJ1dGUoI3tuYW1lLnRvX3N9KSB8fCBuaWxgXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBbXT0obmFtZSwgdmFsdWUsIG9wdGlvbnMgPSB7fSlcbiAgICAgIGlmIG5hbWUgPT0gOmNsYXNzICYmIEJyb3dzZXIuc3VwcG9ydHM/KCdFbGVtZW50LmNsYXNzTmFtZScpXG4gICAgICAgIG5hbWUgPSA6Y2xhc3NOYW1lXG4gICAgICBlbHNpZiBuYW1lID09IDpmb3IgJiYgQnJvd3Nlci5zdXBwb3J0cz8oJ0VsZW1lbnQuaHRtbEZvcicpXG4gICAgICAgIG5hbWUgPSA6aHRtbEZvclxuICAgICAgZW5kXG5cbiAgICAgIGlmIG5hbWVzcGFjZSA9IG9wdGlvbnNbOm5hbWVzcGFjZV0gfHwgQG5hbWVzcGFjZVxuICAgICAgICBpZiB2YWx1ZVxuICAgICAgICAgIGAjQG5hdGl2ZS5zZXRBdHRyaWJ1dGVOUygje25hbWVzcGFjZS50b19zfSwgI3tuYW1lLnRvX3N9LCAje3ZhbHVlfSlgXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBgI0BuYXRpdmUucmVtb3ZlQXR0cmlidXRlTlMoI3tuYW1lc3BhY2UudG9fc30sICN7bmFtZS50b19zfSlgXG4gICAgICAgIGVuZFxuICAgICAgZWxzZVxuICAgICAgICBpZiB2YWx1ZVxuICAgICAgICAgIGAjQG5hdGl2ZS5zZXRBdHRyaWJ1dGUoI3tuYW1lLnRvX3N9LCAje3ZhbHVlLnRvX3N9KWBcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGAjQG5hdGl2ZS5yZW1vdmVBdHRyaWJ1dGUoI3tuYW1lLnRvX3N9KWBcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZWxzZVxuICAgIGRlZiBbXShuYW1lLCBvcHRpb25zID0ge30pXG4gICAgICBpZiBuYW1lc3BhY2UgPSBvcHRpb25zWzpuYW1lc3BhY2VdIHx8IEBuYW1lc3BhY2VcbiAgICAgICAgYCNAbmF0aXZlLmdldEF0dHJpYnV0ZU5TKCN7bmFtZXNwYWNlLnRvX3N9LCAje25hbWUudG9fc30pIHx8IG5pbGBcbiAgICAgIGVsc2VcbiAgICAgICAgYCNAbmF0aXZlLmdldEF0dHJpYnV0ZSgje25hbWUudG9fc30pIHx8IG5pbGBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIFtdPShuYW1lLCB2YWx1ZSwgb3B0aW9ucyA9IHt9KVxuICAgICAgaWYgbmFtZXNwYWNlID0gb3B0aW9uc1s6bmFtZXNwYWNlXSB8fCBAbmFtZXNwYWNlXG4gICAgICAgIGlmIHZhbHVlXG4gICAgICAgICAgYCNAbmF0aXZlLnNldEF0dHJpYnV0ZU5TKCN7bmFtZXNwYWNlLnRvX3N9LCAje25hbWUudG9fc30sICN7dmFsdWV9KWBcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGAjQG5hdGl2ZS5yZW1vdmVBdHRyaWJ1dGVOUygje25hbWVzcGFjZS50b19zfSwgI3tuYW1lLnRvX3N9KWBcbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgIGlmIHZhbHVlXG4gICAgICAgICAgYCNAbmF0aXZlLnNldEF0dHJpYnV0ZSgje25hbWUudG9fc30sICN7dmFsdWUudG9fc30pYFxuICAgICAgICBlbHNlXG4gICAgICAgICAgYCNAbmF0aXZlLnJlbW92ZUF0dHJpYnV0ZSgje25hbWUudG9fc30pYFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcblxuICAjIERlbGV0ZXMgYW4gYXR0cmlidXRlIHdpdGggYSBnaXZlbiBuYW1lXG4gICMgQHJldHVybiBbU3RyaW5nXSBhbiBhdHRyaWJ1dGUgdmFsdWUgYmVmb3JlIGRlbGV0aW9uXG4gIGRlZiBkZWxldGUobmFtZSlcbiAgICBhdHRyID0gc2VsZltuYW1lXVxuICAgIHNlbGZbbmFtZV0gPSBuaWxcbiAgICBhdHRyXG4gIGVuZFxuXG4gIGluY2x1ZGUgRW51bWVyYWJsZVxuXG4gIGRlZiBlYWNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmVhY2ggdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgQGVsZW1lbnQuYXR0cmlidXRlX25vZGVzLmVhY2gge3xhdHRyfFxuICAgICAgeWllbGQgYXR0ci5uYW1lLCBhdHRyLnZhbHVlXG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBhbGlhcyBnZXQgW11cblxuICBkZWYgaGFzX2tleT8obmFtZSlcbiAgICAhIXNlbGZbbmFtZV1cbiAgZW5kXG5cbiAgZGVmIG1lcmdlIShoYXNoKVxuICAgIGhhc2guZWFjaCB7fG5hbWUsIHZhbHVlfFxuICAgICAgc2VsZltuYW1lXSA9IHZhbHVlXG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBhbGlhcyBzZXQgW109XG5lbmRcblxuZW5kOyBlbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPG1vZHVsZTpET00+IiwiPGNsYXNzOkVsZW1lbnQ+IiwiPGNsYXNzOkF0dHJpYnV0ZXM+Iiwic2VsZiIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsImVsZW1lbnQiLCJvcHRpb25zIiwiQGVsZW1lbnQiLCJAbmF0aXZlIiwidG9fbiIsIkBuYW1lc3BhY2UiLCJbXSIsIkJyb3dzZXIiLCJzdXBwb3J0cz8iLCJuYW1lIiwibmFtZXNwYWNlIiwiJHJldF9vcl8xIiwidG9fcyIsIltdPSIsInZhbHVlIiwiZGVsZXRlIiwiYXR0ciIsImluY2x1ZGUiLCJFbnVtZXJhYmxlIiwiZWFjaCIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwiYXR0cmlidXRlX25vZGVzIiwiYmxvY2sgaW4gZWFjaCIsImhhc19rZXk/IiwiISIsIm1lcmdlISIsImhhc2giLCJibG9jayBpbiBtZXJnZSEiLCJibG9jayAoMiBsZXZlbHMpIGluIG1lcmdlISIsIk5vZGUiXSwibWFwcGluZ3MiOiJBQUFBQSxpREFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BQVlBLE9BQUFDO01BQUFBOztRQUFBQTs7UUFFNUJBLE9BQUFDO1FBQUFBOztVQUFBQTs7QUFBQUE7O1VBQ0VDLElBQUFDLGFBQUFBLENBQVksV0FBWkE7O0FBRUFDLFVBQUFBLDBCQUFBQSxzQkFBZUMsT0FBRCxFQUFVQyxPQUF4QkY7QUFBQUEsWUFBQUE7OztZQUNFRyxlQUFhRjtZQUNiRyxpQkFBYUgsT0FBT0ksTUFBQUEsQ0FBQUE7WUFDcEJMLE9BQUFNLENBQUFBLGlCQUFhSixPQUFPSyxPQUFBQSxDQUFDLFdBQURBLENBQXBCRDtVQUhGTixDQUFBQTtVQU1BLElBQUcsQ0FBQSxRQUFBUSxhQUFPQyxjQUFBQSxDQUFXWixtQkFBWFksQ0FBUCxDQUFBLElBQUEsQ0FBQSxRQUEwQ0QsYUFBT0MsY0FBQUEsQ0FBV1osaUJBQVhZLENBQWpELENBQUEsQ0FBQSxDQUFIOzs7QUFDRUYsWUFBQUEsa0JBQUFBLDBCQUFPRyxJQUFELEVBQU9SLE9BQWJLO0FBQUFBLGNBQUFBOzs7Y0FBYSwrQkFBVTtjQUNyQixJQUFHLENBQUEsTUFBQUcsSUFBQSxFQUFRLE9BQVIsQ0FBQSxJQUFBLENBQUEsUUFBa0JG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QUEsQ0FBQUEsQ0FBZ0JILFFBQUFBLEVBQUFBLEVBQUFBLEVBQXhCSSxhQUFnQ1AsSUFBaENPOztjQUFnQztjQUM5QixPQUFBLG9CQUFNUCxJQUFJUCxNQUFBQSxDQUFBQSxDQUFWLEVBQWlCTyxJQUFJRixPQUFBQSxDQUFBQSxDQUFyQixFQUFBLEVBREZTLENBQXdCSjtZQUl4QkEsT0FBQXRCO1VBUEZzQixDQUFBQTtVQVVBLGFBQU0sS0FBTixFQUFVLElBQVY7O0FBRUFLLFVBQUFBLHdCQUFBQSxvQ0FBYWYsSUFBYmU7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUUzQixJQUFJUyxPQUFBQSxDQUFDRyxJQUFESCxDQUFMbUIsTUFBQUEsQ0FBQUEsQ0FBREEsTUFBQUEsQ0FBQUE7VUFERkQsQ0FBQUE7O0FBSUFFLFVBQUFBLHNCQUFBQSxrQ0FBV0MsSUFBWEQ7QUFBQUEsWUFBQUE7OztZQUNNUCxNQUFKUSxJQUFJUixRQUFBQSxFQUFBQSxFQUFBQSxFQUFKUyxhQUFZbkIsSUFBRCxFQUFPSyxLQUFsQmMsRUFBQUM7OztjQUFZO2NBQU07Y0FDaEJBLE9BQUloQixNQUFBQSxDQUFDSixJQUFMLEVBQWFLLEtBQVRELENBQUFBLEVBQUFBLE1BQUpoQixJQUFJZ0IsT0FBQUEsRUFBQUEsRUFBQUEsQ0FBQUEsRUFBQUEsbUJBRE5lLENBQUFBLEdBQUFBLFNBQUFBLENBQUlUO1lBSUpPLE9BQUE3QjtVQUxGNkIsQ0FBQUE7VUFRQTlCLE9BQUEsYUFBTSxLQUFOLEVBQVUsS0FBVjtRQXpHRkEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7TUFGNEJELEdBQUFBLFdBQUFBLEVBQWdCbUMsVUFBaEJuQztJQUFaRCxHQUFBQSxXQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMzNTc5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9kb20vZWxlbWVudC9kYXRhLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NOyBjbGFzcyBFbGVtZW50IDwgTm9kZVxuXG5jbGFzcyBEYXRhXG4gIGF0dHJfcmVhZGVyIDplbGVtZW50XG5cbiAgZGVmIGluaXRpYWxpemUoZWxlbWVudClcbiAgICBAZWxlbWVudCA9IGVsZW1lbnRcbiAgICBAbmF0aXZlICA9IGVsZW1lbnQudG9fblxuXG4gICAgdW5sZXNzIGRlZmluZWQ/KGAjQG5hdGl2ZS4kZGF0YWApXG4gICAgICBgI0BuYXRpdmUuJGRhdGEgPSB7fWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgaW5jbHVkZSBFbnVtZXJhYmxlXG5cbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaCB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIGRhdGEgPSAjQG5hdGl2ZS4kZGF0YTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgI3tibG9jay5jYWxsIGBrZXlgLCBgZGF0YVtrZXldYH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgQGVsZW1lbnQuYXR0cmlidXRlcy5lYWNoIHt8bmFtZSwgdmFsdWV8XG4gICAgICBpZiBuYW1lID1+IC9eZGF0YS0oLiopJC9cbiAgICAgICAgYmxvY2suY2FsbCAkMSwgdmFsdWVcbiAgICAgIGVuZFxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGFzc2lnbihkYXRhKVxuICAgIGRhdGEuZWFjaCB7fG5hbWUsIHZhbHVlfFxuICAgICAgc2VsZltuYW1lXSA9IHZhbHVlXG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgW10obmFtZSlcbiAgICBpZiBkYXRhID0gQGVsZW1lbnRbXCJkYXRhLSN7bmFtZX1cIl1cbiAgICAgIHJldHVybiBkYXRhXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciB2YWx1ZSA9ICNAbmF0aXZlLiRkYXRhW25hbWVdO1xuXG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBbXT0obmFtZSwgdmFsdWUpXG4gICAgYGRlbGV0ZSAjQG5hdGl2ZS4kZGF0YVtuYW1lXWBcbiAgICBpZiBbdHJ1ZSwgZmFsc2UsIG5pbF0uaW5jbHVkZT8odmFsdWUpXG4gICAgICBAZWxlbWVudFtcImRhdGEtI3tuYW1lfVwiXSA9IHZhbHVlXG4gICAgZWxzaWYgdmFsdWUucmVzcG9uZF90bz8gOnRvX3N0clxuICAgICAgQGVsZW1lbnRbXCJkYXRhLSN7bmFtZX1cIl0gPSB2YWx1ZS50b19zdHJcbiAgICBlbHNpZiB2YWx1ZS5yZXNwb25kX3RvPyA6dG9faW50XG4gICAgICBAZWxlbWVudFtcImRhdGEtI3tuYW1lfVwiXSA9IHZhbHVlLnRvX2ludC50b19zXG4gICAgZWxzZVxuICAgICAgYCNAbmF0aXZlLiRkYXRhW25hbWVdID0gdmFsdWVgXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBkZWxldGUobmFtZSlcbiAgICBkYXRhID0gc2VsZltuYW1lXVxuICAgIHNlbGZbbmFtZV0gPSBuaWxcbiAgICBkYXRhXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxtb2R1bGU6RE9NPiIsIjxjbGFzczpFbGVtZW50PiIsIjxjbGFzczpEYXRhPiIsInNlbGYiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJlbGVtZW50IiwiQGVsZW1lbnQiLCJAbmF0aXZlIiwidG9fbiIsImluY2x1ZGUiLCJFbnVtZXJhYmxlIiwiZWFjaCIsImJsb2NrIiwiZW51bV9mb3IiLCJjYWxsIiwiYXR0cmlidXRlcyIsImJsb2NrIGluIGVhY2giLCJuYW1lIiwidmFsdWUiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2giLCI9fiIsImFzc2lnbiIsImRhdGEiLCJibG9jayBpbiBhc3NpZ24iLCJibG9jayAoMiBsZXZlbHMpIGluIGFzc2lnbiIsIltdPSIsIltdIiwiaW5jbHVkZT8iLCJyZXNwb25kX3RvPyIsInRvX3N0ciIsInRvX2ludCIsInRvX3MiLCJkZWxldGUiLCJOb2RlIl0sIm1hcHBpbmdzIjoiQUFBQUEsMkNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUFZQSxPQUFBQztNQUFBQTs7UUFBQUE7O1FBRTVCQSxPQUFBQztRQUFBQTs7VUFBQUE7O0FBQUFBOztVQUNFQyxJQUFBQyxhQUFBQSxDQUFZLFNBQVpBOztBQUVBQyxVQUFBQSwwQkFBQUEsc0JBQWVDLE9BQWZEO0FBQUFBLFlBQUFBOzs7WUFDRUUsZUFBV0Q7WUFDWEUsaUJBQVdGLE9BQU9HLE1BQUFBLENBQUFBO1lBRWxCLElBQUEsUUFBTyxRQUFXRCxjQUFPSCxNQUFsQixrQkFBUCxDQUFBO2NBVEpBLE9BQUE7WUFTSTtjQUNFQSxPQUFFRyxjQUFPSDtZQURYO1VBSkZBLENBQUFBO1VBU0FGLElBQUFPLFNBQUFBLENBQVFDLGdCQUFSRDs7QUFFQUUsVUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxZQUFBQTs7WUFBQUE7OztZQUNFLEtBQUEsUUFBNkJDLEtBQTdCLENBQUE7Y0FBQSxPQUFPVixJQUFBVyxVQUFBQSxDQUFTLE1BQVRBO1lBQVA7O0FBR0pGLGlCQUFrQkosY0FBT0k7O0FBRXpCQTtBQUNBQSxRQUFVQyxLQUFLRSxNQUFBQSxDQUFPSCxHQUFaLEVBQW1CQSxTQUFkRyxDQUF5Qkg7QUFDeENBO0FBQ0FBO1lBRXVCQSxNQUFuQkwsWUFBUVMsWUFBQUEsQ0FBQUEsQ0FBV0osUUFBQUEsRUFBQUEsRUFBQUEsRUFBbkJLLGFBQTJCQyxJQUFELEVBQU9DLEtBQWpDRixFQUFBRzs7O2NBQTJCO2NBQU07Y0FDL0IsSUFBQSxRQUFHRixJQUFLRyxPQUFBQSxDQUFHLGFBQUhBLENBQVIsQ0FBQTtnQkFDRUQsT0FBQVAsS0FBS0UsTUFBQUEsQ0FBTSxpREFBWCxFQUFlSSxLQUFWSjtjQURQO2dCQTVCTkssT0FBQTtjQTRCTSxFQURGSCxDQUFtQkw7WUFNbkJBLE9BQUFUO1VBakJGUyxDQUFBQTs7QUFvQkFVLFVBQUFBLHNCQUFBQSxrQkFBV0MsSUFBWEQ7QUFBQUEsWUFBQUE7OztZQUNNVixNQUFKVyxJQUFJWCxRQUFBQSxFQUFBQSxFQUFBQSxFQUFKWSxhQUFZTixJQUFELEVBQU9DLEtBQWxCSyxFQUFBQzs7O2NBQVk7Y0FBTTtjQUNoQkEsT0FBSUMsTUFBQUEsQ0FBQ1IsSUFBTCxFQUFhQyxLQUFUTyxDQUFBQSxFQUFBQSxNQUFKdkIsSUFBSXVCLE9BQUFBLEVBQUFBLEVBQUFBLENBQUFBLEVBQUFBLG1CQURORixDQUFBQSxHQUFBQSxTQUFBQSxDQUFJWjtZQUlKVSxPQUFBbkI7VUFMRm1CLENBQUFBOztBQVFBSyxVQUFBQSxrQkFBQUEsb0JBQU9ULElBQVBTO0FBQUFBLFlBQUFBOzs7WUFDRSxJQUFBLFFBQUdKLENBQUFBLE9BQU9oQixZQUFRb0IsT0FBQUEsQ0FBRUEsT0FBRCxHQUFBLENBQVFULElBQVIsQ0FBRFMsQ0FBZkosQ0FBSCxDQUFBO2NBQ0UsT0FBT0E7WUFEVDs7QUFLSkksa0JBQW1CbkIsY0FBT21COztBQUUxQkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7VUFkRUEsQ0FBQUE7O0FBaUJBRCxVQUFBQSxtQkFBQUEsdUJBQVFSLElBQUQsRUFBT0MsS0FBZE87QUFBQUEsWUFBQUE7OztZQUNHQSxPQUFRbEIsY0FBT2tCO1lBQ2hCLElBQUEsUUFBRyxDQUFDLElBQUQsRUFBTyxLQUFQLEVBQWMsR0FBZCxDQUFrQkUsYUFBQUEsQ0FBVVQsS0FBVlMsQ0FBckIsQ0FBQTtjQUNFRixPQUFRQSxNQUFBQSxDQUFFQSxPQUFELEdBQUEsQ0FBUVIsSUFBUixDQUFULEVBQTJCQyxLQUFuQk8sQ0FBQUEsRUFBQUEsTUFBUm5CLFlBQVFtQixPQUFBQSxFQUFBQSxFQUFBQSxDQUFBQSxFQUFBQTtZQURWLE9BRUEsSUFBQSxRQUFNUCxLQUFLVSxnQkFBQUEsQ0FBYSxRQUFiQSxDQUFYLENBQUE7Y0FDRUgsT0FBUUEsTUFBQUEsQ0FBRUEsT0FBRCxHQUFBLENBQVFSLElBQVIsQ0FBVCxFQUEyQkMsS0FBS1csUUFBQUEsQ0FBQUEsQ0FBeEJKLENBQUFBLEVBQUFBLE1BQVJuQixZQUFRbUIsT0FBQUEsRUFBQUEsRUFBQUEsQ0FBQUEsRUFBQUE7WUFEVixPQUVBLElBQUEsUUFBTVAsS0FBS1UsZ0JBQUFBLENBQWEsUUFBYkEsQ0FBWCxDQUFBO2NBQ0VILE9BQVFBLE1BQUFBLENBQUVBLE9BQUQsR0FBQSxDQUFRUixJQUFSLENBQVQsRUFBMkJDLEtBQUtZLFFBQUFBLENBQUFBLENBQU9DLE1BQUFBLENBQUFBLENBQS9CTixDQUFBQSxFQUFBQSxNQUFSbkIsWUFBUW1CLE9BQUFBLEVBQUFBLEVBQUFBLENBQUFBLEVBQUFBO1lBRFY7Y0FHRUEsT0FBRWxCLGNBQU9rQjtZQUhYO1VBTkZBLENBQUFBO1VBYUF4QixPQUFBK0Isc0JBQUFBLHdCQUFXZixJQUFYZTtBQUFBQSxZQUFBQTs7O1lBQ0VWLE9BQU9wQixJQUFJd0IsT0FBQUEsQ0FBQ1QsSUFBRFM7WUFDWHhCLElBQUl1QixRQUFBQSxDQUFDUixJQUFMLEVBQWEsR0FBVFE7WUFDSk8sT0FBQVY7VUFIRlUsQ0FBQUE7UUF4RUYvQixHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtNQUY0QkQsR0FBQUEsV0FBQUEsRUFBZ0JpQyxVQUFoQmpDO0lBQVpELEdBQUFBLFdBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzM3MTEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9lbGVtZW50L3Bvc2l0aW9uLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NOyBjbGFzcyBFbGVtZW50IDwgTm9kZVxuXG5jbGFzcyBQb3NpdGlvblxuICBhdHRyX3JlYWRlciA6ZWxlbWVudFxuXG4gICMgQHByaXZhdGVcbiAgZGVmIGluaXRpYWxpemUoZWxlbWVudClcbiAgICBAZWxlbWVudCA9IGVsZW1lbnRcbiAgICBAbmF0aXZlICA9IGVsZW1lbnQudG9fblxuICBlbmRcblxuICAjIEBwcml2YXRlXG4gIGRlZiBnZXRcbiAgICBvZmZzZXQgICAgICAgID0gQGVsZW1lbnQub2Zmc2V0XG4gICAgcG9zaXRpb24gICAgICA9IG9mZnNldC5nZXRcbiAgICBwYXJlbnQgICAgICAgID0gb2Zmc2V0LnBhcmVudFxuICAgIHBhcmVudF9vZmZzZXQgPSBCcm93c2VyOjpQb3NpdGlvbi5uZXcoMCwgMClcblxuICAgIGlmIEBlbGVtZW50LnN0eWxlWzpwb3NpdGlvbl0gPT0gOmZpeGVkXG4gICAgICB1bmxlc3MgcGFyZW50ID1+IDpodG1sXG4gICAgICAgIHBhcmVudF9vZmZzZXQgPSBwYXJlbnQub2Zmc2V0XG4gICAgICBlbmRcblxuICAgICAgcGFyZW50X29mZnNldC54ICs9IHBhcmVudC5zdHlsZVsnYm9yZGVyLXRvcC13aWR0aCddLnRvX2lcbiAgICAgIHBhcmVudF9vZmZzZXQueSArPSBwYXJlbnQuc3R5bGVbJ2JvcmRlci1sZWZ0LXdpZHRoJ10udG9faVxuICAgIGVuZFxuXG4gICAgQnJvd3Nlcjo6UG9zaXRpb24ubmV3KFxuICAgICAgcG9zaXRpb24ueCAtIHBhcmVudF9vZmZzZXQueCAtIEBlbGVtZW50LnN0eWxlWydtYXJnaW4tbGVmdCddLnRvX2ksXG4gICAgICBwb3NpdGlvbi55IC0gcGFyZW50X29mZnNldC55IC0gQGVsZW1lbnQuc3R5bGVbJ21hcmdpbi10b3AnXS50b19pKVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSB4XG4gICMgQHJldHVybiBbSW50ZWdlcl0gdGhlIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50IG9uIHRoZSB4IGF4aXNcbiAgZGVmIHhcbiAgICBnZXQueFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSB5XG4gICMgQHJldHVybiBbSW50ZWdlcl0gdGhlIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50IG9uIHRoZSB5IGF4aXNcbiAgZGVmIHlcbiAgICBnZXQueVxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8bW9kdWxlOkRPTT4iLCI8Y2xhc3M6RWxlbWVudD4iLCI8Y2xhc3M6UG9zaXRpb24+Iiwic2VsZiIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsImVsZW1lbnQiLCJAZWxlbWVudCIsIkBuYXRpdmUiLCJ0b19uIiwiZ2V0Iiwib2Zmc2V0IiwicG9zaXRpb24iLCJwYXJlbnQiLCJwYXJlbnRfb2Zmc2V0IiwiQnJvd3Nlcjo6UG9zaXRpb24iLCJCcm93c2VyIiwibmV3IiwiMCIsInN0eWxlIiwiW10iLCI9fiIsIng9IiwiKyIsIngiLCJ0b19pIiwieT0iLCJ5IiwiLSIsIk5vZGUiXSwibWFwcGluZ3MiOiJBQUFBQSwrQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BQVlBLE9BQUFDO01BQUFBOztRQUFBQTs7UUFFNUJBLE9BQUFDO1FBQUFBOztVQUFBQTs7QUFBQUE7O1VBQ0VDLElBQUFDLGFBQUFBLENBQVksU0FBWkE7O0FBR0FDLFVBQUFBLDBCQUFBQSxzQkFBZUMsT0FBZkQ7QUFBQUEsWUFBQUE7OztZQUNFRSxlQUFXRDtZQUNYRCxPQUFBRyxDQUFBQSxpQkFBV0YsT0FBT0csTUFBQUEsQ0FBQUEsQ0FBbEJEO1VBRkZILENBQUFBOztBQU1BSyxVQUFBQSxtQkFBQUEsZUFBQUE7QUFBQUEsWUFBQUE7OztZQUNFQyxTQUFnQkosWUFBUUksUUFBQUEsQ0FBQUE7WUFDeEJDLFdBQWdCRCxNQUFNRCxLQUFBQSxDQUFBQTtZQUN0QkcsU0FBZ0JGLE1BQU1FLFFBQUFBLENBQUFBO1lBQ3RCQyxnQkFBZ0JDLElBQUFDLGFBQUFELGFBQWlCRSxLQUFBQSxDQUFLQyxDQUF0QixFQUF5QkEsQ0FBUkQ7WUFFakMsSUFBQSxNQUFHVixZQUFRWSxPQUFBQSxDQUFBQSxDQUFNQyxPQUFBQSxDQUFDLFVBQURBLENBQWpCLEVBQWdDLE9BQWhDLENBQUE7O2NBQ0UsS0FBQSxRQUFPUCxNQUFPUSxPQUFBQSxDQUFHLE1BQUhBLENBQWQsQ0FBQTtnQkFDRVAsZ0JBQWdCRCxNQUFNRixRQUFBQSxDQUFBQTtjQUR4QjtjQUlBRyxhQUFhUSxPQUFBQSxDQUFBQyxTQUFiVCxhQUFhVSxHQUFBQSxDQUFBQSxDQUFBRCxFQUFNVixNQUFNTSxPQUFBQSxDQUFBQSxDQUFNQyxPQUFBQSxDQUFDVixrQkFBRFUsQ0FBb0JLLE1BQUFBLENBQUFBLENBQXRDRixDQUFBRDtjQUNiUixhQUFhWSxPQUFBQSxDQUFBSCxTQUFiVCxhQUFhYSxHQUFBQSxDQUFBQSxDQUFBSixFQUFNVixNQUFNTSxPQUFBQSxDQUFBQSxDQUFNQyxPQUFBQSxDQUFDVixtQkFBRFUsQ0FBcUJLLE1BQUFBLENBQUFBLENBQXZDRixDQUFBRztZQU5mO1lBU0FoQixPQUFBSyxJQUFBQyxhQUFBRCxhQUFpQkUsS0FBQUEsQ0FDY1csVUFBbEJBLFVBQVhoQixRQUFRWSxHQUFBQSxDQUFBQSxDQUFHSSxFQUFFZCxhQUFhVSxHQUFBQSxDQUFBQSxDQUFmSSxDQUFrQkEsRUFBRXJCLFlBQVFZLE9BQUFBLENBQUFBLENBQU1DLE9BQUFBLENBQUNWLGFBQURVLENBQWVLLE1BQUFBLENBQUFBLENBQS9CRyxDQUQvQixFQUUrQkEsVUFBbEJBLFVBQVhoQixRQUFRZSxHQUFBQSxDQUFBQSxDQUFHQyxFQUFFZCxhQUFhYSxHQUFBQSxDQUFBQSxDQUFmQyxDQUFrQkEsRUFBRXJCLFlBQVFZLE9BQUFBLENBQUFBLENBQU1DLE9BQUFBLENBQUNWLFlBQURVLENBQWNLLE1BQUFBLENBQUFBLENBQTlCRyxDQUZkWDtVQWZuQlAsQ0FBQUE7O0FBc0JBYyxVQUFBQSxpQkFBQUEsYUFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUFyQixJQUFBTyxLQUFBQSxDQUFBQSxDQUFHYyxHQUFBQSxDQUFBQTtVQURMQSxDQUFBQTtVQU1BdEIsT0FBQXlCLGlCQUFBQSxhQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBQXhCLElBQUFPLEtBQUFBLENBQUFBLENBQUdpQixHQUFBQSxDQUFBQTtVQURMQSxDQUFBQTtRQXRDRnpCLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO01BRjRCRCxHQUFBQSxXQUFBQSxFQUFnQjRCLFVBQWhCNUI7SUFBWkQsR0FBQUEsV0FBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMzc4MiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZG9tL2VsZW1lbnQvb2Zmc2V0LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NOyBjbGFzcyBFbGVtZW50IDwgTm9kZVxuXG5jbGFzcyBPZmZzZXRcbiAgYXR0cl9yZWFkZXIgOmVsZW1lbnRcblxuICAjIEBwcml2YXRlXG4gIGRlZiBpbml0aWFsaXplKGVsZW1lbnQpXG4gICAgQGVsZW1lbnQgPSBlbGVtZW50XG4gICAgQG5hdGl2ZSAgPSBlbGVtZW50LnRvX25cbiAgZW5kXG5cbiAgZGVmIHBhcmVudFxuICAgIERPTShgI0BuYXRpdmUub2Zmc2V0UGFyZW50IHx8ICN7QGVsZW1lbnQuZG9jdW1lbnQucm9vdC50b19ufWApXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgeFxuICAjIEByZXR1cm4gW0ludGVnZXJdXG4gIGRlZiB4XG4gICAgZ2V0LnhcbiAgZW5kXG5cbiAgZGVmIHg9KHZhbHVlKVxuICAgIHNldCB2YWx1ZSwgbmlsXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgeVxuICAjIEByZXR1cm4gW0ludGVnZXJdXG4gIGRlZiB5XG4gICAgZ2V0LnlcbiAgZW5kXG5cbiAgZGVmIHk9KHZhbHVlKVxuICAgIHNldCBuaWwsIHZhbHVlXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCdcbiAgICBkZWYgZ2V0XG4gICAgICBkb2MgID0gQGVsZW1lbnQuZG9jdW1lbnRcbiAgICAgIHJvb3QgPSBkb2Mucm9vdC50b19uXG4gICAgICB3aW4gID0gZG9jLndpbmRvdy50b19uXG5cbiAgICAgICV4e1xuICAgICAgICB2YXIgYm94ID0gI0BuYXRpdmUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICB5ICAgPSBib3gudG9wICsgKCN7d2lufS5wYWdlWU9mZnNldCB8fCAje3Jvb3R9LnNjcm9sbFRvcCkgLSAoI3tyb290fS5jbGllbnRUb3AgfHwgMCksXG4gICAgICAgICAgICB4ICAgPSBib3gubGVmdCArICgje3dpbn0ucGFnZVhPZmZzZXQgfHwgI3tyb290fS5zY3JvbGxMZWZ0KSAtICgje3Jvb3R9LmNsaWVudExlZnQgfHwgMCk7XG4gICAgICB9XG5cbiAgICAgIEJyb3dzZXI6OlBvc2l0aW9uLm5ldyhgeGAsIGB5YClcbiAgICBlbmRcbiAgZWxzZVxuICAgIGRlZiBnZXRcbiAgICAgIGRvYyAgPSBkb2N1bWVudFxuICAgICAgcm9vdCA9IGRvYy5yb290LnRvX25cbiAgICAgIHdpbiAgPSBkb2Mud2luZG93LnRvX25cblxuICAgICAgJXh7XG4gICAgICAgIHZhciB5ID0gKCN7d2lufS5wYWdlWU9mZnNldCB8fCAje3Jvb3R9LnNjcm9sbFRvcCkgLSAoI3tyb290fS5jbGllbnRUb3AgfHwgMCksXG4gICAgICAgICAgICB4ID0gKCN7d2lufS5wYWdlWE9mZnNldCB8fCAje3Jvb3R9LnNjcm9sbExlZnQpIC0gKCN7cm9vdH0uY2xpZW50TGVmdCB8fCAwKTtcbiAgICAgIH1cblxuICAgICAgQnJvd3Nlcjo6UG9zaXRpb24ubmV3KGB4YCwgYHlgKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2V0KCp2YWx1ZSlcbiAgICBwb3NpdGlvbiA9IEBlbGVtZW50LnN0eWxlIVs6cG9zaXRpb25dXG5cbiAgICBpZiBwb3NpdGlvbiA9PSA6c3RhdGljXG4gICAgICBAZWxlbWVudC5zdHlsZVs6cG9zaXRpb25dID0gOnJlbGF0aXZlXG4gICAgZW5kXG5cbiAgICBvZmZzZXQgPSBnZXRcbiAgICB0b3AgICAgPSBAZWxlbWVudC5zdHlsZSFbOnRvcF0udG9fdVxuICAgIGxlZnQgICA9IEBlbGVtZW50LnN0eWxlIVs6bGVmdF0udG9fdVxuXG4gICAgaWYgQnJvd3Nlcjo6UG9zaXRpb24gPT09IHZhbHVlLmZpcnN0XG4gICAgICB4LCB5ID0gdmFsdWUuZmlyc3QueCwgdmFsdWUuZmlyc3QueVxuICAgIGVsc2lmIEhhc2ggPT09IHZhbHVlLmZpcnN0XG4gICAgICB4LCB5ID0gdmFsdWUuZmlyc3RbOnhdLCB2YWx1ZS5maXJzdFs6eV1cbiAgICBlbHNlXG4gICAgICB4LCB5ID0gdmFsdWVcbiAgICBlbmRcblxuICAgIEBlbGVtZW50LnN0eWxlWzpsZWZ0XSA9ICh4LnB4IC0gb2Zmc2V0LngpICsgbGVmdCBpZiB4XG4gICAgQGVsZW1lbnQuc3R5bGVbOnRvcF0gID0gKHkucHggLSBvZmZzZXQueSkgKyB0b3AgIGlmIHlcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPG1vZHVsZTpET00+IiwiPGNsYXNzOkVsZW1lbnQ+IiwiPGNsYXNzOk9mZnNldD4iLCJzZWxmIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiZWxlbWVudCIsIkBlbGVtZW50IiwiQG5hdGl2ZSIsInRvX24iLCJwYXJlbnQiLCJET00iLCJkb2N1bWVudCIsInJvb3QiLCJ4IiwiZ2V0IiwieD0iLCJ2YWx1ZSIsInNldCIsInkiLCJ5PSIsIkJyb3dzZXIiLCJzdXBwb3J0cz8iLCJkb2MiLCJ3aW4iLCJ3aW5kb3ciLCJCcm93c2VyOjpQb3NpdGlvbiIsIm5ldyIsInBvc2l0aW9uIiwic3R5bGUhIiwiW10iLCJzdHlsZSIsIltdPSIsIm9mZnNldCIsInRvcCIsInRvX3UiLCJsZWZ0IiwiZmlyc3QiLCJIYXNoIiwiKyIsIi0iLCJweCIsIk5vZGUiXSwibWFwcGluZ3MiOiJBQUFBQSw2Q0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BQVlBLE9BQUFDO01BQUFBOztRQUFBQTs7UUFFNUJBLE9BQUFDO1FBQUFBOztVQUFBQTs7QUFBQUE7O1VBQ0VDLElBQUFDLGFBQUFBLENBQVksU0FBWkE7O0FBR0FDLFVBQUFBLDBCQUFBQSxzQkFBZUMsT0FBZkQ7QUFBQUEsWUFBQUE7OztZQUNFRSxlQUFXRDtZQUNYRCxPQUFBRyxDQUFBQSxpQkFBV0YsT0FBT0csTUFBQUEsQ0FBQUEsQ0FBbEJEO1VBRkZILENBQUFBOztBQUtBSyxVQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFBUCxJQUFBUSxLQUFBQSxDQUFNSCxjQUFPRSxpQkFBbUJILFlBQVFLLFVBQUFBLENBQUFBLENBQVNDLE1BQUFBLENBQUFBLENBQUtKLE1BQUFBLENBQUFBLENBQXRERTtVQURGRCxDQUFBQTs7QUFNQUksVUFBQUEsaUJBQUFBLGFBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFBWCxJQUFBWSxLQUFBQSxDQUFBQSxDQUFHRCxHQUFBQSxDQUFBQTtVQURMQSxDQUFBQTs7QUFJQUUsVUFBQUEsa0JBQUFBLHdCQUFPQyxLQUFQRDtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBQWIsSUFBQWUsS0FBQUEsQ0FBSUQsS0FBSixFQUFXLEdBQVhDO1VBREZGLENBQUFBOztBQU1BRyxVQUFBQSxpQkFBQUEsYUFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUFoQixJQUFBWSxLQUFBQSxDQUFBQSxDQUFHSSxHQUFBQSxDQUFBQTtVQURMQSxDQUFBQTs7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LENBQUFBLElBQUEsNkJBQUFBLENBQUEsRUFBR0ssQ0FBQUEsSUFBSCw2QkFBR0EsQ0FBSDtZQUhGO1lBTUEsSUFBQSxRQUFvREwsQ0FBcEQsQ0FBQTtjQUFBUCxZQUFRd0IsT0FBQUEsQ0FBQUEsQ0FBTUMsUUFBQUEsQ0FBQyxNQUFmLEVBQTBDTyxTQUFaQyxVQUFMMUIsQ0FBQzJCLElBQUFBLENBQUFBLENBQUlELEVBQUVQLE1BQU1uQixHQUFBQSxDQUFBQSxDQUFSMEIsQ0FBWUQsRUFBRUgsSUFBRkcsQ0FBNUJQO1lBQWQ7WUFDQSxJQUFBLFFBQW9EYixDQUFwRCxDQUFBO2NBQUFELE9BQWNjLE1BQUFBLENBQUMsS0FBZixFQUEwQ08sU0FBWkMsVUFBTHJCLENBQUNzQixJQUFBQSxDQUFBQSxDQUFJRCxFQUFFUCxNQUFNZCxHQUFBQSxDQUFBQSxDQUFScUIsQ0FBWUQsRUFBRUwsR0FBRkssQ0FBNUJQLENBQUFBLEVBQUFBLE1BQWR6QixZQUFRd0IsT0FBQUEsQ0FBQUEsQ0FBTUMsT0FBQUEsRUFBQUEsRUFBQUEsQ0FBQUEsRUFBQUE7WUFBZDtjQXBGSmQsT0FBQTtZQW9GSTtVQXBCRkEsQ0FBQUEsSUFBQUE7UUE5REZoQixHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtNQUY0QkQsR0FBQUEsV0FBQUEsRUFBZ0J5QyxVQUFoQnpDO0lBQVpELEdBQUFBLFdBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzM5MTQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9lbGVtZW50L3Njcm9sbC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgbW9kdWxlIERPTTsgY2xhc3MgRWxlbWVudCA8IE5vZGVcblxuIyBAdG9kbyBDb25zaWRlciB1c2luZyB0aGUgbmV3IGludGVyZmFjZXMgd2hpY2ggYWxsb3cgZm9yIG9wdGlvbmFsXG4jICAgICAgIHNtb290aCB0cmFuc2l0aW9ucy5cbmNsYXNzIFNjcm9sbFxuICBhdHRyX3JlYWRlciA6ZWxlbWVudFxuXG4gICMgQHByaXZhdGVcbiAgZGVmIGluaXRpYWxpemUoZWxlbWVudClcbiAgICBAZWxlbWVudCA9IGVsZW1lbnRcbiAgICBAbmF0aXZlICA9IGVsZW1lbnQudG9fblxuXG4gICAgIyBQb3J0YWJsZSBzdXBwb3J0IGZvciBXaW5kb3cjc2Nyb2xsIGFuZCBEb2N1bWVudCNzY3JvbGxcbiAgICBAc2Nyb2xsaW5nX25hdGl2ZSA9IEBuYXRpdmVcbiAgICBpZiBbRG9jdW1lbnQsIFdpbmRvd10uaW5jbHVkZT8oQGVsZW1lbnQuY2xhc3MpXG4gICAgICAjIElmIHdlIGFyZSBhIHdpbmRvdywgbGV0J3MgYmVjb21lIGEgZG9jdW1lbnQgZmlyc3QuXG4gICAgICBpZiBkZWZpbmVkPyBgI0BzY3JvbGxpbmdfbmF0aXZlLmRvY3VtZW50YFxuICAgICAgICBAc2Nyb2xsaW5nX25hdGl2ZSA9IGAjQHNjcm9sbGluZ19uYXRpdmUuZG9jdW1lbnRgXG4gICAgICBlbmRcbiAgICAgICMgVGhlcmUgd2VyZSBzbGlnaHQgZGlzYWdyZWVtZW50cyBpbiB0aGUgcGFzdCB3aGljaCBlbGVtZW50XG4gICAgICAjIHNob3VsZCB3ZSBoYW5kbGUuXG4gICAgICBpZiBkZWZpbmVkPyBgI0BzY3JvbGxpbmdfbmF0aXZlLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3BgXG4gICAgICAgIEBzY3JvbGxpbmdfbmF0aXZlID0gYCNAc2Nyb2xsaW5nX25hdGl2ZS5kb2N1bWVudEVsZW1lbnRgXG4gICAgICBlbHNpZiBkZWZpbmVkPyBgI0BzY3JvbGxpbmdfbmF0aXZlLmJvZHkuc2Nyb2xsVG9wYFxuICAgICAgICBAc2Nyb2xsaW5nX25hdGl2ZSA9IGAjQHNjcm9sbGluZ19uYXRpdmUuYm9keWBcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcblxuICAjIEBvdmVybG9hZCB0byh4LCB5KVxuICAjXG4gICMgICBTY3JvbGwgdG8gdGhlIGdpdmVuIHggYW5kIHkuXG4gICNcbiAgIyAgIEBwYXJhbSB4IFtJbnRlZ2VyXSBzY3JvbGwgdG8geCBvbiB0aGUgeCBheGlzXG4gICMgICBAcGFyYW0geSBbSW50ZWdlcl0gc2Nyb2xsIHRvIHkgb24gdGhlIHkgYXhpc1xuICAjXG4gICMgQG92ZXJsb2FkIHRvKGhhc2gpXG4gICNcbiAgIyAgIFNjcm9sbCB0byB0aGUgZ2l2ZW4geCBhbmQgeS5cbiAgI1xuICAjICAgQHBhcmFtIGhhc2ggW0hhc2hdIHRoZSBkZXNjcmlwdG9yXG4gICNcbiAgIyAgIEBvcHRpb24gaGFzaCBbSW50ZWdlcl0gOnggc2Nyb2xsIHRvIHggb24gdGhlIHggYXhpc1xuICAjICAgQG9wdGlvbiBoYXNoIFtJbnRlZ2VyXSA6eSBzY3JvbGwgdG8geSBvbiB0aGUgeSBheGlzXG4gICNcbiAgIyBAb3ZlcmxvYWQgdG8oc3ltYm9sKVxuICAjXG4gICMgICBTY3JvbGwgdG8gOnRvcCBvciB0byA6Ym90dG9tXG4gICNcbiAgIyAgIEBwYXJhbSBzeW1ib2wgW1N5bWJvbF0gZWl0aGVyIDp0b3Agb3IgOmJvdHRvbVxuICBkZWYgdG8oKmFyZ3MpXG4gICAgeCwgeSA9IG5pbCwgbmlsXG4gICAgY2FzZSBhcmdzLmZpcnN0XG4gICAgd2hlbiBIYXNoXG4gICAgICB4ID0gYXJncy5maXJzdFs6eF1cbiAgICAgIHkgPSBhcmdzLmZpcnN0Wzp5XVxuICAgIHdoZW4gOnRvcFxuICAgICAgeSA9IDBcbiAgICB3aGVuIDpib3R0b21cbiAgICAgIHkgPSA5OTk5OTk5OVxuICAgIGVsc2VcbiAgICAgIHgsIHkgPSBhcmdzXG4gICAgZW5kXG5cbiAgICBzZXQoeCwgeSkgaWYgeCB8fCB5XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gICMgQG92ZXJsb2FkIGJ5KHgsIHkpXG4gICNcbiAgIyAgIFNjcm9sbCBieSB0aGUgZ2l2ZW4geCBhbmQgeS5cbiAgI1xuICAjICAgQHBhcmFtIHggW0ludGVnZXJdIHNjcm9sbCBieSB4IG9uIHRoZSB4IGF4aXNcbiAgIyAgIEBwYXJhbSB5IFtJbnRlZ2VyXSBzY3JvbGwgYnkgeSBvbiB0aGUgeSBheGlzXG4gICNcbiAgIyBAb3ZlcmxvYWQgYnkoaGFzaClcbiAgI1xuICAjICAgU2Nyb2xsIGJ5IHRoZSBnaXZlbiB4IGFuZCB5LlxuICAjXG4gICMgICBAcGFyYW0gaGFzaCBbSGFzaF0gdGhlIGRlc2NyaXB0b3JcbiAgI1xuICAjICAgQG9wdGlvbiBoYXNoIFtJbnRlZ2VyXSA6eCBzY3JvbGwgYnkgeCBvbiB0aGUgeCBheGlzXG4gICMgICBAb3B0aW9uIGhhc2ggW0ludGVnZXJdIDp5IHNjcm9sbCBieSB5IG9uIHRoZSB5IGF4aXNcbiAgZGVmIGJ5KCphcmdzKVxuICAgIGNhc2UgYXJncy5maXJzdFxuICAgIHdoZW4gSGFzaFxuICAgICAgeCA9IGFyZ3MuZmlyc3RbOnhdIHx8IDBcbiAgICAgIHkgPSBhcmdzLmZpcnN0Wzp5XSB8fCAwXG4gICAgZWxzZVxuICAgICAgeCwgeSA9IGFyZ3NcbiAgICBlbmRcblxuICAgIHNldF9ieSh4LCB5KVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRWxlbWVudC5zY3JvbGxCeSdcbiAgICBwcml2YXRlIGRlZiBzZXRfYnkoeCwgeSlcbiAgICAgIGAjQHNjcm9sbGluZ19uYXRpdmUuc2Nyb2xsQnkoI3t4fSwgI3t5fSlgXG4gICAgZW5kXG4gIGVsc2VcbiAgICBwcml2YXRlIGRlZiBzZXRfYnkoeCwgeSlcbiAgICAgIHNldChzZWxmLnggKyB4LCBzZWxmLnkgKyB5KVxuICAgIGVuZFxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRWxlbWVudC5zY3JvbGwnXG4gICAgcHJpdmF0ZSBkZWYgc2V0KHg9bmlsLCB5PW5pbClcbiAgICAgIGAjQHNjcm9sbGluZ19uYXRpdmUuc2Nyb2xsVG9wICA9ICN7eX1gIGlmIHlcbiAgICAgIGAjQHNjcm9sbGluZ19uYXRpdmUuc2Nyb2xsTGVmdCA9ICN7eH1gIGlmIHhcbiAgICBlbmRcblxuICAgIGRlZiBwb3NpdGlvblxuICAgICAgQnJvd3Nlcjo6UG9zaXRpb24ubmV3KGAjQHNjcm9sbGluZ19uYXRpdmUuc2Nyb2xsTGVmdGAsIGAjQHNjcm9sbGluZ19uYXRpdmUuc2Nyb2xsVG9wYClcbiAgICBlbmRcbiAgZWxzZVxuICAgIHByaXZhdGUgZGVmIHNldCh4PW5pbCwgeT1uaWwpXG4gICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCAnc2Nyb2xsIG9uIGVsZW1lbnQgdW5zdXBwb3J0ZWQnXG4gICAgZW5kXG5cbiAgICBkZWYgcG9zaXRpb25cbiAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsICdzY3JvbGwgb24gZWxlbWVudCB1bnN1cHBvcnRlZCdcbiAgICBlbmRcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0geFxuICAjIEByZXR1cm4gW0ludGVnZXJdIHRoZSBzY3JvbGwgcG9zaXRpb24gb24gdGhlIHggYXhpc1xuICBkZWYgeFxuICAgIHBvc2l0aW9uLnhcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0geVxuICAjIEByZXR1cm4gW0ludGVnZXJdIHRoZSBzY3JvbGwgcG9zaXRpb24gb24gdGhlIHkgYXhpc1xuICBkZWYgeVxuICAgIHBvc2l0aW9uLnlcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gaGVpZ2h0XG4gICMgQHJldHVybiBbSW50ZWdlcl0gdGhlIGhlaWdodCBvZiB0aGUgc2Nyb2xsXG4gIGRlZiBoZWlnaHRcbiAgICBgI0BzY3JvbGxpbmdfbmF0aXZlLnNjcm9sbEhlaWdodGBcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gd2lkdGhcbiAgIyBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgd2lkdGggb2YgdGhlIHNjcm9sbFxuICBkZWYgd2lkdGhcbiAgICBgI0BzY3JvbGxpbmdfbmF0aXZlLnNjcm9sbFdpZHRoYFxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRWxlbWVudC5zY3JvbGxJbnRvVmlld0lmTmVlZGVkJ1xuICAgIGRlZiBpbnRvX3ZpZXcoYWxpZ24gPSB0cnVlKVxuICAgICAgYCNAc2Nyb2xsaW5nX25hdGl2ZS5zY3JvbGxJbnRvVmlld0lmTmVlZGVkKGFsaWduKWBcbiAgICBlbmRcbiAgZWxzZVxuICAgICMgTm9uLXN0YW5kYXJkLiBOb3Qgc3VwcG9ydGVkIGJ5IG1vZGVybiBGaXJlZm94LiBVc2UgeyNpbnRvX3ZpZXchfVxuICAgIGRlZiBpbnRvX3ZpZXcoYWxpZ24gPSB0cnVlKVxuICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaW50b192aWV3IShhbGlnbiA9IHRydWUpXG4gICAgYCNAc2Nyb2xsaW5nX25hdGl2ZS5zY3JvbGxJbnRvVmlldyhhbGlnbilgXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxtb2R1bGU6RE9NPiIsIjxjbGFzczpFbGVtZW50PiIsIjxjbGFzczpTY3JvbGw+Iiwic2VsZiIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsImVsZW1lbnQiLCJAZWxlbWVudCIsIkBuYXRpdmUiLCJ0b19uIiwiQHNjcm9sbGluZ19uYXRpdmUiLCJEb2N1bWVudCIsIldpbmRvdyIsImluY2x1ZGU/IiwiY2xhc3MiLCJ0byIsIngiLCJ5IiwiSGFzaCIsIiRyZXRfb3JfMSIsImFyZ3MiLCJmaXJzdCIsIltdIiwiMCIsIjk5OTk5OTk5Iiwic2V0IiwiYnkiLCIkcmV0X29yXzIiLCJzZXRfYnkiLCJCcm93c2VyIiwic3VwcG9ydHM/IiwicHJpdmF0ZSIsIisiLCJwb3NpdGlvbiIsIkJyb3dzZXI6OlBvc2l0aW9uIiwibmV3IiwicmFpc2UiLCJOb3RJbXBsZW1lbnRlZEVycm9yIiwiaGVpZ2h0Iiwid2lkdGgiLCJpbnRvX3ZpZXciLCJhbGlnbiIsImludG9fdmlldyEiLCJOb2RlIl0sIm1hcHBpbmdzIjoiQUFBQUEsNkNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7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UTtjQUNwQkEsT0FBQXJDLElBQUFpQyxPQUFBQSxDQUFNQyx5QkFBTkQ7WUFERkksQ0FBQUEsSUFBQUE7VUFORjtVQVdBdEMsT0FBQXdDLDBCQUFBQSxrQ0FBZUQsS0FBZkM7QUFBQUEsWUFBQUE7OztZQUFlLDJCQUFRO1lBQ3JCQSxPQUFFaEMscUJBQWlCZ0M7VUFEckJBLENBQUFBLElBQUFBO1FBOUpGeEMsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7TUFKNEJELEdBQUFBLFdBQUFBLEVBQWdCMEMsVUFBaEIxQztJQUFaRCxHQUFBQSxXQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM0MTE1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9kb20vZWxlbWVudC9zaXplLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NOyBjbGFzcyBFbGVtZW50IDwgTm9kZVxuXG5jbGFzcyBTaXplXG4gIGF0dHJfcmVhZGVyIDplbGVtZW50XG5cbiAgIyBAcHJpdmF0ZVxuICBkZWYgaW5pdGlhbGl6ZShlbGVtZW50LCAqaW5jKVxuICAgIEBlbGVtZW50ID0gZWxlbWVudFxuICAgIEBuYXRpdmUgID0gZWxlbWVudC50b19uXG4gICAgQGluY2x1ZGUgPSBpbmNcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSB3aWR0aFxuICAjIEByZXR1cm4gW0ludGVnZXJdIHRoZSBlbGVtZW50IHdpZHRoXG4gIGRlZiB3aWR0aFxuICAgIGAjQG5hdGl2ZS5vZmZzZXRXaWR0aGBcbiAgZW5kXG5cbiAgZGVmIHdpZHRoPSh2YWx1ZSlcbiAgICBAZWxlbWVudC5zdHlsZVs6d2lkdGhdID0gdmFsdWVcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBoZWlnaHRcbiAgIyBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgZWxlbWVudCBoZWlnaHRcbiAgZGVmIGhlaWdodFxuICAgIGAjQG5hdGl2ZS5vZmZzZXRIZWlnaHRgXG4gIGVuZFxuXG4gIGRlZiBoZWlnaHQ9KHZhbHVlKVxuICAgIEBlbGVtZW50LnN0eWxlWzpoZWlnaHRdID0gdmFsdWVcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBjbGllbnRfd2lkdGhcbiAgIyBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgY29udGVudC1ib3ggd2lkdGggb2YgYW4gZWxlbWVudFxuICBkZWYgY2xpZW50X3dpZHRoXG4gICAgYCNAbmF0aXZlLmNsaWVudFdpZHRoYFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIGNsaWVudF9oZWlnaHRcbiAgIyBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgY29udGVudC1ib3ggaGVpZ2h0IG9mIGFuIGVsZW1lbnRcbiAgZGVmIGNsaWVudF9oZWlnaHRcbiAgICBgI0BuYXRpdmUuY2xpZW50SGVpZ2h0YFxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8bW9kdWxlOkRPTT4iLCI8Y2xhc3M6RWxlbWVudD4iLCI8Y2xhc3M6U2l6ZT4iLCJzZWxmIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiZWxlbWVudCIsIkBlbGVtZW50IiwiQG5hdGl2ZSIsInRvX24iLCJAaW5jbHVkZSIsImluYyIsIndpZHRoIiwid2lkdGg9IiwidmFsdWUiLCJbXT0iLCJzdHlsZSIsImhlaWdodCIsImhlaWdodD0iLCJjbGllbnRfd2lkdGgiLCJjbGllbnRfaGVpZ2h0IiwiTm9kZSJdLCJtYXBwaW5ncyI6IkFBQUFBLDJDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFBWUEsT0FBQUM7TUFBQUE7O1FBQUFBOztRQUU1QkEsT0FBQUM7UUFBQUE7O1VBQUFBOztBQUFBQTs7VUFDRUMsSUFBQUMsYUFBQUEsQ0FBWSxTQUFaQTs7QUFHQUMsVUFBQUEsMEJBQUFBLHNCQUFlQyxPQUFELEVBTmhCLEVBTUVEO0FBQUFBLFlBQUFBOzs7WUFORjtZQU0wQjtZQUN0QkUsZUFBV0Q7WUFDWEUsaUJBQVdGLE9BQU9HLE1BQUFBLENBQUFBO1lBQ2xCSixPQUFBSyxDQUFBQSxlQUFXQyxHQUFYRDtVQUhGTCxDQUFBQSxJQUFBQTs7QUFRQU8sVUFBQUEscUJBQUFBLGlCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUosY0FBT0k7VUFEWEEsQ0FBQUE7O0FBSUFDLFVBQUFBLHNCQUFBQSwwQkFBV0MsS0FBWEQ7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQWNFLE1BQUFBLENBQUMsT0FBZixFQUF5QkQsS0FBWEMsQ0FBQUEsRUFBQUEsTUFBZFIsWUFBUVMsT0FBQUEsQ0FBQUEsQ0FBTUQsT0FBQUEsRUFBQUEsRUFBQUEsQ0FBQUEsRUFBQUE7VUFEaEJGLENBQUFBOztBQU1BSSxVQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFVCxjQUFPUztVQURYQSxDQUFBQTs7QUFJQUMsVUFBQUEsdUJBQUFBLDJCQUFZSixLQUFaSTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBY0gsTUFBQUEsQ0FBQyxRQUFmLEVBQTBCRCxLQUFaQyxDQUFBQSxFQUFBQSxNQUFkUixZQUFRUyxPQUFBQSxDQUFBQSxDQUFNRCxPQUFBQSxFQUFBQSxFQUFBQSxDQUFBQSxFQUFBQTtVQURoQkcsQ0FBQUE7O0FBTUFDLFVBQUFBLDRCQUFBQSx3QkFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVYLGNBQU9XO1VBRFhBLENBQUFBO1VBTUFqQixPQUFBa0IsNkJBQUFBLHlCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRVosY0FBT1k7VUFEWEEsQ0FBQUE7UUF0Q0ZsQixHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtNQUY0QkQsR0FBQUEsV0FBQUEsRUFBZ0JvQixVQUFoQnBCO0lBQVpELEdBQUFBLFdBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzQxOTQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9lbGVtZW50L2J1dHRvbi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgbW9kdWxlIERPTTsgY2xhc3MgRWxlbWVudCA8IE5vZGVcblxuY2xhc3MgQnV0dG9uIDwgRWxlbWVudFxuICBkZWZfc2VsZWN0b3IgXCJidXR0b25cIlxuXG4gIGRlZiBkaXNhYmxlZD9cbiAgICBgI0BuYXRpdmUuZGlzYWJsZWRgXG4gIGVuZFxuXG4gIGRlZiBkaXNhYmxlZD0odmFsdWUpXG4gICAgYCNAbmF0aXZlLmRpc2FibGVkID0gI3t2YWx1ZX1gXG4gIGVuZFxuXG4gIGRlZiBhdXRvZm9jdXM/XG4gICAgYCNAbmF0aXZlLmF1dG9mb2N1c2BcbiAgZW5kXG5cbiAgZGVmIGF1dG9mb2N1cz0odmFsdWUpXG4gICAgYCNAbmF0aXZlLmF1dG9mb2N1cyA9ICN7dmFsdWV9YFxuICBlbmRcblxuICBkZWYgbmFtZV9cbiAgICBgI0BuYXRpdmUubmFtZWBcbiAgZW5kXG5cbiAgZGVmIG5hbWVfPSh2YWx1ZSlcbiAgICBgI0BuYXRpdmUubmFtZSA9ICN7dmFsdWV9YFxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8bW9kdWxlOkRPTT4iLCI8Y2xhc3M6RWxlbWVudD4iLCI8Y2xhc3M6QnV0dG9uPiIsInNlbGYiLCJkZWZfc2VsZWN0b3IiLCJkaXNhYmxlZD8iLCJAbmF0aXZlIiwiZGlzYWJsZWQ9IiwidmFsdWUiLCJhdXRvZm9jdXM/IiwiYXV0b2ZvY3VzPSIsIm5hbWVfIiwibmFtZV89IiwiRWxlbWVudCIsIk5vZGUiXSwibWFwcGluZ3MiOiJBQUFBQSw2Q0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BQVlBLE9BQUFDO01BQUFBOztRQUFBQTs7UUFFNUJBLE9BQUFDO1FBQUFBOztVQUFBQTs7QUFBQUE7O1VBQ0VDLElBQUFDLGNBQUFBLENBQWFGLFFBQWJFOztBQUVBQyxVQUFBQSx5QkFBQUEsaUNBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFQyxjQUFPRDtVQURYQSxDQUFBQTs7QUFJQUUsVUFBQUEseUJBQUFBLCtCQUFjQyxLQUFkRDtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUQsY0FBT0MsWUFBY0M7VUFEekJELENBQUFBOztBQUlBRSxVQUFBQSwwQkFBQUEsa0NBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFSCxjQUFPRztVQURYQSxDQUFBQTs7QUFJQUMsVUFBQUEsMEJBQUFBLGdDQUFlRixLQUFmRTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUosY0FBT0ksYUFBZUY7VUFEMUJFLENBQUFBOztBQUlBQyxVQUFBQSxxQkFBQUEsaUJBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFTCxjQUFPSztVQURYQSxDQUFBQTtVQUlBVCxPQUFBVSxzQkFBQUEsNEJBQVdKLEtBQVhJO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFTixjQUFPTSxRQUFVSjtVQURyQkksQ0FBQUE7UUF2QkZWLEdBQUFBLFdBQUFBLEVBQWVXLGFBQWZYO01BRjRCRCxHQUFBQSxXQUFBQSxFQUFnQmEsVUFBaEJiO0lBQVpELEdBQUFBLFdBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzQyNjIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9lbGVtZW50L2ltYWdlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NOyBjbGFzcyBFbGVtZW50IDwgTm9kZVxuXG5jbGFzcyBJbWFnZSA8IEVsZW1lbnRcbiAgZGVmX3NlbGVjdG9yIFwiaW1nXCJcblxuICBkZWYgY29tcGxldGU/XG4gICAgYCNAbmF0aXZlLmNvbXBsZXRlYFxuICBlbmRcblxuICBkZWYgY3Jvc3M/XG4gICAgYCNAbmF0aXZlLmNyb3NzT3JpZ2luYFxuICBlbmRcblxuICBkZWYgaGVpZ2h0XG4gICAgYCNAbmF0aXZlLm5hdHVyYWxIZWlnaHRgXG4gIGVuZFxuXG4gIGRlZiB3aWR0aFxuICAgIGAjQG5hdGl2ZS5uYXR1cmFsV2lkdGhgXG4gIGVuZFxuZW5kXG5cbkltZyA9IEltYWdlXG5cbmVuZDsgZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxtb2R1bGU6RE9NPiIsIjxjbGFzczpFbGVtZW50PiIsIjxjbGFzczpJbWFnZT4iLCJzZWxmIiwiZGVmX3NlbGVjdG9yIiwiY29tcGxldGU/IiwiQG5hdGl2ZSIsImNyb3NzPyIsImhlaWdodCIsIndpZHRoIiwiRWxlbWVudCIsIkltYWdlIiwiTm9kZSJdLCJtYXBwaW5ncyI6IkFBQUFBLDRDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFBWUEsT0FBQUM7TUFBQUE7O1FBQUFBOzs7UUFFNUJDO1FBQUFBOztVQUFBQTs7QUFBQUE7O1VBQ0VDLElBQUFDLGNBQUFBLENBQWFGLEtBQWJFOztBQUVBQyxVQUFBQSx5QkFBQUEsZ0NBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFQyxjQUFPRDtVQURYQSxDQUFBQTs7QUFJQUUsVUFBQUEsc0JBQUFBLDZCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUQsY0FBT0M7VUFEWEEsQ0FBQUE7O0FBSUFDLFVBQUFBLHNCQUFBQSxrQkFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVGLGNBQU9FO1VBRFhBLENBQUFBO1VBSUFOLE9BQUFPLHFCQUFBQSxpQkFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVILGNBQU9HO1VBRFhBLENBQUFBO1FBZkZQLEdBQUFBLFdBQUFBLEVBQWNRLGFBQWRSO1FBb0JBRCxPQUFBLCtCQUFNVSxXQUFOO01BdEI0QlYsR0FBQUEsV0FBQUEsRUFBZ0JXLFVBQWhCWDtJQUFaRCxHQUFBQSxXQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM0MzIwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9kb20vZWxlbWVudC9mb3JtLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NOyBjbGFzcyBFbGVtZW50IDwgTm9kZVxuXG5jbGFzcyBGb3JtIDwgRWxlbWVudFxuICBkZWZfc2VsZWN0b3IgXCJmb3JtXCJcblxuICAjIENhcHR1cmUgdGhlIGNvbnRlbnQgb2YgdGhpcyBmb3JtIHRvIGEgbmV3IHtGb3JtRGF0YX0gb2JqZWN0LFxuICAjXG4gICMgQHJldHVybiBbRm9ybURhdGFdXG4gIGRlZiBmb3JtX2RhdGFcbiAgICBGb3JtRGF0YS5jcmVhdGUoc2VsZilcbiAgZW5kXG5cbiAgIyBSZXR1cm5zIHRydWUgaWYgZm9ybSBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gIGRlZiB2YWxpZD9cbiAgICBgI0BuYXRpdmUucmVwb3J0VmFsaWRpdHkoKWBcbiAgZW5kXG5cbiAgIyBTdWJtaXQgYSBmb3JtLiBUaGlzIHdpbGwgTk9UIGZpcmUgYSBzdWJtaXQgZXZlbnQuXG4gIGRlZiBzdWJtaXRcbiAgICBgI0BuYXRpdmUuc3VibWl0KClgXG4gIGVuZFxuXG4gICMgU3VibWl0IGEgZm9ybSwgb3B0aW9uYWxseSB3aXRoIGEgYnV0dG9uIGFyZ3VtZW50LlxuICAjIFRoaXMgd2lsbCBmaXJlIGEgc3VibWl0IGV2ZW50LlxuICBkZWYgcmVxdWVzdF9zdWJtaXQoc3VibWl0dGVyID0gbmlsKVxuICAgIGlmIHN1Ym1pdHRlclxuICAgICAgYCNAbmF0aXZlLnJlcXVlc3RTdWJtaXQoI3tzdWJtaXR0ZXIudG9fbn0pYFxuICAgIGVsc2VcbiAgICAgIGAjQG5hdGl2ZS5yZXF1ZXN0U3VibWl0KClgXG4gICAgZW5kXG4gIGVuZFxuXG4gICMgU3VibWl0IGEgZm9ybSB1c2luZyBBSkFYLlxuICBkZWYgYWpheF9zdWJtaXQoJmJsb2NrKVxuICAgIGRhdGEgPSBmb3JtX2RhdGFcbiAgICBkYXRhID0gZGF0YS50b19oIHVubGVzcyBlbmNvZGluZyA9PSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSdcbiAgICBIVFRQLnNlbmQobWV0aG9kLCB0YXJnZXQsIGZvcm1fZGF0YSwgJmJsb2NrKVxuICBlbmRcblxuICAjIFJlc2V0IGEgZm9ybS4gVGhpcyB3aWxsIGZpcmUgYSByZXNldCBldmVudC5cbiAgZGVmIHJlc2V0XG4gICAgYCNAbmF0aXZlLnJlc2V0KClgXG4gIGVuZFxuXG4gIGFsaWFzX25hdGl2ZSA6YWN0aW9uXG4gIGFsaWFzX25hdGl2ZSA6YWN0aW9uPVxuICBhbGlhc19uYXRpdmUgOm1ldGhvZFxuICBhbGlhc19uYXRpdmUgOm1ldGhvZD1cbiAgYWxpYXNfbmF0aXZlIDp0YXJnZXRcbiAgYWxpYXNfbmF0aXZlIDp0YXJnZXQ9XG4gIGFsaWFzX25hdGl2ZSA6ZW5jb2RpbmdcbiAgYWxpYXNfbmF0aXZlIDplbmNvZGluZz1cblxuICAjIFJldHVybiBhIE5vZGVTZXQgY29udGFpbmluZyBhbGwgZm9ybSBjb250cm9scyBiZWxvbmdpbmcgdG8gdGhpcyBmb3JtIGVsZW1lbnQuXG4gIGRlZiBjb250cm9sc1xuICAgIE5vZGVTZXRbTmF0aXZlOjpBcnJheS5uZXcoYCNAbmF0aXZlLmVsZW1lbnRzYCldXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxtb2R1bGU6RE9NPiIsIjxjbGFzczpFbGVtZW50PiIsIjxjbGFzczpGb3JtPiIsInNlbGYiLCJkZWZfc2VsZWN0b3IiLCJmb3JtX2RhdGEiLCJGb3JtRGF0YSIsImNyZWF0ZSIsInZhbGlkPyIsIkBuYXRpdmUiLCJzdWJtaXQiLCJyZXF1ZXN0X3N1Ym1pdCIsInN1Ym1pdHRlciIsInRvX24iLCJhamF4X3N1Ym1pdCIsImRhdGEiLCJlbmNvZGluZyIsInRvX2giLCJzZW5kIiwiSFRUUCIsIm1ldGhvZCIsInRhcmdldCIsImJsb2NrIiwidG9fcHJvYyIsInJlc2V0IiwiYWxpYXNfbmF0aXZlIiwiY29udHJvbHMiLCJOb2RlU2V0IiwiW10iLCJOYXRpdmU6OkFycmF5IiwiTmF0aXZlIiwibmV3IiwiRWxlbWVudCIsIk5vZGUiXSwibWFwcGluZ3MiOiJBQUFBQSwyQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BQVlBLE9BQUFDO01BQUFBOztRQUFBQTs7UUFFNUJBLE9BQUFDO1FBQUFBOztVQUFBQTs7QUFBQUE7O1VBQ0VDLElBQUFDLGNBQUFBLENBQWFGLE1BQWJFOztBQUtBQyxVQUFBQSx5QkFBQUEscUJBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFBQyxjQUFRQyxRQUFBQSxDQUFRSixJQUFSSTtVQURWRixDQUFBQTs7QUFLQUcsVUFBQUEsc0JBQUFBLDRCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUMsY0FBT0Q7VUFEWEEsQ0FBQUE7O0FBS0FFLFVBQUFBLHNCQUFBQSxrQkFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVELGNBQU9DO1VBRFhBLENBQUFBOztBQU1BQyxVQUFBQSw4QkFBQUEsMEJBQW1CQyxTQUFuQkQ7QUFBQUEsWUFBQUE7OztZQUFtQixtQ0FBWTtZQUM3QixJQUFBLFFBQUdDLFNBQUgsQ0FBQTtjQUNFRCxPQUFFRixjQUFPRSxlQUFpQkMsU0FBU0MsTUFBQUEsQ0FBQUEsQ0FBTUY7WUFEM0M7Y0FHRUEsT0FBRUYsY0FBT0U7WUFIWDtVQURGQSxDQUFBQSxJQUFBQTs7QUFTQUcsVUFBQUEsMkJBQUFBLHVCQUFBQTtBQUFBQSxZQUFBQTs7WUFBQUE7OztZQUNFQyxPQUFPWixJQUFBRSxXQUFBQSxDQUFBQTtZQUNQLEtBQUEsTUFBd0JGLElBQUFhLFVBQUFBLENBQUFBLENBQXhCLEVBQW9DRixxQkFBcEMsQ0FBQTtjQUFBQyxPQUFPQSxJQUFJRSxNQUFBQSxDQUFBQTtZQUFYO1lBQ0FILE9BQUlJLE1BQUpDLFVBQUlELFFBQUFBLEVBQUFBLENBQU1mLElBQUFpQixRQUFBQSxDQUFBQSxDQUFWLEVBQWtCakIsSUFBQWtCLFFBQUFBLENBQUFBLENBQWxCLEVBQTBCbEIsSUFBQUUsV0FBQUEsQ0FBQUEsQ0FBdEJhLENBQUFBLEVBQWtDSSxLQUFEQyxTQUFBQSxDQUFBQSxDQUFqQ0w7VUFITkosQ0FBQUE7O0FBT0FVLFVBQUFBLHFCQUFBQSxpQkFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVmLGNBQU9lO1VBRFhBLENBQUFBO1VBSUFyQixJQUFBc0IsY0FBQUEsQ0FBYSxRQUFiQTtVQUNBdEIsSUFBQXNCLGNBQUFBLENBQWEsU0FBYkE7VUFDQXRCLElBQUFzQixjQUFBQSxDQUFhLFFBQWJBO1VBQ0F0QixJQUFBc0IsY0FBQUEsQ0FBYSxTQUFiQTtVQUNBdEIsSUFBQXNCLGNBQUFBLENBQWEsUUFBYkE7VUFDQXRCLElBQUFzQixjQUFBQSxDQUFhLFNBQWJBO1VBQ0F0QixJQUFBc0IsY0FBQUEsQ0FBYSxVQUFiQTtVQUNBdEIsSUFBQXNCLGNBQUFBLENBQWEsV0FBYkE7VUFHQXZCLE9BQUF3Qix3QkFBQUEsb0JBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFBQyxhQUFPQyxPQUFBQSxDQUFDQyxJQUFBQyxZQUFBRCxVQUFhRSxLQUFBQSxDQUFPdEIsY0FBT2lCLFNBQWRLLENBQWRIO1VBRFRGLENBQUFBO1FBcERGeEIsR0FBQUEsV0FBQUEsRUFBYThCLGFBQWI5QjtNQUY0QkQsR0FBQUEsV0FBQUEsRUFBZ0JnQyxVQUFoQmhDO0lBQVpELEdBQUFBLFdBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzQ0MTUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9lbGVtZW50L2lucHV0LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NOyBjbGFzcyBFbGVtZW50IDwgTm9kZVxuXG5jbGFzcyBJbnB1dCA8IEVsZW1lbnRcbiAgZGVmX3NlbGVjdG9yIFwiaW5wdXRcIlxuXG4gIGRlZiB2YWx1ZVxuICAgICV4e1xuICAgICAgaWYgKCNAbmF0aXZlLnZhbHVlID09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI0BuYXRpdmUudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgdmFsdWU9KHZhbHVlKVxuICAgIGAjQG5hdGl2ZS52YWx1ZSA9ICN7dmFsdWV9YFxuICBlbmRcblxuICBkZWYgbmFtZV9cbiAgICBgI0BuYXRpdmUubmFtZWBcbiAgZW5kXG5cbiAgZGVmIHR5cGVcbiAgICBgI0BuYXRpdmUudHlwZWBcbiAgZW5kXG5cbiAgZGVmIGNoZWNrZWQ/XG4gICAgYCNAbmF0aXZlLmNoZWNrZWRgXG4gIGVuZFxuXG4gIGRlZiBjaGVjayFcbiAgICBgI0BuYXRpdmUuY2hlY2tlZCA9ICdjaGVja2VkJ2BcbiAgZW5kXG5cbiAgZGVmIHVuY2hlY2shXG4gICAgYCNAbmF0aXZlLmNoZWNrZWQgPSAnJ2BcbiAgZW5kXG5cbiAgZGVmIGVuYWJsZWQ/XG4gICAgYCNAbmF0aXZlLmVuYWJsZWRgXG4gIGVuZFxuXG4gIGRlZiBkaXNhYmxlIVxuICAgIGAjQG5hdGl2ZS5kaXNhYmxlZCA9ICdkaXNhYmxlZCdgXG4gIGVuZFxuXG4gIGRlZiBlbmFibGUhXG4gICAgYCNAbmF0aXZlLmRpc2FibGVkID0gJydgXG4gIGVuZFxuXG4gIGRlZiBjbGVhclxuICAgIGAjQG5hdGl2ZS52YWx1ZSA9ICcnYFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBmaWxlc1xuICAjIEByZXR1cm4gW0FycmF5PEZpbGU+XSBsaXN0IG9mIGZpbGVzIGF0dGFjaGVkIHRvIHRoaXMge0lucHV0fVxuICBkZWYgZmlsZXNcbiAgICBOYXRpdmU6OkFycmF5Lm5ldyhgI0BuYXRpdmUuZmlsZXNgKS5tYXAgeyB8ZnwgRmlsZS5uZXcoZi50b19uKSB9XG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxtb2R1bGU6RE9NPiIsIjxjbGFzczpFbGVtZW50PiIsIjxjbGFzczpJbnB1dD4iLCJzZWxmIiwiZGVmX3NlbGVjdG9yIiwidmFsdWUiLCJAbmF0aXZlIiwidmFsdWU9IiwibmFtZV8iLCJ0eXBlIiwiY2hlY2tlZD8iLCJjaGVjayEiLCJ1bmNoZWNrISIsImVuYWJsZWQ/IiwiZGlzYWJsZSEiLCJlbmFibGUhIiwiY2xlYXIiLCJmaWxlcyIsIm1hcCIsIk5hdGl2ZTo6QXJyYXkiLCJOYXRpdmUiLCJuZXciLCJibG9jayBpbiBmaWxlcyIsImYiLCJibG9jayAoMiBsZXZlbHMpIGluIGZpbGVzIiwiRmlsZSIsInRvX24iLCJFbGVtZW50IiwiTm9kZSJdLCJtYXBwaW5ncyI6IkFBQUFBLDRDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFBWUEsT0FBQUM7TUFBQUE7O1FBQUFBOztRQUU1QkEsT0FBQUM7UUFBQUE7O1VBQUFBOztBQUFBQTs7VUFDRUMsSUFBQUMsY0FBQUEsQ0FBYUYsT0FBYkU7O0FBRUFDLFVBQUFBLHFCQUFBQSxpQkFBQUE7QUFBQUEsWUFBQUE7OztBQUVGQSxVQUFXQyxjQUFPRDtBQUNsQkE7QUFDQUE7QUFDQUE7QUFDQUEsZUFBZ0JDLGNBQU9EO0FBQ3ZCQTtBQUNBQTtVQVJFQSxDQUFBQTs7QUFXQUUsVUFBQUEsc0JBQUFBLDJCQUFXRixLQUFYRTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUQsY0FBT0MsU0FBV0Y7VUFEdEJFLENBQUFBOztBQUlBQyxVQUFBQSxxQkFBQUEsaUJBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRixjQUFPRTtVQURYQSxDQUFBQTs7QUFJQUMsVUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUgsY0FBT0c7VUFEWEEsQ0FBQUE7O0FBSUFDLFVBQUFBLHdCQUFBQSwrQkFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVKLGNBQU9JO1VBRFhBLENBQUFBOztBQUlBQyxVQUFBQSxzQkFBQUEsNkJBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFTCxjQUFPSztVQURYQSxDQUFBQTs7QUFJQUMsVUFBQUEsd0JBQUFBLCtCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRU4sY0FBT007VUFEWEEsQ0FBQUE7O0FBSUFDLFVBQUFBLHdCQUFBQSwrQkFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVQLGNBQU9PO1VBRFhBLENBQUFBOztBQUlBQyxVQUFBQSx3QkFBQUEsK0JBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFUixjQUFPUTtVQURYQSxDQUFBQTs7QUFJQUMsVUFBQUEsdUJBQUFBLDhCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRVQsY0FBT1M7VUFEWEEsQ0FBQUE7O0FBSUFDLFVBQUFBLHFCQUFBQSxpQkFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVWLGNBQU9VO1VBRFhBLENBQUFBO1VBTUFkLE9BQUFlLHFCQUFBQSxpQkFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQW1DQyxNQUFuQ0MsSUFBQUMsWUFBQUQsVUFBYUUsS0FBQUEsQ0FBT2YsY0FBT1csTUFBZEksQ0FBc0JILE9BQUFBLEVBQUFBLEVBQUFBLEVBQW5DSSxhQUEyQ0MsQ0FBM0NEOztjQUEyQztjQUFHRSxPQUFBQyxVQUFJSixLQUFBQSxDQUFLRSxDQUFDRyxNQUFBQSxDQUFBQSxDQUFOTCxFQUFsREMsQ0FBbUNKO1VBRHJDRCxDQUFBQTtRQXhERmYsR0FBQUEsV0FBQUEsRUFBY3lCLGFBQWR6QjtNQUY0QkQsR0FBQUEsV0FBQUEsRUFBZ0IyQixVQUFoQjNCO0lBQVpELEdBQUFBLFdBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzQ1MjksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9lbGVtZW50L3NlbGVjdC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgbW9kdWxlIERPTTsgY2xhc3MgRWxlbWVudCA8IE5vZGVcblxuY2xhc3MgU2VsZWN0IDwgRWxlbWVudFxuICBkZWZfc2VsZWN0b3IgXCJzZWxlY3RcIlxuXG4gIGRlZiB2YWx1ZVxuICAgICV4e1xuICAgICAgaWYgKCNAbmF0aXZlLnZhbHVlID09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI0BuYXRpdmUudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgdmFsdWU9IHZhbHVlXG4gICAgYCNAbmF0aXZlLnZhbHVlID0gI3t2YWx1ZS50b19ufWBcbiAgZW5kXG5cbiAgZGVmIGxhYmVsc1xuICAgIE5vZGVTZXRbTmF0aXZlOjpBcnJheS5uZXcoYCNAbmF0aXZlLmxhYmVsc2ApXVxuICBlbmRcblxuICBkZWYgb3B0aW9uc1xuICAgIE5vZGVTZXRbTmF0aXZlOjpBcnJheS5uZXcoYCNAbmF0aXZlLm9wdGlvbnNgKV1cbiAgZW5kXG5cbiAgZGVmIG9wdGlvblxuICAgIERPTShgI0BuYXRpdmUub3B0aW9uc1sjQG5hdGl2ZS5zZWxlY3RlZEluZGV4XWApXG4gIGVuZFxuXG4gIGRlZiBpbmRleFxuICAgIGAjQG5hdGl2ZS5zZWxlY3RlZEluZGV4YFxuICBlbmRcblxuICBhbGlhc19uYXRpdmUgOm11bHRpcGxlPywgOm11bHRpcGxlXG4gIGFsaWFzX25hdGl2ZSA6cmVxdWlyZWQ/LCA6cmVxdWlyZWRcbiAgYWxpYXNfbmF0aXZlIDpsZW5ndGhcbmVuZFxuXG5lbmQ7IGVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8bW9kdWxlOkRPTT4iLCI8Y2xhc3M6RWxlbWVudD4iLCI8Y2xhc3M6U2VsZWN0PiIsInNlbGYiLCJkZWZfc2VsZWN0b3IiLCJ2YWx1ZSIsIkBuYXRpdmUiLCJ2YWx1ZT0iLCJ0b19uIiwibGFiZWxzIiwiTm9kZVNldCIsIltdIiwiTmF0aXZlOjpBcnJheSIsIk5hdGl2ZSIsIm5ldyIsIm9wdGlvbnMiLCJvcHRpb24iLCJET00iLCJpbmRleCIsImFsaWFzX25hdGl2ZSIsIkVsZW1lbnQiLCJOb2RlIl0sIm1hcHBpbmdzIjoiQUFBQUEsNkNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUFZQSxPQUFBQztNQUFBQTs7UUFBQUE7O1FBRTVCQSxPQUFBQztRQUFBQTs7VUFBQUE7O0FBQUFBOztVQUNFQyxJQUFBQyxjQUFBQSxDQUFhRixRQUFiRTs7QUFFQUMsVUFBQUEscUJBQUFBLGlCQUFBQTtBQUFBQSxZQUFBQTs7O0FBRUZBLFVBQVdDLGNBQU9EO0FBQ2xCQTtBQUNBQTtBQUNBQTtBQUNBQSxlQUFnQkMsY0FBT0Q7QUFDdkJBO0FBQ0FBO1VBUkVBLENBQUFBOztBQVdBRSxVQUFBQSxzQkFBQUEsNEJBQVdGLEtBQVhFO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRCxjQUFPQyxTQUFXRixLQUFLRyxNQUFBQSxDQUFBQTtVQUQzQkQsQ0FBQUE7O0FBSUFFLFVBQUFBLHNCQUFBQSxrQkFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUFDLGFBQU9DLE9BQUFBLENBQUNDLElBQUFDLFlBQUFELFVBQWFFLEtBQUFBLENBQU9SLGNBQU9HLE9BQWRLLENBQWRIO1VBRFRGLENBQUFBOztBQUlBTSxVQUFBQSx1QkFBQUEsbUJBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFBTCxhQUFPQyxPQUFBQSxDQUFDQyxJQUFBQyxZQUFBRCxVQUFhRSxLQUFBQSxDQUFPUixjQUFPUyxRQUFkRCxDQUFkSDtVQURUSSxDQUFBQTs7QUFJQUMsVUFBQUEsc0JBQUFBLGtCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBQWIsSUFBQWMsS0FBQUEsQ0FBTVgsY0FBT1UsU0FBVVYsY0FBT1UsZUFBOUJDO1VBREZELENBQUFBOztBQUlBRSxVQUFBQSxxQkFBQUEsaUJBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFWixjQUFPWTtVQURYQSxDQUFBQTtVQUlBZixJQUFBZ0IsY0FBQUEsQ0FBYSxXQUFiLEVBQXlCLFVBQXpCQTtVQUNBaEIsSUFBQWdCLGNBQUFBLENBQWEsV0FBYixFQUF5QixVQUF6QkE7VUFDQWpCLE9BQUFDLElBQUFnQixjQUFBQSxDQUFhLFFBQWJBO1FBcENGakIsR0FBQUEsV0FBQUEsRUFBZWtCLGFBQWZsQjtNQUY0QkQsR0FBQUEsV0FBQUEsRUFBZ0JvQixVQUFoQnBCO0lBQVpELEdBQUFBLFdBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzQ2MDgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9lbGVtZW50L3RlbXBsYXRlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NOyBjbGFzcyBFbGVtZW50IDwgTm9kZVxuXG5jbGFzcyBUZW1wbGF0ZSA8IEVsZW1lbnRcbiAgZGVmX3NlbGVjdG9yIFwidGVtcGxhdGVcIlxuXG4gIGRlZiBjb250ZW50XG4gICAgRE9NKGAjQG5hdGl2ZS5jb250ZW50YClcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPG1vZHVsZTpET00+IiwiPGNsYXNzOkVsZW1lbnQ+IiwiPGNsYXNzOlRlbXBsYXRlPiIsInNlbGYiLCJkZWZfc2VsZWN0b3IiLCJjb250ZW50IiwiRE9NIiwiQG5hdGl2ZSIsIkVsZW1lbnQiLCJOb2RlIl0sIm1hcHBpbmdzIjoiQUFBQUEsK0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUFZQSxPQUFBQztNQUFBQTs7UUFBQUE7O1FBRTVCQSxPQUFBQztRQUFBQTs7VUFBQUE7O0FBQUFBOztVQUNFQyxJQUFBQyxjQUFBQSxDQUFhRixVQUFiRTtVQUVBRixPQUFBRyx1QkFBQUEsbUJBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFBRixJQUFBRyxLQUFBQSxDQUFNQyxjQUFPRixRQUFiQztVQURGRCxDQUFBQTtRQUhGSCxHQUFBQSxXQUFBQSxFQUFpQk0sYUFBakJOO01BRjRCRCxHQUFBQSxXQUFBQSxFQUFnQlEsVUFBaEJSO0lBQVpELEdBQUFBLFdBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzQ2NDYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9lbGVtZW50L3RleHRhcmVhLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NOyBjbGFzcyBFbGVtZW50IDwgTm9kZVxuXG5jbGFzcyBUZXh0YXJlYSA8IEVsZW1lbnRcbiAgZGVmX3NlbGVjdG9yIFwidGV4dGFyZWFcIlxuXG4gIGRlZiB2YWx1ZVxuICAgICV4e1xuICAgICAgaWYgKCNAbmF0aXZlLnZhbHVlID09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI0BuYXRpdmUudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgdmFsdWU9KHZhbHVlKVxuICAgIGAjQG5hdGl2ZS52YWx1ZSA9ICN7dmFsdWV9YFxuICBlbmRcblxuICBkZWYgY2xlYXJcbiAgICBgI0BuYXRpdmUudmFsdWUgPSAnJ2BcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPG1vZHVsZTpET00+IiwiPGNsYXNzOkVsZW1lbnQ+IiwiPGNsYXNzOlRleHRhcmVhPiIsInNlbGYiLCJkZWZfc2VsZWN0b3IiLCJ2YWx1ZSIsIkBuYXRpdmUiLCJ2YWx1ZT0iLCJjbGVhciIsIkVsZW1lbnQiLCJOb2RlIl0sIm1hcHBpbmdzIjoiQUFBQUEsK0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUFZQSxPQUFBQztNQUFBQTs7UUFBQUE7O1FBRTVCQSxPQUFBQztRQUFBQTs7VUFBQUE7O0FBQUFBOztVQUNFQyxJQUFBQyxjQUFBQSxDQUFhRixVQUFiRTs7QUFFQUMsVUFBQUEscUJBQUFBLGlCQUFBQTtBQUFBQSxZQUFBQTs7O0FBRUZBLFVBQVdDLGNBQU9EO0FBQ2xCQTtBQUNBQTtBQUNBQTtBQUNBQSxlQUFnQkMsY0FBT0Q7QUFDdkJBO0FBQ0FBO1VBUkVBLENBQUFBOztBQVdBRSxVQUFBQSxzQkFBQUEsOEJBQVdGLEtBQVhFO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRCxjQUFPQyxTQUFXRjtVQUR0QkUsQ0FBQUE7VUFJQUwsT0FBQU0scUJBQUFBLGlCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUYsY0FBT0U7VUFEWEEsQ0FBQUE7UUFsQkZOLEdBQUFBLFdBQUFBLEVBQWlCTyxhQUFqQlA7TUFGNEJELEdBQUFBLFdBQUFBLEVBQWdCUyxVQUFoQlQ7SUFBWkQsR0FBQUEsV0FBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozNDcwMywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZG9tL2VsZW1lbnQvaWZyYW1lLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NOyBjbGFzcyBFbGVtZW50IDwgTm9kZVxuXG5jbGFzcyBJZnJhbWUgPCBFbGVtZW50XG4gIGRlZl9zZWxlY3RvciBcImlmcmFtZVwiXG5cbiAgIyBAIWF0dHJpYnV0ZSBzcmNcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBVUkwgb2YgdGhlIHBhZ2UgdG8gZW1iZWRcbiAgYWxpYXNfbmF0aXZlIDpzcmNcbiAgYWxpYXNfbmF0aXZlIDpzcmM9XG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gY29udGVudF93aW5kb3dcbiAgIyBAcmV0dXJuIFtXaW5kb3ddIHdpbmRvdyBvZiBjb250ZW50IG9mIHRoaXMgaWZyYW1lXG4gIGRlZiBjb250ZW50X3dpbmRvd1xuICAgIEJyb3dzZXI6OldpbmRvdy5uZXcoYCNAbmF0aXZlLmNvbnRlbnRXaW5kb3dgKVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBjb250ZW50X2RvY3VtZW50XG4gICMgQHJldHVybiBbRG9jdW1lbnRdIGRvY3VtZW50IG9mIGNvbnRlbnQgb2YgdGhpcyBpZnJhbWUgXG4gIGRlZiBjb250ZW50X2RvY3VtZW50XG4gICAgRE9NKGAjQG5hdGl2ZS5jb250ZW50RG9jdW1lbnQgfHwgI0BuYXRpdmUuY29udGVudFdpbmRvdy5kb2N1bWVudGApXG4gIGVuZFxuXG4gICMgU2VuZCBhIG1lc3NhZ2UgdG8gdGhlIGlmcmFtZSBjb250ZW50J3Mgd2luZG93LlxuICAjXG4gICMgQHBhcmFtIG1lc3NhZ2UgW1N0cmluZ10gdGhlIG1lc3NhZ2VcbiAgIyBAcGFyYW0gb3B0aW9ucyBbSGFzaF0gb3B0aW9uYWwgYHRvOiB0YXJnZXRgXG4gIGRlZiBzZW5kKG1lc3NhZ2UsIG9wdGlvbnM9e30pXG4gICAgY29udGVudF93aW5kb3cuc2VuZChtZXNzYWdlLCBvcHRpb25zKVxuICBlbmRcbmVuZFxuXG4jIE9iamVjdCBpcyBub3QgYW4gaWZyYW1lLCBidXQgYWN0cyB0aGUgc2FtZS5cbmNsYXNzIE9iamVjdCA8IElmcmFtZVxuICBkZWZfc2VsZWN0b3IgXCJvYmplY3RcIlxuZW5kXG5cbmVuZDsgZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxtb2R1bGU6RE9NPiIsIjxjbGFzczpFbGVtZW50PiIsIjxjbGFzczpJZnJhbWU+Iiwic2VsZiIsImRlZl9zZWxlY3RvciIsImFsaWFzX25hdGl2ZSIsImNvbnRlbnRfd2luZG93IiwiQnJvd3Nlcjo6V2luZG93IiwiQnJvd3NlciIsIm5ldyIsIkBuYXRpdmUiLCJjb250ZW50X2RvY3VtZW50IiwiRE9NIiwic2VuZCIsIm1lc3NhZ2UiLCJvcHRpb25zIiwiRWxlbWVudCIsIjxjbGFzczpPYmplY3Q+IiwiSWZyYW1lIiwiTm9kZSJdLCJtYXBwaW5ncyI6IkFBQUFBLDZDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFBWUEsT0FBQUM7TUFBQUE7O1FBQUFBOzs7UUFFNUJDO1FBQUFBOztVQUFBQTs7QUFBQUE7O1VBQ0VDLElBQUFDLGNBQUFBLENBQWFGLFFBQWJFO1VBSUFELElBQUFFLGNBQUFBLENBQWEsS0FBYkE7VUFDQUYsSUFBQUUsY0FBQUEsQ0FBYSxNQUFiQTs7QUFJQUMsVUFBQUEsOEJBQUFBLDBCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBQUMsSUFBQUMsYUFBQUQsV0FBZUUsS0FBQUEsQ0FBT0MsY0FBT0osY0FBZEc7VUFEakJILENBQUFBOztBQU1BSyxVQUFBQSxnQ0FBQUEsNEJBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFBUixJQUFBUyxLQUFBQSxDQUFNRixjQUFPQyxvQkFBcUJELGNBQU9DLHVCQUF6Q0M7VUFERkQsQ0FBQUE7VUFRQVQsT0FBQVcsb0JBQUFBLGdCQUFTQyxPQUFELEVBQVVDLE9BQWxCRjtBQUFBQSxZQUFBQTs7O1lBQWtCLCtCQUFRO1lBQ3hCQSxPQUFBVixJQUFBRyxnQkFBQUEsQ0FBQUEsQ0FBY08sTUFBQUEsQ0FBTUMsT0FBcEIsRUFBNkJDLE9BQWZGO1VBRGhCQSxDQUFBQSxJQUFBQTtRQXhCRlgsR0FBQUEsV0FBQUEsRUFBZWMsYUFBZmQ7UUE4QkFELE9BQUFnQjtRQUFBQTs7O1VBQ0VBLE9BQUFkLElBQUFDLGNBQUFBLENBQWFhLFFBQWJiO1FBREZhLEdBQUFBLFdBQUFBLEVBQWVDLFlBQWZEO01BaEM0QmhCLEdBQUFBLFdBQUFBLEVBQWdCa0IsVUFBaEJsQjtJQUFaRCxHQUFBQSxXQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM0NzY0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9kb20vZWxlbWVudC9tZWRpYS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgbW9kdWxlIERPTTsgY2xhc3MgRWxlbWVudCA8IE5vZGVcblxuY2xhc3MgTWVkaWEgPCBFbGVtZW50XG4gIGRlZiBwbGF5XG4gICAgYCNAbmF0aXZlLnBsYXkoKWBcbiAgZW5kXG5lbmRcblxuY2xhc3MgVmlkZW8gPCBNZWRpYVxuICBkZWZfc2VsZWN0b3IgXCJ2aWRlb1wiXG5lbmRcblxuY2xhc3MgQXVkaW8gPCBNZWRpYVxuICBkZWZfc2VsZWN0b3IgXCJhdWRpb1wiXG5lbmRcblxuZW5kOyBlbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPG1vZHVsZTpET00+IiwiPGNsYXNzOkVsZW1lbnQ+IiwiPGNsYXNzOk1lZGlhPiIsInBsYXkiLCJAbmF0aXZlIiwiRWxlbWVudCIsIjxjbGFzczpWaWRlbz4iLCJzZWxmIiwiZGVmX3NlbGVjdG9yIiwiTWVkaWEiLCI8Y2xhc3M6QXVkaW8+IiwiTm9kZSJdLCJtYXBwaW5ncyI6IkFBQUFBLDRDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFBWUEsT0FBQUM7TUFBQUE7O1FBQUFBOzs7UUFFNUJDO1FBQUFBOztVQUFBQTs7QUFBQUE7VUFDRUEsT0FBQUMsb0JBQUFBLGdCQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUMsY0FBT0Q7VUFEWEEsQ0FBQUE7UUFERkQsR0FBQUEsV0FBQUEsRUFBY0csYUFBZEg7UUFNQUk7UUFBQUE7OztVQUNFQSxPQUFBQyxJQUFBQyxjQUFBQSxDQUFhRixPQUFiRTtRQURGRixHQUFBQSxXQUFBQSxFQUFjRyxXQUFkSDtRQUlBTCxPQUFBUztRQUFBQTs7O1VBQ0VBLE9BQUFILElBQUFDLGNBQUFBLENBQWFFLE9BQWJGO1FBREZFLEdBQUFBLFdBQUFBLEVBQWNELFdBQWRDO01BWjRCVCxHQUFBQSxXQUFBQSxFQUFnQlUsVUFBaEJWO0lBQVpELEdBQUFBLFdBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzQ4MTMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9lbGVtZW50LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgUmVxdWlyZXMgYXJlIG1vdmVkIHRvIHRoZSBib3R0b20gb2YgdGhpcyBmaWxlLlxuXG5tb2R1bGUgQnJvd3NlcjsgbW9kdWxlIERPTVxuXG5jbGFzcyBFbGVtZW50IDwgTm9kZVxuICBkZWYgc2VsZi5jcmVhdGUoKmFyZ3MsICZibG9jaylcbiAgICBpZiBEb2N1bWVudCA9PT0gYXJncy5maXJzdFxuICAgICAgZG9jdW1lbnQgPSBhcmdzLnNoaWZ0XG4gICAgZWxzZVxuICAgICAgZG9jdW1lbnQgPSAkZG9jdW1lbnRcbiAgICBlbmRcblxuICAgIGlmIHNlbGYgPT0gRWxlbWVudFxuICAgICAgZG9jdW1lbnQuY3JlYXRlX2VsZW1lbnQoKmFyZ3MsICZibG9jaylcbiAgICBlbHNpZiBAdGFnX25hbWVcbiAgICAgIGRvY3VtZW50LmNyZWF0ZV9lbGVtZW50KEB0YWdfbmFtZSwgKmFyZ3MsICZibG9jaylcbiAgICBlbHNpZiBAc2VsZWN0b3JcbiAgICAgICMgVGhhdCdzIGNydWRlLCBidXQgc2hvdWxkIGNvdmVyIHRoZSBtb3N0IGJhc2ljIGNhc2VzLlxuICAgICAgIyBKdXN0IGluIGNhc2UsIHlvdSBjYW4gb3ZlcnJpZGUgaXQgc2FmZWx5LiBUbyByZWl0ZXJhdGU6XG4gICAgICAjIC5jcmVhdGUgaXMgbm90IHRvIGJlIHVzZWQgaW5zaWRlIGxpYnJhcmllcywgdGhvc2UgYXJlXG4gICAgICAjIGV4cGVjdGVkIHRvIHVzZSB0aGUgRG9jdW1lbnQjY3JlYXRlX2VsZW1lbnQgQVBJLlxuICAgICAga3dhcmdzID0ge31cbiAgICAgIGt3YXJncyA9IGFyZ3MucG9wIGlmIEhhc2ggPT09IGFyZ3MubGFzdFxuICAgICAgY3VzdG9tX2F0dHJzLCBjdXN0b21faWQsIGN1c3RvbV9jbGFzc2VzID0gbmlsLCBuaWwsIG5pbFxuICAgICAgdGFnX25hbWUgPSAoQHNlbGVjdG9yLnNjYW4oL15bXFx3LV0rLykuZmlyc3QgfHwgXCJkaXZcIikudXBjYXNlXG4gICAgICBjbGFzc2VzID0gQHNlbGVjdG9yLnNjYW4oL1xcLihbXFx3LV0rKS8pLmZsYXR0ZW5cbiAgICAgIGNsYXNzZXMgfD0gY3VzdG9tX2NsYXNzZXMgaWYgY3VzdG9tX2NsYXNzZXMgPSBrd2FyZ3MuZGVsZXRlKDpjbGFzc2VzKVxuICAgICAgaWQgPSBAc2VsZWN0b3Iuc2NhbigvIyhbXFx3LV0rKS8pLmZsYXR0ZW4uZmlyc3RcbiAgICAgIGlkID0gY3VzdG9tX2lkIGlmIGN1c3RvbV9pZCA9IGt3YXJncy5kZWxldGUoOmlkKVxuICAgICAgYXR0cnMgPSBAc2VsZWN0b3Iuc2NhbigvXFxbKFtcXHctXSspPSgoW1wiJ10pKC4qPylcXDN8W1xcd18tXSopXFxdLykubWFwIHsgfGEsYixfLGR8IFthLGR8fGJdIH0udG9faFxuICAgICAgYXR0cnMgPSBhdHRycy5tZXJnZShjdXN0b21fYXR0cnMpIGlmIGN1c3RvbV9hdHRycyA9IGt3YXJncy5kZWxldGUoOmF0dHJzKVxuICAgICAgZG9jdW1lbnQuY3JlYXRlX2VsZW1lbnQodGFnX25hbWUsICphcmdzLCBjbGFzc2VzOiBjbGFzc2VzLCBpZDogaWQsIGF0dHJzOiBhdHRycywgKiprd2FyZ3MsICZibG9jaylcbiAgICBlbHNlXG4gICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnN1YmNsYXNzZXNcbiAgICBAc3ViY2xhc3NlcyB8fD0gW11cbiAgZW5kXG5cbiAgIyBEZWZpbmUgYSBzZWxlY3RvciBmb3Igc3ViY2xhc3MgZGlzcGF0Y2hcbiAgI1xuICAjIEV4YW1wbGU6XG4gICMgYGBgXG4gICMgY2xhc3MgQ3VzdG9tRWxlbWVudCA8IEJyb3dzZXI6OkRPTTo6RWxlbWVudFxuICAjICAgZGVmX3NlbGVjdG9yIFwiZGl2LmhlbGxvLXdvcmxkXCJcbiAgIyBlbmRcbiAgIyBgYGBcbiAgZGVmIHNlbGYuZGVmX3NlbGVjdG9yKHNlbGVjdG9yKVxuICAgIEVsZW1lbnQuc3ViY2xhc3NlcyA8PCBzZWxmXG5cbiAgICBAc2VsZWN0b3IgPSBzZWxlY3RvclxuXG4gICAgIyBBIHNwZWNpYWwgY2FzZSB0byBzcGVlZHVwIGRpc3BhdGNoXG4gICAgQHRhZ19uYW1lID0gc2VsZWN0b3IudXBjYXNlIHVubGVzcyBzZWxlY3RvciA9fiAvW15cXHctXS9cbiAgZW5kXG5cbiAgZGVmIHNlbGYuc2VsZWN0b3JcbiAgICBAc2VsZWN0b3JcbiAgZW5kXG5cbiAgZGVmIHNlbGYudGFnX25hbWVcbiAgICBAdGFnX25hbWVcbiAgZW5kXG5cbiAgZGVmIHNlbGYubmV3KCphcmdzLCAmYmxvY2spXG4gICAgaWYgYXJncy5sZW5ndGggPT0gMSAmJiAhYmxvY2tfZ2l2ZW4/ICYmIE9wYWwubmF0aXZlPyhhcmdzWzBdKVxuICAgICAgIyBVc2UgYC5uZXdgIGFzIGEgd3JhcHBpbmcgbWV0aG9kLlxuICAgICAgbm9kZSA9IGFyZ3NbMF1cbiAgICBlbHNlXG4gICAgICAjIFVzZSBgLm5ld2AgYXMgYW4gYWxpYXMgZm9yIGAuY3JlYXRlYC5cbiAgICAgIHJldHVybiBjcmVhdGUoKmFyZ3MsICZibG9jaylcbiAgICBlbmRcblxuICAgIGlmIHNlbGYgPT0gRWxlbWVudFxuICAgICAgc3ViY2xhc3MgPSBFbGVtZW50LnN1YmNsYXNzZXMuc2VsZWN0IGRvIHxzdWJjbGFzc3xcbiAgICAgICAgRWxlbWVudC5uYXRpdmVfaXM/KG5vZGUsIHN1YmNsYXNzKVxuICAgICAgZW5kLmxhc3RcblxuICAgICAgaWYgc3ViY2xhc3NcbiAgICAgICAgc3ViY2xhc3MubmV3KG5vZGUpXG4gICAgICBlbHNlXG4gICAgICAgIHN1cGVyKG5vZGUpXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBzdXBlcihub2RlKVxuICAgIGVuZFxuICBlbmRcblxuICBpbmNsdWRlIEV2ZW50OjpUYXJnZXRcblxuICB0YXJnZXQge3x2YWx1ZXxcbiAgICBiZWdpblxuICAgICAgRE9NKHZhbHVlKVxuICAgIHJlc2N1ZSBTdGFuZGFyZEVycm9yLCBKUzo6RXJyb3JcbiAgICAgIG5pbFxuICAgIGVuZFxuICB9XG5cbiAgZGVmIHNlbGYubmF0aXZlX2lzPyAobmF0aXZlLCBrbGFzcylcbiAgICBpZiB0YWdfbmFtZSA9IGtsYXNzLnRhZ19uYW1lXG4gICAgICBpcyA9IGAoI3tuYXRpdmV9LmdldEF0dHJpYnV0ZShcImlzXCIpIHx8IFwiXCIpYFxuICAgICAgYCN7dGFnX25hbWV9ID09PSAje2lzfS50b1VwcGVyQ2FzZSgpIHx8ICN7dGFnX25hbWV9ID09PSAje25hdGl2ZX0ubm9kZU5hbWVgXG4gICAgZWxzZVxuICAgICAgRWxlbWVudC5uYXRpdmVfbWF0Y2hlcz8obmF0aXZlLCBrbGFzcy5zZWxlY3RvcilcbiAgICBlbmRcbiAgZW5kXG5cbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0VsZW1lbnQubWF0Y2hlcydcbiAgICBkZWYgc2VsZi5uYXRpdmVfbWF0Y2hlcz8gKG5hdGl2ZSwgc2VsZWN0b3IpXG4gICAgICBgI3tuYXRpdmV9Lm1hdGNoZXMoI3tzZWxlY3Rvcn0pYFxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnRWxlbWVudC5tYXRjaGVzIChPcGVyYSknXG4gICAgZGVmIHNlbGYubmF0aXZlX21hdGNoZXM/IChuYXRpdmUsIHNlbGVjdG9yKVxuICAgICAgYCN7bmF0aXZlfS5vTWF0Y2hlc1NlbGVjdG9yKCN7c2VsZWN0b3J9KWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0VsZW1lbnQubWF0Y2hlcyAoSW50ZXJuZXQgRXhwbG9yZXIpJ1xuICAgIGRlZiBzZWxmLm5hdGl2ZV9tYXRjaGVzPyAobmF0aXZlLCBzZWxlY3RvcilcbiAgICAgIGAje25hdGl2ZX0ubXNNYXRjaGVzU2VsZWN0b3IoI3tzZWxlY3Rvcn0pYFxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnRWxlbWVudC5tYXRjaGVzIChGaXJlZm94KSdcbiAgICBkZWYgc2VsZi5uYXRpdmVfbWF0Y2hlcz8gKG5hdGl2ZSwgc2VsZWN0b3IpXG4gICAgICBgI3tuYXRpdmV9Lm1vek1hdGNoZXNTZWxlY3Rvcigje3NlbGVjdG9yfSlgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFbGVtZW50Lm1hdGNoZXMgKENocm9tZSknXG4gICAgZGVmIHNlbGYubmF0aXZlX21hdGNoZXM/IChuYXRpdmUsIHNlbGVjdG9yKVxuICAgICAgYCN7bmF0aXZlfS53ZWJraXRNYXRjaGVzU2VsZWN0b3IoI3tzZWxlY3Rvcn0pYFxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLmxvYWRlZD8gJ1NpenpsZSdcbiAgICBkZWYgc2VsZi5uYXRpdmVfbWF0Y2hlcz8gKG5hdGl2ZSwgc2VsZWN0b3IpXG4gICAgICBgU2l6emxlLm1hdGNoZXNTZWxlY3Rvcigje25hdGl2ZX0sICN7c2VsZWN0b3J9KWBcbiAgICBlbmRcbiAgZWxzZVxuICAgIGRlZiBzZWxmLm5hdGl2ZV9tYXRjaGVzPyAobmF0aXZlLCBzZWxlY3RvcilcbiAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsICdzZWxlY3RvciBtYXRjaGluZyB1bnN1cHBvcnRlZCdcbiAgICBlbmRcbiAgZW5kXG5cbiAgIyBDaGVjayB3aGV0aGVyIHRoZSBlbGVtZW50IG1hdGNoZXMgdGhlIGdpdmVuIHNlbGVjdG9yLlxuICAjXG4gICMgQHBhcmFtIHNlbGVjdG9yIFtTdHJpbmddIHRoZSBDU1Mgc2VsZWN0b3JcbiAgZGVmID1+KHNlbGVjdG9yKVxuICAgIEVsZW1lbnQubmF0aXZlX21hdGNoZXM/KEBuYXRpdmUsIHNlbGVjdG9yKVxuICBlbmRcblxuICAjIEFsbG93IGZvciBjYXNlIGV4cHJlc3Npb25zXG4gIGFsaWFzID09PSA9flxuXG4gICMgUXVlcnkgZm9yIGNoaWxkcmVuIHdpdGggdGhlIGdpdmVuIFhQcGF0aHMuXG4gICNcbiAgIyBAcGFyYW0gcGF0aHMgW0FycmF5PFN0cmluZz5dIHRoZSBYUGF0aHMgdG8gbG9vayBmb3JcbiAgI1xuICAjIEByZXR1cm4gW05vZGVTZXRdXG4gIGRlZiAvKCpwYXRocylcbiAgICBOb2RlU2V0W3BhdGhzLm1hcCB7IHxwYXRofCB4cGF0aChwYXRoKSB9XVxuICBlbmRcblxuICAjIEdldCB0aGUgYXR0cmlidXRlIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gICNcbiAgIyBAcGFyYW0gbmFtZSBbU3RyaW5nXSB0aGUgYXR0cmlidXRlIG5hbWVcbiAgIyBAcGFyYW0gb3B0aW9ucyBbSGFzaF0gb3B0aW9ucyBmb3IgdGhlIGF0dHJpYnV0ZVxuICAjXG4gICMgQG9wdGlvbiBvcHRpb25zIFtTdHJpbmddIDpuYW1lc3BhY2UgdGhlIG5hbWVzcGFjZSBmb3IgdGhlIGF0dHJpYnV0ZVxuICAjXG4gICMgQHJldHVybiBbU3RyaW5nP11cbiAgZGVmIFtdKG5hbWUsIG9wdGlvbnMgPSB7fSlcbiAgICBhdHRyaWJ1dGVzLmdldChuYW1lLCBvcHRpb25zKVxuICBlbmRcblxuICAjIFNldCB0aGUgYXR0cmlidXRlIHdpdGggdGhlIGdpdmVuIG5hbWUgYW5kIHZhbHVlLlxuICAjXG4gICMgQHBhcmFtIG5hbWUgW1N0cmluZ10gdGhlIGF0dHJpYnV0ZSBuYW1lXG4gICMgQHBhcmFtIHZhbHVlIFtPYmplY3RdIHRoZSBhdHRyaWJ1dGUgdmFsdWVcbiAgIyBAcGFyYW0gb3B0aW9ucyBbSGFzaF0gdGhlIG9wdGlvbnMgZm9yIHRoZSBhdHRyaWJ1dGVcbiAgI1xuICAjIEBvcHRpb24gb3B0aW9ucyBbU3RyaW5nXSA6bmFtZXNwYWNlIHRoZSBuYW1lc3BhY2UgZm9yIHRoZSBhdHRyaWJ1dGVcbiAgZGVmIFtdPShuYW1lLCB2YWx1ZSwgb3B0aW9ucyA9IHt9KVxuICAgIGF0dHJpYnV0ZXMuc2V0KG5hbWUsIHZhbHVlLCBvcHRpb25zKVxuICBlbmRcblxuICAjIEFkZCBjbGFzcyBuYW1lcyB0byB0aGUgZWxlbWVudC5cbiAgI1xuICAjIEBwYXJhbSBuYW1lcyBbQXJyYXk8U3RyaW5nPl0gY2xhc3MgbmFtZXMgdG8gYWRkXG4gICNcbiAgIyBAcmV0dXJuIFtzZWxmXVxuICBkZWYgYWRkX2NsYXNzKCpuYW1lcylcbiAgICBjbGFzc2VzID0gY2xhc3NfbmFtZXMgKyBuYW1lc1xuXG4gICAgdW5sZXNzIGNsYXNzZXMuZW1wdHk/XG4gICAgICBgI0BuYXRpdmUuY2xhc3NOYW1lID0gI3tjbGFzc2VzLnVuaXEuam9pbiAnICd9YFxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICAjIEdldCB0aGUgZmlyc3Qgbm9kZSB0aGF0IG1hdGNoZXMgdGhlIGdpdmVuIENTUyBzZWxlY3RvciBvciBYUGF0aC5cbiAgI1xuICAjIEBwYXJhbSBwYXRoX29yX3NlbGVjdG9yIFtTdHJpbmddIGFuIFhQYXRoIG9yIENTUyBzZWxlY3RvclxuICAjXG4gICMgQHJldHVybiBbTm9kZT9dXG4gIGRlZiBhdChwYXRoX29yX3NlbGVjdG9yKVxuICAgIHhwYXRoKHBhdGhfb3Jfc2VsZWN0b3IpLmZpcnN0IHx8IGNzcyhwYXRoX29yX3NlbGVjdG9yKS5maXJzdFxuICBlbmRcblxuICAjIEdldCB0aGUgZmlyc3Qgbm9kZSBtYXRjaGluZyB0aGUgZ2l2ZW4gQ1NTIHNlbGVjdG9ycy5cbiAgI1xuICAjIEBwYXJhbSBydWxlcyBbQXJyYXk8U3RyaW5nPl0gdGhlIENTUyBzZWxlY3RvcnMgdG8gbWF0Y2ggd2l0aFxuICAjXG4gICMgQHJldHVybiBbTm9kZT9dXG4gIGRlZiBhdF9jc3MoKnJ1bGVzKVxuICAgIHJlc3VsdCA9IG5pbFxuXG4gICAgcnVsZXMuZWFjaCB7fHJ1bGV8XG4gICAgICBpZiByZXN1bHQgPSBjc3MocnVsZSkuZmlyc3RcbiAgICAgICAgYnJlYWtcbiAgICAgIGVuZFxuICAgIH1cblxuICAgIHJlc3VsdFxuICBlbmRcblxuICAjIEdldCB0aGUgZmlyc3Qgbm9kZSBtYXRjaGluZyB0aGUgZ2l2ZW4gWFBhdGguXG4gICNcbiAgIyBAcGFyYW0gcGF0aHMgW0FycmF5PFN0cmluZz5dIHRoZSBYUGF0aCB0byBtYXRjaCB3aXRoXG4gICNcbiAgIyBAcmV0dXJuIFtOb2RlP11cbiAgZGVmIGF0X3hwYXRoKCpwYXRocylcbiAgICByZXN1bHQgPSBuaWxcblxuICAgIHBhdGhzLmVhY2gge3xwYXRofFxuICAgICAgaWYgcmVzdWx0ID0geHBhdGgocGF0aCkuZmlyc3RcbiAgICAgICAgYnJlYWtcbiAgICAgIGVuZFxuICAgIH1cblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBhbGlhcyBhdHRyIFtdXG5cbiAgYWxpYXMgYXR0cmlidXRlIFtdXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gYXR0cmlidXRlc1xuICAjIEByZXR1cm4gW0F0dHJpYnV0ZXNdIHRoZSBhdHRyaWJ1dGVzIGZvciB0aGUgZWxlbWVudFxuICBkZWYgYXR0cmlidXRlcyhvcHRpb25zID0ge30pXG4gICAgQXR0cmlidXRlcy5uZXcoc2VsZiwgb3B0aW9ucylcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gYXR0cmlidXRlX25vZGVzXG4gICMgQHJldHVybiBbTm9kZVNldF0gdGhlIGF0dHJpYnV0ZSBub2RlcyBmb3IgdGhlIGVsZW1lbnRcbiAgZGVmIGF0dHJpYnV0ZV9ub2Rlc1xuICAgIE5vZGVTZXRbTmF0aXZlOjpBcnJheS5uZXcoYCNAbmF0aXZlLmF0dHJpYnV0ZXNgLCBnZXQ6IDppdGVtKV1cbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gY2xhc3NfbmFtZVxuICAjIEByZXR1cm4gW1N0cmluZ10gYWxsIHRoZSBlbGVtZW50IGNsYXNzIG5hbWVzXG4gIGFsaWFzX25hdGl2ZSA6Y2xhc3NfbmFtZSwgOmNsYXNzTmFtZVxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIGNsYXNzX25hbWVzXG4gICMgQHJldHVybiBbQXJyYXk8U3RyaW5nPl0gYWxsIHRoZSBlbGVtZW50IGNsYXNzIG5hbWVzXG4gIGRlZiBjbGFzc19uYW1lc1xuICAgIGAjQG5hdGl2ZS5jbGFzc05hbWVgLnNwbGl0KC9cXHMrLykucmVqZWN0KCY6ZW1wdHk/KVxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnUXVlcnkuY3NzJ1xuICAgIGRlZiBjc3MocGF0aClcbiAgICAgIE5vZGVTZXRbTmF0aXZlOjpBcnJheS5uZXcoYCNAbmF0aXZlLnF1ZXJ5U2VsZWN0b3JBbGwocGF0aClgKV1cbiAgICByZXNjdWUgU3RhbmRhcmRFcnJvciwgSlM6OkVycm9yXG4gICAgICBOb2RlU2V0W11cbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5sb2FkZWQ/ICdTaXp6bGUnXG4gICAgZGVmIGNzcyhwYXRoKVxuICAgICAgTm9kZVNldFtgU2l6emxlKHBhdGgsICNAbmF0aXZlKWBdXG4gICAgcmVzY3VlIFN0YW5kYXJkRXJyb3IsIEpTOjpFcnJvclxuICAgICAgTm9kZVNldFtdXG4gICAgZW5kXG4gIGVsc2VcbiAgICAjIFF1ZXJ5IGZvciBjaGlsZHJlbiBtYXRjaGluZyB0aGUgZ2l2ZW4gQ1NTIHNlbGVjdG9yLlxuICAgICNcbiAgICAjIEBwYXJhbSBzZWxlY3RvciBbU3RyaW5nXSB0aGUgQ1NTIHNlbGVjdG9yXG4gICAgI1xuICAgICMgQHJldHVybiBbTm9kZVNldF1cbiAgICBkZWYgY3NzKHNlbGVjdG9yKVxuICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgJ3F1ZXJ5IGJ5IENTUyBzZWxlY3RvciB1bnN1cHBvcnRlZCdcbiAgICBlbmRcbiAgZW5kXG5cbiAgIyBDbGljayB0aGUgZWxlbWVudC4gaXQgZmlyZXMgdGhlIGVsZW1lbnQncyBjbGljayBldmVudC5cbiAgZGVmIGNsaWNrXG4gICAgYCNAbmF0aXZlLmNsaWNrKClgXG4gICAgc2VsZlxuICBlbmRcblxuICAjIEBvdmVybG9hZCBkYXRhKClcbiAgI1xuICAjICAgUmV0dXJuIHRoZSBkYXRhIGZvciB0aGUgZWxlbWVudC5cbiAgI1xuICAjICAgQHJldHVybiBbRGF0YV1cbiAgI1xuICAjIEBvdmVybG9hZCBkYXRhKGhhc2gpXG4gICNcbiAgIyAgIFNldCBkYXRhIG9uIHRoZSBlbGVtZW50LlxuICAjXG4gICMgICBAcGFyYW0gaGFzaCBbSGFzaF0gdGhlIGRhdGEgdG8gc2V0XG4gICNcbiAgIyAgIEByZXR1cm4gW3NlbGZdXG4gIGRlZiBkYXRhKHZhbHVlID0gbmlsKVxuICAgIGRhdGEgPSBEYXRhLm5ldyhzZWxmKVxuXG4gICAgcmV0dXJuIGRhdGEgdW5sZXNzIHZhbHVlXG5cbiAgICBpZiBIYXNoID09PSB2YWx1ZVxuICAgICAgZGF0YS5hc3NpZ24odmFsdWUpXG4gICAgZWxzZVxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3Vua25vd24gZGF0YSB0eXBlJ1xuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBhbGlhcyBnZXRfYXR0cmlidXRlIFtdXG5cbiAgYWxpYXMgZ2V0IFtdXG5cbiAgIyBAIWF0dHJpYnV0ZSBoZWlnaHRcbiAgIyBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgaGVpZ2h0IG9mIHRoZSBlbGVtZW50XG4gIGRlZiBoZWlnaHRcbiAgICBzaXplLmhlaWdodFxuICBlbmRcblxuICBkZWYgaGVpZ2h0PSh2YWx1ZSlcbiAgICBzaXplLmhlaWdodCA9IHZhbHVlXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgaWRcbiAgIyBAcmV0dXJuIFtTdHJpbmc/XSB0aGUgSUQgb2YgdGhlIGVsZW1lbnRcbiAgZGVmIGlkXG4gICAgJXh7XG4gICAgICB2YXIgaWQgPSAjQG5hdGl2ZS5pZDtcblxuICAgICAgaWYgKGlkID09PSBcIlwiKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGlkPSh2YWx1ZSlcbiAgICBgI0BuYXRpdmUuaWQgPSAje3ZhbHVlLnRvX3N9YFxuICBlbmRcblxuICAjIFNldCB0aGUgaW5uZXIgRE9NIG9mIHRoZSBlbGVtZW50IHVzaW5nIHRoZSB7QnVpbGRlcn0uXG4gIGRlZiBpbm5lcl9kb20oYnVpbGRlcj1uaWwsICZibG9jaylcbiAgICBzZWxmLmlubmVyX2RvbSA9IEJ1aWxkZXIubmV3KGRvY3VtZW50LCBidWlsZGVyLCAmYmxvY2spLnRvX2FcbiAgICBzZWxmXG4gIGVuZFxuXG4gICMgU2V0IHRoZSBpbm5lciBET00gd2l0aCB0aGUgZ2l2ZW4gbm9kZS5cbiAgI1xuICAjIChzZWUgI2FwcGVuZF9jaGlsZClcbiAgZGVmIGlubmVyX2RvbT0obm9kZSlcbiAgICBjbGVhclxuXG4gICAgc2VsZiA8PCBub2RlXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgaW5uZXJfaHRtbFxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIGlubmVyIEhUTUwgb2YgdGhlIGVsZW1lbnRcbiAgZGVmIGlubmVyX2h0bWxcbiAgICBgI0BuYXRpdmUuaW5uZXJIVE1MYFxuICBlbmRcblxuICBkZWYgaW5uZXJfaHRtbD0odmFsdWUpXG4gICAgYCNAbmF0aXZlLmlubmVySFRNTCA9ICN7dmFsdWV9YFxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIGluc3BlY3QgPSBuYW1lLmRvd25jYXNlXG5cbiAgICBpZiBpZFxuICAgICAgaW5zcGVjdCArPSAnLicgKyBpZCArICchJ1xuICAgIGVuZFxuXG4gICAgdW5sZXNzIGNsYXNzX25hbWVzLmVtcHR5P1xuICAgICAgaW5zcGVjdCArPSAnLicgKyBjbGFzc19uYW1lcy5qb2luKCcuJylcbiAgICBlbmRcblxuICAgIFwiIzwje3NlbGYuY2xhc3MubmFtZS5nc3ViKFwiQnJvd3Nlcjo6XCIsXCJcIil9OiAje2luc3BlY3R9PlwiXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgb2Zmc2V0XG4gICMgQHJldHVybiBbT2Zmc2V0XSB0aGUgb2Zmc2V0IG9mIHRoZSBlbGVtZW50XG4gIGRlZiBvZmZzZXQoKnZhbHVlcylcbiAgICBvZmYgPSBPZmZzZXQubmV3KHNlbGYpXG5cbiAgICB1bmxlc3MgdmFsdWVzLmVtcHR5P1xuICAgICAgb2ZmLnNldCgqdmFsdWVzKVxuICAgIGVuZFxuXG4gICAgb2ZmXG4gIGVuZFxuXG4gIGRlZiBvZmZzZXQ9KHZhbHVlKVxuICAgIG9mZnNldC5zZXQoKnZhbHVlKVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIG91dGVyX2h0bWxcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBvdXRlciBIVE1MIG9mIHRoZSBlbGVtZW50XG4gIGRlZiBvdXRlcl9odG1sXG4gICAgYCNAbmF0aXZlLm91dGVySFRNTGBcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gcG9zaXRpb25cbiAgIyBAcmV0dXJuIFtQb3NpdGlvbl0gdGhlIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50XG4gIGRlZiBwb3NpdGlvblxuICAgIEBwb3NpdGlvbiB8fD0gUG9zaXRpb24ubmV3KHNlbGYpXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIHNjcm9sbFxuICAjIEByZXR1cm4gW1Njcm9sbF0gdGhlIHNjcm9sbGluZyBmb3IgdGhlIGVsZW1lbnRcbiAgZGVmIHNjcm9sbFxuICAgIEBzY3JvbGwgfHw9IFNjcm9sbC5uZXcoc2VsZilcbiAgZW5kXG5cbiAgIyBTZWFyY2ggZm9yIGFsbCB0aGUgY2hpbGRyZW4gbWF0Y2hpbmcgdGhlIGdpdmVuIFhQYXRocyBvciBDU1Mgc2VsZWN0b3JzLlxuICAjXG4gICMgQHBhcmFtIHNlbGVjdG9ycyBbQXJyYXk8U3RyaW5nPl0gbWl4ZWQgbGlzdCBvZiBYUGF0aHMgYW5kIENTUyBzZWxlY3RvcnNcbiAgI1xuICAjIEByZXR1cm4gW05vZGVTZXRdXG4gIGRlZiBzZWFyY2goKnNlbGVjdG9ycylcbiAgICBOb2RlU2V0Lm5ldyBzZWxlY3RvcnMubWFwIHt8c2VsZWN0b3J8XG4gICAgICB4cGF0aChzZWxlY3RvcikudG9fYS5jb25jYXQoY3NzKHNlbGVjdG9yKS50b19hKVxuICAgIH0uZmxhdHRlbi51bmlxXG4gIGVuZFxuXG4gIGFsaWFzIHNldCBbXT1cblxuICBhbGlhcyBzZXRfYXR0cmlidXRlIFtdPVxuXG4gICMgQ3JlYXRlcyBvciBhY2Nlc3NlcyB0aGUgc2hhZG93IHJvb3Qgb2YgdGhpcyBlbGVtZW50XG4gICNcbiAgIyBAcGFyYW0gb3BlbiBbQm9vbGVhbl0gc2V0IHRvIGZhbHNlIGlmIHlvdSB3YW50IHRvIGNyZWF0ZSBhIGNsb3NlZFxuICAjICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3cgcm9vdFxuICAjXG4gICMgQHJldHVybiBbU2hhZG93Um9vdF1cbiAgZGVmIHNoYWRvdyAob3BlbiA9IHRydWUpXG4gICAgaWYgcm9vdCA9IGAjQG5hdGl2ZS5zaGFkb3dSb290YFxuICAgICAgRE9NKHJvb3QpXG4gICAgZWxzZVxuICAgICAgRE9NKGAjQG5hdGl2ZS5hdHRhY2hTaGFkb3coe21vZGU6ICN7b3BlbiA/IFwib3BlblwiIDogXCJjbG9zZWRcIn19KWApXG4gICAgZW5kXG4gIGVuZFxuXG4gICMgQ2hlY2tzIGZvciBhIHByZXNlbmNlIG9mIGEgc2hhZG93IHJvb3Qgb2YgdGhpcyBlbGVtZW50XG4gICNcbiAgIyBAcmV0dXJuIFtCb29sZWFuXVxuICBkZWYgc2hhZG93P1xuICAgIGAhISNAbmF0aXZlLnNoYWRvd1Jvb3RgXG4gIGVuZFxuXG4gICMgQG92ZXJsb2FkIHN0eWxlKClcbiAgI1xuICAjICAgUmV0dXJuIHRoZSBzdHlsZSBmb3IgdGhlIGVsZW1lbnQuXG4gICNcbiAgIyAgIEByZXR1cm4gW0NTUzo6RGVjbGFyYXRpb25dXG4gICNcbiAgIyBAb3ZlcmxvYWQgc3R5bGUoZGF0YSlcbiAgI1xuICAjICAgU2V0IHRoZSBDU1Mgc3R5bGUgYXMgc3RyaW5nIG9yIHNldCBvZiB2YWx1ZXMuXG4gICNcbiAgIyAgIEBwYXJhbSBkYXRhIFtTdHJpbmcsIEhhc2hdIHRoZSBuZXcgc3R5bGVcbiAgI1xuICAjICAgQHJldHVybiBbc2VsZl1cbiAgI1xuICAjIEBvdmVybG9hZCBzdHlsZSgmYmxvY2spXG4gICNcbiAgIyAgIFNldCB0aGUgQ1NTIHN0eWxlIGZyb20gYSBDU1MgYnVpbGRlciBEU0wuXG4gICNcbiAgIyAgIEByZXR1cm4gW3NlbGZdXG4gIGRlZiBzdHlsZShkYXRhID0gbmlsLCAmYmxvY2spXG4gICAgc3R5bGUgPSBDU1M6OkRlY2xhcmF0aW9uLm5ldyhgI0BuYXRpdmUuc3R5bGVgKVxuXG4gICAgcmV0dXJuIHN0eWxlIHVubGVzcyBkYXRhIHx8IGJsb2NrXG5cbiAgICBpZiBTdHJpbmcgPT09IGRhdGFcbiAgICAgIHN0eWxlLnJlcGxhY2UoZGF0YSlcbiAgICBlbHNpZiBIYXNoID09PSBkYXRhXG4gICAgICBzdHlsZS5hc3NpZ24oZGF0YSlcbiAgICBlbHNpZiBibG9ja1xuICAgICAgc3R5bGUuYXBwbHkoJmJsb2NrKVxuICAgIGVsc2VcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd1bmtub3duIGRhdGEgdHlwZSdcbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0NTUy5jb21wdXRlZCdcbiAgICBkZWYgc3R5bGUhXG4gICAgICBDU1M6OkRlY2xhcmF0aW9uLm5ldyhgI3t3aW5kb3cudG9fbn0uZ2V0Q29tcHV0ZWRTdHlsZSgjQG5hdGl2ZSwgbnVsbClgKVxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnQ1NTLmN1cnJlbnQnXG4gICAgZGVmIHN0eWxlIVxuICAgICAgQ1NTOjpEZWNsYXJhdGlvbi5uZXcoYCNAbmF0aXZlLmN1cnJlbnRTdHlsZWApXG4gICAgZW5kXG4gIGVsc2VcbiAgICAjIEAhYXR0cmlidXRlIFtyXSBzdHlsZSFcbiAgICAjIEByZXR1cm4gW0NTUzo6RGVjbGFyYXRpb25dIGdldCB0aGUgY29tcHV0ZWQgc3R5bGUgZm9yIHRoZSBlbGVtZW50XG4gICAgZGVmIHN0eWxlIVxuICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgJ2NvbXB1dGVkIHN0eWxlIHVuc3VwcG9ydGVkJ1xuICAgIGVuZFxuICBlbmRcblxuICAjIFJlbW92ZSBhbiBhdHRyaWJ1dGUgZnJvbSB0aGUgZWxlbWVudC5cbiAgI1xuICAjIEBwYXJhbSBuYW1lIFtTdHJpbmddIHRoZSBhdHRyaWJ1dGUgbmFtZVxuICBkZWYgcmVtb3ZlX2F0dHJpYnV0ZShuYW1lKVxuICAgIGAjQG5hdGl2ZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSlgXG4gIGVuZFxuXG4gICMgUmVtb3ZlIGNsYXNzIG5hbWVzIGZyb20gdGhlIGVsZW1lbnQuXG4gICNcbiAgIyBAcGFyYW0gbmFtZXMgW0FycmF5PFN0cmluZz5dIGNsYXNzIG5hbWVzIHRvIHJlbW92ZVxuICAjXG4gICMgQHJldHVybiBbc2VsZl1cbiAgZGVmIHJlbW92ZV9jbGFzcygqbmFtZXMpXG4gICAgY2xhc3NlcyA9IGNsYXNzX25hbWVzIC0gbmFtZXNcblxuICAgIGlmIGNsYXNzZXMuZW1wdHk/XG4gICAgICBgI0BuYXRpdmUucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpYFxuICAgIGVsc2VcbiAgICAgIGAjQG5hdGl2ZS5jbGFzc05hbWUgPSAje2NsYXNzZXMuam9pbiAnICd9YFxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBzaXplXG4gICMgQHJldHVybiBbU2l6ZV0gdGhlIHNpemUgb2YgdGhlIGVsZW1lbnRcbiAgZGVmIHNpemUoKmluYylcbiAgICBTaXplLm5ldyhzZWxmLCAqaW5jKVxuICBlbmRcblxuICAjIFRvZ2dsZSBjbGFzcyBuYW1lcyBvZiB0aGUgZWxlbWVudC5cbiAgI1xuICAjIEBwYXJhbSBuYW1lcyBbQXJyYXk8U3RyaW5nPl0gY2xhc3MgbmFtZXMgdG8gdG9nZ2xlXG4gICNcbiAgIyBAcmV0dXJuIFtzZWxmXVxuICBkZWYgdG9nZ2xlX2NsYXNzKCpuYW1lcylcbiAgICB0b19yZW1vdmUsIHRvX2FkZCA9IG5hbWVzLnBhcnRpdGlvbiB7IHxuYW1lfCBjbGFzc19uYW1lcy5pbmNsdWRlPyBuYW1lIH1cblxuICAgIGFkZF9jbGFzcygqdG9fYWRkKVxuICAgIHJlbW92ZV9jbGFzcygqdG9fcmVtb3ZlKVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIHdpZHRoXG4gICMgQHJldHVybiBbSW50ZWdlcl0gdGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50XG4gIGRlZiB3aWR0aFxuICAgIHNpemUud2lkdGhcbiAgZW5kXG5cbiAgZGVmIHdpZHRoPSh2YWx1ZSlcbiAgICBzaXplLndpZHRoID0gdmFsdWVcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gd2luZG93XG4gICMgQHJldHVybiBbV2luZG93XSB0aGUgd2luZG93IGZvciB0aGUgZWxlbWVudFxuICBkZWYgd2luZG93XG4gICAgZG9jdW1lbnQud2luZG93XG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/KCdRdWVyeS54cGF0aCcpIHx8IEJyb3dzZXIubG9hZGVkPygnd2lja2VkLWdvb2QteHBhdGgnKVxuICAgIGlmIEJyb3dzZXIubG9hZGVkPyAnd2lja2VkLWdvb2QteHBhdGgnXG4gICAgICBgd2d4cGF0aC5pbnN0YWxsKClgXG4gICAgZW5kXG5cbiAgICBkZWYgeHBhdGgocGF0aClcbiAgICAgIE5vZGVTZXRbTmF0aXZlOjpBcnJheS5uZXcoXG4gICAgICAgIGAoI0BuYXRpdmUub3duZXJEb2N1bWVudCB8fCAjQG5hdGl2ZSkuZXZhbHVhdGUocGF0aCxcbiAgICAgICAgICAgI0BuYXRpdmUsIG51bGwsIFhQYXRoUmVzdWx0Lk9SREVSRURfTk9ERV9TTkFQU0hPVF9UWVBFLCBudWxsKWAsXG4gICAgICAgIGdldDogICAgOnNuYXBzaG90SXRlbSxcbiAgICAgICAgbGVuZ3RoOiA6c25hcHNob3RMZW5ndGgpXVxuICAgIHJlc2N1ZSBTdGFuZGFyZEVycm9yLCBKUzo6RXJyb3JcbiAgICAgIE5vZGVTZXRbXVxuICAgIGVuZFxuICBlbHNlXG4gICAgIyBRdWVyeSBmb3IgY2hpbGRyZW4gbWF0Y2hpbmcgdGhlIGdpdmVuIFhQYXRoLlxuICAgICNcbiAgICAjIEBwYXJhbSBwYXRoIFtTdHJpbmddIHRoZSBYUGF0aFxuICAgICNcbiAgICAjIEByZXR1cm4gW05vZGVTZXRdXG4gICAgZGVmIHhwYXRoKHBhdGgpXG4gICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCAncXVlcnkgYnkgWFBhdGggdW5zdXBwb3J0ZWQnXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG5cbnJlcXVpcmUgJ2Jyb3dzZXIvZG9tL2VsZW1lbnQvYXR0cmlidXRlcydcbnJlcXVpcmUgJ2Jyb3dzZXIvZG9tL2VsZW1lbnQvZGF0YSdcbnJlcXVpcmUgJ2Jyb3dzZXIvZG9tL2VsZW1lbnQvcG9zaXRpb24nXG5yZXF1aXJlICdicm93c2VyL2RvbS9lbGVtZW50L29mZnNldCdcbnJlcXVpcmUgJ2Jyb3dzZXIvZG9tL2VsZW1lbnQvc2Nyb2xsJ1xucmVxdWlyZSAnYnJvd3Nlci9kb20vZWxlbWVudC9zaXplJ1xuXG5yZXF1aXJlICdicm93c2VyL2RvbS9lbGVtZW50L2J1dHRvbidcbnJlcXVpcmUgJ2Jyb3dzZXIvZG9tL2VsZW1lbnQvaW1hZ2UnXG5yZXF1aXJlICdicm93c2VyL2RvbS9lbGVtZW50L2Zvcm0nXG5yZXF1aXJlICdicm93c2VyL2RvbS9lbGVtZW50L2lucHV0J1xucmVxdWlyZSAnYnJvd3Nlci9kb20vZWxlbWVudC9zZWxlY3QnXG5yZXF1aXJlICdicm93c2VyL2RvbS9lbGVtZW50L3RlbXBsYXRlJ1xucmVxdWlyZSAnYnJvd3Nlci9kb20vZWxlbWVudC90ZXh0YXJlYSdcbnJlcXVpcmUgJ2Jyb3dzZXIvZG9tL2VsZW1lbnQvaWZyYW1lJ1xucmVxdWlyZSAnYnJvd3Nlci9kb20vZWxlbWVudC9tZWRpYSdcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxtb2R1bGU6RE9NPiIsIjxjbGFzczpFbGVtZW50PiIsImNyZWF0ZSIsInNlbGYiLCJEb2N1bWVudCIsImFyZ3MiLCJmaXJzdCIsImRvY3VtZW50Iiwic2hpZnQiLCIkZG9jdW1lbnQiLCJFbGVtZW50IiwiY3JlYXRlX2VsZW1lbnQiLCJibG9jayIsInRvX3Byb2MiLCJAdGFnX25hbWUiLCJAc2VsZWN0b3IiLCJrd2FyZ3MiLCJIYXNoIiwibGFzdCIsInBvcCIsImN1c3RvbV9hdHRycyIsImN1c3RvbV9pZCIsImN1c3RvbV9jbGFzc2VzIiwidGFnX25hbWUiLCIkcmV0X29yXzEiLCJzY2FuIiwidXBjYXNlIiwiY2xhc3NlcyIsImZsYXR0ZW4iLCJkZWxldGUiLCJ8IiwiaWQiLCJhdHRycyIsIm1hcCIsImJsb2NrIGluIGNyZWF0ZSIsImEiLCJiIiwiXyIsImQiLCJibG9jayAoMiBsZXZlbHMpIGluIGNyZWF0ZSIsInRvX2giLCJtZXJnZSIsInJhaXNlIiwiTm90SW1wbGVtZW50ZWRFcnJvciIsInN1YmNsYXNzZXMiLCJAc3ViY2xhc3NlcyIsImRlZl9zZWxlY3RvciIsInNlbGVjdG9yIiwiPDwiLCI9fiIsIm5ldyIsImxlbmd0aCIsIjEiLCJibG9ja19naXZlbj8iLCJPcGFsIiwibmF0aXZlPyIsIltdIiwiMCIsIm5vZGUiLCJzdWJjbGFzcyIsInNlbGVjdCIsImJsb2NrIGluIG5ldyIsImJsb2NrICgyIGxldmVscykgaW4gbmV3IiwibmF0aXZlX2lzPyIsImluY2x1ZGUiLCJFdmVudDo6VGFyZ2V0IiwiRXZlbnQiLCJ0YXJnZXQiLCJibG9jayBpbiA8Y2xhc3M6RWxlbWVudD4iLCJ2YWx1ZSIsImJsb2NrICgyIGxldmVscykgaW4gPGNsYXNzOkVsZW1lbnQ+IiwiRE9NIiwiU3RhbmRhcmRFcnJvciIsIkpTOjpFcnJvciIsIkpTIiwibmF0aXZlJCIsImtsYXNzIiwiaXMiLCJuYXRpdmVfbWF0Y2hlcz8iLCJCcm93c2VyIiwic3VwcG9ydHM/IiwibG9hZGVkPyIsIkBuYXRpdmUiLCIvIiwiTm9kZVNldCIsInBhdGhzIiwiYmxvY2sgaW4gLyIsInBhdGgiLCJibG9jayAoMiBsZXZlbHMpIGluIC8iLCJ4cGF0aCIsIm5hbWUiLCJvcHRpb25zIiwiYXR0cmlidXRlcyIsImdldCIsIltdPSIsInNldCIsImFkZF9jbGFzcyIsIisiLCJjbGFzc19uYW1lcyIsIm5hbWVzIiwiZW1wdHk/IiwidW5pcSIsImpvaW4iLCJhdCIsInBhdGhfb3Jfc2VsZWN0b3IiLCJjc3MiLCJhdF9jc3MiLCJyZXN1bHQiLCJlYWNoIiwicnVsZXMiLCJibG9jayBpbiBhdF9jc3MiLCJydWxlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBhdF9jc3MiLCJhdF94cGF0aCIsImJsb2NrIGluIGF0X3hwYXRoIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBhdF94cGF0aCIsIkF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVfbm9kZXMiLCJOYXRpdmU6OkFycmF5IiwiTmF0aXZlIiwiYWxpYXNfbmF0aXZlIiwicmVqZWN0Iiwic3BsaXQiLCJjbGljayIsImRhdGEiLCJEYXRhIiwiYXNzaWduIiwiQXJndW1lbnRFcnJvciIsImhlaWdodCIsInNpemUiLCJoZWlnaHQ9IiwiaWQ9IiwidG9fcyIsImlubmVyX2RvbSIsImJ1aWxkZXIiLCJpbm5lcl9kb209IiwiQnVpbGRlciIsInRvX2EiLCJjbGVhciIsImlubmVyX2h0bWwiLCJpbm5lcl9odG1sPSIsImluc3BlY3QiLCJkb3duY2FzZSIsImNsYXNzIiwiZ3N1YiIsIm9mZnNldCIsIm9mZiIsIk9mZnNldCIsInZhbHVlcyIsIm9mZnNldD0iLCJvdXRlcl9odG1sIiwicG9zaXRpb24iLCJAcG9zaXRpb24iLCJQb3NpdGlvbiIsInNjcm9sbCIsIkBzY3JvbGwiLCJTY3JvbGwiLCJzZWFyY2giLCJzZWxlY3RvcnMiLCJibG9jayBpbiBzZWFyY2giLCJibG9jayAoMiBsZXZlbHMpIGluIHNlYXJjaCIsImNvbmNhdCIsInNoYWRvdyIsIm9wZW4iLCJyb290Iiwic2hhZG93PyIsInN0eWxlIiwiQ1NTOjpEZWNsYXJhdGlvbiIsIkNTUyIsIlN0cmluZyIsInJlcGxhY2UiLCJhcHBseSIsInN0eWxlISIsIndpbmRvdyIsInRvX24iLCJyZW1vdmVfYXR0cmlidXRlIiwicmVtb3ZlX2NsYXNzIiwiLSIsIlNpemUiLCJpbmMiLCJ0b2dnbGVfY2xhc3MiLCJwYXJ0aXRpb24iLCJibG9jayBpbiB0b2dnbGVfY2xhc3MiLCJibG9jayAoMiBsZXZlbHMpIGluIHRvZ2dsZV9jbGFzcyIsImluY2x1ZGU/IiwidG9fcmVtb3ZlIiwidG9fYWRkIiwid2lkdGgiLCJ3aWR0aD0iLCJOb2RlIiwicmVxdWlyZSJdLCJtYXBwaW5ncyI6IkFBQUFBLHNDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWhCQSxPQUFBQztNQUFBQTs7UUFBQUE7O0FBQUFBOztRQUNFQyxNQUFJQyxJQUFKRCxhQUFBQSxrQkFMRixFQUtFQTtBQUFBQSxVQUFBQTtBQUFBQTtBQUFBQTtBQUFB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QUFBLFdBQUFBLEVBQWdCNEwsVUFBaEI1TDtJQUZnQkQsR0FBQUEsV0FBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0VBd2xCQUksSUFBQTJMLFNBQUFBLENBQVFoTSxnQ0FBUmdNO0VBQ0EzTCxJQUFBMkwsU0FBQUEsQ0FBUWhNLDBCQUFSZ007RUFDQTNMLElBQUEyTCxTQUFBQSxDQUFRaE0sOEJBQVJnTTtFQUNBM0wsSUFBQTJMLFNBQUFBLENBQVFoTSw0QkFBUmdNO0VBQ0EzTCxJQUFBMkwsU0FBQUEsQ0FBUWhNLDRCQUFSZ007RUFDQTNMLElBQUEyTCxTQUFBQSxDQUFRaE0sMEJBQVJnTTtFQUVBM0wsSUFBQTJMLFNBQUFBLENBQVFoTSw0QkFBUmdNO0VBQ0EzTCxJQUFBMkwsU0FBQUEsQ0FBUWhNLDJCQUFSZ007RUFDQTNMLElBQUEyTCxTQUFBQSxDQUFRaE0sMEJBQVJnTTtFQUNBM0wsSUFBQTJMLFNBQUFBLENBQVFoTSwyQkFBUmdNO0VBQ0EzTCxJQUFBMkwsU0FBQUEsQ0FBUWhNLDRCQUFSZ007RUFDQTNMLElBQUEyTCxTQUFBQSxDQUFRaE0sOEJBQVJnTTtFQUNBM0wsSUFBQTJMLFNBQUFBLENBQVFoTSw4QkFBUmdNO0VBQ0EzTCxJQUFBMkwsU0FBQUEsQ0FBUWhNLDRCQUFSZ007RUFDQWhNLE9BQUFLLElBQUEyTCxTQUFBQSxDQUFRaE0sMkJBQVJnTTtBQXptQkFoTTsifX0seyJvZmZzZXQiOnsibGluZSI6MzU0ODksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9kb2N1bWVudF9vcl9zaGFkb3dfcm9vdC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgbW9kdWxlIERPTVxuXG4jIERvY3VtZW50IGFuZCBTaGFkb3dSb290IGhhdmUgc29tZSBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIGluIGNvbW1vbi5cbiMgVGhpcyBzb2x1dGlvbiBtaW1pY3MgaG93IGl0J3MgZG9uZSBpbiBET00uXG4jXG4jIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RvY3VtZW50T3JTaGFkb3dSb290XG5tb2R1bGUgRG9jdW1lbnRPclNoYWRvd1Jvb3RcbiAgIyBAIWF0dHJpYnV0ZSBbcl0gc3R5bGVfc2hlZXRzXG4gICMgQHJldHVybiBbQXJyYXk8Q1NTOjpTdHlsZVNoZWV0Pl0gdGhlIHN0eWxlIHNoZWV0cyBmb3IgdGhlIGRvY3VtZW50XG4gIGRlZiBzdHlsZV9zaGVldHNcbiAgICBOYXRpdmU6OkFycmF5Lm5ldyhgI0BuYXRpdmUuc3R5bGVTaGVldHNgKSB7fGV8XG4gICAgICBDU1M6OlN0eWxlU2hlZXQubmV3KGUpXG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBzdHlsZXNoZWV0cyBzdHlsZV9zaGVldHNcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPG1vZHVsZTpET00+IiwiPG1vZHVsZTpEb2N1bWVudE9yU2hhZG93Um9vdD4iLCJzdHlsZV9zaGVldHMiLCJuZXciLCJOYXRpdmU6OkFycmF5IiwiTmF0aXZlIiwiQG5hdGl2ZSIsImJsb2NrIGluIHN0eWxlX3NoZWV0cyIsImUiLCJibG9jayAoMiBsZXZlbHMpIGluIHN0eWxlX3NoZWV0cyIsIkNTUzo6U3R5bGVTaGVldCIsIkNTUyJdLCJtYXBwaW5ncyI6IkFBQUFBLHNEQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFNaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7OztBQUdFQyxRQUFBQSw0QkFBQUEsd0JBQUFBO0FBQUFBLFVBQUFBO0FBQUFBOztVQUNFQSxPQUFhQyxNQUFiQyxJQUFBQyxZQUFBRCxVQUFhRCxPQUFBQSxFQUFBQSxDQUFPRyxjQUFPSixZQUFkQyxDQUFBQSxFQUFiSSxhQUE0Q0MsQ0FBNUNEOztZQUE0QztZQUMxQ0UsT0FBQUMsSUFBQUMsU0FBQUQsZUFBZVAsS0FBQUEsQ0FBS0ssQ0FBTEwsRUFEakJJLENBQWFKO1FBRGZELENBQUFBO1FBTUFELE9BQUEsYUFBTSxhQUFOLEVBQWtCLGNBQWxCO01BVEZBLEdBQUFBLFdBQUFBO0lBTmdCRCxHQUFBQSxXQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM1NTI1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9kb20vZG9jdW1lbnQucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBET01cblxuY2xhc3MgRG9jdW1lbnQgPCBFbGVtZW50XG4gIGluY2x1ZGUgRG9jdW1lbnRPclNoYWRvd1Jvb3RcblxuICAjIEdldCB0aGUgZmlyc3QgZWxlbWVudCBtYXRjaGluZyB0aGUgZ2l2ZW4gSUQsIENTUyBzZWxlY3RvciBvciBYUGF0aC5cbiAgI1xuICAjIEBwYXJhbSB3aGF0IFtTdHJpbmddIElELCBDU1Mgc2VsZWN0b3Igb3IgWFBhdGhcbiAgI1xuICAjIEByZXR1cm4gW0VsZW1lbnQ/XSB0aGUgZmlyc3QgbWF0Y2hpbmcgZWxlbWVudFxuICBkZWYgW10od2hhdClcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSAjQG5hdGl2ZS5nZXRFbGVtZW50QnlJZCh3aGF0KTtcblxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gI3tET00oYHJlc3VsdGApfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjc3Mod2hhdCkuZmlyc3QgfHwgeHBhdGgod2hhdCkuZmlyc3RcbiAgZW5kXG5cbiAgYWxpYXMgYXQgW11cblxuICAjIEAhYXR0cmlidXRlIFtyXSBib2R5XG4gICMgQHJldHVybiBbRWxlbWVudD9dIHRoZSBib2R5IGVsZW1lbnQgb2YgdGhlIGRvY3VtZW50XG4gIGRlZiBib2R5XG4gICAgRE9NKGAjQG5hdGl2ZS5ib2R5YClcbiAgcmVzY3VlIEFyZ3VtZW50RXJyb3JcbiAgICByYWlzZSAnJGRvY3VtZW50LmJvZHkgaXMgbm90IGRlZmluZWQ7IHRyeSB0byB3cmFwIHlvdXIgY29kZSBpbiAkZG9jdW1lbnQucmVhZHl7fSdcbiAgZW5kXG5cbiAgIyBDcmVhdGUgYSBuZXcgZWxlbWVudCBmb3IgdGhlIGRvY3VtZW50LlxuICAjXG4gICMgQHBhcmFtIG5hbWUgW1N0cmluZ10gdGhlIG5vZGUgbmFtZVxuICAjIEBwYXJhbSBidWlsZGVyIFtCcm93c2VyOjpET006OkJ1aWxkZXJdIG9wdGlvbmFsIGJ1aWxkZXIgdG8gYXBwZW5kIGVsZW1lbnQgdG9cbiAgIyBAcGFyYW0gb3B0aW9ucyBbU3RyaW5nXSA6bmFtZXNwYWNlIG9wdGlvbmFsIG5hbWVzcGFjZSBuYW1lXG4gICMgQHBhcmFtIG9wdGlvbnMgW1N0cmluZ10gOmlzIG9wdGlvbmFsIFdlYkNvbXBvbmVudHMgaXMgcGFyYW1ldGVyXG4gICMgQHBhcmFtIG9wdGlvbnMgW1N0cmluZ10gOmlkIG9wdGlvbmFsIGlkIHRvIHNldFxuICAjIEBwYXJhbSBvcHRpb25zIFtBcnJheTxTdHJpbmc+XSA6Y2xhc3NlcyBvcHRpb25hbCBjbGFzc2VzIHRvIHNldFxuICAjIEBwYXJhbSBvcHRpb25zIFtIYXNoXSA6YXR0cnMgb3B0aW9uYWwgYXR0cmlidXRlcyB0byBzZXRcbiAgI1xuICAjIEByZXR1cm4gW0VsZW1lbnRdXG4gIGRlZiBjcmVhdGVfZWxlbWVudChuYW1lLCBidWlsZGVyPW5pbCwgKipvcHRpb25zLCAmYmxvY2spXG4gICAgb3B0cyA9IHt9XG5cbiAgICBpZiBvcHRpb25zWzppc10gfHw9IChvcHRpb25zLmRpZyg6YXR0cnMsIDppcykpXG4gICAgICBvcHRzWzppc10gPSBvcHRpb25zWzppc11cbiAgICBlbmRcblxuICAgIGlmIG5zID0gb3B0aW9uc1s6bmFtZXNwYWNlXVxuICAgICAgZWxlbSA9IGAjQG5hdGl2ZS5jcmVhdGVFbGVtZW50TlMoI3tuc30sICN7bmFtZX0sICN7b3B0cy50b19ufSlgXG4gICAgZWxzZVxuICAgICAgZWxlbSA9IGAjQG5hdGl2ZS5jcmVhdGVFbGVtZW50KG5hbWUsICN7b3B0cy50b19ufSlgXG4gICAgZW5kXG5cbiAgICBpZiBvcHRpb25zWzpjbGFzc2VzXVxuICAgICAgYCN7ZWxlbX0uY2xhc3NOYW1lID0gI3tBcnJheShvcHRpb25zWzpjbGFzc2VzXSkuam9pbihcIiBcIil9YFxuICAgIGVuZFxuXG4gICAgaWYgb3B0aW9uc1s6aWRdXG4gICAgICBgI3tlbGVtfS5pZCA9ICN7b3B0aW9uc1s6aWRdfWBcbiAgICBlbmRcblxuICAgIGlmIG9wdGlvbnNbOmF0dHJzXVxuICAgICAgb3B0aW9uc1s6YXR0cnNdLmVhY2ggZG8gfGssdnxcbiAgICAgICAgbmV4dCB1bmxlc3MgdlxuICAgICAgICBgI3tlbGVtfS5zZXRBdHRyaWJ1dGUoI3trfSwgI3t2fSlgXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRvbSA9IERPTShlbGVtKVxuXG4gICAgaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICBkb20uaW5uZXJfZG9tKGJ1aWxkZXIsICZibG9jaylcbiAgICBlbmRcblxuICAgIGlmIGJ1aWxkZXJcbiAgICAgIGJ1aWxkZXIgPDwgZG9tXG4gICAgZW5kXG5cbiAgICBkb21cbiAgZW5kXG5cbiAgIyBDcmVhdGUgYSBuZXcgZG9jdW1lbnQgZnJhZ21lbnQuXG4gICNcbiAgIyBAcmV0dXJuIFtEb2N1bWVudEZyYWdtZW50XVxuICBkZWYgY3JlYXRlX2RvY3VtZW50X2ZyYWdtZW50XG4gICAgRE9NKGAjQG5hdGl2ZS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClgKVxuICBlbmRcblxuICAjIENyZWF0ZSBhIG5ldyB0ZXh0IG5vZGUgZm9yIHRoZSBkb2N1bWVudC5cbiAgI1xuICAjIEBwYXJhbSBjb250ZW50IFtTdHJpbmddIHRoZSB0ZXh0IGNvbnRlbnRcbiAgI1xuICAjIEByZXR1cm4gW1RleHRdXG4gIGRlZiBjcmVhdGVfdGV4dChjb250ZW50KVxuICAgIERPTShgI0BuYXRpdmUuY3JlYXRlVGV4dE5vZGUoI3tjb250ZW50fSlgKVxuICBlbmRcblxuICAjIENyZWF0ZSBhIG5ldyBjb21tZW50IG5vZGUgZm9yIHRoZSBkb2N1bWVudC5cbiAgI1xuICAjIEBwYXJhbSBjb250ZW50IFtTdHJpbmddIHRoZSBjb21tZW50IGNvbnRlbnRcbiAgI1xuICAjIEByZXR1cm4gW0NvbW1lbnRdXG4gIGRlZiBjcmVhdGVfY29tbWVudChjb250ZW50KVxuICAgIERPTShgI0BuYXRpdmUuY3JlYXRlQ29tbWVudCgje2NvbnRlbnR9KWApXG4gIGVuZFxuXG4gIGRlZiBkb2N1bWVudFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gaGVhZFxuICAjIEByZXR1cm4gW0VsZW1lbnQ/XSB0aGUgaGVhZCBlbGVtZW50IG9mIHRoZSBkb2N1bWVudFxuICBkZWYgaGVhZFxuICAgIERPTShgI0BuYXRpdmUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdYClcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBcIiM8RE9NOjpEb2N1bWVudD5cIlxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuYWRkTGlzdGVuZXInXG4gICAgZGVmIHJlYWR5KCZibG9jaylcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICAgIHJldHVybiBibG9jay5jYWxsIGlmIHJlYWR5P1xuXG4gICAgICBvbiAnZG9tOmxvYWQnIGRvIHxlfFxuICAgICAgICBlLm9mZlxuXG4gICAgICAgIGJsb2NrLmNhbGxcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuYXR0YWNoJ1xuICAgIGRlZiByZWFkeSgmYmxvY2spXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnbm8gYmxvY2sgZ2l2ZW4nIHVubGVzcyBibG9ja1xuXG4gICAgICByZXR1cm4gYmxvY2suY2FsbCBpZiByZWFkeT9cblxuICAgICAgb24gJ3JlYWR5OnN0YXRlOmNoYW5nZScgZG8gfGV8XG4gICAgICAgIGlmIHJlYWR5P1xuICAgICAgICAgIGUub2ZmXG5cbiAgICAgICAgICBibG9jay5jYWxsXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVsc2VcbiAgICAjIFdhaXQgZm9yIHRoZSBkb2N1bWVudCB0byBiZSByZWFkeSBhbmQgY2FsbCB0aGUgYmxvY2suXG4gICAgZGVmIHJlYWR5KCZibG9jaylcbiAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsICdkb2N1bWVudCByZWFkeSB1bnN1cHBvcnRlZCdcbiAgICBlbmRcbiAgZW5kXG5cbiAgIyBDaGVjayBpZiB0aGUgZG9jdW1lbnQgaXMgcmVhZHkuXG4gIGRlZiByZWFkeT9cbiAgICBgI0BuYXRpdmUucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8ICNAbmF0aXZlLnJlYWR5U3RhdGUgPT09IFwiaW50ZXJhY3RpdmVcImBcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSByZWZlcnJlclxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIHJlZmVycmluZyBkb2N1bWVudCwgb3IgZW1wdHkgc3RyaW5nIGlmIGRpcmVjdCBhY2Nlc3NcbiAgZGVmIHJlZmVycmVyXG4gICAgYCNAbmF0aXZlLnJlZmVycmVyYFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIHJvb3RcbiAgIyBAcmV0dXJuIFtFbGVtZW50P10gdGhlIHJvb3QgZWxlbWVudCBvZiB0aGUgZG9jdW1lbnRcbiAgZGVmIHJvb3RcbiAgICBET00oYCNAbmF0aXZlLmRvY3VtZW50RWxlbWVudGApXG4gIGVuZFxuXG4gIGRlZiByb290PShlbGVtZW50KVxuICAgIGAjQG5hdGl2ZS5kb2N1bWVudEVsZW1lbnQgPSAje05hdGl2ZS5jb252ZXJ0KGVsZW1lbnQpfWBcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSB0aXRsZVxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIGRvY3VtZW50IHRpdGxlXG4gIGRlZiB0aXRsZVxuICAgIGAjQG5hdGl2ZS50aXRsZWBcbiAgZW5kXG5cbiAgZGVmIHRpdGxlPSh2YWx1ZSlcbiAgICBgI0BuYXRpdmUudGl0bGUgPSB2YWx1ZWBcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gaGlkZGVuP1xuICAjIEByZXR1cm4gW0Jvb2xlYW5dIGlzIHRoZSBwYWdlIGNvbnNpZGVyZWQgaGlkZGVuP1xuICBkZWYgaGlkZGVuP1xuICAgIGAjQG5hdGl2ZS5oaWRkZW5gXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIHZpc2liaWxpdHlcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSB2aXNpYmlsaXR5IHN0YXRlIG9mIHRoZSBkb2N1bWVudCAtIHByZXJlbmRlciwgaGlkZGVuIG9yIHZpc2libGVcbiAgZGVmIHZpc2liaWxpdHlcbiAgICBgI0BuYXRpdmUudmlzaWJpbGl0eVN0YXRlYFxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRG9jdW1lbnQudmlldydcbiAgICBkZWYgd2luZG93XG4gICAgICBXaW5kb3cubmV3KGAjQG5hdGl2ZS5kZWZhdWx0Vmlld2ApXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdEb2N1bWVudC53aW5kb3cnXG4gICAgZGVmIHdpbmRvd1xuICAgICAgV2luZG93Lm5ldyhgI0BuYXRpdmUucGFyZW50V2luZG93YClcbiAgICBlbmRcbiAgZWxzZVxuICAgICMgQCFhdHRyaWJ1dGUgW3JdIHdpbmRvd1xuICAgICMgQHJldHVybiBbV2luZG93XSB0aGUgd2luZG93IGZvciB0aGUgZG9jdW1lbnRcbiAgICBkZWYgd2luZG93XG4gICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCAnd2luZG93IGZyb20gZG9jdW1lbnQgdW5zdXBwb3J0ZWQnXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8bW9kdWxlOkRPTT4iLCI8Y2xhc3M6RG9jdW1lbnQ+Iiwic2VsZiIsImluY2x1ZGUiLCJEb2N1bWVudE9yU2hhZG93Um9vdCIsIltdIiwid2hhdCIsIkBuYXRpdmUiLCJET00iLCIkcmV0X29yXzEiLCJjc3MiLCJmaXJzdCIsInhwYXRoIiwiYm9keSIsIkFyZ3VtZW50RXJyb3IiLCJyYWlzZSIsImNyZWF0ZV9lbGVtZW50IiwibmFtZSIsIm9wdHMiLCJvcHRpb25zIiwiW109IiwiZGlnIiwibnMiLCJlbGVtIiwidG9fbiIsIkFycmF5Iiwiam9pbiIsImVhY2giLCJibG9jayBpbiBjcmVhdGVfZWxlbWVudCIsImsiLCJ2IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjcmVhdGVfZWxlbWVudCIsImRvbSIsImJsb2NrX2dpdmVuPyIsImlubmVyX2RvbSIsImJ1aWxkZXIiLCJibG9jayIsInRvX3Byb2MiLCI8PCIsImNyZWF0ZV9kb2N1bWVudF9mcmFnbWVudCIsImNyZWF0ZV90ZXh0IiwiY29udGVudCIsImNyZWF0ZV9jb21tZW50IiwiZG9jdW1lbnQiLCJoZWFkIiwiaW5zcGVjdCIsIkJyb3dzZXIiLCJzdXBwb3J0cz8iLCJyZWFkeSIsInJlYWR5PyIsImNhbGwiLCJvbiIsImJsb2NrIGluIHJlYWR5IiwiZSIsIm9mZiIsImJsb2NrICgyIGxldmVscykgaW4gcmVhZHkiLCJOb3RJbXBsZW1lbnRlZEVycm9yIiwicmVmZXJyZXIiLCJyb290Iiwicm9vdD0iLCJlbGVtZW50IiwiTmF0aXZlIiwiY29udmVydCIsInRpdGxlIiwidGl0bGU9IiwidmFsdWUiLCJoaWRkZW4/IiwidmlzaWJpbGl0eSIsIndpbmRvdyIsIldpbmRvdyIsIm5ldyIsIkVsZW1lbnQiXSwibWFwcGluZ3MiOiJBQUFBQSx1Q0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWhCQSxPQUFBQztNQUFBQTs7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RjtVQU9FbkUsT0FBQW1FLHNCQUFBQSxrQkFBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUFsRSxJQUFBYSxPQUFBQSxDQUFNeUMseUJBQU4sRUFBMkJZLGtDQUEzQnJEO1VBREZxRCxDQUFBQTtRQVBGO01Bek1GbkUsR0FBQUEsV0FBQUEsRUFBaUJzRSxhQUFqQnRFO0lBRmdCRCxHQUFBQSxXQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM1Nzg0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9kb20vZG9jdW1lbnRfZnJhZ21lbnQucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBET01cblxuIyBUT0RPOiBEb2N1bWVudEZyYWdtZW50IGlzIG5vdCBhIHN1YmNsYXNzIG9mIEVsZW1lbnQsIGJ1dFxuIyAgICAgICBhIHN1YmNsYXNzIG9mIE5vZGUuIEl0IGltcGxlbWVudHMgYSBQYXJlbnROb2RlLlxuI1xuIyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGFsL29wYWwtYnJvd3Nlci9wdWxsLzQ2XG5jbGFzcyBEb2N1bWVudEZyYWdtZW50IDwgRWxlbWVudFxuICBkZWYgc2VsZi5uZXcobm9kZSlcbiAgICBpZiBzZWxmID09IERvY3VtZW50RnJhZ21lbnRcbiAgICAgIGlmIGRlZmluZWQ/IGAje25vZGV9Lm1vZGVgXG4gICAgICAgIFNoYWRvd1Jvb3QubmV3KG5vZGUpXG4gICAgICBlbHNlXG4gICAgICAgIHN1cGVyXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBzdXBlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2VsZi5jcmVhdGVcbiAgICAkZG9jdW1lbnQuY3JlYXRlX2RvY3VtZW50X2ZyYWdtZW50XG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8bW9kdWxlOkRPTT4iLCI8Y2xhc3M6RG9jdW1lbnRGcmFnbWVudD4iLCJuZXciLCJzZWxmIiwibm9kZSIsIkRvY3VtZW50RnJhZ21lbnQiLCJTaGFkb3dSb290IiwiY3JlYXRlIiwiJGRvY3VtZW50IiwiY3JlYXRlX2RvY3VtZW50X2ZyYWdtZW50IiwiRWxlbWVudCJdLCJtYXBwaW5ncyI6IkFBQUFBLGdEQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFNaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7O1FBQ0VDLE1BQUlDLElBQUpELFVBQUFBLGlDQUFhRSxJQUFiRjtBQUFBQSxVQUFBQTs7VUFBQUE7VUFDRSxJQUFBLE1BQUdDLElBQUgsRUFBV0Usc0JBQVgsQ0FBQTtZQUNFLElBQUEsUUFBRyxRQUFZRCxJQUFLRixLQUFqQixrQkFBSCxDQUFBO2NBQ0VBLE9BQUFJLGdCQUFVSixLQUFBQSxDQUFLRSxJQUFMRjtZQURaO2NBR0VBLE9BQUEsT0FBQUMsSUFBQSxFQUFBLDhEQUFBLE9BQUEsRUFBQSxDQUFBQyxJQUFBLENBQUEsRUFBQSxNQUFBO1lBSEY7VUFERjtZQU9FRixPQUFBLE9BQUFDLElBQUEsRUFBQSw4REFBQSxPQUFBLEVBQUEsQ0FBQUMsSUFBQSxDQUFBLEVBQUEsTUFBQTtVQVBGO1FBREZGLENBQUFBO1FBWUFELE9BQUFNLE1BQUlKLElBQUpJLGFBQUFBLGtCQUFBQTtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBQUMsZUFBU0MsMEJBQUFBLENBQUFBO1FBRFhGLENBQUFBO01BYkZOLEdBQUFBLFdBQUFBLEVBQXlCUyxhQUF6QlQ7SUFOZ0JELEdBQUFBLFdBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzU4MjgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9zaGFkb3dfcm9vdC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgbW9kdWxlIERPTVxuXG5jbGFzcyBTaGFkb3dSb290IDwgRG9jdW1lbnRGcmFnbWVudFxuICBpbmNsdWRlIERvY3VtZW50T3JTaGFkb3dSb290XG5cbiAgIyBVc2U6IEVsZW1lbnQjc2hhZG93XG4gIGRlZiBzZWxmLmNyZWF0ZVxuICAgIHJhaXNlIEFyZ3VtZW50RXJyb3JcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxtb2R1bGU6RE9NPiIsIjxjbGFzczpTaGFkb3dSb290PiIsInNlbGYiLCJpbmNsdWRlIiwiRG9jdW1lbnRPclNoYWRvd1Jvb3QiLCJjcmVhdGUiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJEb2N1bWVudEZyYWdtZW50Il0sIm1hcHBpbmdzIjoiQUFBQUEsMENBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUVoQkEsT0FBQUM7TUFBQUE7O1FBQUFBOzs7UUFDRUMsSUFBQUMsU0FBQUEsQ0FBUUMsMEJBQVJEO1FBR0FGLE9BQUFJLE1BQUlILElBQUpHLGFBQUFBLGtCQUFBQTtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBQUgsSUFBQUksT0FBQUEsQ0FBTUMsbUJBQU5EO1FBREZELENBQUFBO01BSkZKLEdBQUFBLFdBQUFBLEVBQW1CTyxzQkFBbkJQO0lBRmdCRCxHQUFBQSxXQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM1ODU5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9kb20vbXV0YXRpb25fb2JzZXJ2ZXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBET01cblxuIyBBIHtNdXRhdGlvbk9ic2VydmVyfSBpcyBhIHBlcmZvcm1hbnQgd2F5IHRvIG9ic2VydmUgY2hhbmdlcyBpbiB0aGUgRE9NLFxuIyBlaXRoZXIgb24gdGhlIHRyZWUsIHRoZSBhdHRyaWJ1dGVzIG9yIGRhdGEuXG4jXG4jIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL011dGF0aW9uT2JzZXJ2ZXJcbmNsYXNzIE11dGF0aW9uT2JzZXJ2ZXJcbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIEJyb3dzZXIuc3VwcG9ydHM/IDpNdXRhdGlvbk9ic2VydmVyXG4gIGVuZFxuXG4gIGluY2x1ZGUgTmF0aXZlOjpXcmFwcGVyXG5cbiAgIyBFbmNhcHN1bGF0ZXMgYSByZWNvcmRlZCBjaGFuZ2UuXG4gIGNsYXNzIFJlY29yZFxuICAgIGluY2x1ZGUgQnJvd3Nlcjo6TmF0aXZlQ2FjaGVkV3JhcHBlclxuXG4gICAgIyBAIWF0dHJpYnV0ZSBbcl0gdHlwZVxuICAgICMgQHJldHVybiBbOmF0dHJpYnV0ZXMsIDp0cmVlLCA6Y2RhdGFdIHRoZSB0eXBlIG9mIHRoZSByZWNvcmRlZCBjaGFuZ2VcbiAgICBkZWYgdHlwZVxuICAgICAgY2FzZSBgI0BuYXRpdmUudHlwZWBcbiAgICAgIHdoZW4gOmF0dHJpYnV0ZXMgICAgdGhlbiA6YXR0cmlidXRlXG4gICAgICB3aGVuIDpjaGlsZExpc3QgICAgIHRoZW4gOnRyZWVcbiAgICAgIHdoZW4gOmNoYXJhY3RlckRhdGEgdGhlbiA6Y2RhdGFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgIyBSZXR1cm5zIHRydWUgaWYgdGhlIGNoYW5nZSBoYXBwZW5lZCBvbiBhdHRyaWJ1dGVzLlxuICAgIGRlZiBhdHRyaWJ1dGU/XG4gICAgICB0eXBlID09IDphdHRyaWJ1dGVcbiAgICBlbmRcblxuICAgICMgUmV0dXJucyB0cnVlIGlmIHRoZSBjaGFuZ2UgaGFwcGVuZWQgb24gdGhlIHRyZWUuXG4gICAgZGVmIHRyZWU/XG4gICAgICB0eXBlID09IDp0cmVlXG4gICAgZW5kXG5cbiAgICAjIFJldHVybnMgdHJ1ZSBpZiB0aGUgY2hhbmdlIGhhcHBlbmVkIGluIGEgQ0RBVEEgc2VjdGlvbi5cbiAgICBkZWYgY2RhdGE/XG4gICAgICB0eXBlID09IDpjZGF0YVxuICAgIGVuZFxuXG4gICAgIyBAIWF0dHJpYnV0ZSBbcl0gYWRkZWRcbiAgICAjIEByZXR1cm4gW05vZGVTZXRdIHRoZSBhZGRlZCBub2Rlc1xuICAgIGRlZiBhZGRlZFxuICAgICAgYXJyYXkgPSBpZiBgI0BuYXRpdmUuYWRkZWROb2RlcyAhPSBudWxsYFxuICAgICAgICBOYXRpdmU6OkFycmF5Lm5ldyhgI0BuYXRpdmUuYWRkZWROb2Rlc2ApXG4gICAgICBlbHNlXG4gICAgICAgIFtdXG4gICAgICBlbmRcblxuICAgICAgTm9kZVNldFthcnJheV1cbiAgICBlbmRcblxuICAgICMgQCFhdHRyaWJ1dGUgW3JdIHJlbW92ZWRcbiAgICAjIEByZXR1cm4gW05vZGVTZXRdIHRoZSByZW1vdmVkIG5vZGVzXG4gICAgZGVmIHJlbW92ZWRcbiAgICAgIGFycmF5ID0gaWYgYCNAbmF0aXZlLnJlbW92ZWROb2RlcyAhPSBudWxsYFxuICAgICAgICBOYXRpdmU6OkFycmF5Lm5ldyhgI0BuYXRpdmUucmVtb3ZlZE5vZGVzYClcbiAgICAgIGVsc2VcbiAgICAgICAgW11cbiAgICAgIGVuZFxuXG4gICAgICBOb2RlU2V0W2FycmF5XVxuICAgIGVuZFxuXG4gICAgIyBAIWF0dHJpYnV0ZSBbcl0gdGFyZ2V0XG4gICAgIyBAcmV0dXJuIFtOb2RlXSB0aGUgbm9kZSB0aGUgbXV0YXRpb24gYWZmZWN0ZWRcbiAgICBkZWYgdGFyZ2V0XG4gICAgICBET00oYCNAbmF0aXZlLnRhcmdldGApXG4gICAgZW5kXG5cbiAgICAjIEAhYXR0cmlidXRlIFtyXSBvbGRcbiAgICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIG9sZCB2YWx1ZVxuICAgIGFsaWFzX25hdGl2ZSA6b2xkLCA6b2xkVmFsdWVcblxuICAgICMgQCFhdHRyaWJ1dGUgW3JdIG5hbWVcbiAgICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgIGFsaWFzX25hdGl2ZSA6bmFtZSwgOmF0dHJpYnV0ZU5hbWVcblxuICAgICMgQCFhdHRyaWJ1dGUgW3JdIG5hbWVzcGFjZVxuICAgICMgQHJldHVybiBbU3RyaW5nXSB0aGUgbmFtZXNwYWNlIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICBhbGlhc19uYXRpdmUgOm5hbWVzcGFjZSwgOmF0dHJpYnV0ZU5hbWVzcGFjZVxuICBlbmRcblxuICAjIENyZWF0ZSBhIG5ldyBNdXRhdGlvbk9ic2VydmVyIHdpdGggdGhlIGdpdmVuIGJsb2NrLlxuICAjXG4gICMgQHlpZWxkcGFyYW0gcmVjb3JkcyBbQXJyYXk8UmVjb3JkPl0gdGhlIHJlY29yZGVkIGNoYW5nZXNcbiAgZGVmIGluaXRpYWxpemUoJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIGZ1bmMgPSBmdW5jdGlvbihyZWNvcmRzKSB7XG4gICAgICAgIHJldHVybiAje2Jsb2NrLmNhbGwoYHJlY29yZHNgLm1hcCB7IHxyfCBCcm93c2VyOjpET006Ok11dGF0aW9uT2JzZXJ2ZXI6OlJlY29yZC5uZXcocikgfSl9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHN1cGVyKGBuZXcgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIoZnVuYylgKVxuICBlbmRcblxuICAjIE9ic2VydmUgdGhlIGdpdmVuIHRhcmdldCB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuICAjXG4gICMgVGhlIHN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAgI1xuICAjICsgKipjaGlsZHJlbioqIC0gd2hldGhlciB0byBvYnNlcnZlIGNoYW5nZXMgb24gdGhlIGNoaWxkcmVuXG4gICMgICBvZiB0aGUgdGFyZ2V0IG9yIG5vdFxuICAjICsgKip0cmVlKiogLSB3aGV0aGVyIHRvIG9ic2VydmUgY2hhbmdlcyBvbiB0aGUgd2hvbGUgc3VidHJlZVxuICAjICAgb3Igbm90XG4gICMgKyAqKmF0dHJpYnV0ZXMqKiAtIHdoZXRoZXIgdG8gb2JzZXJ2ZSBjaGFuZ2VzIHRvIGF0dHJpYnV0ZXMgb3Igbm90LFxuICAjICAgaWYgdGhlIHZhbHVlIGlzIGA6b2xkYCB0aGUgb2xkIHZhbHVlIHdpbGwgYmUgc2F2ZWRcbiAgIyArICoqY2RhdGEqKiAtIHdoZXRoZXIgdG8gb2JzZXJ2ZSBjaGFuZ2VzIHRvIENEQVRBIHNlY3Rpb25zIG9yIG5vdCxcbiAgIyAgIGlmIHRoZSB2YWx1ZSBpcyBgOm9sZGAgdGhlIG9sZCB2YWx1ZSB3aWxsIGJlIHNhdmVkXG4gICMgKyAqKmZpbHRlcioqIC0gYXJyYXkgb2YgYXR0cmlidXRlIG5hbWVzIHRvIG9ic2VydmVcbiAgI1xuICAjIEBwYXJhbSB0YXJnZXQgW0RPTTo6Tm9kZSwgbmF0aXZlXSB0aGUgbm9kZSB0byBvYnNlcnZlXG4gICMgQHBhcmFtIG9wdGlvbnMgW0hhc2g/XSB0aGUgb3B0aW9uc1xuICBkZWYgb2JzZXJ2ZSh0YXJnZXQsIG9wdGlvbnMgPSBuaWwpXG4gICAgdW5sZXNzIG9wdGlvbnNcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIGNoaWxkcmVuOiAgIHRydWUsXG4gICAgICAgIHRyZWU6ICAgICAgIHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IDpvbGQsXG4gICAgICAgIGNkYXRhOiAgICAgIDpvbGRcbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGAjQG5hdGl2ZS5vYnNlcnZlKCN7TmF0aXZlLmNvbnZlcnQodGFyZ2V0KX0sICN7Y29udmVydChvcHRpb25zKX0pYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICAjIEVtcHR5IHRoZSBvYnNlcnZlciBxdWV1ZSBhbmQgcmV0dXJuIGl0cyBjb250ZW50cy5cbiAgI1xuICAjIEByZXR1cm4gW0FycmF5PFJlY29yZD5dXG4gIGRlZiB0YWtlXG4gICAgYCNAbmF0aXZlLnRha2VSZWNvcmRzKClgLm1hcCB7IHxyfCBSZWNvcmQubmV3KHIpIH1cbiAgZW5kXG5cbiAgIyBEaXNjb25uZWN0IHRoZSBvYnNlcnZlciwgdGh1cyBzdG9wcGluZyBvYnNlcnZpbmcgYW55IGNoYW5nZXMuXG4gIGRlZiBkaXNjb25uZWN0XG4gICAgYCNAbmF0aXZlLmRpc2Nvbm5lY3QoKWBcbiAgZW5kXG5cbnByaXZhdGVcbiAgZGVmIGNvbnZlcnQoaGFzaClcbiAgICBvcHRpb25zID0gTmF0aXZlKGB7fWApXG5cbiAgICBpZiBoYXNoWzpjaGlsZHJlbl1cbiAgICAgIG9wdGlvbnNbOmNoaWxkTGlzdF0gPSB0cnVlXG4gICAgZW5kXG5cbiAgICBpZiBoYXNoWzp0cmVlXVxuICAgICAgb3B0aW9uc1s6c3VidHJlZV0gPSB0cnVlXG4gICAgZW5kXG5cbiAgICBpZiBhdHRycyA9IGhhc2hbOmF0dHJpYnV0ZXNdXG4gICAgICBvcHRpb25zWzphdHRyaWJ1dGVzXSA9IHRydWVcblxuICAgICAgaWYgYXR0cnMgPT0gOm9sZFxuICAgICAgICBvcHRpb25zWzphdHRyaWJ1dGVPbGRWYWx1ZV0gPSB0cnVlXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGlmIGZpbHRlciA9IGhhc2hbOmZpbHRlcl1cbiAgICAgIG9wdGlvbnNbOmF0dHJpYnV0ZUZpbHRlcl0gPSBmaWx0ZXJcbiAgICBlbmRcblxuICAgIGlmIGNkYXRhID0gaGFzaFs6Y2RhdGFdXG4gICAgICBvcHRpb25zWzpjaGFyYWN0ZXJEYXRhXSA9IHRydWVcblxuICAgICAgaWYgY2RhdGEgPT0gOm9sZFxuICAgICAgICBvcHRpb25zWzpjaGFyYWN0ZXJEYXRhT2xkVmFsdWVdID0gdHJ1ZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBvcHRpb25zLnRvX25cbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxtb2R1bGU6RE9NPiIsIjxjbGFzczpNdXRhdGlvbk9ic2VydmVyPiIsInN1cHBvcnRlZD8iLCJzZWxmIiwiQnJvd3NlciIsInN1cHBvcnRzPyIsImluY2x1ZGUiLCJOYXRpdmU6OldyYXBwZXIiLCJOYXRpdmUiLCI8Y2xhc3M6UmVjb3JkPiIsIkJyb3dzZXI6Ok5hdGl2ZUNhY2hlZFdyYXBwZXIiLCJ0eXBlIiwiQG5hdGl2ZSIsImF0dHJpYnV0ZT8iLCI9PSIsInRyZWU/IiwiY2RhdGE/IiwiYWRkZWQiLCJhcnJheSIsIk5hdGl2ZTo6QXJyYXkiLCJuZXciLCJOb2RlU2V0IiwiW10iLCJyZW1vdmVkIiwidGFyZ2V0IiwiRE9NIiwiYWxpYXNfbmF0aXZlIiwiaW5pdGlhbGl6ZSIsImJsb2NrIiwiY2FsbCIsIm1hcCIsImJsb2NrIGluIGluaXRpYWxpemUiLCJyIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbml0aWFsaXplIiwiQnJvd3Nlcjo6RE9NOjpNdXRhdGlvbk9ic2VydmVyOjpSZWNvcmQiLCJCcm93c2VyOjpET006Ok11dGF0aW9uT2JzZXJ2ZXIiLCJCcm93c2VyOjpET00iLCJvYnNlcnZlIiwib3B0aW9ucyIsImNvbnZlcnQiLCJ0YWtlIiwiYmxvY2sgaW4gdGFrZSIsImJsb2NrICgyIGxldmVscykgaW4gdGFrZSIsIlJlY29yZCIsImRpc2Nvbm5lY3QiLCJwcml2YXRlIiwiaGFzaCIsIltdPSIsImF0dHJzIiwiZmlsdGVyIiwiY2RhdGEiLCJ0b19uIl0sIm1hcHBpbmdzIjoiQUFBQUEsZ0RBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQU1oQkEsT0FBQUM7TUFBQUE7O1FBQUFBOztBQUFBQTs7UUFDRUMsTUFBSUMsSUFBSkQsaUJBQUFBLDRDQUFBQTtBQUFBQTtVQUNFQSxPQUFBRSxhQUFPQyxjQUFBQSxDQUFXLGtCQUFYQTtRQURUSCxDQUFBQTtRQUlBQyxJQUFBRyxTQUFBQSxDQUFRQyxJQUFBQyxZQUFBRCxZQUFSRDtRQUdBRztRQUFBQTs7VUFBQUE7O0FBQUFBOztVQUNFTixJQUFBRyxTQUFBQSxDQUFRSSxJQUFBTixhQUFBTSx3QkFBUko7O0FBSUFL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Q0FBSCxDQUFBO1lBQ0VYLE9BQU9TLFFBQUFBLENBQUMsaUJBQVIsRUFBNEJFLE1BQXJCRjtVQURUO1VBSUEsSUFBQSxRQUFHRyxDQUFBQSxRQUFRSixJQUFJeEIsT0FBQUEsQ0FBQyxPQUFEQSxDQUFaNEIsQ0FBSCxDQUFBOztZQUNFWixPQUFPUyxRQUFBQSxDQUFDLGVBQVIsRUFBMEIsSUFBbkJBO1lBRVAsSUFBQSxNQUFHRyxLQUFILEVBQVksS0FBWixDQUFBO2NBQ0VaLE9BQU9TLFFBQUFBLENBQUMsdUJBQVIsRUFBa0MsSUFBM0JBO1lBRFQ7VUFIRjtVQVFBUixPQUFBRCxPQUFPYSxNQUFBQSxDQUFBQTtRQS9CVFosQ0FBQUE7TUF4SUZ0QyxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtJQU5nQkQsR0FBQUEsV0FBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozNjAzMywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZG9tLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2Jyb3dzZXIvZG9tL25vZGVfc2V0J1xucmVxdWlyZSAnYnJvd3Nlci9kb20vbm9kZSdcbnJlcXVpcmUgJ2Jyb3dzZXIvZG9tL2F0dHJpYnV0ZSdcbnJlcXVpcmUgJ2Jyb3dzZXIvZG9tL2NoYXJhY3Rlcl9kYXRhJ1xucmVxdWlyZSAnYnJvd3Nlci9kb20vdGV4dCdcbnJlcXVpcmUgJ2Jyb3dzZXIvZG9tL2NkYXRhJ1xucmVxdWlyZSAnYnJvd3Nlci9kb20vY29tbWVudCdcbnJlcXVpcmUgJ2Jyb3dzZXIvZG9tL2VsZW1lbnQnXG5yZXF1aXJlICdicm93c2VyL2RvbS9kb2N1bWVudF9vcl9zaGFkb3dfcm9vdCdcbnJlcXVpcmUgJ2Jyb3dzZXIvZG9tL2RvY3VtZW50J1xucmVxdWlyZSAnYnJvd3Nlci9kb20vZG9jdW1lbnRfZnJhZ21lbnQnXG5yZXF1aXJlICdicm93c2VyL2RvbS9zaGFkb3dfcm9vdCdcbnJlcXVpcmUgJ2Jyb3dzZXIvZG9tL211dGF0aW9uX29ic2VydmVyJ1xuXG5tb2R1bGUgS2VybmVsXG4gICMgUGFyc2UgYW4gWE1MIHN0cmluZyBpbnRvIGEgRE9NIHVzYWJsZSB7QnJvd3Nlcjo6RE9NOjpEb2N1bWVudH1cbiAgI1xuICAjIEBwYXJhbSB3aGF0IFtTdHJpbmddIHRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgIyBAcmV0dXJuIFtCcm93c2VyOjpET006OkRvY3VtZW50XSB0aGUgZG9jdW1lbnRcbiAgZGVmIFhNTCh3aGF0KVxuICAgICV4e1xuICAgICAgdmFyIGRvYztcblxuICAgICAgaWYgKHdpbmRvdy5ET01QYXJzZXIpIHtcbiAgICAgICAgZG9jID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyh3aGF0LCAndGV4dC94bWwnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBkb2MgICAgICAgPSBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTERPTScpO1xuICAgICAgICBkb2MuYXN5bmMgPSAnZmFsc2UnO1xuICAgICAgICBkb2MubG9hZFhNTCh3aGF0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBET00oYGRvY2ApXG4gIGVuZFxuXG4gICMgQG92ZXJsb2FkIERPTShkb2N1bWVudCA9ICRkb2N1bWVudCwgJmJsb2NrKVxuICAjXG4gICMgICBDcmVhdGUgYSBET00gdHJlZSB1c2luZyB0aGUge1BhZ2dpbzo6SFRNTH0gRFNMLlxuICAjXG4gICMgICBAcGFyYW0gZG9jdW1lbnQgW0Jyb3dzZXI6OkRPTTo6RG9jdW1lbnRdIHRoZSBkb2N1bWVudCBpbnN0YW5jZVxuICAjICAgICB3ZSBpbnRlbmQgdG8gdXNlXG4gICNcbiAgIyAgIEByZXR1cm4gW0Jyb3dzZXI6OkRPTTo6Tm9kZSwgQnJvd3Nlcjo6RE9NOjpOb2RlU2V0XVxuICAjXG4gICMgQG92ZXJsb2FkIERPTShzdHJpbmcsIGRvY3VtZW50ID0gJGRvY3VtZW50KVxuICAjXG4gICMgICBDcmVhdGUgYSBET00gdHJlZSBmcm9tIGEgSFRNTCBzdHJpbmcuXG4gICNcbiAgIyAgIEBwYXJhbSBzdHJpbmcgW1N0cmluZ10gdGhlIEhUTUwgc3RyaW5nXG4gICMgICBAcGFyYW0gZG9jdW1lbnQgW0Jyb3dzZXI6OkRPTTo6RG9jdW1lbnRdIHRoZSBkb2N1bWVudCBpbnN0YW5jZVxuICAjICAgICB3ZSBpbnRlbmQgdG8gdXNlXG4gICNcbiAgIyAgIEByZXR1cm4gW0Jyb3dzZXI6OkRPTTo6Tm9kZV1cbiAgI1xuICAjIEBvdmVybG9hZCBET00obmF0aXZlKVxuICAjXG4gICMgICBXcmFwIGEgbmF0aXZlIGVsZW1lbnQgdG8gY3JlYXRlIGEgRE9NIHRyZWUuXG4gICNcbiAgIyAgIEBwYXJhbSBuYXRpdmUgW05hdGl2ZV0gdGhlIE5hdGl2ZSBub2RlXG4gICNcbiAgIyAgIEByZXR1cm4gW0Jyb3dzZXI6OkRPTTo6Tm9kZV1cbiAgI1xuICBkZWYgRE9NKCphcmdzLCAmYmxvY2spXG4gICAgaWYgYmxvY2tcbiAgICAgIGRvY3VtZW50ID0gYXJncy5zaGlmdCB8fCAkZG9jdW1lbnRcbiAgICAgIHJvb3RzICAgID0gQnJvd3Nlcjo6RE9NOjpCdWlsZGVyLm5ldyhkb2N1bWVudCwgJmJsb2NrKS50b19hXG5cbiAgICAgIGlmIHJvb3RzLmxlbmd0aCA9PSAxXG4gICAgICAgIHJvb3RzLmZpcnN0XG4gICAgICBlbHNlXG4gICAgICAgIEJyb3dzZXI6OkRPTTo6Tm9kZVNldC5uZXcocm9vdHMpXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICB3aGF0ICAgICA9IGFyZ3Muc2hpZnRcbiAgICAgIGRvY3VtZW50ID0gYXJncy5zaGlmdCB8fCAkZG9jdW1lbnRcblxuICAgICAgd2hhdCA9IHdoYXQudG9fZG9tKGRvY3VtZW50KSBpZiBPcGFsLnJlc3BvbmRfdG8/IHdoYXQsIDp0b19kb21cblxuICAgICAgaWYgYHR5cGVvZigje3doYXR9KSA9PT0gJ3VuZGVmaW5lZCcgfHwgI3t3aGF0fSA9PT0gbnVsbGBcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2FyZ3VtZW50IGlzIG51bGwnXG4gICAgICBlbHNpZiBuYXRpdmU/KHdoYXQpXG4gICAgICAgIEJyb3dzZXI6OkRPTTo6Tm9kZS5uZXcod2hhdClcbiAgICAgIGVsc2lmIEJyb3dzZXI6OkRPTTo6Tm9kZSA9PT0gd2hhdFxuICAgICAgICB3aGF0XG4gICAgICBlbHNpZiBPcGFsLnJlc3BvbmRfdG8/IHdoYXQsIDplYWNoICMgZWcuIE5vZGVTZXQsIEFycmF5XG4gICAgICAgIGRvY3VtZW50LmNyZWF0ZV9lbGVtZW50KFwiRElWXCIpLnRhcCBkbyB8ZGl2fFxuICAgICAgICAgIGRpdiA8PCB3aGF0XG4gICAgICAgIGVuZFxuICAgICAgZWxzaWYgU3RyaW5nID09PSB3aGF0XG4gICAgICAgICV4e1xuICAgICAgICAgIHZhciBkb2MgPSAje05hdGl2ZS50cnlfY29udmVydChkb2N1bWVudCl9LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIGRvYy5pbm5lckhUTUwgPSB3aGF0O1xuXG4gICAgICAgICAgcmV0dXJuICN7RE9NKGBkb2MuY2hpbGROb2Rlcy5sZW5ndGggPT0gMSA/IGRvYy5jaGlsZE5vZGVzWzBdIDogZG9jYCl9O1xuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdhcmd1bWVudCBpcyBub3QgRE9NIGNvbnZlcnRpYmxlJ1xuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBCcm93c2VyXG5cbmNsYXNzIFdpbmRvd1xuICAjIEdldCB0aGUge0RPTTo6RG9jdW1lbnR9IGZvciB0aGlzIHdpbmRvdy5cbiAgI1xuICAjIEByZXR1cm4gW0RPTTo6RG9jdW1lbnRdXG4gIGRlZiBkb2N1bWVudFxuICAgIERPTShgI0BuYXRpdmUuZG9jdW1lbnRgKVxuICBlbmRcbmVuZFxuXG5lbmRcblxuJGRvY3VtZW50ID0gJHdpbmRvdy5kb2N1bWVudFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxtb2R1bGU6S2VybmVsPiIsIlhNTCIsIndoYXQiLCJET00iLCJibG9jayIsImRvY3VtZW50IiwiJHJldF9vcl8xIiwiYXJncyIsInNoaWZ0IiwiJGRvY3VtZW50Iiwicm9vdHMiLCJuZXciLCJCcm93c2VyOjpET006OkJ1aWxkZXIiLCJCcm93c2VyOjpET00iLCJCcm93c2VyIiwidG9fcHJvYyIsInRvX2EiLCJsZW5ndGgiLCIxIiwiZmlyc3QiLCJCcm93c2VyOjpET006Ok5vZGVTZXQiLCJPcGFsIiwicmVzcG9uZF90bz8iLCJ0b19kb20iLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJuYXRpdmU/IiwiQnJvd3Nlcjo6RE9NOjpOb2RlIiwidGFwIiwiY3JlYXRlX2VsZW1lbnQiLCJibG9jayBpbiBET00iLCJkaXYiLCJibG9jayAoMiBsZXZlbHMpIGluIERPTSIsIjw8IiwiU3RyaW5nIiwiTmF0aXZlIiwidHJ5X2NvbnZlcnQiLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOldpbmRvdz4iLCJAbmF0aXZlIiwiJHdpbmRvdyJdLCJtYXBwaW5ncyI6IkFBQUFBLDhCQUFBQSxnQkFBQUE7RUFBQUE7QUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixzQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsa0JBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLHVCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRiw0QkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsa0JBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLG1CQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixxQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYscUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLHFDQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixzQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsK0JBQVJFO0VBQ0FELElBQUFD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O0lBQUFBOztJQUVBQSxPQUFBQztJQUFBQTs7TUFBQUE7O0FBQUFBO01BSUVBLE9BQUFqQyx3QkFBQUEsb0JBQUFBO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFBUCxJQUFBSyxLQUFBQSxDQUFNb0MsY0FBT2xDLFNBQWJGO01BREZFLENBQUFBO0lBSkZpQyxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQUZBRCxHQUFBQSxXQUFBQTtFQWFBeEMsT0FBQVksQ0FBQUEsa0JBQVkrQixhQUFPbkMsVUFBQUEsQ0FBQUEsQ0FBbkJJO0FBcEhBWjsifX0seyJvZmZzZXQiOnsibGluZSI6MzYxNDcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2Nzcy9kZWNsYXJhdGlvbi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgbW9kdWxlIENTU1xuXG5jbGFzcyBEZWNsYXJhdGlvblxuICBpbmNsdWRlIEJyb3dzZXI6Ok5hdGl2ZUNhY2hlZFdyYXBwZXJcbiAgaW5jbHVkZSBFbnVtZXJhYmxlXG5cbiAgZGVmIHJ1bGVcbiAgICBSdWxlLm5ldyhgI0BuYXRpdmUucGFyZW50UnVsZWApIGlmIGRlZmluZWQ/KGAjQG5hdGl2ZS5wYXJlbnRSdWxlYClcbiAgZW5kXG5cbiAgZGVmIGFzc2lnbihkYXRhKVxuICAgIGRhdGEuZWFjaCB7fG5hbWUsIHZhbHVlfFxuICAgICAgc2VsZltuYW1lXSA9IHZhbHVlXG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmVwbGFjZShzdHJpbmcpXG4gICAgYCNAbmF0aXZlLmNzc1RleHQgPSAje3N0cmluZ31gXG4gIGVuZFxuXG4gIGRlZiBhcHBseSgmYmxvY2spXG4gICAgUGFnZ2lvOjpDU1M6OkRlZmluaXRpb24ubmV3KCZibG9jaykuZWFjaCB7fHN0eWxlfFxuICAgICAgaWYgc3R5bGUuaW1wb3J0YW50XG4gICAgICAgIGAjQG5hdGl2ZS5zZXRQcm9wZXJ0eSgje3N0eWxlLm5hbWV9LCAje3N0eWxlLnZhbHVlfSwgXCJpbXBvcnRhbnRcIilgXG4gICAgICBlbHNlXG4gICAgICAgIGAjQG5hdGl2ZS5zZXRQcm9wZXJ0eSgje3N0eWxlLm5hbWV9LCAje3N0eWxlLnZhbHVlfSwgXCJcIilgXG4gICAgICBlbmRcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWxldGUobmFtZSlcbiAgICBgI0BuYXRpdmUucmVtb3ZlUHJvcGVydHkoI3tuYW1lfSlgXG4gIGVuZFxuXG4gIGRlZiBbXShuYW1lKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9ICNAbmF0aXZlLmdldFByb3BlcnR5VmFsdWUoI3tuYW1lfSk7XG5cbiAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCB8fCByZXN1bHQgPT09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBbXT0obmFtZSwgdmFsdWUpXG4gICAgYCNAbmF0aXZlLnNldFByb3BlcnR5KCN7bmFtZX0sICN7dmFsdWUudG9fc30sIFwiXCIpYFxuICBlbmRcblxuICBkZWYgaW1wb3J0YW50PyhuYW1lKVxuICAgIGAjQG5hdGl2ZS5nZXRQcm9wZXJ0eVByaW9yaXR5KCN7bmFtZX0pID09IFwiaW1wb3J0YW50XCJgXG4gIGVuZFxuXG4gIGRlZiBlYWNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmVhY2ggdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gI0BuYXRpdmUubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5hbWUgID0gI0BuYXRpdmUuaXRlbShpKTtcblxuICAgICAgICAje3lpZWxkIGBuYW1lYCwgc2VsZltgbmFtZWBdfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgYWxpYXNfbmF0aXZlIDpsZW5ndGhcbiAgYWxpYXNfbmF0aXZlIDp0b19zLCA6Y3NzVGV4dFxuXG4gIGRlZiBtZXRob2RfbWlzc2luZyhuYW1lLCB2YWx1ZSA9IG5pbClcbiAgICBpZiBuYW1lLmVuZF93aXRoPyA/PVxuICAgICAgc2VsZltuYW1lWzAgLi4gLTJdXSA9IHZhbHVlXG4gICAgZWxzZVxuICAgICAgc2VsZltuYW1lXVxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPG1vZHVsZTpDU1M+IiwiPGNsYXNzOkRlY2xhcmF0aW9uPiIsInNlbGYiLCJpbmNsdWRlIiwiQnJvd3Nlcjo6TmF0aXZlQ2FjaGVkV3JhcHBlciIsIkJyb3dzZXIiLCJFbnVtZXJhYmxlIiwicnVsZSIsIkBuYXRpdmUiLCJSdWxlIiwibmV3IiwiYXNzaWduIiwiZGF0YSIsImVhY2giLCJibG9jayBpbiBhc3NpZ24iLCJuYW1lIiwidmFsdWUiLCJibG9jayAoMiBsZXZlbHMpIGluIGFzc2lnbiIsIltdPSIsInJlcGxhY2UiLCJzdHJpbmciLCJhcHBseSIsIlBhZ2dpbzo6Q1NTOjpEZWZpbml0aW9uIiwiUGFnZ2lvOjpDU1MiLCJQYWdnaW8iLCJibG9jayIsInRvX3Byb2MiLCJibG9jayBpbiBhcHBseSIsInN0eWxlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBhcHBseSIsImltcG9ydGFudCIsImRlbGV0ZSIsIltdIiwidG9fcyIsImltcG9ydGFudD8iLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsImFsaWFzX25hdGl2ZSIsIm1ldGhvZF9taXNzaW5nIiwiZW5kX3dpdGg/IiwiMCIsIi0yIl0sIm1hcHBpbmdzIjoiQUFBQUEsMENBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUVoQkEsT0FBQUM7TUFBQUE7O1FBQUFBOztBQUFBQTs7UUFDRUMsSUFBQUMsU0FBQUEsQ0FBUUMsSUFBQUMs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SUFBQW1DLGNBQUFBLENBQWEsTUFBYixFQUFvQixTQUFwQkE7UUFFQXBDLE9BQUFxQyw4QkFBQUEsMEJBQW1CdkIsSUFBRCxFQUFPQyxLQUF6QnNCO0FBQUFBLFVBQUFBOzs7VUFBeUIsMkJBQVE7VUFDL0IsSUFBQSxRQUFHdkIsSUFBSXdCLGNBQUFBLENBQVdELEdBQVhDLENBQVAsQ0FBQTtZQUNFRCxPQUFJcEIsTUFBQUEsQ0FBQ0gsSUFBSWlCLE9BQUFBLENBQUMsT0FBQVEsQ0FBQSxFQUFLQyxFQUFMLFFBQURULENBQVQsRUFBc0JoQixLQUFsQkUsQ0FBQUEsRUFBQUEsTUFBSmhCLElBQUlnQixPQUFBQSxFQUFBQSxFQUFBQSxDQUFBQSxFQUFBQTtVQUROO1lBR0VvQixPQUFBcEMsSUFBSThCLE9BQUFBLENBQUNqQixJQUFEaUI7VUFITjtRQURGTSxDQUFBQSxJQUFBQTtNQXZFRnJDLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0lBRmdCRCxHQUFBQSxXQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM2Mjg2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9jc3Mvc3R5bGVfc2hlZXQucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBDU1NcblxuY2xhc3MgU3R5bGVTaGVldFxuICBpbmNsdWRlIEJyb3dzZXI6Ok5hdGl2ZUNhY2hlZFdyYXBwZXJcblxuICBkZWYgaW5pdGlhbGl6ZSh3aGF0KVxuICAgIGlmIERPTTo6RWxlbWVudCA9PT0gd2hhdFxuICAgICAgc3VwZXIoYCN7d2hhdC50b19ufS5zaGVldGApXG4gICAgZWxzZVxuICAgICAgc3VwZXIod2hhdClcbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXNfbmF0aXZlIDpkaXNhYmxlZD8sIDpkaXNhYmxlZFxuICBhbGlhc19uYXRpdmUgOmhyZWZcbiAgYWxpYXNfbmF0aXZlIDp0aXRsZVxuICBhbGlhc19uYXRpdmUgOnR5cGVcblxuICBkZWYgbWVkaWFcbiAgICBNZWRpYS5uZXcoYCNAbmF0aXZlLm1lZGlhYCkgaWYgYCNAbmF0aXZlLm1lZGlhICE9IG51bGxgXG4gIGVuZFxuXG4gIGRlZiBvd25lclxuICAgIERPTShgI0BuYXRpdmUub3duZXJOb2RlYClcbiAgZW5kXG5cbiAgZGVmIHBhcmVudFxuICAgIFNoZWV0Lm5ldyhgI0BuYXRpdmUucGFyZW50U3R5bGVTaGVldGApIGlmIGAjQG5hdGl2ZS5wYXJlbnRTdHlsZVNoZWV0ICE9IG51bGxgXG4gIGVuZFxuXG4gIGRlZiBydWxlc1xuICAgIE5hdGl2ZTo6QXJyYXkubmV3KGAjQG5hdGl2ZS5jc3NSdWxlc2ApIHsgfGV8XG4gICAgICBSdWxlLm5ldyhlKVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZShpbmRleClcbiAgICBgI0BuYXRpdmUuZGVsZXRlUnVsZShpbmRleClgXG4gIGVuZFxuXG4gIGRlZiBpbnNlcnQoaW5kZXgsIHJ1bGUpXG4gICAgYCNAbmF0aXZlLmluc2VydFJ1bGUoI3tydWxlfSwgI3tpbmRleH0pYFxuICBlbmRcblxuICBkZWYgcnVsZShzZWxlY3RvciwgYm9keSlcbiAgICB1bmxlc3MgU3RyaW5nID09PSBzZWxlY3RvclxuICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5qb2luICcsICdcbiAgICBlbmRcblxuICAgIHVubGVzcyBTdHJpbmcgPT09IGJvZHlcbiAgICAgIGJvZHkgPSBib2R5Lm1hcCB7fG5hbWUsIHZhbHVlfFxuICAgICAgICBcIiN7bmFtZX06ICN7dmFsdWV9O1wiXG4gICAgICB9LmpvaW4gXCJcXG5cIlxuICAgIGVuZFxuXG4gICAgaW5zZXJ0KGxlbmd0aCwgXCIje3NlbGVjdG9yfSB7ICN7Ym9keX0gfVwiKVxuICBlbmRcblxuICBkZWYgW10oaWQpXG4gICAgcnVsZXMuZmluZCB7IHxyfCBsb2cgcjsgci5pZCA9PSBpZCB9XG4gIGVuZFxuXG4gIGRlZiBtZXRob2RfbWlzc2luZygqYXJncywgJmJsb2NrKVxuICAgIHJ1bGVzLl9fc2VuZF9fKCphcmdzLCAmYmxvY2spXG4gIGVuZFxuXG4gIGNsYXNzIE1lZGlhIDwgTmF0aXZlOjpBcnJheVxuICAgIGFsaWFzX25hdGl2ZSA6dGV4dCwgOm1lZGlhVGV4dFxuICAgIGFsaWFzX25hdGl2ZSA6dG9fcywgOm1lZGlhVGV4dFxuXG4gICAgZGVmIHB1c2gobWVkaXVtKVxuICAgICAgYCNAbmF0aXZlLmFwcGVuZE1lZGl1bSgje21lZGl1bX0pYFxuXG4gICAgICBzZWxmXG4gICAgZW5kXG5cbiAgICBkZWYgZGVsZXRlKG1lZGl1bSlcbiAgICAgIGAjQG5hdGl2ZS5kZWxldGVNZWRpdW0oI3ttZWRpdW19KWBcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxtb2R1bGU6Q1NTPiIsIjxjbGFzczpTdHlsZVNoZWV0PiIsInNlbGYiLCJpbmNsdWRlIiwiQnJvd3Nlcjo6TmF0aXZlQ2FjaGVkV3JhcHBlciIsIkJyb3dzZXIiLCJpbml0aWFsaXplIiwid2hhdCIsIkRPTTo6RWxlbWVudCIsIkRPTSIsInRvX24iLCJhbGlhc19uYXRpdmUiLCJtZWRpYSIsIkBuYXRpdmUiLCJNZWRpYSIsIm5ldyIsIm93bmVyIiwicGFyZW50IiwiU2hlZXQiLCJydWxlcyIsIk5hdGl2ZTo6QXJyYXkiLCJOYXRpdmUiLCJibG9jayBpbiBydWxlcyIsImUiLCJibG9jayAoMiBsZXZlbHMpIGluIHJ1bGVzIiwiUnVsZSIsImRlbGV0ZSIsImluZGV4IiwiaW5zZXJ0IiwicnVsZSIsInNlbGVjdG9yIiwiYm9keSIsIlN0cmluZyIsImpvaW4iLCJtYXAiLCJibG9jayBpbiBydWxlIiwibmFtZSIsInZhbHVlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBydWxlIiwibGVuZ3RoIiwiW10iLCJpZCIsImZpbmQiLCJibG9jayBpbiBbXSIsInIiLCJibG9jayAoMiBsZXZlbHMpIGluIFtdIiwibG9nIiwiPT0iLCJtZXRob2RfbWlzc2luZyIsIl9fc2VuZF9fIiwiYXJncyIsImJsb2NrIiwidG9fcHJvYyIsIjxjbGFzczpNZWRpYT4iLCJwdXNoIiwibWVkaXVtIl0sIm1hcHBpbmdzIjoiQUFBQUEsMENBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUVoQkEsT0FBQUM7TUFBQUE7O1FBQUFBOztBQUFBQTs7UUFDRUMsSUFBQUMsU0FBQUEsQ0FBUUMsSUFBQUMsYUFBQUQsd0JBQVJEOztBQUVBRyxRQUFBQSwwQkFBQUEsc0JBQWVDLElBQWZEO0FBQUFBLFVBQUFBOztVQUFBQTtVQUNFLElBQUEsUUFBR0UsSUFBQUMsU0FBQUQsWUFBSCxFQUFvQkQsSUFBcEIsQ0FBQTtZQUNFRCxPQUFBLE9BQUFKLElBQUEsRUFBQSwwREFBQSxjQUFBLEVBQUEsQ0FBU0ssSUFBSUcsTUFBQUEsQ0FBQUEsQ0FBTUosTUFBbkIsQ0FBQSxFQUFBLElBQUE7VUFERjtZQUdFQSxPQUFBLE9BQUFKLElBQUEsRUFBQSwwREFBQSxjQUFBLEVBQUEsQ0FBTUssSUFBTixDQUFBLEVBQUEsSUFBQTtVQUhGO1FBREZELENBQUFBO1FBUUFKLElBQUFTLGNBQUFBLENBQWEsV0FBYixFQUF5QixVQUF6QkE7UUFDQVQsSUFBQVMsY0FBQUEsQ0FBYSxNQUFiQTtRQUNBVCxJQUFBUyxjQUFBQSxDQUFhLE9BQWJBO1FBQ0FULElBQUFTLGNBQUFBLENBQWEsTUFBYkE7O0FBRUFDLFFBQUFBLHFCQUFBQSxpQkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0UsSUFBQSxRQUFpQ0MsY0FBT0QsY0FBeEMsQ0FBQTtZQUFBQSxPQUFBRSxXQUFLQyxLQUFBQSxDQUFPRixjQUFPRCxNQUFkRztVQUFMO1lBbkJKSCxPQUFBO1VBbUJJO1FBREZBLENBQUFBOztBQUlBSSxRQUFBQSxxQkFBQUEsaUJBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBZCxJQUFBTyxLQUFB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QUEseUJBQVc2QixNQUFYN0I7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUViLGNBQU9hLGNBQWdCNkIsTUFBTzdCO1VBRGxDQSxDQUFBQTtRQVZGMkIsR0FBQUEsV0FBQUEsRUFBY2pDLElBQUFDLFlBQUFELFVBQWRpQztNQWhFRnBELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0lBRmdCRCxHQUFBQSxXQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM2NDM3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9jc3MvcnVsZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgbW9kdWxlIENTU1xuXG5jbGFzcyBSdWxlXG4gIGluY2x1ZGUgQnJvd3Nlcjo6TmF0aXZlQ2FjaGVkV3JhcHBlclxuXG4gIFNUWUxFX1JVTEUgICAgICAgICAgICAgICA9IDFcbiAgQ0hBUlNFVF9SVUxFICAgICAgICAgICAgID0gMlxuICBJTVBPUlRfUlVMRSAgICAgICAgICAgICAgPSAzXG4gIE1FRElBX1JVTEUgICAgICAgICAgICAgICA9IDRcbiAgRk9OVF9GQUNFX1JVTEUgICAgICAgICAgID0gNVxuICBQQUdFX1JVTEUgICAgICAgICAgICAgICAgPSA2XG4gIEtFWUZSQU1FU19SVUxFICAgICAgICAgICA9IDdcbiAgS0VZRlJBTUVfUlVMRSAgICAgICAgICAgID0gOFxuICBOQU1FU1BBQ0VfUlVMRSAgICAgICAgICAgPSAxMFxuICBDT1VOVEVSX1NUWUxFX1JVTEUgICAgICAgPSAxMVxuICBTVVBQT1JUU19SVUxFICAgICAgICAgICAgPSAxMlxuICBET0NVTUVOVF9SVUxFICAgICAgICAgICAgPSAxM1xuICBGT05UX0ZFQVRVUkVfVkFMVUVTX1JVTEUgPSAxNFxuICBWSUVXUE9SVF9SVUxFICAgICAgICAgICAgPSAxNVxuICBSRUdJT05fU1RZTEVfUlVMRSAgICAgICAgPSAxNlxuXG4gIGRlZiBzZWxmLm5ldyhydWxlKVxuICAgIGlmIHNlbGYgPT0gUnVsZVxuICAgICAgQGNsYXNzZXMgfHw9IFtuaWwsIFN0eWxlXVxuXG4gICAgICBpZiBrbGFzcyA9IEBjbGFzc2VzW2BydWxlLnR5cGVgXVxuICAgICAgICBrbGFzcy5uZXcocnVsZSlcbiAgICAgIGVsc2VcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2Nhbm5vdCBpbnN0YW50aWF0ZSBhIG5vbiBkZXJpdmVkIFJ1bGUgb2JqZWN0J1xuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgc3VwZXIocnVsZSlcbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXNfbmF0aXZlIDp0ZXh0LCA6Y3NzVGV4dFxuICBhbGlhc19uYXRpdmUgOnRvX3MsIDpjc3NUZXh0XG5cbiAgZGVmIHBhcmVudFxuICAgIFJ1bGUubmV3KGAjQG5hdGl2ZS5wYXJlbnRSdWxlYCkgaWYgYCNAbmF0aXZlLnBhcmVudFJ1bGUgIT0gbnVsbGBcbiAgZW5kXG5cbiAgZGVmIHN0eWxlX3NoZWV0XG4gICAgU3R5bGVTaGVldC5uZXcoYCNAbmF0aXZlLnBhcmVudFN0eWxlU2hlZXRgKSBpZiBgI0BuYXRpdmUucGFyZW50U3R5bGVTaGVldCAhPSBudWxsYFxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPG1vZHVsZTpDU1M+IiwiPGNsYXNzOlJ1bGU+Iiwic2VsZiIsImluY2x1ZGUiLCJCcm93c2VyOjpOYXRpdmVDYWNoZWRXcmFwcGVyIiwiQnJvd3NlciIsIjEiLCIyIiwiMyIsIjQiLCI1IiwiNiIsIjciLCI4IiwiMTAiLCIxMSIsIjEyIiwiMTMiLCIxNCIsIjE1IiwiMTYiLCJuZXciLCJydWxlIiwiUnVsZSIsIkBjbGFzc2VzIiwiJHJldF9vcl8xIiwiU3R5bGUiLCJrbGFzcyIsIltdIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwiYWxpYXNfbmF0aXZlIiwicGFyZW50IiwiQG5hdGl2ZSIsInN0eWxlX3NoZWV0IiwiU3R5bGVTaGVldCJdLCJtYXBwaW5ncyI6IkFBQUFBLG1DQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7QUFBQUE7O1FBQ0VDLElBQUFDLFNBQUFBLENBQVFDLElBQUFDLGFBQUFELHdCQUFSRDtRQUVBLHNDQUEyQkcsQ0FBM0I7UUFDQSx3Q0FBMkJDLENBQTNCO1FBQ0EsdUNBQTJCQyxDQUEzQjtRQUNBLHNDQUEyQkMsQ0FBM0I7UUFDQSwwQ0FBMkJDLENBQTNCO1FBQ0EscUNBQTJCQyxDQUEzQjtRQUNBLDBDQUEyQkMsQ0FBM0I7UUFDQSx5Q0FBMkJDLENBQTNCO1FBQ0EsMENBQTJCQyxFQUEzQjtRQUNBLDhDQUEyQkMsRUFBM0I7UUFDQSx5Q0FBMkJDLEVBQTNCO1FBQ0EseUNBQTJCQyxFQUEzQjtRQUNBLG9EQUEyQkMsRUFBM0I7UUFDQSx5Q0FBMkJDLEVBQTNCO1FBQ0EsNkNBQTJCQyxFQUEzQjtRQUVBQyxNQUFJbkIsSUFBSm1CLFVBQUFBLHFCQUFhQyxJQUFiRDtBQUFBQSxVQUFBQTtBQUFBQTs7VUFBQUE7VUFDRSxJQUFBLE1BQUduQixJQUFILEVBQVdxQixVQUFYLENBQUE7O1lBQ0VDLGVBdkJOLENBQUEsUUFBQUMsQ0FBQUEsWUF1Qk1ELFlBdkJOQyxDQUFBLENBQUEsR0FBQSxDQUFBLFNBQUEsSUFBQSxDQXVCbUIsQ0FBQyxHQUFELEVBQU1DLFdBQU4sQ0F2Qm5CLENBQUE7WUF5Qk0sSUFBQSxRQUFHQyxDQUFBQSxRQUFRSCxZQUFRSSxPQUFBQSxDQUFFUCxTQUFGTyxDQUFoQkQsQ0FBSCxDQUFBO2NBQ0VOLE9BQUFNLEtBQUtOLEtBQUFBLENBQUtDLElBQUxEO1lBRFA7Y0FHRUEsT0FBQW5CLElBQUEyQixPQUFBQSxDQUFNQyxtQkFBTixFQUFxQlQsOENBQXJCUTtZQUhGO1VBSEY7WUFTRVIsT0FBQSxPQUFBbkIsSUFBQSxFQUFBLGtEQUFBLE9BQUEsRUFBQSxDQUFNb0IsSUFBTixDQUFBLEVBQUEsSUFBQTtVQVRGO1FBREZELENBQUFBO1FBY0FuQixJQUFBNkIsY0FBQUEsQ0FBYSxNQUFiLEVBQW9CLFNBQXBCQTtRQUNBN0IsSUFBQTZCLGNBQUFBLENBQWEsTUFBYixFQUFvQixTQUFwQkE7O0FBRUFDLFFBQUFBLHNCQUFBQSxrQkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0UsSUFBQSxRQUFxQ0MsY0FBT0QsbUJBQTVDLENBQUE7WUFBQUEsT0FBQVQsVUFBSUYsS0FBQUEsQ0FBT1ksY0FBT0QsV0FBZFg7VUFBSjtZQXZDSlcsT0FBQTtVQXVDSTtRQURGQSxDQUFBQTtRQUlBL0IsT0FBQWlDLDJCQUFBQSx1QkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0UsSUFBQSxRQUFpREQsY0FBT0MseUJBQXhELENBQUE7WUFBQUEsT0FBQUMsZ0JBQVVkLEtBQUFBLENBQU9ZLGNBQU9DLGlCQUFkYjtVQUFWO1lBM0NKYSxPQUFBO1VBMkNJO1FBREZBLENBQUFBO01BeENGakMsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7SUFGZ0JELEdBQUFBLFdBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzY1MTcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2Nzcy9ydWxlL3N0eWxlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgQ1NTOyBjbGFzcyBSdWxlXG5cbmNsYXNzIFN0eWxlIDwgUnVsZVxuICBhbGlhc19uYXRpdmUgOnNlbGVjdG9yLCA6c2VsZWN0b3JUZXh0XG4gIGFsaWFzX25hdGl2ZSA6aWQsIDpzZWxlY3RvclRleHRcblxuICBkZWYgZGVjbGFyYXRpb25cbiAgICBEZWNsYXJhdGlvbi5uZXcoYCNAbmF0aXZlLnN0eWxlYClcbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF9taXNzaW5nKCphcmdzLCAmYmxvY2spXG4gICAgZGVjbGFyYXRpb24uX19zZW5kX18oKmFyZ3MsICZibG9jaylcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPG1vZHVsZTpDU1M+IiwiPGNsYXNzOlJ1bGU+IiwiPGNsYXNzOlN0eWxlPiIsInNlbGYiLCJhbGlhc19uYXRpdmUiLCJkZWNsYXJhdGlvbiIsIkRlY2xhcmF0aW9uIiwibmV3IiwiQG5hdGl2ZSIsIm1ldGhvZF9taXNzaW5nIiwiX19zZW5kX18iLCJhcmdzIiwiYmxvY2siLCJ0b19wcm9jIiwiUnVsZSJdLCJtYXBwaW5ncyI6IkFBQUFBLHlDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFBWUEsT0FBQUM7TUFBQUE7O1FBQUFBOztRQUU1QkEsT0FBQUM7UUFBQUE7O1VBQUFBOztBQUFBQTs7VUFDRUMsSUFBQUMsY0FBQUEsQ0FBYSxVQUFiLEVBQXdCLGNBQXhCQTtVQUNBRCxJQUFBQyxjQUFBQSxDQUFhLElBQWIsRUFBa0IsY0FBbEJBOztBQUVBQyxVQUFBQSwyQkFBQUEsdUJBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFBQyxpQkFBV0MsS0FBQUEsQ0FBT0MsY0FBT0gsTUFBZEU7VUFEYkYsQ0FBQUE7VUFJQUgsT0FBQU8sOEJBQUFBLDBCQVZGLEVBVUVBO0FBQUFBLFlBQUFBOztZQUFBQTs7O1lBVkY7WUFVcUI7WUFDakJBLE9BQVdDLE1BQVhQLElBQUFFLGFBQUFBLENBQUFBLENBQVdLLFlBQUFBLEVBQVUsTUFBQ0MsSUFBRCxDQUFWRCxFQUFrQkUsS0FBREMsU0FBQUEsQ0FBQUEsQ0FBakJIO1VBRGJELENBQUFBLElBQUFBO1FBUkZQLEdBQUFBLFdBQUFBLEVBQWNZLFVBQWRaO01BRjRCRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtJQUFaRCxHQUFBQSxXQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM2NTY3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9jc3MucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnYnJvd3Nlci9jc3MvZGVjbGFyYXRpb24nXG5yZXF1aXJlICdicm93c2VyL2Nzcy9zdHlsZV9zaGVldCdcbnJlcXVpcmUgJ2Jyb3dzZXIvY3NzL3J1bGUnXG5yZXF1aXJlICdicm93c2VyL2Nzcy9ydWxlL3N0eWxlJ1xuXG5tb2R1bGUgS2VybmVsXG4gICMgQG92ZXJsb2FkIENTUyhkb2N1bWVudCA9ICRkb2N1bWVudCwgJmJsb2NrKVxuICAjXG4gICMgICBDcmVhdGUgYSBgPHN0eWxlPmAgZWxlbWVudCBmcm9tIGEge1BhZ2dpbzo6Q1NTfSBEU0wuXG4gICNcbiAgIyAgIEBwYXJhbSBkb2N1bWVudCBbQnJvd3Nlcjo6RE9NOjpEb2N1bWVudF0gdGhlIGRvY3VtZW50IGluc3RhbmNlXG4gICMgICAgIHdlIGludGVuZCB0byB1c2VcbiAgI1xuICAjICAgQHJldHVybiBbQnJvd3Nlcjo6RE9NOjpFbGVtZW50XSB0aGUgY3JlYXRlZCBgPHN0eWxlPmAgZWxlbWVudFxuICAjXG4gICMgQG92ZXJsb2FkIENTUyhzdHJpbmcsIGRvY3VtZW50ID0gJGRvY3VtZW50KVxuICAjXG4gICMgICBDcmVhdGUgYSBgPHN0eWxlPmAgZWxlbWVudCBmcm9tIGEgc3RyaW5nLlxuICAjXG4gICMgICBAcGFyYW0gZG9jdW1lbnQgW0Jyb3dzZXI6OkRPTTo6RG9jdW1lbnRdIHRoZSBkb2N1bWVudCBpbnN0YW5jZVxuICAjICAgICB3ZSBpbnRlbmQgdG8gdXNlXG4gICNcbiAgIyAgIEByZXR1cm4gW0Jyb3dzZXI6OkRPTTo6RWxlbWVudF0gdGhlIGNyZWF0ZWQgYDxzdHlsZT5gIGVsZW1lbnRcbiAgZGVmIENTUygqYXJncywgJmJsb2NrKVxuICAgIGRvY3VtZW50ID0gaWYgYXJncy5sZW5ndGggPiAxIHx8IGJsb2NrX2dpdmVuP1xuICAgICAgYXJncy5wb3BcbiAgICBlbmQgfHwgJGRvY3VtZW50XG5cbiAgICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZV9lbGVtZW50KDpzdHlsZSlcbiAgICBzdHlsZVs6dHlwZV0gPSAndGV4dC9jc3MnXG5cbiAgICBpZiBibG9ja1xuICAgICAgc3R5bGUuaW5uZXJfdGV4dCA9IFBhZ2dpby5jc3MoJmJsb2NrKVxuICAgIGVsc2VcbiAgICAgIHN0eWxlLmlubmVyX3RleHQgPSBhcmdzLmpvaW4oXCJcIilcbiAgICBlbmRcblxuICAgIHN0eWxlXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPG1vZHVsZTpLZXJuZWw+IiwiQ1NTIiwiZG9jdW1lbnQiLCIkcmV0X29yXzEiLCI+IiwiYXJncyIsImxlbmd0aCIsIjEiLCJibG9ja19naXZlbj8iLCJwb3AiLCIkZG9jdW1lbnQiLCJzdHlsZSIsImNyZWF0ZV9lbGVtZW50IiwiW109IiwiYmxvY2siLCJpbm5lcl90ZXh0PSIsImNzcyIsIlBhZ2dpbyIsInRvX3Byb2MiLCJqb2luIl0sIm1hcHBpbmdzIjoiQUFBQUEsOEJBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLHlCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRix5QkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsa0JBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLHdCQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7O0lBa0JFQSxPQUFBQyxtQkFBQUEsZUF2QkYsRUF1QkVBO0FBQUFBLE1BQUFBO0FBQUFBOztNQUFBQTs7O01BdkJGO01BdUJVO01BQ05DLFdBQVcsQ0FBQSxRQUFBQyxDQUFBQSxZQUFBLENBQUcsQ0FBQSxRQUFZQyxPQUFaQyxJQUFJQyxRQUFBQSxDQUFBQSxDQUFRRixFQUFFRyxDQUFGSCxDQUFaLENBQUEsSUFBQSxDQUFtQkksZUFBbkIsQ0FBQSxDQUFILEdBQUEsQ0FDVEgsSUFBSUksS0FBQUEsQ0FBQUEsQ0FESyxJQUFBLEdBQUEsQ0FBQU4sQ0FBQSxDQUFBLEdBQUEsQ0FBQSxTQUFBLElBQUEsQ0FFSk8sZUFGSSxDQUFBO01BSVhDLFFBQVFULFFBQVFVLGdCQUFBQSxDQUFnQixPQUFoQkE7TUFDaEJELEtBQUtFLFFBQUFBLENBQUMsTUFBTixFQUFlWixVQUFWWTtNQUVMLElBQUEsUUFBR0MsS0FBSCxDQUFBO1FBQ0VILEtBQUtJLGdCQUFBQSxDQUFvQkMsTUFBTkMsWUFBTUQsT0FBQUEsRUFBQUEsRUFBQUEsRUFBTUYsS0FBREksU0FBQUEsQ0FBQUEsQ0FBTEYsQ0FBcEJEO01BRFA7UUFHRUosS0FBS0ksZ0JBQUFBLENBQWNWLElBQUljLE1BQUFBLENBQU1sQixFQUFOa0IsQ0FBbEJKO01BSFA7TUFNQWQsT0FBQVU7SUFkRlYsQ0FBQUEsSUFBQUE7RUFsQkZELEdBQUFBLFdBQUFBO0FBTEFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozNjYwMywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvc2V0dXAvbWluaS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGJyb3dzZXIvc2V0dXAvbWluaSAtIEEgc21hbGxlciBzZXQgb2YgcmVxdWlyZXMsIGRlc2lnbmVkIGZvciBzbGltIGNvZGViYXNlc1xuXG5yZXF1aXJlICdicm93c2VyL3NldHVwL2Jhc2UnXG5cbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQnXG5yZXF1aXJlICdicm93c2VyL3dpbmRvdydcbnJlcXVpcmUgJ2Jyb3dzZXIvZG9tJ1xucmVxdWlyZSAnYnJvd3Nlci9jc3MnXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiQUFBQUEscUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBRUFDLElBQUFDLFNBQUFBLENBQVFGLG9CQUFSRTtFQUVBRCxJQUFBQyxTQUFBQSxDQUFRRixlQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixnQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsYUFBUkU7RUFDQUYsT0FBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsYUFBUkU7QUFQQUY7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM2NjE1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9hbmltYXRpb25fZnJhbWUucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXJcblxuIyBBbGxvd3MgeW91IHRvIHdyYXAgYSBibG9jayB0byB1c2UgaW4gYW4gYW5pbWF0aW9uIHJlbmRlcmluZyBjeWNsZS5cbiNcbiMgQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuY2xhc3MgQW5pbWF0aW9uRnJhbWVcbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIFsnQW5pbWF0aW9uLnJlcXVlc3QnLFxuICAgICAnQW5pbWF0aW9uLnJlcXVlc3QgKENocm9tZSknLFxuICAgICAnQW5pbWF0aW9uLnJlcXVlc3QgKEZpcmVmb3gpJyxcbiAgICAgJ0FuaW1hdGlvbi5yZXF1ZXN0IChPcGVyYSknLFxuICAgICAnQW5pbWF0aW9uLnJlcXVlc3QgKEludGVybmV0IEV4cGxvcmVyKSddLmFueT8ge3xmZWF0dXJlfFxuICAgICAgIEJyb3dzZXIuc3VwcG9ydHM/IGZlYXR1cmVcbiAgICAgfVxuICBlbmRcblxuICAjIEV4ZWN1dGUgdGhlIGJsb2NrIHRvIHVwZGF0ZSBhbiBhbmltYXRpb24gYmVmb3JlIHRoZSBuZXh0IHJlcGFpbnQuXG4gICNcbiAgIyBAcGFyYW0gd2luZG93IFtXaW5kb3ddIHRoZSB3aW5kb3cgdG8gcmVxdWVzdCB0aGUgZnJhbWUgb25cbiAgZGVmIGluaXRpYWxpemUod2luZG93LCAmYmxvY2spXG4gICAgQHdpbmRvdyA9IHdpbmRvd1xuICAgIEBuYXRpdmUgPSB3aW5kb3cudG9fblxuICAgIEBpZCAgICAgPSByZXF1ZXN0KGJsb2NrKVxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnQW5pbWF0aW9uLnJlcXVlc3QnXG4gICAgZGVmIHJlcXVlc3QoYmxvY2spXG4gICAgICBgI0BuYXRpdmUucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCN7YmxvY2sudG9fbn0pYFxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnQW5pbWF0aW9uLnJlcXVlc3QgKENocm9tZSknXG4gICAgZGVmIHJlcXVlc3QoYmxvY2spXG4gICAgICBgI0BuYXRpdmUud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKCN7YmxvY2sudG9fbn0pYFxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnQW5pbWF0aW9uLnJlcXVlc3QgKEZpcmVmb3gpJ1xuICAgIGRlZiByZXF1ZXN0KGJsb2NrKVxuICAgICAgYCNAbmF0aXZlLm1velJlcXVlc3RBbmltYXRpb25GcmFtZSgje2Jsb2NrLnRvX259KWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0FuaW1hdGlvbi5yZXF1ZXN0IChPcGVyYSknXG4gICAgZGVmIHJlcXVlc3QoYmxvY2spXG4gICAgICBgI0BuYXRpdmUub1JlcXVlc3RBbmltYXRpb25GcmFtZSgje2Jsb2NrLnRvX259KWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0FuaW1hdGlvbi5yZXF1ZXN0IChJbnRlcm5ldCBFeHBsb3JlciknXG4gICAgZGVmIHJlcXVlc3QoYmxvY2spXG4gICAgICBgI0BuYXRpdmUubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoI3tibG9jay50b19ufSlgXG4gICAgZW5kXG4gIGVsc2VcbiAgICAjIFJlcXVlc3QgdGhlIGFuaW1hdGlvbiBmcmFtZS5cbiAgICBkZWYgcmVxdWVzdFxuICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgJ3dpbmRvdyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgdW5zdXBwb3J0ZWQnXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdBbmltYXRpb24uY2FuY2VsJ1xuICAgIGRlZiBjYW5jZWxcbiAgICAgIGAjQG5hdGl2ZS5jYW5jZWxBbmltYXRpb25GcmFtZSgjQGlkKWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0FuaW1hdGlvbi5jYW5jZWwgKENocm9tZSknXG4gICAgZGVmIGNhbmNlbFxuICAgICAgYCNAbmF0aXZlLndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lKCNAaWQpYFxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnQW5pbWF0aW9uLmNhbmNlbFJlcXVlc3QgKENocm9tZSknXG4gICAgZGVmIGNhbmNlbFxuICAgICAgYCNAbmF0aXZlLndlYmtpdENhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSgjQGlkKWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0FuaW1hdGlvbi5jYW5jZWwgKEZpcmVmb3gpJ1xuICAgIGRlZiBjYW5jZWxcbiAgICAgIGAjQG5hdGl2ZS5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSgjQGlkKWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0FuaW1hdGlvbi5jYW5jZWxSZXF1ZXN0IChGaXJlZm94KSdcbiAgICBkZWYgY2FuY2VsXG4gICAgICBgI0BuYXRpdmUubW96Q2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lKCNAaWQpYFxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnQW5pbWF0aW9uLmNhbmNlbCAoT3BlcmEpJ1xuICAgIGRlZiBjYW5jZWxcbiAgICAgIGAjQG5hdGl2ZS5vQ2FuY2VsQW5pbWF0aW9uRnJhbWUoI0BpZClgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdBbmltYXRpb24uY2FuY2VsUmVxdWVzdCAoT3BlcmEpJ1xuICAgIGRlZiBjYW5jZWxcbiAgICAgIGAjQG5hdGl2ZS5vQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lKCNAaWQpYFxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnQW5pbWF0aW9uLmNhbmNlbCAoSW50ZXJuZXQgRXhwbG9yZXIpJ1xuICAgIGRlZiBjYW5jZWxcbiAgICAgIGAjQG5hdGl2ZS5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lKCNAaWQpYFxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnQW5pbWF0aW9uLmNhbmNlbFJlcXVlc3QgKEludGVybmV0IEV4cGxvcmVyKSdcbiAgICBkZWYgY2FuY2VsXG4gICAgICBgI0BuYXRpdmUubXNDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoI0BpZClgXG4gICAgZW5kXG4gIGVsc2VcbiAgICAjIENhbmNlbCB0aGUgYW5pbWF0aW9uIGZyYW1lIHJlcXVlc3QuXG4gICAgZGVmIGNhbmNlbFxuICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgJ3dpbmRvdyBjYW5jZWxBbmltYXRpb25GcmFtZSB1bnN1cHBvcnRlZCdcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuZW5kXG5cbm1vZHVsZSBLZXJuZWxcbiAgIyAoc2VlIEJyb3dzZXI6OkFuaW1hdGlvbkZyYW1lLm5ldylcbiAgZGVmIGFuaW1hdGlvbl9mcmFtZSgmYmxvY2spXG4gICAgQnJvd3Nlcjo6QW5pbWF0aW9uRnJhbWUubmV3KCR3aW5kb3csICZibG9jaylcbiAgZW5kXG5lbmRcblxuY2xhc3MgUHJvY1xuICAjIChzZWUgQnJvd3Nlcjo6QW5pbWF0aW9uRnJhbWUubmV3KVxuICBkZWYgYW5pbWF0aW9uX2ZyYW1lXG4gICAgQnJvd3Nlcjo6QW5pbWF0aW9uRnJhbWUubmV3KCR3aW5kb3csICZzZWxmKVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkFuaW1hdGlvbkZyYW1lPiIsInN1cHBvcnRlZD8iLCJzZWxmIiwiYW55PyIsImJsb2NrIGluIHN1cHBvcnRlZD8iLCJmZWF0dXJlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzdXBwb3J0ZWQ/IiwiQnJvd3NlciIsInN1cHBvcnRzPyIsImluaXRpYWxpemUiLCJ3aW5kb3ciLCJAd2luZG93IiwiQG5hdGl2ZSIsInRvX24iLCJAaWQiLCJyZXF1ZXN0IiwiYmxvY2siLCJyYWlzZSIsIk5vdEltcGxlbWVudGVkRXJyb3IiLCJjYW5jZWwiLCI8bW9kdWxlOktlcm5lbD4iLCJhbmltYXRpb25fZnJhbWUiLCJuZXciLCJCcm93c2VyOjpBbmltYXRpb25GcmFtZSIsIiR3aW5kb3ciLCJ0b19wcm9jIiwiPGNsYXNzOlByb2M+Il0sIm1hcHBpbmdzIjoiQUFBQUEsMENBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDO0VBQUFBOztJQUFBQTs7SUFLQUEsT0FBQUM7SUFBQUE7O01BQUFBOztBQUFBQTs7TUFDRUMsTUFBSUMsSUFBSkQsaUJBQUFBLDBDQUFBQTtBQUFBQTtRQUNFQSxPQUl5Q0UsTUFKekMsQ0FBQ0YsbUJBQUQsRUFDQ0EsNEJBREQsRUFFQ0EsNkJBRkQsRUFHQ0EsMkJBSEQsRUFJQ0EsdUNBSkQsQ0FJeUNFLFFBQUFBLEVBQUFBLEVBQUFBLEVBSnpDQyxhQUlpREMsT0FKakREOztVQUlpRDtVQUM5Q0UsT0FBQUMsYUFBT0MsY0FBQUEsQ0FBV0gsT0FBWEcsRUFMVkosQ0FJeUNEO01BTDNDRixDQUFBQTs7QUFhQVEsTUFBQUEsMEJBQUFBLHNCQUFlQyxNQUFmRDtBQUFBQSxRQUFBQTs7UUFBQUE7OztRQUNFRSxjQUFVRDtRQUNWRSxpQkFBVUYsTUFBTUcsTUFBQUEsQ0FBQUE7UUFDaEJKLE9BQUFLLENBQUFBLFVBQVVaLElBQUFhLFNBQUFBLENBQVFDLEtBQVJELENBQVZEO01BSEZMLENBQUFBO01BTUEs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QUxGLENBQUFBLEVBQWVwQixJQUFEdUIsU0FBQUEsQ0FBQUEsQ0FBZEg7SUFEekJELENBQUFBO0VBRkZLLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBekdBNUI7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM2Nzg1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9lZmZlY3RzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2Jyb3dzZXIvYW5pbWF0aW9uX2ZyYW1lJ1xuXG5tb2R1bGUgQnJvd3NlcjsgbW9kdWxlIERPTVxuXG5jbGFzcyBEb2N1bWVudCA8IEVsZW1lbnRcbiAgIyBAIWF0dHJpYnV0ZSBbcl0gYWN0aXZlX2VsZW1lbnRcbiAgIyBAcmV0dXJuIFtFbGVtZW50XSB0aGUgZWxlbWVudCB3aXRoIGZvY3VzXG4gIGRlZiBhY3RpdmVfZWxlbWVudFxuICAgIERPTShgI0BuYXRpdmUuYWN0aXZlRWxlbWVudGApXG4gIGVuZFxuZW5kXG5cbmNsYXNzIEVsZW1lbnRcbiAgIyBTaG93IHRoZSBlbGVtZW50LlxuICAjXG4gICMgQHBhcmFtIHdoYXQgW1N5bWJvbF0gaG93IHRvIGRpc3BsYXkgaXRcbiAgZGVmIHNob3cod2hhdCA9IDpibG9jaylcbiAgICBzdHlsZVs6ZGlzcGxheV0gPSB3aGF0XG4gICAgc2VsZlxuICBlbmRcblxuICAjIEhpZGUgdGhlIGVsZW1lbnQuXG4gIGRlZiBoaWRlXG4gICAgc3R5bGVbOmRpc3BsYXldID0gOm5vbmVcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB2aXNpYmxlP1xuICAgICMgTGV0J3MgY2hlY2sgaWYgd2Ugd2FudCB0byBsaWUgYWJvdXQgdGhlIHJlYWwgdmlzaWJpbGl0eSBvZiBhbiBlbGVtZW50LlxuICAgICMgSXQgY291bGQgYmUgd2lzZSB0byBsaWUgYWJvdXQgaXQgd2hlbiBpdCdzIGluIGEgcHJvY2VzcyBvZiBhbmltYXRpb24uLi5cbiAgICBpZiAhQHZpcnR1YWxseV92aXNpYmxlLm5pbD9cbiAgICAgIEB2aXJ0dWFsbHlfdmlzaWJsZVxuICAgIGVsc2VcbiAgICAgIHN0eWxlIVs6ZGlzcGxheV0gIT0gOm5vbmVcbiAgICBlbmRcbiAgZW5kXG5cbiAgIyBUb2dnbGUgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGVsZW1lbnQsIGhpZGUgaXQgaWYgaXQncyBzaG93biwgc2hvdyBpdCBpZlxuICAjIGl0J3MgaGlkZGVuLlxuICBkZWYgdG9nZ2xlKHdoYXQgPSA6YmxvY2spXG4gICAgaWYgdmlzaWJsZT9cbiAgICAgIGhpZGVcbiAgICBlbHNlXG4gICAgICBzaG93KHdoYXQpXG4gICAgZW5kXG4gICAgc2VsZlxuICBlbmRcblxuICAjIFNldCB0aGUgZm9jdXMgb24gdGhlIGVsZW1lbnQuXG4gIGRlZiBmb2N1c1xuICAgIGAjQG5hdGl2ZS5mb2N1cygpYFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgIyBCbHVyIHRoZSBmb2N1cyBmcm9tIHRoZSBlbGVtZW50LlxuICBkZWYgYmx1clxuICAgIGAjQG5hdGl2ZS5ibHVyKClgXG4gICAgc2VsZlxuICBlbmRcblxuICAjIENoZWNrIGlmIHRoZSBlbGVtZW50IGlzIGZvY3VzZWQuXG4gIGRlZiBmb2N1c2VkP1xuICAgIGAjQG5hdGl2ZS5oYXNGb2N1c2BcbiAgZW5kXG5cbiAgIyBRdWV1ZSB0aGUgYmxvY2sgdG8gaGFwcGVuIHdoZW4gY3VycmVudGx5IHF1ZXVlZCBhbmltYXRpb25zIGZpbmlzaCBvciBkdXJpbmdcbiAgIyB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWUuXG4gIGRlZiBhbmltYXRpb25fcXVldWUgJmJsb2NrXG4gICAgcHJvbWlzZSA9IFByb21pc2UubmV3XG5cbiAgICBwcm9taXNlX3Jlc29sdmUgPSBwcm9jIGRvXG4gICAgICBAYW5pbWF0aW9uX3Byb21pc2UgPSBuaWwgaWYgQGFuaW1hdGlvbl9wcm9taXNlID09IHByb21pc2VcbiAgICAgIHByb21pc2UucmVzb2x2ZVxuICAgIGVuZFxuXG4gICAgQGFuaW1hdGlvbl9wcm9taXNlID0gKEBhbmltYXRpb25fcHJvbWlzZSB8fCBQcm9taXNlLnZhbHVlKHRydWUpKS50aGVuIGRvXG4gICAgICBhbmltYXRpb25fZnJhbWUgZG9cbiAgICAgICAgeWllbGQgcHJvbWlzZV9yZXNvbHZlXG4gICAgICBlbmRcbiAgICAgIHByb21pc2VcbiAgICBlbmRcbiAgZW5kXG5cbiAgIyBUcmFuc2Zvcm0gYW4gZWxlbWVudCBzbW9vdGhseSB1c2luZyBDU1MgdHJhbnNpdGlvbnMsIGpRdWVyeSBzdHlsZS4gWWllbGRcbiAgIyBhIGJsb2NrIGFmdGVyd2FyZHMgaWYgaXQncyBwcm92aWRlZC5cbiAgZGVmIGFuaW1hdGUocHJvcGVydGllcywgZHVyYXRpb246IDAuNC5zLCBlYXNpbmc6IDplYXNlLCByZXNvbHZlOiBmYWxzZSwgJmJsb2NrKVxuICAgIGFuaW1hdGlvbl9xdWV1ZShyZXNvbHZlKSBkbyB8cmVzfFxuICAgICAgZHVyYXRpb24gPSAwLjYucyBpZiBkdXJhdGlvbiA9PSA6c2xvd1xuICAgICAgZHVyYXRpb24gPSAwLjIucyBpZiBkdXJhdGlvbiA9PSA6ZmFzdFxuXG4gICAgICBvcmlnaW5hbF92YWx1ZSA9IHN0eWxlWyd0cmFuc2l0aW9uJ11cblxuICAgICAgc3R5bGVbJ3RyYW5zaXRpb24nXSA9IFtvcmlnaW5hbF92YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAqcHJvcGVydGllcy5rZXlzLm1hcCBkbyB8a2V5fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIje2tleX0gI3tkdXJhdGlvbn0gI3tlYXNpbmd9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRdLmNvbXBhY3Quam9pbihcIiwgXCIpXG5cbiAgICAgIHByb3BlcnRpZXMuZWFjaCBkbyB8a2V5LCB2YWx1ZXxcbiAgICAgICAgc3R5bGVba2V5XSA9IHZhbHVlXG4gICAgICBlbmRcblxuICAgICAgcHJvbWlzZSA9IFByb21pc2UubmV3XG5cbiAgICAgIG9uZSA6dHJhbnNpdGlvbmVuZCBkbyB8KmFyZ3N8XG4gICAgICAgIHN0eWxlWyd0cmFuc2l0aW9uJ10gPSBvcmlnaW5hbF92YWx1ZVxuXG4gICAgICAgIHlpZWxkKCphcmdzKSBpZiBibG9ja19naXZlbj9cblxuICAgICAgICByZXMuY2FsbFxuICAgICAgZW5kXG4gICAgZW5kXG4gICAgc2VsZlxuICBlbmRcblxuICAjIFNob3cgYSBoaWRkZW4gZWxlbWVudCB3aXRoIGEgXCJmYWRlIGluXCIgYW5pbWF0aW9uLiBZaWVsZCBhIGJsb2NrIGFmdGVyd2FyZHMuXG4gIGRlZiBmYWRlX2luKCoqa3dhcmdzLCAmYmxvY2spXG4gICAgYW5pbWF0aW9uX3F1ZXVlIGRvIHxyZXNvbHZlfFxuICAgICAgaWYgIXZpc2libGU/XG4gICAgICAgIEB2aXJ0dWFsbHlfdmlzaWJsZSA9IHRydWVcbiAgICAgICAgc2hvd1xuXG4gICAgICAgIHN0eWxlWzpvcGFjaXR5XSA9IDAuMFxuICAgICAgICBhbmltYXRlIG9wYWNpdHk6IDEuMCwgKiprd2FyZ3MgZG8gfCphcmdzfFxuICAgICAgICAgIEB2aXJ0dWFsbHlfdmlzaWJsZSA9IG5pbFxuICAgICAgICAgIHN0eWxlWzpvcGFjaXR5XSA9IG5pbFxuICAgICAgICAgIHlpZWxkKCphcmdzKSBpZiBibG9ja19naXZlbj9cbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIHJlc29sdmUuY2FsbFxuICAgIGVuZFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgIyBIaWRlIGEgdmlzaWJsZSBlbGVtZW50IHdpdGggYSBcImZhZGUgb3V0XCIgYW5pbWF0aW9uLiBZaWVsZCBhIGJsb2NrIGFmdGVyd2FyZHMuXG4gIGRlZiBmYWRlX291dCgqKmt3YXJncywgJmJsb2NrKVxuICAgIGFuaW1hdGlvbl9xdWV1ZSBkbyB8cmVzb2x2ZXxcbiAgICAgIGlmIHZpc2libGU/XG4gICAgICAgIEB2aXJ0dWFsbHlfdmlzaWJsZSA9IGZhbHNlXG5cbiAgICAgICAgc3R5bGVbOm9wYWNpdHldID0gMS4wXG4gICAgICAgIGFuaW1hdGUgb3BhY2l0eTogMC4wLCAqKmt3YXJncyBkbyB8KmFyZ3N8XG4gICAgICAgICAgQHZpcnR1YWxseV92aXNpYmxlID0gbmlsXG4gICAgICAgICAgc3R5bGVbOm9wYWNpdHldID0gbmlsXG4gICAgICAgICAgaGlkZVxuICAgICAgICAgIHlpZWxkKCphcmdzKSBpZiBibG9ja19naXZlbj9cbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIHJlc29sdmUuY2FsbFxuICAgIGVuZFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgIyBUb2dnbGUgYSB2aXNpYmlsaXR5IG9mIGFuIGVsZW1lbnQgd2l0aCBhIFwiZmFkZSBpblwiL1wiZmFkZSBvdXRcIiBhbmltYXRpb24uIFlpZWxkXG4gICMgYSBibG9jayBhZnRlcndhcmRzLlxuICBkZWYgZmFkZV90b2dnbGUoKiprd2FyZ3MsICZibG9jaylcbiAgICBpZiB2aXNpYmxlP1xuICAgICAgZmFkZV9vdXQoKiprd2FyZ3MsICZibG9jaylcbiAgICBlbHNlXG4gICAgICBmYWRlX2luKCoqa3dhcmdzLCAmYmxvY2spXG4gICAgZW5kXG4gICAgc2VsZlxuICBlbmRcblxuICAjIFNob3cgYSBoaWRkZW4gZWxlbWVudCB3aXRoIGEgXCJzbGlkZSBkb3duXCIgYW5pbWF0aW9uLiBZaWVsZCBhIGJsb2NrIGFmdGVyd2FyZHMuXG4gIGRlZiBzbGlkZV9kb3duKCoqa3dhcmdzLCAmYmxvY2spXG4gICAgYW5pbWF0aW9uX3F1ZXVlIGRvIHxyZXNvbHZlfFxuICAgICAgaWYgIXZpc2libGU/XG4gICAgICAgIEB2aXJ0dWFsbHlfdmlzaWJsZSA9IHRydWVcbiAgICAgICAgc2hvd1xuICAgICAgICBoZWlnaHQgPSBzaXplLmhlaWdodFxuICAgICAgICBvcmlnX2hlaWdodCA9IHN0eWxlWzpoZWlnaHRdXG4gICAgICAgIHN0eWxlWzpoZWlnaHRdID0gMC5weFxuXG4gICAgICAgIGFuaW1hdGUgaGVpZ2h0OiBoZWlnaHQucHgsICoqa3dhcmdzIGRvIHwqYXJnc3xcbiAgICAgICAgICBAdmlydHVhbGx5X3Zpc2libGUgPSBuaWxcbiAgICAgICAgICBzdHlsZVs6aGVpZ2h0XSA9IG9yaWdfaGVpZ2h0XG4gICAgICAgICAgeWllbGQoKmFyZ3MpIGlmIGJsb2NrX2dpdmVuP1xuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgICAgcmVzb2x2ZS5jYWxsXG4gICAgZW5kXG4gICAgc2VsZlxuICBlbmRcblxuICAjIEhpZGUgYSB2aXNpYmxlIGVsZW1lbnQgd2l0aCBhIFwic2xpZGUgdXBcIiBhbmltYXRpb24uIFlpZWxkIGEgYmxvY2sgYWZ0ZXJ3YXJkcy5cbiAgZGVmIHNsaWRlX3VwKCoqa3dhcmdzLCAmYmxvY2spXG4gICAgYW5pbWF0aW9uX3F1ZXVlIGRvIHxyZXNvbHZlfFxuICAgICAgaWYgdmlzaWJsZT9cbiAgICAgICAgQHZpcnR1YWxseV92aXNpYmxlID0gZmFsc2VcbiAgICAgICAgb3JpZ19oZWlnaHQgPSBzdHlsZVs6aGVpZ2h0XVxuXG4gICAgICAgIGFuaW1hdGUgaGVpZ2h0OiAwLnB4LCAqKmt3YXJncyBkbyB8KmFyZ3N8XG4gICAgICAgICAgQHZpcnR1YWxseV92aXNpYmxlID0gbmlsXG4gICAgICAgICAgc3R5bGVbOmhlaWdodF0gPSBvcmlnX2hlaWdodFxuICAgICAgICAgIGhpZGVcbiAgICAgICAgICB5aWVsZCgqYXJncykgaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICByZXNvbHZlLmNhbGxcbiAgICBlbmRcbiAgICBzZWxmXG4gIGVuZFxuXG4gICMgVG9nZ2xlIGEgdmlzaWJpbGl0eSBvZiBhbiBlbGVtZW50IHdpdGggYSBcInNsaWRlIHVwXCIvXCJzbGlkZSBkb3duXCIgYW5pbWF0aW9uLlxuICAjIFlpZWxkIGEgYmxvY2sgYWZ0ZXJ3YXJkcy5cbiAgZGVmIHNsaWRlX3RvZ2dsZSgqKmt3YXJncywgJmJsb2NrKVxuICAgIGlmIHZpc2libGU/XG4gICAgICBzbGlkZV91cCgqKmt3YXJncywgJmJsb2NrKVxuICAgIGVsc2VcbiAgICAgIHNsaWRlX2Rvd24oKiprd2FyZ3MsICZibG9jaylcbiAgICBlbmRcbiAgICBzZWxmXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPG1vZHVsZTpCcm93c2VyPiIsIjxtb2R1bGU6RE9NPiIsIjxjbGFzczpEb2N1bWVudD4iLCJhY3RpdmVfZWxlbWVudCIsIkRPTSIsIkBuYXRpdmUiLCJFbGVtZW50IiwiPGNsYXNzOkVsZW1lbnQ+Iiwic2hvdyIsIndoYXQiLCJzdHlsZSIsIltdPSIsImhpZGUiLCJ2aXNpYmxlPyIsIkB2aXJ0dWFsbHlfdmlzaWJsZSIsIm5pbD8iLCJzdHlsZSEiLCJbXSIsIiE9IiwidG9nZ2xlIiwiZm9jdXMiLCJibHVyIiwiZm9jdXNlZD8iLCJhbmltYXRpb25fcXVldWUiLCJwcm9taXNlIiwiUHJvbWlzZSIsIm5ldyIsInByb21pc2VfcmVzb2x2ZSIsInByb2MiLCJibG9jayBpbiBhbmltYXRpb25fcXVldWUiLCJibG9jayAoMiBsZXZlbHMpIGluIGFuaW1hdGlvbl9xdWV1ZSIsIkBhbmltYXRpb25fcHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwiJHJldF9vcl8xIiwidmFsdWUiLCJhbmltYXRpb25fZnJhbWUiLCJhbmltYXRlIiwicHJvcGVydGllcyIsIiRrd2FyZ3MiLCJzIiwiYmxvY2sgaW4gYW5pbWF0ZSIsInJlcyIsImJsb2NrICgyIGxldmVscykgaW4gYW5pbWF0ZSIsImR1cmF0aW9uIiwib3JpZ2luYWxfdmFsdWUiLCJtYXAiLCJrZXlzIiwia2V5IiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiBhbmltYXRlIiwiZWFzaW5nIiwiY29tcGFjdCIsImpvaW4iLCJlYWNoIiwib25lIiwiYmxvY2tfZ2l2ZW4/IiwiYXJncyIsImNhbGwiLCJmYWRlX2luIiwiYmxvY2sgaW4gZmFkZV9pbiIsImJsb2NrICgyIGxldmVscykgaW4gZmFkZV9pbiIsImt3YXJncyIsImJsb2NrICgzIGxldmVscykgaW4gZmFkZV9pbiIsImZhZGVfb3V0IiwiYmxvY2sgaW4gZmFkZV9vdXQiLCJibG9jayAoMiBsZXZlbHMpIGluIGZhZGVfb3V0IiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiBmYWRlX291dCIsImZhZGVfdG9nZ2xlIiwiYmxvY2siLCJ0b19wcm9jIiwic2xpZGVfZG93biIsImJsb2NrIGluIHNsaWRlX2Rvd24iLCJibG9jayAoMiBsZXZlbHMpIGluIHNsaWRlX2Rvd24iLCJoZWlnaHQiLCJzaXplIiwib3JpZ19oZWlnaHQiLCIwIiwicHgiLCJibG9jayAoMyBsZXZlbHMpIGluIHNsaWRlX2Rvd24iLCJzbGlkZV91cCIsImJsb2NrIGluIHNsaWRlX3VwIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzbGlkZV91cCIsImJsb2NrICgzIGxldmVscykgaW4gc2xpZGVfdXAiLCJzbGlkZV90b2dnbGUiXSwibWFwcGluZ3MiOiJBQUFBQSxrQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsSUFBQUMsU0FBQUEsQ0FBUUYseUJBQVJFO0VBRUFGLE9BQUFHO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7O01BRWhCQztNQUFBQTs7UUFBQUE7O0FBQUFBO1FBR0VBLE9BQUFDLDhCQUFBQSwwQkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUFMLElBQUFNLEtBQUFBLENBQU1DLGNBQU9GLGNBQWJDO1FBREZELENBQUFBO01BSEZELEdBQUFBLFdBQUFBLEVBQWlCSSxhQUFqQko7TUFRQUQsT0FBQU07TUFBQUE7O1FBQUFBOztBQUFBQTs7O0FBSUVDLFFBQUFBLG9CQUFBQSxnQkFBU0MsSUFBVEQ7QUFBQUEsVUFBQUE7OztVQUFTLHlCQUFPO1VBQ2RWLElBQUFZLE9BQUFBLENBQUFBLENBQUtDLFFBQUFBLENBQUMsU0FBTixFQUFrQkYsSUFBYkU7VUFDTEgsT0FBQVY7UUFGRlUsQ0FBQUEsSUFBQUE7O0FBTUFJLFFBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsVUFBQUE7OztVQUNFZCxJQUFBWSxPQUFBQSxDQUFBQSxDQUFLQyxRQUFBQSxDQUFDLFNBQU4sRUFBa0IsTUFBYkE7VUFDTEMsT0FBQWQ7UUFGRmMsQ0FBQUE7O0FBS0FDLFFBQUFBLHdCQUFBQSxpQ0FBQUE7QUFBQUEsVUFBQUE7O1VBR0UsSUFBQSxLQUFJQyxzQkFBa0JDLFNBQUFBLENBQUFBLENBQXRCLENBQUE7WUFDRUYsT0FBQUM7VUFERjtZQUdFRCxPQUFBZixJQUFBa0IsV0FBQUEsQ0FBQUEsQ0FBTUMsT0FBQUEsQ0FBQyxTQUFEQSxDQUFXQyxPQUFBQSxDQUFHLE1BQUhBO1VBSG5CO1FBSEZMLENBQUFBOztBQVlBTSxRQUFBQSxzQkFBQUEsa0JBQVdWLElBQVhVO0FBQUFBLFVBQUFBOzs7VUFBVyx5QkFBTztVQUNoQixJQUFBLFFBQUdyQixJQUFBZSxhQUFBQSxDQUFBQSxDQUFILENBQUE7WUFDRWYsSUFBQWMsTUFBQUEsQ0FBQUE7VUFERjtZQUdFZCxJQUFBVSxNQUFBQSxDQUFLQyxJQUFMRDtVQUhGO1VBS0FXLE9BQUFyQjtRQU5GcUIsQ0FBQUEsSUFBQUE7O0FBVUFDLFFBQUFBLHFCQUFBQSxpQkFBQUE7QUFBQUEsVUFBQUE7OztVQUNJZixjQUFPZTtVQUNUQSxPQUFBdEI7UUFGRnNCLENBQUFBOztBQU1BQyxRQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLFVBQUFBOzs7VUFDSWhCLGNBQU9nQjtVQUNUQSxPQUFBdkI7UUFGRnVCLENBQUFBOztBQU1BQyxRQUFBQSx3QkFBQUEsaUNBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFFakIsY0FBT2lCO1FBRFhBLENBQUFBOztBQU1BQyxRQUFBQSwrQkFBQUEsMkJBQUFBO0FBQUFBLFVBQUFBOztVQUFBQTs7O1VBQ0VDLFVBQVVDLGFBQU9DLEtBQUFBLENBQUFBO1VBRWpCQyxrQkFBa0JDLE1BQUE5QixJQUFBOEIsUUFBQUEsRUFBQUEsRUFBQUEsRUFBQUMsYUFBQUEsRUFBQUM7QUFBQUE7OztZQUNoQixJQUFBLE1BQTRCQyxzQkFBNUIsRUFBa0RQLE9BQWxELENBQUE7Y0FBQU8seUJBQXFCO1lBQXJCO1lBQ0FELE9BQUFOLE9BQU9RLFNBQUFBLENBQUFBLEVBRlNILENBQUFBLEdBQUFBLFNBQUFBLENBQUFEO1VBS2xCTCxPQUFBUSxDQUFBQSx5QkFBZ0VFLE1BQTFDLENBQUEsUUFBQUMsQ0FBQUEsWUFBQUgsc0JBQUFHLENBQUEsQ0FBQSxHQUFBLENBQUEsU0FBQSxJQUFBLENBQXNCVCxhQUFPVSxPQUFBQSxDQUFPLElBQVBBLENBQTdCLENBQUEsQ0FBMENGLFFBQUFBLEVBQUFBLEVBQUFBLEVBQTNDSixhQUFBQSxFQUFBQzs7O1lBQ25CTSxNQUFBdEMsSUFBQXNDLG1CQUFBQSxFQUFBQSxFQUFBQSxFQUFBTixhQUFBQTtjQUNFLE9BQUEsbUJBQU1ILGVBQU4sQ0FBQSxDQURGRyxDQUFBTTtZQUdBTixPQUFBTixRQUptQkssQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBMkNJLENBQWhFRjtRQVJGUixDQUFBQTs7QUFrQkFjLFFBQUFBLHVCQUFBQSxtQkFBWUMsVUFBRCxFQXJGYkMsT0FxRkVGO0FBQUFBLFVBQUFBOztVQUFBQTs7O1VBckZGOztVQXFGMEIsMENBQUEsaUNBQVUsQ0FBQSxHQUFBLENBQUdHLEdBQUFBLENBQUFBOztVQUFJLHNDQUFBLDZCQUFROztVQUFPLHdDQUFBLCtCQUFTO1VBQy9EakIsTUFBQXpCLElBQUF5QixtQkFBQUEsRUFBQUEsQ0FBZ0JTLE9BQWhCVCxDQUFBQSxFQUFBa0IsYUFBNkJDLEdBQTdCRCxFQUFBRTs7O1lBQTZCO1lBQzNCLElBQUEsTUFBb0JDLFFBQXBCLEVBQWdDLE1BQWhDLENBQUE7Y0FBQUEsV0FBVyxDQUFBLEdBQUEsQ0FBR0osR0FBQUEsQ0FBQUE7WUFBZDtZQUNBLElBQUEsTUFBb0JJLFFBQXBCLEVBQWdDLE1BQWhDLENBQUE7Y0FBQUEsV0FBVyxDQUFBLEdBQUEsQ0FBR0osR0FBQUEsQ0FBQUE7WUFBZDtZQUVBSyxpQkFBaUIvQyxJQUFBWSxPQUFBQSxDQUFBQSxDQUFLTyxPQUFBQSxDQUFDMEIsWUFBRDFCO1lBRXRCbkIsSUFBQVksT0FBQUEsQ0FBQUEsQ0FBS0MsUUFBQUEsQ0FBQ2dDLFlBQU4sRUFBc0IsQ0FBQ0UsY0FBRCxDQUFBLFFBQ0EsTUFBZ0JDLE1BQWZSLFVBQVVTLE1BQUFBLENBQUFBLENBQUtELE9BQUFBLEVBQUFBLEVBQUFBLEVBQWZILGFBQXdCSyxHQUF4Qkw7O2NBQXdCO2NBQ3ZCTSxPQUFBLEVBQUEsR0FBQSxDQUFHRCxHQUFILENBQUEsR0FBT0MsR0FBUCxHQUFBLENBQVVMLFFBQVYsQ0FBQSxHQUFtQkssR0FBbkIsR0FBQSxDQUFzQkMsTUFBdEIsRUFERFAsQ0FBZUcsQ0FBaEIsQ0FEQSxDQUdJSyxTQUFBQSxDQUFBQSxDQUFRQyxNQUFBQSxDQUFNVCxJQUFOUyxDQUg3QnpDO1lBS0swQyxNQUFWZixVQUFVZSxRQUFBQSxFQUFBQSxFQUFBQSxFQUFWVixhQUFvQkssR0FBRCxFQUFNYixLQUF6QlEsRUFBQU07OztjQUFvQjtjQUFLO2NBQ3ZCQSxPQUFLdEMsTUFBQUEsQ0FBQ3FDLEdBQU4sRUFBYWIsS0FBUnhCLENBQUFBLEVBQUFBLE1BQUxiLElBQUFZLE9BQUFBLENBQUFBLENBQUtDLE9BQUFBLEVBQUFBLEVBQUFBLENBQUFBLEVBQUFBLG1CQURQZ0MsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBVVU7WUFJVjdCLFVBQVVDLGFBQU9DLEtBQUFBLENBQUFBO1lBRWpCaUIsT0FBQVcsTUFBQXhELElBQUF3RCxPQUFBQSxFQUFBQSxDQUFJLGVBQUpBLENBQUFBLEVBQUFYLGFBdkdOLEVBdUdNQSxFQUFBTTs7O2NBdkdOO2NBdUc2QjtjQUNyQm5ELElBQUFZLE9BQUFBLENBQUFBLENBQUtDLFFBQUFBLENBQUNzQyxZQUFOLEVBQXNCSixjQUFqQmxDO2NBRUwsSUFBZ0I0QyxlQUFoQjtnQkFBQSxtQkFBTSxNQUFDQyxJQUFELENBQU47Y0FBQTtjQUVBUCxPQUFBUCxHQUFHZSxNQUFBQSxDQUFBQSxFQUxMZCxDQUFBQSxHQUFBQSxzQkFBQUEsQ0FBQVcsRUFqQkZiLENBQUFBLEdBQUFBLFNBQUFBLENBQUFsQjtVQXlCQWMsT0FBQXZDO1FBMUJGdUMsQ0FBQUEsSUFBQUE7O0FBOEJBcUIsUUFBQUEsdUJBQUFBLG1CQW5IRm5CLE9BbUhFbUI7QUFBQUEsVUFBQUE7O1VBQUFBOzs7VUFuSEY7VUFtSGM7VUFDVm5DLE1BQUF6QixJQUFBeUIsbUJBQUFBLEVBQUFBLEVBQUFBLEVBQUFvQyxjQUFvQjNCLE9BQXBCMkIsRUFBQUM7OztZQUFvQjtZQUNsQixJQUFBLEtBQUk5RCxJQUFBZSxhQUFBQSxDQUFBQSxDQUFKLENBQUE7O2NBQ0VDLHlCQUFxQjtjQUNyQmhCLElBQUFVLE1BQUFBLENBQUFBO2NBRUFWLElBQUFZLE9BQUFBLENBQUFBLENBQUtDLFFBQUFBLENBQUMsU0FBTixFQUFrQixHQUFiQTtjQUNMMEIsTUFBQXZDLElBQUF1QyxXQUFBQSxFQUFBQSxDQUFRLFVBQUEsVUFBQSxFQUFTLEdBQVQsQ0FBQSxHQUFBLFFBQWMsYUFBRXdCLE1BQUYsQ0FBZCxDQUFSeEIsQ0FBQUEsRUFBQXVCLGNBMUhSLEVBMEhRQSxFQUFBRTs7O2dCQTFIUjtnQkEwSDJDO2dCQUNqQ2hELHlCQUFxQjtnQkFDckJoQixJQUFBWSxPQUFBQSxDQUFBQSxDQUFLQyxRQUFBQSxDQUFDLFNBQU4sRUFBa0IsR0FBYkE7Z0JBQ0wsSUFBZ0I0QyxlQUFoQjtrQkFBQSxPQUFBLG1CQUFNLE1BQUNDLElBQUQsQ0FBTixDQUFBO2dCQUFBO2tCQTdIVk0sT0FBQTtnQkE2SFUsRUFIRkYsQ0FBQUEsR0FBQUEsc0JBQUFBLENBQUF2QjtZQUxGO1lBV0F1QixPQUFBNUIsT0FBT3lCLE1BQUFBLENBQUFBLEVBWlRFLENBQUFBLEdBQUFBLFNBQUFBLENBQUFwQztVQWNBbUMsT0FBQTVEO1FBZkY0RCxDQUFBQSxJQUFBQTs7QUFtQkFLLFFBQUFBLHdCQUFBQSxvQkF0SUZ4QixPQXNJRXdCO0FBQUFBLFVBQUFBOztVQUFBQTs7O1VBdElGO1VBc0llO1VBQ1h4QyxNQUFBekIsSUFBQXlCLG1CQUFBQSxFQUFBQSxFQUFBQSxFQUFBeUMsY0FBb0JoQyxPQUFwQmdDLEVBQUFDOzs7WUFBb0I7WUFDbEIsSUFBQSxRQUFHbkUsSUFBQWUsYUFBQUEsQ0FBQUEsQ0FBSCxDQUFBOztjQUNFQyx5QkFBcUI7Y0FFckJoQixJQUFBWSxPQUFBQSxDQUFBQSxDQUFLQyxRQUFBQSxDQUFDLFNBQU4sRUFBa0IsR0FBYkE7Y0FDTDBCLE1BQUF2QyxJQUFBdUMsV0FBQUEsRUFBQUEsQ0FBUSxVQUFBLFVBQUEsRUFBUyxHQUFULENBQUEsR0FBQSxRQUFjLGFBQUV3QixNQUFGLENBQWQsQ0FBUnhCLENBQUFBLEVBQUE0QixjQTVJUixFQTRJUUEsRUFBQUM7OztnQkE1SVI7Z0JBNEkyQztnQkFDakNwRCx5QkFBcUI7Z0JBQ3JCaEIsSUFBQVksT0FBQUEsQ0FBQUEsQ0FBS0MsUUFBQUEsQ0FBQyxTQUFOLEVBQWtCLEdBQWJBO2dCQUNMYixJQUFBYyxNQUFBQSxDQUFBQTtnQkFDQSxJQUFnQjJDLGVBQWhCO2tCQUFBLE9BQUEsbUJBQU0sTUFBQ0MsSUFBRCxDQUFOLENBQUE7Z0JBQUE7a0JBaEpWVSxPQUFBO2dCQWdKVSxFQUpGRCxDQUFBQSxHQUFBQSxzQkFBQUEsQ0FBQTVCO1lBSkY7WUFXQTRCLE9BQUFqQyxPQUFPeUIsTUFBQUEsQ0FBQUEsRUFaVE8sQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBQXpDO1VBY0F3QyxPQUFBakU7UUFmRmlFLENBQUFBLElBQUFBOztBQW9CQUksUUFBQUEsMkJBQUFBLHVCQTFKRjVCLE9BMEpFNEI7QUFBQUEsVUFBQUE7O1VBQUFBOzs7VUExSkY7VUEwSmtCO1VBQ2QsSUFBQSxRQUFHckUsSUFBQWUsYUFBQUEsQ0FBQUEsQ0FBSCxDQUFBO1lBQ0VrRCxNQUFBakUsSUFBQWlFLFlBQUFBLEVBQUFBLENBQVMsYUFBRUYsTUFBRixDQUFURSxDQUFBQSxFQUFvQkssS0FBREMsU0FBQUEsQ0FBQUEsQ0FBbkJOO1VBREY7WUFHRUwsTUFBQTVELElBQUE0RCxXQUFBQSxFQUFBQSxDQUFRLGFBQUVHLE1BQUYsQ0FBUkgsQ0FBQUEsRUFBbUJVLEtBQURDLFNBQUFBLENBQUFBLENBQWxCWDtVQUhGO1VBS0FTLE9BQUFyRTtRQU5GcUUsQ0FBQUEsSUFBQUE7O0FBVUFHLFFBQUFBLDBCQUFBQSxzQkFwS0YvQixPQW9LRStCO0FBQUFBLFVBQUFBOztVQUFBQTs7O1VBcEtGO1VBb0tpQjtVQUNiL0MsTUFBQXpCLElBQUF5QixtQkFBQUEsRUFBQUEsRUFBQUEsRUFBQWdELGNBQW9CdkMsT0FBcEJ1QyxFQUFBQzs7O1lBQW9CO1lBQ2xCLElBQUEsS0FBSTFFLElBQUFlLGFBQUFBLENBQUFBLENBQUosQ0FBQTs7Y0FDRUMseUJBQXFCO2NBQ3JCaEIsSUFBQVUsTUFBQUEsQ0FBQUE7Y0FDQWlFLFNBQVMzRSxJQUFBNEUsTUFBQUEsQ0FBQUEsQ0FBSUQsUUFBQUEsQ0FBQUE7Y0FDYkUsY0FBYzdFLElBQUFZLE9BQUFBLENBQUFBLENBQUtPLE9BQUFBLENBQUMsUUFBREE7Y0FDbkJuQixJQUFBWSxPQUFBQSxDQUFBQSxDQUFLQyxRQUFBQSxDQUFDLFFBQU4sRUFBaUJpRSxDQUFBQSxDQUFBQSxDQUFDQyxJQUFBQSxDQUFBQSxDQUFibEU7Y0FFTDBCLE1BQUF2QyxJQUFBdUMsV0FBQUEsRUFBQUEsQ0FBUSxVQUFBLFNBQUEsRUFBUW9DLE1BQU1JLElBQUFBLENBQUFBLENBQWQsQ0FBQSxHQUFBLFFBQW1CLGFBQUVoQixNQUFGLENBQW5CLENBQVJ4QixDQUFBQSxFQUFBbUMsY0E3S1IsRUE2S1FBLEVBQUFNOzs7Z0JBN0tSO2dCQTZLZ0Q7Z0JBQ3RDaEUseUJBQXFCO2dCQUNyQmhCLElBQUFZLE9BQUFBLENBQUFBLENBQUtDLFFBQUFBLENBQUMsUUFBTixFQUFpQmdFLFdBQVpoRTtnQkFDTCxJQUFnQjRDLGVBQWhCO2tCQUFBLE9BQUEsbUJBQU0sTUFBQ0MsSUFBRCxDQUFOLENBQUE7Z0JBQUE7a0JBaExWc0IsT0FBQTtnQkFnTFUsRUFIRk4sQ0FBQUEsR0FBQUEsc0JBQUFBLENBQUFuQztZQVBGO1lBYUFtQyxPQUFBeEMsT0FBT3lCLE1BQUFBLENBQUFBLEVBZFRjLENBQUFBLEdBQUFBLFNBQUFBLENBQUFoRDtVQWdCQStDLE9BQUF4RTtRQWpCRndFLENBQUFBLElBQUFBOztBQXFCQVMsUUFBQUEsd0JBQUFBLG9CQXpMRnhDLE9BeUxFd0M7QUFBQUEsVUFBQUE7O1VBQUFBOzs7VUF6TEY7VUF5TGU7VUFDWHhELE1BQUF6QixJQUFBeUIsbUJBQUFBLEVBQUFBLEVBQUFBLEVBQUF5RCxjQUFvQmhELE9BQXBCZ0QsRUFBQUM7OztZQUFvQjtZQUNsQixJQUFBLFFBQUduRixJQUFBZSxhQUFBQSxDQUFBQSxDQUFILENBQUE7O2NBQ0VDLHlCQUFxQjtjQUNyQjZELGNBQWM3RSxJQUFBWSxPQUFBQSxDQUFBQSxDQUFLTyxPQUFBQSxDQUFDLFFBQURBO2NBRW5Cb0IsTUFBQXZDLElBQUF1QyxXQUFBQSxFQUFBQSxDQUFRLFVBQUEsU0FBQSxFQUFRdUMsQ0FBQUEsQ0FBQUEsQ0FBQ0MsSUFBQUEsQ0FBQUEsQ0FBVCxDQUFBLEdBQUEsUUFBYyxhQUFFaEIsTUFBRixDQUFkLENBQVJ4QixDQUFBQSxFQUFBNEMsY0EvTFIsRUErTFFBLEVBQUFDOzs7Z0JBL0xSO2dCQStMMkM7Z0JBQ2pDcEUseUJBQXFCO2dCQUNyQmhCLElBQUFZLE9BQUFBLENBQUFBLENBQUtDLFFBQUFBLENBQUMsUUFBTixFQUFpQmdFLFdBQVpoRTtnQkFDTGIsSUFBQWMsTUFBQUEsQ0FBQUE7Z0JBQ0EsSUFBZ0IyQyxlQUFoQjtrQkFBQSxPQUFBLG1CQUFNLE1BQUNDLElBQUQsQ0FBTixDQUFBO2dCQUFBO2tCQW5NVjBCLE9BQUE7Z0JBbU1VLEVBSkZELENBQUFBLEdBQUFBLHNCQUFBQSxDQUFBNUM7WUFKRjtZQVdBNEMsT0FBQWpELE9BQU95QixNQUFBQSxDQUFBQSxFQVpUdUIsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBQXpEO1VBY0F3RCxPQUFBakY7UUFmRmlGLENBQUFBLElBQUFBO1FBb0JBeEUsT0FBQTRFLDRCQUFBQSx3QkE3TUY1QyxPQTZNRTRDO0FBQUFBLFVBQUFBOztVQUFBQTs7O1VBN01GO1VBNk1tQjtVQUNmLElBQUEsUUFBR3JGLElBQUFlLGFBQUFBLENBQUFBLENBQUgsQ0FBQTtZQUNFa0UsTUFBQWpGLElBQUFpRixZQUFBQSxFQUFBQSxDQUFTLGFBQUVsQixNQUFGLENBQVRrQixDQUFBQSxFQUFvQlgsS0FBREMsU0FBQUEsQ0FBQUEsQ0FBbkJVO1VBREY7WUFHRVQsTUFBQXhFLElBQUF3RSxjQUFBQSxFQUFBQSxDQUFXLGFBQUVULE1BQUYsQ0FBWFMsQ0FBQUEsRUFBc0JGLEtBQURDLFNBQUFBLENBQUFBLENBQXJCQztVQUhGO1VBS0FhLE9BQUFyRjtRQU5GcUYsQ0FBQUEsSUFBQUE7TUFqTUY1RSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtJQVZnQk4sR0FBQUEsV0FBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBRkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozNzEyOCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvaHR0cC9iaW5hcnkucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBIVFRQXG5cbiMgUmVwcmVzZW50cyBhIGJpbmFyeSByZXN1bHQgZnJvbSBhIEhUVFAgcmVzcG9uc2UuXG5jbGFzcyBCaW5hcnlcbiAgIyBAIWF0dHJpYnV0ZSBbcl0gdHlwZVxuICAjIEByZXR1cm4gWzpzdHJpbmcsIDpidWZmZXJdIHRoZSB0eXBlIG9mIGJpbmFyeVxuICBhdHRyX3JlYWRlciA6dHlwZVxuXG4gICMgQ3JlYXRlIGEgYmluYXJ5IGZyb20gYSB2YWx1ZS5cbiAgI1xuICAjIEBwYXJhbSB2YWx1ZSBbU3RyaW5nLCBCdWZmZXJdIHRoZSBiaW5hcnlcbiAgZGVmIGluaXRpYWxpemUodmFsdWUpXG4gICAgaWYgU3RyaW5nID09PSB2YWx1ZVxuICAgICAgQHR5cGUgPSA6c3RyaW5nXG4gICAgICBAZGF0YSA9IHZhbHVlXG4gICAgZWxzZVxuICAgICAgQHR5cGUgPSA6YnVmZmVyXG4gICAgICBAZGF0YSA9IHZhbHVlLnRvX2FcbiAgICBlbmRcbiAgZW5kXG5cbiAgaW5jbHVkZSBFbnVtZXJhYmxlXG5cbiAgIyBJdGVyYXRlIG92ZXIgZWFjaCBieXRlIGluIHRoZSBiaW5hcnkuXG4gICNcbiAgIyBAeWllbGQgW2J5dGVdIHRoZSBieXRlXG4gICNcbiAgIyBAcmV0dXJuIFtzZWxmXVxuICBkZWYgZWFjaCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDplYWNoIHVubGVzcyBibG9ja1xuXG4gICAgaW5kZXggID0gMFxuICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoXG5cbiAgICB3aGlsZSBpbmRleCA8IGxlbmd0aFxuICAgICAgYmxvY2suY2FsbChzZWxmW2luZGV4XSlcblxuICAgICAgaW5kZXggKz0gMVxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICAjIEFjY2VzcyBhIGJ5dGUgZnJvbSB0aGUgYmluYXJ5LlxuICAjXG4gICMgQHJldHVybiBbSW50ZWdlcl0gYSBieXRlXG4gIGRlZiBbXShpbmRleClcbiAgICBAdHlwZSA9PSA6c3RyaW5nID8gYCNAZGF0YS5jaGFyQ29kZUF0KGluZGV4KSAmIDB4ZmZgIDogQGRhdGFbaW5kZXhdXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIGxlbmd0aFxuICAjIEByZXR1cm4gW0ludGVnZXJdIHRoZSBsZW5ndGggb2YgdGhlIGJpbmFyeVxuICBkZWYgbGVuZ3RoXG4gICAgQGRhdGEubGVuZ3RoXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8bW9kdWxlOkhUVFA+IiwiPGNsYXNzOkJpbmFyeT4iLCJzZWxmIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwidmFsdWUiLCJTdHJpbmciLCJAdHlwZSIsIkBkYXRhIiwidG9fYSIsImluY2x1ZGUiLCJFbnVtZXJhYmxlIiwiZWFjaCIsImJsb2NrIiwiZW51bV9mb3IiLCJpbmRleCIsIjAiLCJsZW5ndGgiLCI8IiwiY2FsbCIsIltdIiwiKyIsIjEiXSwibWFwcGluZ3MiOiJBQUFBQSxzQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BR2hCQSxPQUFBQztNQUFBQTs7UUFBQUE7O0FBQUFBOztRQUdFQyxJQUFBQyxhQUFBQSxDQUFZLE1BQVpBOztBQUtBQyxRQUFBQSwwQkFBQUEsc0JBQWVDLEtBQWZEO0FBQUFBLFVBQUFBOztVQUNFLElBQUEsUUFBR0UsWUFBSCxFQUFjRCxLQUFkLENBQUE7O1lBQ0VFLFlBQVE7WUFDUkgsT0FBQUksQ0FBQUEsWUFBUUgsS0FBUkc7VUFGRjs7WUFJRUQsWUFBUTtZQUNSSCxPQUFBSSxDQUFBQSxZQUFRSCxLQUFLSSxNQUFBQSxDQUFBQSxDQUFiRDtVQUxGO1FBREZKLENBQUFBO1FBVUFGLElBQUFRLFNBQUFBLENBQVFDLGdCQUFSRDs7QUFPQUUsUUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxVQUFBQTs7VUFBQUE7OztVQUNFLEtBQUEsUUFBNkJDLEtBQTdCLENBQUE7WUFBQSxPQUFPWCxJQUFBWSxVQUFBQSxDQUFTLE1BQVRBO1VBQVA7VUFFQUMsUUFBU0M7VUFDVEMsU0FBU2YsSUFBSWUsUUFBQUEsQ0FBQUE7VUFFYixPQUFBLFFBQVlDLE9BQU5ILEtBQU1HLEVBQUVELE1BQUZDLENBQVosQ0FBQTs7WUFDRUwsS0FBS00sTUFBQUEsQ0FBTWpCLElBQUlrQixPQUFBQSxDQUFDTCxLQUFESyxDQUFWRDtZQUVMSixRQUFNTSxTQUFOTixLQUFNTSxFQUFHQyxDQUFIRDtVQUhSO1VBTUFULE9BQUFWO1FBWkZVLENBQUFBOztBQWtCQVEsUUFBQUEsa0JBQUFBLHNCQUFPTCxLQUFQSztBQUFBQSxVQUFBQTs7VUFDRSxJQUFBLE1BQUFiLFNBQUEsRUFBUyxRQUFULENBQUE7WUFBbUJhLE9BQUVaLFNBQUtZO1VBQTFCO1lBQXVEQSxPQUFBWixTQUFLWSxPQUFBQSxDQUFDTCxLQUFESztVQUE1RDtRQURGQSxDQUFBQTtRQU1BbkIsT0FBQWdCLHNCQUFBQSxrQkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUFULFNBQUtTLFFBQUFBLENBQUFBO1FBRFBBLENBQUFBO01BakRGaEIsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7SUFIZ0JELEdBQUFBLFdBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzcyMDQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2h0dHAvaGVhZGVycy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgbW9kdWxlIEhUVFBcblxuIyBSZXByZXNlbnRzIGEgc2luZ2xlIEhUVFAgaGVhZGVyLlxuSGVhZGVyID0gU3RydWN0Lm5ldyg6bmFtZSwgOnZhbHVlKVxuXG4jIFJlcHJlc2VudHMgSFRUUCBoZWFkZXJzLlxuY2xhc3MgSGVhZGVyc1xuICAjIFBhcnNlIEhUVFAgaGVhZGVycyBmcm9tIGEgc3RyaW5nLlxuICAjXG4gICMgQHBhcmFtIHN0cmluZyBbU3RyaW5nXSB0aGUgd2hvbGUgSFRUUCBoZWFkZXJzIHJlc3BvbnNlXG4gICMgQHJldHVybiBbSGVhZGVyc10gdGhlIHBhcnNlZCBoZWFkZXJzXG4gIGRlZiBzZWxmLnBhcnNlKHN0cmluZylcbiAgICBzZWxmW3N0cmluZy5saW5lcy5tYXAgeyB8bHwgbC5jaG9tcC5zcGxpdCgvXFxzKjpcXHMqLykgfV1cbiAgZW5kXG5cbiAgIyBDcmVhdGUge0hlYWRlcnN9IGZyb20gYSBoYXNoLlxuICAjXG4gICMgQHBhcmFtIGhhc2ggW0hhc2hdXG4gIGRlZiBzZWxmLltdKGhhc2gpXG4gICAgcmVzdWx0ID0gbmV3XG5cbiAgICBoYXNoLmVhY2gge3xuYW1lLCB2YWx1ZXxcbiAgICAgIHJlc3VsdFtuYW1lXSA9IHZhbHVlXG4gICAgfVxuXG4gICAgcmVzdWx0XG4gIGVuZFxuXG4gIGluY2x1ZGUgRW51bWVyYWJsZVxuXG4gICMgQ3JlYXRlIGFuIGVtcHR5IHtIZWFkZXJzfS5cbiAgZGVmIGluaXRpYWxpemVcbiAgICBAaGFzaCA9IEhhc2gubmV3XG4gIGVuZFxuXG4gICMgQ2xlYXIgdGhlIHtIZWFkZXJzfS5cbiAgZGVmIGNsZWFyXG4gICAgQGhhc2guY2xlYXJcbiAgZW5kXG5cbiAgIyBFbnVtZXJhdGUgb3ZlciB0aGUgaGVhZGVycy5cbiAgI1xuICAjIEB5aWVsZHBhcmFtIG5hbWUgW1N0cmluZ10gdGhlIG5hbWUgb2YgdGhlIGhlYWRlclxuICAjIEB5aWVsZHBhcmFtIHZhbHVlIFtTdHJpbmddIHRoZSB2YWx1ZSBvZiB0aGUgaGVhZGVyXG4gICNcbiAgIyBAcmV0dXJuIFtzZWxmXVxuICBkZWYgZWFjaCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDplYWNoIHVubGVzcyBibG9ja1xuXG4gICAgQGhhc2guZWFjaCB7fF8sIGhlYWRlcnxcbiAgICAgIGJsb2NrLmNhbGwgW2hlYWRlci5uYW1lLCBoZWFkZXIudmFsdWVdXG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICAjIEdldCB0aGUgdmFsdWUgb2YgYSBoZWFkZXIuXG4gICNcbiAgIyBAcGFyYW0gbmFtZSBbU3RyaW5nXSB0aGUgbmFtZSBvZiB0aGUgaGVhZGVyXG4gICNcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSB2YWx1ZSBvZiB0aGUgaGVhZGVyXG4gIGRlZiBbXShuYW1lKVxuICAgIEBoYXNoW25hbWUuZG93bmNhc2VdXG4gIGVuZFxuXG4gICMgU2V0IGEgdmFsdWUgZm9yIHRoZSBoZWFkZXIuXG4gICNcbiAgIyBAcGFyYW0gbmFtZSBbU3RyaW5nXSB0aGUgbmFtZSBvZiB0aGUgaGVhZGVyXG4gICMgQHBhcmFtIHZhbHVlIFtTdHJpbmddIHRoZSB2YWx1ZSBvZiB0aGUgaGVhZGVyXG4gIGRlZiBbXT0obmFtZSwgdmFsdWUpXG4gICAgaGVhZGVyID0gSGVhZGVyLm5ldyhuYW1lLCB2YWx1ZSlcblxuICAgIEBoYXNoW25hbWUuZG93bmNhc2VdID0gaGVhZGVyXG4gIGVuZFxuXG4gICMgUHVzaCBhIGhlYWRlci5cbiAgI1xuICAjIEBwYXJhbSBoZWFkZXIgW0hlYWRlcl0gdGhlIGhlYWRlciB0byBwdXNoXG4gICNcbiAgIyBAcmV0dXJuIFtzZWxmXVxuICBkZWYgPDwoaGVhZGVyKVxuICAgIEBoYXNoW2hlYWRlci5uYW1lLmRvd25jYXNlXSA9IGhlYWRlclxuXG4gICAgc2VsZlxuICBlbmRcblxuICBhbGlhcyBwdXNoIDw8XG5cbiAgIyBNZXJnZSBpbiBwbGFjZSBvdGhlciBoZWFkZXJzLlxuICAjXG4gICMgQHBhcmFtIG90aGVyIFtIZWFkZXJzLCBIYXNoLCAjZWFjaF0gdGhlIGhlYWRlcnMgdG8gbWVyZ2VcbiAgI1xuICAjIEByZXR1cm4gW3NlbGZdXG4gIGRlZiBtZXJnZSEob3RoZXIpXG4gICAgb3RoZXIuZWFjaCB7fG5hbWUsIHZhbHVlfFxuICAgICAgc2VsZltuYW1lXSA9IHZhbHVlXG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBsZW5ndGhcbiAgIyBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgbnVtYmVyIG9mIGhlYWRlcnNcbiAgZGVmIGxlbmd0aFxuICAgIEBoYXNoLmxlbmd0aFxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPG1vZHVsZTpIVFRQPiIsIlN0cnVjdCIsIm5ldyIsIjxjbGFzczpIZWFkZXJzPiIsInBhcnNlIiwic2VsZiIsInN0cmluZyIsIltdIiwibWFwIiwibGluZXMiLCJibG9jayBpbiBwYXJzZSIsImwiLCJibG9jayAoMiBsZXZlbHMpIGluIHBhcnNlIiwiY2hvbXAiLCJzcGxpdCIsImhhc2giLCJyZXN1bHQiLCJlYWNoIiwiYmxvY2sgaW4gW10iLCJuYW1lIiwidmFsdWUiLCJibG9jayAoMiBsZXZlbHMpIGluIFtdIiwiW109IiwiaW5jbHVkZSIsIkVudW1lcmFibGUiLCJpbml0aWFsaXplIiwiQGhhc2giLCJIYXNoIiwiY2xlYXIiLCJibG9jayIsImVudW1fZm9yIiwiYmxvY2sgaW4gZWFjaCIsIl8iLCJoZWFkZXIiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2giLCJjYWxsIiwiZG93bmNhc2UiLCJIZWFkZXIiLCI8PCIsIm1lcmdlISIsIm90aGVyIiwiYmxvY2sgaW4gbWVyZ2UhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBtZXJnZSEiLCJsZW5ndGgiXSwibWFwcGluZ3MiOiJBQUFBQSx1Q0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7OztNQUdoQixrQ0FBU0MsWUFBTUMsS0FBQUEsQ0FBSyxNQUFYLEVBQWtCLE9BQVpBLENBQWY7TUFHQUYsT0FBQUc7TUFBQUE7O1FBQUFBOztBQUFBQTs7UUFLRUMsTUFBSUMsSUFBSkQsWUFBQUEsaUJBQWVFLE1BQWZGO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBQyxJQUFJRSxPQUFBQSxDQUFhQyxNQUFaRixNQUFNRyxPQUFBQSxDQUFBQSxDQUFNRCxPQUFBQSxFQUFBQSxFQUFBQSxFQUFaRSxhQUFvQkMsQ0FBcEJEOztZQUFvQjtZQUFHRSxPQUFBRCxDQUFDRSxPQUFBQSxDQUFBQSxDQUFNQyxPQUFBQSxDQUFPLFNBQVBBLEVBQTlCSixDQUFZRixDQUFiRDtRQUROSCxDQUFBQTtRQU9BRyxNQUFJRixJQUFKRSxTQUFBQSx1QkFBWVEsSUFBWlI7QUFBQUEsVUFBQUE7OztVQUNFUyxTQUFTWCxJQUFBSCxLQUFBQSxDQUFBQTtVQUVMZSxNQUFKRixJQUFJRSxRQUFBQSxFQUFBQSxFQUFBQSxFQUFKQyxhQUFZQyxJQUFELEVBQU9DLEtBQWxCRixFQUFBRzs7O1lBQVk7WUFBTTtZQUNoQkEsT0FBTUMsTUFBQUEsQ0FBQ0gsSUFBUCxFQUFlQyxLQUFURSxDQUFBQSxFQUFBQSxNQUFOTixNQUFNTSxPQUFBQSxFQUFBQSxFQUFBQSxDQUFBQSxFQUFBQSxtQkFEUkosQ0FBSUQ7VUFJSlYsT0FBQVM7UUFQRlQsQ0FBQUE7UUFVQUYsSUFBQWtCLFNBQUFBLENBQVFDLGdCQUFSRDs7QUFHQUUsUUFBQUEsMEJBQUFBLHNCQUFBQTtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBQUMsQ0FBQUEsWUFBUUMsVUFBSXpCLEtBQUFBLENBQUFBLENBQVp3QjtRQURGRCxDQUFBQTs7QUFLQUcsUUFBQUEscUJBQUFBLGlCQUFBQTtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBQUYsU0FBS0UsT0FBQUEsQ0FBQUE7UUFEUEEsQ0FBQUE7O0FBVUFYLFFBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsVUFBQUE7O1VBQUFBOzs7VUFDRSxLQUFBLFFBQTZCWSxLQUE3QixDQUFBO1lBQUEsT0FBT3hCLElBQUF5QixVQUFBQSxDQUFTLE1BQVRBO1VBQVA7VUFFS2IsTUFBTFMsU0FBS1QsUUFBQUEsRUFBQUEsRUFBQUEsRUFBTGMsYUFBYUMsQ0FBRCxFQUFJQyxNQUFoQkY7O1lBQWE7WUFBRztZQUNkRyxPQUFBTCxLQUFLTSxNQUFBQSxDQUFNLENBQUNGLE1BQU1kLE1BQUFBLENBQUFBLENBQVAsRUFBY2MsTUFBTWIsT0FBQUEsQ0FBQUEsQ0FBcEIsQ0FBTmUsRUFEUEosQ0FBS2Q7VUFJTEEsT0FBQVo7UUFQRlksQ0FBQUE7O0FBZUFWLFFBQUFBLGtCQUFBQSx1QkFBT1ksSUFBUFo7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUFtQixTQUFLbkIsT0FBQUEsQ0FBQ1ksSUFBSWlCLFVBQUFBLENBQUFBLENBQUw3QjtRQURQQSxDQUFBQTs7QUFRQWUsUUFBQUEsbUJBQUFBLDBCQUFRSCxJQUFELEVBQU9DLEtBQWRFO0FBQUFBLFVBQUFBOzs7VUFDRVcsU0FBU0ksWUFBTW5DLEtBQUFBLENBQUtpQixJQUFYLEVBQWlCQyxLQUFYbEI7VUFFZm9CLE9BQUtBLE1BQUFBLENBQUNILElBQUlpQixVQUFBQSxDQUFBQSxDQUFWLEVBQXVCSCxNQUFsQlgsQ0FBQUEsRUFBQUEsTUFBTEksU0FBS0osT0FBQUEsRUFBQUEsRUFBQUEsQ0FBQUEsRUFBQUE7UUFIUEEsQ0FBQUE7O0FBV0FnQixRQUFBQSxrQkFBQUEsMkJBQU9MLE1BQVBLO0FBQUFBLFVBQUFBOzs7VUFDRVosU0FBS0osUUFBQUEsQ0FBQ1csTUFBTWQsTUFBQUEsQ0FBQUEsQ0FBS2lCLFVBQUFBLENBQUFBLENBQWpCLEVBQThCSCxNQUF6Qlg7VUFFTGdCLE9BQUFqQztRQUhGaUMsQ0FBQUE7UUFNQSxhQUFNLE1BQU4sRUFBVyxJQUFYOztBQU9BQyxRQUFBQSxzQkFBQUEsK0JBQVdDLEtBQVhEO0FBQUFBLFVBQUFBOzs7VUFDT3RCLE1BQUx1QixLQUFLdkIsUUFBQUEsRUFBQUEsRUFBQUEsRUFBTHdCLGFBQWF0QixJQUFELEVBQU9DLEtBQW5CcUIsRUFBQUM7OztZQUFhO1lBQU07WUFDakJBLE9BQUlwQixNQUFBQSxDQUFDSCxJQUFMLEVBQWFDLEtBQVRFLENBQUFBLEVBQUFBLE1BQUpqQixJQUFJaUIsT0FBQUEsRUFBQUEsRUFBQUEsQ0FBQUEsRUFBQUEsbUJBRE5tQixDQUFBQSxHQUFBQSxTQUFBQSxDQUFLeEI7VUFJTHNCLE9BQUFsQztRQUxGa0MsQ0FBQUE7UUFVQXBDLE9BQUF3QyxzQkFBQUEsa0JBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBakIsU0FBS2lCLFFBQUFBLENBQUFBO1FBRFBBLENBQUFBO01BakdGeEMsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7SUFOZ0JILEdBQUFBLFdBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzczMjQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2h0dHAvcmVxdWVzdC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgbW9kdWxlIEhUVFBcblxuY2xhc3MgUmVxdWVzdFxuICBpbmNsdWRlIE5hdGl2ZTo6V3JhcHBlclxuICBpbmNsdWRlIEV2ZW50OjpUYXJnZXRcblxuICAjIERlZmF1bHQgaGVhZGVycy5cbiAgSEVBREVSUyA9IHtcbiAgICAnWC1SZXF1ZXN0ZWQtV2l0aCcgPT4gJ1hNTEh0dHBSZXF1ZXN0JyxcbiAgICAnWC1PcGFsLVZlcnNpb24nICAgPT4gUlVCWV9FTkdJTkVfVkVSU0lPTixcbiAgICAnQWNjZXB0JyAgICAgICAgICAgPT4gJ3RleHQvamF2YXNjcmlwdCwgdGV4dC9odG1sLCBhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sLCAqLyonXG4gIH1cblxuICBTVEFURVMgPSAld1t1bmluaXRpYWxpemVkIGxvYWRpbmcgbG9hZGVkIGludGVyYWN0aXZlIGNvbXBsZXRlXVxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIGhlYWRlcnNcbiAgIyBAcmV0dXJuIFtIZWFkZXJzXSB0aGUgcmVxdWVzdCBoZWFkZXJzXG4gIGF0dHJfcmVhZGVyIDpoZWFkZXJzXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gcmVzcG9uc2VcbiAgIyBAcmV0dXJuIFtSZXNwb25zZV0gdGhlIHJlc3BvbnNlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHJlcXVlc3RcbiAgYXR0cl9yZWFkZXIgOnJlc3BvbnNlXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gbWV0aG9kXG4gICMgQHJldHVybiBbU3ltYm9sXSB0aGUgSFRUUCBtZXRob2QgZm9yIHRoaXMgcmVxdWVzdFxuICBhdHRyX3JlYWRlciA6bWV0aG9kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gdXJsXG4gICMgQHJldHVybiBbU3RyaW5nLCAjdG9fc10gdGhlIFVSTCBmb3IgdGhpcyByZXF1ZXN0XG4gIGF0dHJfcmVhZGVyIDp1cmxcblxuICAjIENyZWF0ZSBhIHJlcXVlc3Qgd2l0aCB0aGUgb3B0aW9uYWxseSBnaXZlbiBjb25maWd1cmF0aW9uIGJsb2NrLlxuICAjXG4gICMgQHlpZWxkIFtyZXF1ZXN0XSBpZiB0aGUgYmxvY2sgaGFzIGEgcGFyYW1ldGVyIHRoZSByZXF1ZXN0IGlzIHBhc3NlZFxuICAjICAgICAgICAgICAgICAgICAgb3RoZXJ3aXNlIGl0J3MgaW5zdGFuY2VfZXhlYydkXG4gIGRlZiBpbml0aWFsaXplKCZibG9jaylcbiAgICBzdXBlcih0cmFuc3BvcnQpXG5cbiAgICBAcGFyYW1ldGVycyAgID0ge31cbiAgICBAcXVlcnkgICAgICAgID0ge31cbiAgICBAaGVhZGVycyAgICAgID0gSGVhZGVyc1tIRUFERVJTXVxuICAgIEBtZXRob2QgICAgICAgPSA6Z2V0XG4gICAgQGFzeW5jaHJvbm91cyA9IHRydWVcbiAgICBAYmluYXJ5ICAgICAgID0gZmFsc2VcbiAgICBAY2FjaGVhYmxlICAgID0gdHJ1ZVxuICAgIEBvcGVuZWQgICAgICAgPSBmYWxzZVxuICAgIEBzZW50ICAgICAgICAgPSBmYWxzZVxuICAgIEBjb21wbGV0ZWQgICAgPSBmYWxzZVxuICAgIEBjYWxsYmFja3MgICAgPSBIYXNoLm5ldyB7IHxoLCBrfCBoW2tdID0gW10gfVxuXG4gICAgaWYgYmxvY2suYXJpdHkgPT0gMFxuICAgICAgaW5zdGFuY2VfZXhlYygmYmxvY2spXG4gICAgZWxzZVxuICAgICAgYmxvY2suY2FsbChzZWxmKVxuICAgIGVuZCBpZiBibG9ja1xuICBlbmRcblxuICAjIEAhbWV0aG9kIHRyYW5zcG9ydFxuICAjICAgQHByaXZhdGVcbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gOlhIUlxuICAgIGRlZiB0cmFuc3BvcnRcbiAgICAgIGBuZXcgWE1MSHR0cFJlcXVlc3QoKWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gOkFjdGl2ZVhcbiAgICBkZWYgdHJhbnNwb3J0XG4gICAgICBgbmV3IEFjdGl2ZVhPYmplY3QoXCJNU1hNTDIuWE1MSFRUUC4zLjBcIilgXG4gICAgZW5kXG4gIGVsc2VcbiAgICBkZWYgdHJhbnNwb3J0XG4gICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yXG4gICAgZW5kXG4gIGVuZFxuXG4gICMgQ2hlY2sgaWYgdGhlIHJlcXVlc3QgaGFzIGJlZW4gb3BlbmVkLlxuICBkZWYgb3BlbmVkP1xuICAgIEBvcGVuZWRcbiAgZW5kXG5cbiAgIyBDaGVjayBpZiB0aGUgcmVxdWVzdCBoYXMgYmVlbiBzZW50LlxuICBkZWYgc2VudD9cbiAgICBAc2VudFxuICBlbmRcblxuICAjIENoZWNrIGlmIHRoZSByZXF1ZXN0IGhhcyBjb21wbGV0ZWQuXG4gIGRlZiBjb21wbGV0ZWQ/XG4gICAgQGNvbXBsZXRlZFxuICBlbmRcblxuICAjIENoZWNrIHRoZSByZXF1ZXN0IGlzIGFzeW5jaHJvbm91cy5cbiAgZGVmIGFzeW5jaHJvbm91cz9cbiAgICBAYXN5bmNocm9ub3VzXG4gIGVuZFxuXG4gICMgQ2hlY2sgdGhlIHJlcXVlc3QgaXMgc3luY2hyb25vdXMuXG4gIGRlZiBzeW5jaHJvbm91cz9cbiAgICAhQGFzeW5jaHJvbm91c1xuICBlbmRcblxuICAjIE1ha2UgdGhlIHJlcXVlc3QgYXN5bmNocm9ub3VzLlxuICBkZWYgYXN5bmNocm9ub3VzIVxuICAgIEBhc3luY2hyb25vdXMgPSB0cnVlXG4gIGVuZFxuXG4gICMgTWFrZSB0aGUgcmVxdWVzdCBzeW5jaHJvbm91cy5cbiAgZGVmIHN5bmNocm9ub3VzIVxuICAgIEBhc3luY2hyb25vdXMgPSBmYWxzZVxuICBlbmRcblxuICAjIENoZWNrIHRoZSByZXF1ZXN0IGlzIGJpbmFyeS5cbiAgZGVmIGJpbmFyeT9cbiAgICBAYmluYXJ5XG4gIGVuZFxuXG4gICMgTWFrZSB0aGUgcmVxdWVzdCBiaW5hcnkuXG4gIGRlZiBiaW5hcnkhXG4gICAgQGJpbmFyeSA9IHRydWVcbiAgZW5kXG5cbiAgIyBDaGVjayBpZiB0aGUgcmVxdWVzdCBpcyBjYWNoZWFibGUuXG4gIGRlZiBjYWNoZWFibGU/XG4gICAgQGNhY2hlYWJsZVxuICBlbmRcblxuICAjIERpc2FibGUgY2FjaGluZyBmb3IgdGhpcyByZXF1ZXN0LlxuICBkZWYgbm9fY2FjaGUhXG4gICAgQGNhY2hlYWJsZSA9IGZhbHNlXG4gIGVuZFxuXG4gICMgR2V0IG9yIHNldCB0aGUgdXNlciB1c2VkIGZvciBhdXRoZW50aWNhdGlvbi5cbiAgI1xuICAjIEBwYXJhbSB2YWx1ZSBbU3RyaW5nXSB3aGVuIHBhc3NlZCBpdCBzZXRzLCB3aGVuIG9taXR0ZWQgaXQgZ2V0c1xuICAjXG4gICMgQHJldHVybiBbU3RyaW5nXVxuICBkZWYgdXNlcih2YWx1ZSA9IG5pbClcbiAgICB2YWx1ZSA/IEB1c2VyID0gdmFsdWUgOiBAdXNlclxuICBlbmRcblxuICAjIEdldCBvciBzZXQgdGhlIHBhc3N3b3JkIHVzZWQgZm9yIGF1dGhlbnRpY2F0aW9uLlxuICAjXG4gICMgQHBhcmFtIHZhbHVlIFtTdHJpbmddIHdoZW4gcGFzc2VkIGl0IHNldHMsIHdoZW4gb21pdHRlZCBpdCBnZXRzXG4gICNcbiAgIyBAcmV0dXJuIFtTdHJpbmddXG4gIGRlZiBwYXNzd29yZCh2YWx1ZSA9IG5pbClcbiAgICB2YWx1ZSA/IEBwYXNzd29yZCA9IHZhbHVlIDogQHBhc3N3b3JkXG4gIGVuZFxuXG4gICMgR2V0IG9yIHNldCB0aGUgTUlNRSB0eXBlIG9mIHRoZSByZXF1ZXN0LlxuICAjXG4gICMgQHBhcmFtIHZhbHVlIFtTdHJpbmddIHdoZW4gcGFzc2VkIGl0IHNldHMsIHdoZW4gb21pdHRlZCBpdCBnZXRzXG4gICNcbiAgIyBAcmV0dXJuIFtTdHJpbmddXG4gIGRlZiBtaW1lX3R5cGUodmFsdWUgPSBuaWwpXG4gICAgdmFsdWUgPyBAbWltZV90eXBlID0gdmFsdWUgOiBAbWltZV90eXBlXG4gIGVuZFxuXG4gICMgR2V0IG9yIHNldCB0aGUgQ29udGVudC1UeXBlIG9mIHRoZSByZXF1ZXN0LlxuICAjXG4gICMgQHBhcmFtIHZhbHVlIFtTdHJpbmddIHdoZW4gcGFzc2VkIGl0IHNldHMsIHdoZW4gb21pdHRlZCBpdCBnZXRzXG4gICNcbiAgIyBAcmV0dXJuIFtTdHJpbmddXG4gIGRlZiBjb250ZW50X3R5cGUodmFsdWUgPSBuaWwpXG4gICAgdmFsdWUgPyBAY29udGVudF90eXBlID0gdmFsdWUgOiBAY29udGVudF90eXBlXG4gIGVuZFxuXG4gICMgR2V0IG9yIHNldCB0aGUgZW5jb2Rpbmcgb2YgdGhlIHJlcXVlc3QuXG4gICNcbiAgIyBAcGFyYW0gdmFsdWUgW1N0cmluZ10gd2hlbiBwYXNzZWQgaXQgc2V0cywgd2hlbiBvbWl0dGVkIGl0IGdldHNcbiAgI1xuICAjIEByZXR1cm4gW1N0cmluZ11cbiAgZGVmIGVuY29kaW5nKHZhbHVlID0gbmlsKVxuICAgIHZhbHVlID8gQGVuY29kaW5nID0gdmFsdWUgOiBAZW5jb2RpbmdcbiAgZW5kXG5cbiAgIyBTZXQgdGhlIHJlcXVlc3QgcGFyYW1ldGVycy5cbiAgI1xuICAjIEBwYXJhbSBoYXNoIFtIYXNoXSB0aGUgcGFyYW1ldGVyc1xuICAjXG4gICMgQHJldHVybiBbSGFzaF1cbiAgZGVmIHBhcmFtZXRlcnMoaGFzaCA9IG5pbClcbiAgICBoYXNoID8gQHBhcmFtZXRlcnMgPSBoYXNoIDogQHBhcmFtZXRlcnNcbiAgZW5kXG5cbiAgIyBTZXQgdGhlIFVSSSBxdWVyeS5cbiAgI1xuICAjIEBwYXJhbSBoYXNoIFtIYXNoXSB0aGUgcXVlcnlcbiAgI1xuICAjIEByZXR1cm4gW0hhc2hdXG4gIGRlZiBxdWVyeShoYXNoID0gbmlsKVxuICAgIGhhc2ggPyBAcXVlcnkgPSBoYXNoIDogQHF1ZXJ5XG4gIGVuZFxuXG4gICMgUmVnaXN0ZXIgYW4gZXZlbnQgb24gdGhlIHJlcXVlc3QuXG4gICNcbiAgIyBAcGFyYW0gd2hhdCBbU3ltYm9sLCBTdHJpbmddIHRoZSBldmVudCBuYW1lXG4gICNcbiAgIyBAeWllbGRwYXJhbSByZXNwb25zZSBbUmVzcG9uc2VdIHRoZSByZXNwb25zZSBmb3IgdGhlIGV2ZW50XG4gIGRlZiBvbih3aGF0LCAqLCAmYmxvY2spXG4gICAgaWYgU1RBVEVTLmluY2x1ZGU/KHdoYXQpIHx8ICV3W3N1Y2Nlc3MgZmFpbHVyZV0uaW5jbHVkZT8od2hhdCkgfHwgSW50ZWdlciA9PT0gd2hhdFxuICAgICAgQGNhbGxiYWNrc1t3aGF0XSA8PCBibG9ja1xuICAgIGVsc2VcbiAgICAgIHN1cGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gICMgT3BlbiB0aGUgcmVxdWVzdC5cbiAgI1xuICAjIEBwYXJhbSBtZXRob2QgW1N5bWJvbF0gdGhlIEhUVFAgbWV0aG9kIHRvIHVzZVxuICAjIEBwYXJhbSB1cmwgW1N0cmluZywgI3RvX3NdIHRoZSBVUkwgdG8gc2VuZCB0aGUgcmVxdWVzdCB0b1xuICAjIEBwYXJhbSBhc3luY2hyb25vdXMgW0Jvb2xlYW5dIHdoZXRoZXIgdGhlIHJlcXVlc3QgaXMgYXN5bmNocm9ub3VzIG9yIG5vdFxuICAjIEBwYXJhbSB1c2VyIFtTdHJpbmddIHRoZSB1c2VyIHRvIHVzZSBmb3IgYXV0aGVudGljYXRpb25cbiAgIyBAcGFyYW0gcGFzc3dvcmQgW1N0cmluZ10gdGhlIHBhc3N3b3JkIHRvIHVzZSBmb3IgYXV0aGVudGljYXRpb25cbiAgI1xuICAjIEByZXR1cm4gW3NlbGZdXG4gIGRlZiBvcGVuKG1ldGhvZCA9IG5pbCwgdXJsID0gbmlsLCBhc3luY2hyb25vdXMgPSBuaWwsIHVzZXIgPSBuaWwsIHBhc3N3b3JkID0gbmlsKVxuICAgIHJhaXNlICd0aGUgcmVxdWVzdCBoYXMgYWxyZWFkeSBiZWVuIG9wZW5lZCcgaWYgb3BlbmVkP1xuXG4gICAgQG1ldGhvZCAgICAgICA9IG1ldGhvZCAgICAgICB1bmxlc3MgbWV0aG9kLm5pbD9cbiAgICBAdXJsICAgICAgICAgID0gdXJsICAgICAgICAgIHVubGVzcyB1cmwubmlsP1xuICAgIEBhc3luY2hyb25vdXMgPSBhc3luY2hyb25vdXMgdW5sZXNzIGFzeW5jaHJvbm91cy5uaWw/XG4gICAgQHVzZXIgICAgICAgICA9IHVzZXIgICAgICAgICB1bmxlc3MgdXNlci5uaWw/XG4gICAgQHBhc3N3b3JkICAgICA9IHBhc3N3b3JkICAgICB1bmxlc3MgcGFzc3dvcmQubmlsP1xuXG4gICAgdXJsID0gQHVybFxuXG4gICAgIyBhZGQgYSBkdW1teSByYW5kb20gcGFyYW1ldGVyIHRvIHRoZSBxdWVyeSB0byB0cnkgY2lyY3VtdmVudCBjYWNoaW5nXG4gICAgdW5sZXNzIGNhY2hlYWJsZT9cbiAgICAgIEBxdWVyeVs6X10gPSByYW5kXG4gICAgZW5kXG5cbiAgICAjIGFkZCB0aGUgZW5jb2RlZCBxdWVyeSB0byB0aGUgQHVybCwgcHJlcGVuZGluZyB0aGUgcmlnaHQgY2hhcmFjdGVyIGlmXG4gICAgIyB0aGVyZSB3YXMgYWxyZWFkeSBhIHF1ZXJ5IGluIHRoZSBkZWZpbmVkIEB1cmwgb3Igbm90XG4gICAgdW5sZXNzIEBxdWVyeS5lbXB0eT9cbiAgICAgIGlmIHVybC5pbmNsdWRlPyA/P1xuICAgICAgICB1cmwgKz0gPyZcbiAgICAgIGVsc2VcbiAgICAgICAgdXJsICs9ID8/XG4gICAgICBlbmRcblxuICAgICAgdXJsICs9IEZvcm1EYXRhLmJ1aWxkX3F1ZXJ5KEBxdWVyeSlcbiAgICBlbmRcblxuICAgIGAjQG5hdGl2ZS5vcGVuKCN7QG1ldGhvZC50b19zLnVwY2FzZX0sICN7dXJsLnRvX3N9LCAje0Bhc3luY2hyb25vdXN9LCAje0B1c2VyLnRvX259LCAje0BwYXNzd29yZC50b19ufSlgXG5cbiAgICAjIGlmIHRoZXJlIGFyZSBubyByZWdpc3RlcmVkIGNhbGxiYWNrcyBubyBwb2ludCBpbiBzZXR0aW5nIHRoZSBldmVudFxuICAgICMgaGFuZGxlclxuICAgIHVubGVzcyBAY2FsbGJhY2tzLmVtcHR5P1xuICAgICAgYCNAbmF0aXZlLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICN7Y2FsbGJhY2t9YFxuICAgIGVuZFxuXG4gICAgQG9wZW5lZCA9IHRydWVcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgIyBTZW5kIHRoZSByZXF1ZXN0IHdpdGggb3B0aW9uYWwgcGFyYW1ldGVycy5cbiAgI1xuICAjIEBwYXJhbSBwYXJhbWV0ZXJzIFtTdHJpbmcsIEhhc2hdIHRoZSBkYXRhIHRvIHNlbmRcbiAgI1xuICAjIEByZXR1cm4gW1Jlc3BvbnNlXSB0aGUgcmVzcG9uc2VcbiAgZGVmIHNlbmQocGFyYW1ldGVycyA9IEBwYXJhbWV0ZXJzKVxuICAgIHJhaXNlICd0aGUgcmVxdWVzdCBoYXMgbm90IGJlZW4gb3BlbmVkJyB1bmxlc3Mgb3BlbmVkP1xuXG4gICAgcmFpc2UgJ3RoZSByZXF1ZXN0IGhhcyBhbHJlYWR5IGJlZW4gc2VudCcgaWYgc2VudD9cblxuICAgICMgdHJ5IHRvIGNpcmN1bXZlbnQgY2FjaGluZyBzZXR0aW5nIGFuIElmLU1vZGlmaWVkLVNpbmNlIGhlYWRlciB3aXRoIGEgdmVyeVxuICAgICMgb2xkIGRhdGVcbiAgICB1bmxlc3MgY2FjaGVhYmxlP1xuICAgICAgYCNAbmF0aXZlLnNldFJlcXVlc3RIZWFkZXIoXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBcIlR1ZSwgMTEgU2VwIDIwMDEgMTI6NDY6MDAgR01UXCIpYFxuICAgIGVuZFxuXG4gICAgQGhlYWRlcnMuZWFjaCB7fG5hbWUsIHZhbHVlfFxuICAgICAgYCNAbmF0aXZlLnNldFJlcXVlc3RIZWFkZXIoI3tuYW1lLnRvX3N9LCAje3ZhbHVlLnRvX3N9KWBcbiAgICB9XG5cbiAgICBpZiBAY29udGVudF90eXBlXG4gICAgICBoZWFkZXIgID0gQGNvbnRlbnRfdHlwZVxuICAgICAgaGVhZGVyICs9IFwiOyBjaGFyc2V0PSN7QGVuY29kaW5nfVwiIGlmIEBlbmNvZGluZ1xuXG4gICAgICBgI0BuYXRpdmUuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgaGVhZGVyKWBcbiAgICBlbmRcblxuICAgIGlmIGJpbmFyeT9cbiAgICAgIGlmIEJ1ZmZlci5zdXBwb3J0ZWQ/XG4gICAgICAgIGAjQG5hdGl2ZS5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInYFxuICAgICAgZWxzZVxuICAgICAgICBgI0BuYXRpdmUub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZCcpYFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBpZiBtaW1lX3R5cGUgJiYgIWJpbmFyeT9cbiAgICAgIGAjQG5hdGl2ZS5vdmVycmlkZU1pbWVUeXBlKCNAbWltZV90eXBlKWBcbiAgICBlbmRcblxuICAgIEBzZW50ICAgICA9IHRydWVcbiAgICBAcmVzcG9uc2UgPSBSZXNwb25zZS5uZXcoc2VsZilcblxuICAgIGlmIFN0cmluZyA9PT0gcGFyYW1ldGVyc1xuICAgICAgZGF0YSA9IHBhcmFtZXRlcnNcbiAgICBlbHNpZiAoSGFzaCA9PT0gcGFyYW1ldGVycyAmJiAhcGFyYW1ldGVycy5lbXB0eT8pIHx8IEZvcm1EYXRhID09PSBwYXJhbWV0ZXJzXG4gICAgICBkYXRhID0gaWYgSGFzaCA9PT0gcGFyYW1ldGVyc1xuICAgICAgICBpZiBGb3JtRGF0YS5jb250YWluX2ZpbGVzPyhwYXJhbWV0ZXJzKVxuICAgICAgICAgIEZvcm1EYXRhLmJ1aWxkX2Zvcm1fZGF0YShwYXJhbWV0ZXJzKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgRm9ybURhdGEuYnVpbGRfcXVlcnkocGFyYW1ldGVycylcbiAgICAgICAgZW5kXG4gICAgICBlbHNlICNpZiBGb3JtRGF0YSA9PT0gcGFyYW1ldGVyc1xuICAgICAgICBwYXJhbWV0ZXJzXG4gICAgICBlbmRcblxuICAgICAgdW5sZXNzIEBjb250ZW50X3R5cGVcbiAgICAgICAgaWYgRm9ybURhdGEgPT09IGRhdGFcbiAgICAgICAgICAjIEkgdGhvdWdodCBpdCdzIGRvbmUgdGhpcyB3YXksIGJ1dCBpdCBpc24ndC4gSXQgYWN0dWFsbHkgaXNcbiAgICAgICAgICAjIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YTsgYm91bmRhcnk9LS0tLS0tLS0tLS0uLi4uLi4uXCIuIExldCdzIG1pc3MgaXRcbiAgICAgICAgICAjIHB1cnBvc2VmdWxseSwgYmVjYXVzZSBpdCdzIGZpbGxlZCBpbiBhdXRvbWF0aWNhbGx5IGluIHRoaXMgZXhhbXBsZS5cbiAgICAgICAgICAjIGAjQG5hdGl2ZS5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScpYFxuICAgICAgICBlbHNlXG4gICAgICAgICAgYCNAbmF0aXZlLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKWBcbiAgICAgICAgZW5kXG4gICAgICBlbmRcblxuICAgICAgZGF0YSA9IGRhdGEudG9fblxuICAgIGVsc2VcbiAgICAgIGRhdGEgPSBgbnVsbGBcbiAgICBlbmRcblxuICAgIGAjQG5hdGl2ZS5zZW5kKCN7ZGF0YX0pYFxuXG4gICAgQHJlc3BvbnNlXG4gIGVuZFxuXG4gICMgQWJvcnQgdGhlIHJlcXVlc3QuXG4gIGRlZiBhYm9ydFxuICAgIGAjQG5hdGl2ZS5hYm9ydCgpYFxuICBlbmRcblxucHJpdmF0ZVxuICBkZWYgY2FsbGJhY2tcbiAgICAtPiBldmVudCB7XG4gICAgICBzdGF0ZSA9IFNUQVRFU1tgI0BuYXRpdmUucmVhZHlTdGF0ZWBdXG4gICAgICByZXMgICA9IHJlc3BvbnNlXG5cbiAgICAgIEBjYWxsYmFja3Nbc3RhdGVdLmVhY2ggeyB8YnwgYi4ocmVzKSB9XG5cbiAgICAgIGlmIHN0YXRlID09IDpjb21wbGV0ZVxuICAgICAgICBAY29tcGxldGVkID0gdHJ1ZVxuXG4gICAgICAgIEBjYWxsYmFja3NbcmVzLnN0YXR1cy5jb2RlXS5lYWNoIHsgfGJ8IGIuKHJlcykgfVxuXG4gICAgICAgIGlmIHJlcy5zdWNjZXNzP1xuICAgICAgICAgIEBjYWxsYmFja3NbOnN1Y2Nlc3NdLmVhY2ggeyB8YnwgYi4ocmVzKSB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBAY2FsbGJhY2tzWzpmYWlsdXJlXS5lYWNoIHsgfGJ8IGIuKHJlcykgfVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIH1cbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxtb2R1bGU6SFRUUD4iLCI8Y2xhc3M6UmVxdWVzdD4iLCJzZWxmIiwiaW5jbHVkZSIsIk5hdGl2ZTo6V3JhcHBlciIsIk5hdGl2ZSIsIkV2ZW50OjpUYXJnZXQiLCJFdmVudCIsIlJVQllfRU5HSU5FX1ZFUlNJT04iLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJ0cmFuc3BvcnQiLCJAcGFyYW1ldGVycyIsIkBxdWVyeSIsIkBoZWFkZXJzIiwiSGVhZGVycyIsIltdIiwiSEVBREVSUyIsIkBtZXRob2QiLCJAYXN5bmNocm9ub3VzIiwiQGJpbmFyeSIsIkBjYWNoZWFibGUiLCJAb3BlbmVkIiwiQHNlbnQiLCJAY29tcGxldGVkIiwiQGNhbGxiYWNrcyIsIm5ldyIsIkhhc2giLCJibG9jayBpbiBpbml0aWFsaXplIiwiaCIsImsiLCJibG9jayAoMiBsZXZlbHMpIGluIGluaXRpYWxpemUiLCJbXT0iLCJibG9jayIsImFyaXR5IiwiMCIsImluc3RhbmNlX2V4ZWMiLCJ0b19wcm9jIiwiY2FsbCIsIkJyb3dzZXIiLCJzdXBwb3J0cz8iLCJyYWlzZSIsIk5vdEltcGxlbWVudGVkRXJyb3IiLCJvcGVuZWQ/Iiwic2VudD8iLCJjb21wbGV0ZWQ/IiwiYXN5bmNocm9ub3VzPyIsInN5bmNocm9ub3VzPyIsIiEiLCJhc3luY2hyb25vdXMhIiwic3luY2hyb25vdXMhIiwiYmluYXJ5PyIsImJpbmFyeSEiLCJjYWNoZWFibGU/Iiwibm9fY2FjaGUhIiwidXNlciIsInZhbHVlIiwiQHVzZXIiLCJwYXNzd29yZCIsIkBwYXNzd29yZCIsIm1pbWVfdHlwZSIsIkBtaW1lX3R5cGUiLCJjb250ZW50X3R5cGUiLCJAY29udGVudF90eXBlIiwiZW5jb2RpbmciLCJAZW5jb2RpbmciLCJwYXJhbWV0ZXJzIiwiaGFzaCIsInF1ZXJ5Iiwib24iLCJ3aGF0IiwiU1RBVEVTIiwiaW5jbHVkZT8iLCJJbnRlZ2VyIiwiPDwiLCIkZndkX3Jlc3QiLCJvcGVuIiwibWV0aG9kIiwidXJsIiwiYXN5bmNocm9ub3VzIiwibmlsPyIsIkB1cmwiLCJyYW5kIiwiZW1wdHk/IiwiKyIsIkZvcm1EYXRhIiwiYnVpbGRfcXVlcnkiLCJAbmF0aXZlIiwidG9fcyIsInVwY2FzZSIsInRvX24iLCJjYWxsYmFjayIsInNlbmQiLCJlYWNoIiwiYmxvY2sgaW4gc2VuZCIsIm5hbWUiLCJibG9jayAoMiBsZXZlbHMpIGluIHNlbmQiLCJoZWFkZXIiLCJCdWZmZXIiLCJzdXBwb3J0ZWQ/IiwiQHJlc3BvbnNlIiwiUmVzcG9uc2UiLCJTdHJpbmciLCJkYXRhIiwiY29udGFpbl9maWxlcz8iLCJidWlsZF9mb3JtX2RhdGEiLCJhYm9ydCIsInByaXZhdGUiLCJibG9jayBpbiBjYWxsYmFjayIsImV2ZW50IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjYWxsYmFjayIsInN0YXRlIiwicmVzIiwicmVzcG9uc2UiLCJiIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiBjYWxsYmFjayIsInN0YXR1cyIsImNvZGUiLCJzdWNjZXNzPyJdLCJtYXBwaW5ncyI6IkFBQUFBLHVDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7QUFBQUE7O1FBQ0VDLElBQUFDLFNBQUFBLENBQVFDLElBQUFDLFlBQUFELFlBQVJEO1FBQ0FELElBQUFDLFNBQUFBLENBQVFHLElBQUFDLFdBQUFELFdBQVJIO1FBR0EsbUNBQVUsVUFBQSxtQkFBQSxFQUNjRixnQkFEZCxDQUFBLEVBQUEsaUJBQUEsRUFFY08seUJBRmQsQ0FBQSxFQUFBLFNBQUEsRUFHY1AsNERBSGQsQ0FBQSxHQUFWO1FBTUEsa0NBQVMsQ0FBR0EsZUFBSCxFQUFpQkEsU0FBakIsRUFBeUJBLFFBQXpCLEVBQWdDQSxhQUFoQyxFQUE0Q0EsVUFBNUMsQ0FBVDtRQUlBQyxJQUFBTyxhQUFBQSxDQUFZLFNBQVpBO1FBSUFQLElBQUFPLGFBQUFBLENBQVksVUFBWkE7UUFJQVAsSUFBQU8sYUFBQUEsQ0FBWSxRQUFaQTtRQUlBUCxJQUFBTyxhQUFBQSxDQUFZLEtBQVpBOztBQU1BQyxRQUFBQSwwQkFBQUEsc0JBQUFBO0FBQUFBLFVBQUFBOztVQUFBQTs7O1VBQ0UsT0FBQVIsSUFBQSxFQUFBLDBEQUFBLGNBQUEs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ImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL2pzb24ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXG5cbm1vZHVsZSBKU09OXG4gIGNsYXNzIEpTT05FcnJvciA8IFN0YW5kYXJkRXJyb3JcbiAgZW5kXG5cbiAgY2xhc3MgUGFyc2VyRXJyb3IgPCBKU09ORXJyb3JcbiAgZW5kXG5cbiAgJXh7XG4gICAgdmFyICRoYXNPd24gPSBPcGFsLmhhc093blByb3BlcnR5O1xuXG4gICAgZnVuY3Rpb24gJHBhcnNlKHNvdXJjZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc291cmNlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgI3tyYWlzZSBKU09OOjpQYXJzZXJFcnJvciwgYGUubWVzc2FnZWB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0b19vcGFsKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICB2YXIga2xhc3MsIGFyciwgaGFzaCwgaSwgaWksIGs7XG5cbiAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgIHJldHVybiAhIXZhbHVlO1xuXG4gICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgcmV0dXJuIG5pbDtcblxuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgIGlmICghdmFsdWUpIHJldHVybiBuaWw7XG5cbiAgICAgICAgICBpZiAodmFsdWUuJCRpc19hcnJheSkge1xuICAgICAgICAgICAgYXJyID0gI3tgT3BhbC5oYXNoX2dldChvcHRpb25zLCAnYXJyYXlfY2xhc3MnKWAubmV3fTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgaWkgPSB2YWx1ZS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICN7YGFycmAucHVzaChgdG9fb3BhbCh2YWx1ZVtpXSwgb3B0aW9ucylgKX07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGFzaCA9ICN7YE9wYWwuaGFzaF9nZXQob3B0aW9ucywgJ29iamVjdF9jbGFzcycpYC5uZXd9O1xuXG4gICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgaWYgKCRoYXNPd24uY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAje2BoYXNoYFtga2BdID0gYHRvX29wYWwodmFsdWVba10sIG9wdGlvbnMpYH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFPcGFsLmhhc2hfZ2V0KG9wdGlvbnMsICdwYXJzZScpICYmIChrbGFzcyA9ICN7YGhhc2hgW0pTT04uY3JlYXRlX2lkXX0pICE9IG5pbCkge1xuICAgICAgICAgICAgICByZXR1cm4gI3s6Ok9iamVjdC5jb25zdF9nZXQoYGtsYXNzYCkuanNvbl9jcmVhdGUoYGhhc2hgKX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBhdHRyX2FjY2Vzc29yIDpjcmVhdGVfaWRcbiAgZW5kXG5cbiAgc2VsZi5jcmVhdGVfaWQgPSA6anNvbl9jbGFzc1xuXG4gIGRlZiBzZWxmLltdKHZhbHVlLCBvcHRpb25zID0ge30pXG4gICAgaWYgU3RyaW5nID09PSB2YWx1ZVxuICAgICAgcGFyc2UodmFsdWUsIG9wdGlvbnMpXG4gICAgZWxzZVxuICAgICAgZ2VuZXJhdGUodmFsdWUsIG9wdGlvbnMpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnBhcnNlKHNvdXJjZSwgb3B0aW9ucyA9IHt9KVxuICAgIGZyb21fb2JqZWN0KGAkcGFyc2Uoc291cmNlKWAsIG9wdGlvbnMubWVyZ2UocGFyc2U6IHRydWUpKVxuICBlbmRcblxuICBkZWYgc2VsZi5wYXJzZSEoc291cmNlLCBvcHRpb25zID0ge30pXG4gICAgcGFyc2Uoc291cmNlLCBvcHRpb25zKVxuICBlbmRcblxuICBkZWYgc2VsZi5sb2FkKHNvdXJjZSwgb3B0aW9ucyA9IHt9KVxuICAgIGZyb21fb2JqZWN0KGAkcGFyc2Uoc291cmNlKWAsIG9wdGlvbnMpXG4gIGVuZFxuXG4gICMgUmF3IGpzIG9iamVjdCA9PiBvcGFsIG9iamVjdFxuICBkZWYgc2VsZi5mcm9tX29iamVjdChqc19vYmplY3QsIG9wdGlvbnMgPSB7fSlcbiAgICBvcHRpb25zWzpvYmplY3RfY2xhc3NdIHx8PSBIYXNoXG4gICAgb3B0aW9uc1s6YXJyYXlfY2xhc3NdICB8fD0gQXJyYXlcblxuICAgIGB0b19vcGFsKGpzX29iamVjdCwgb3B0aW9ucylgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmdlbmVyYXRlKG9iaiwgb3B0aW9ucyA9IHt9KVxuICAgIG9iai50b19qc29uKG9wdGlvbnMpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmR1bXAob2JqLCBpbyA9IG5pbCwgbGltaXQgPSBuaWwpXG4gICAgc3RyaW5nID0gZ2VuZXJhdGUob2JqKVxuXG4gICAgaWYgaW9cbiAgICAgIGlvID0gaW8udG9faW8gaWYgaW8ucmVzcG9uZHNfdG8/IDp0b19pb1xuICAgICAgaW8ud3JpdGUgc3RyaW5nXG5cbiAgICAgIGlvXG4gICAgZWxzZVxuICAgICAgc3RyaW5nXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmNsYXNzIE9iamVjdFxuICBkZWYgdG9fanNvblxuICAgIHRvX3MudG9fanNvblxuICBlbmRcbmVuZFxuXG4jIEJVRzogRW51bWVyYWJsZSBtdXN0IGNvbWUgYmVmb3JlIEFycmF5LCBvdGhlcndpc2UgaXQgb3ZlcnJpZGVzICN0b19qc29uXG4jICAgICAgdGhpcyBpcyBkdWUgdG8gaG93IG1vZHVsZXMgYXJlIGltcGxlbWVudGVkLlxubW9kdWxlIEVudW1lcmFibGVcbiAgZGVmIHRvX2pzb25cbiAgICB0b19hLnRvX2pzb25cbiAgZW5kXG5lbmRcblxuY2xhc3MgQXJyYXlcbiAgZGVmIHRvX2pzb25cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9ICN7c2VsZn0ubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2goI3tgc2VsZltpXWAudG9fanNvbn0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ1snICsgcmVzdWx0LmpvaW4oJywnKSArICddJztcbiAgICB9XG4gIGVuZFxuZW5kXG5cbmNsYXNzIEJvb2xlYW5cbiAgZGVmIHRvX2pzb25cbiAgICBgKHNlbGYgPT0gdHJ1ZSkgPyAndHJ1ZScgOiAnZmFsc2UnYFxuICBlbmRcbmVuZFxuXG5jbGFzcyBIYXNoXG4gIGRlZiB0b19qc29uXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIE9wYWwuaGFzaF9lYWNoKHNlbGYsIGZhbHNlLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKCN7YGtleWAudG9fcy50b19qc29ufSArICc6JyArICN7YHZhbHVlYC50b19qc29ufSk7XG4gICAgICAgIHJldHVybiBbZmFsc2UsIGZhbHNlXTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gJ3snICsgcmVzdWx0LmpvaW4oJywnKSArICd9JztcbiAgICB9XG4gIGVuZFxuZW5kXG5cbmNsYXNzIE5pbENsYXNzXG4gIGRlZiB0b19qc29uXG4gICAgJ251bGwnXG4gIGVuZFxuZW5kXG5cbmNsYXNzIE51bWVyaWNcbiAgZGVmIHRvX2pzb25cbiAgICBgc2VsZi50b1N0cmluZygpYFxuICBlbmRcbmVuZFxuXG5jbGFzcyBTdHJpbmdcbiAgZGVmIHRvX2pzb25cbiAgICBgSlNPTi5zdHJpbmdpZnkoc2VsZilgXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFRpbWVcbiAgZGVmIHRvX2pzb25cbiAgICBzdHJmdGltZSgnJUZUJVQleicpLnRvX2pzb25cbiAgZW5kXG5lbmRcblxuY2xhc3MgRGF0ZVxuICBkZWYgdG9fanNvblxuICAgIHRvX3MudG9fanNvblxuICBlbmRcblxuICBkZWYgYXNfanNvblxuICAgIHRvX3NcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpKU09OPiIsIjxjbGFzczpKU09ORXJyb3I+IiwiU3RhbmRhcmRFcnJvciIsIjxjbGFzczpQYXJzZXJFcnJvcj4iLCJKU09ORXJyb3IiLCJzZWxmIiwicmFpc2UiLCJKU09OOjpQYXJzZXJFcnJvciIsIkpTT04iLCJuZXciLCJwdXNoIiwiW109IiwiW10iLCJjcmVhdGVfaWQiLCJPYmplY3QiLCJjb25zdF9nZXQiLCJqc29uX2NyZWF0ZSIsImF0dHJfYWNjZXNzb3IiLCJjcmVhdGVfaWQ9IiwidmFsdWUiLCJvcHRpb25zIiwiU3RyaW5nIiwicGFyc2UiLCJnZW5lcmF0ZSIsInNvdXJjZSIsImZyb21fb2JqZWN0IiwibWVyZ2UiLCJwYXJzZSEiLCJsb2FkIiwianNfb2JqZWN0IiwiJHJldF9vcl8xIiwiSGFzaCIsIkFycmF5Iiwib2JqIiwidG9fanNvbiIsImR1bXAiLCJpbyIsImxpbWl0Iiwic3RyaW5nIiwicmVzcG9uZHNfdG8/IiwidG9faW8iLCJ3cml0ZSIsIjxjbGFzczpPYmplY3Q+IiwidG9fcyIsIjxtb2R1bGU6RW51bWVyYWJsZT4iLCJ0b19hIiwiPGNsYXNzOkFycmF5PiIsIjxjbGFzczpCb29sZWFuPiIsIjxjbGFzczpIYXNoPiIsIjxjbGFzczpOaWxDbGFzcz4iLCI8Y2xhc3M6TnVtZXJpYz4iLCI8Y2xhc3M6U3RyaW5nPiIsIjxjbGFzczpUaW1lPiIsInN0cmZ0aW1lIiwiPGNsYXNzOkRhdGU+IiwiYXNfanNvbiJdLCJtYXBwaW5ncyI6IkFBQUFBLHVCQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQztFQUFBQTs7SUFBQUE7OztJQUNFQyxPQUFBQSxXQUFBQSxFQUFrQkMsbUJBQWxCRDtJQUdBRSxPQUFBQSxXQUFBQSxFQUFvQkMsZUFBcEJEOztBQUlGSDs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsUUFBVUssSUFBQUMsT0FBQUEsQ0FBTUMsSUFBQUMsVUFBQUQsZ0JBQU4sRUFBMEJQLFNBQTFCTSxDQUFxQ047QUFDL0NBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQSxrQkFBb0JBLENBQUNBLHFDQUFEQSxDQUF1Q1MsS0FBQUEsQ0FBQUEsQ0FBS1Q7O0FBRWhFQTtBQUNBQSxjQUFnQkEsQ0FBQ0EsR0FBREEsQ0FBS1UsTUFBQUEsQ0FBT1YsMEJBQVBVLENBQW9DVjtBQUN6REE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBLG1CQUFxQkEsQ0FBQ0Esc0NBQURBLENBQXdDUyxLQUFBQSxDQUFBQSxDQUFLVDs7QUFFbEVBO0FBQ0FBO0FBQ0FBLGdCQUF3QlcsTUFBQUEsQ0FBRVgsQ0FBUixFQUFlQSwwQkFBVFcsQ0FBQUEsRUFBQUEsTUFBTlgsQ0FBQ0EsSUFBREEsQ0FBTVcsT0FBQUEsRUFBQUEsRUFBQUEsQ0FBQUEsRUFBQUEsa0JBQXFDWDtBQUM3REE7QUFDQUE7O0FBRUFBLDZEQUErREEsQ0FBQ0EsSUFBREEsQ0FBTVksT0FBQUEsQ0FBQ0osVUFBSUssV0FBQUEsQ0FBQUEsQ0FBTEQsQ0FBaUJaO0FBQ3RGQSxxQkFBdUJjLE9BQVFDLFdBQUFBLENBQVlmLEtBQVplLENBQW1CQyxhQUFBQSxD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QUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0EsZUFBREE7SUFERkEsQ0FBQUE7RUFERmdCLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBTUFDO0VBQUFBOzs7SUFDRUEsT0FBQWpCLHVCQUFBQSxtQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUNBLG9CQUFEQTtJQURGQSxDQUFBQTtFQURGaUIsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFNQUM7RUFBQUE7OztJQUNFQSxPQUFBbEIsdUJBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQTdCLElBQUFnRCxVQUFBQSxDQUFTbkIsU0FBVG1CLENBQW1CbkIsU0FBQUEsQ0FBQUE7SUFEckJBLENBQUFBO0VBREZrQixHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQU1BckQsT0FBQXVEO0VBQUFBOzs7OztBQUNFcEIsSUFBQUEsdUJBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQTdCLElBQUFzQyxNQUFBQSxDQUFBQSxDQUFJVCxTQUFBQSxDQUFBQTtJQUROQSxDQUFBQTtJQUlBb0IsT0FBQUMsdUJBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQWxELElBQUFzQyxNQUFBQSxDQUFBQTtJQURGWSxDQUFBQTtFQUxGRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQWpNQXZEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozNzk2MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvaHR0cC9yZXNwb25zZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdqc29uJ1xuXG5tb2R1bGUgQnJvd3NlcjsgbW9kdWxlIEhUVFBcblxuIyBSZXByZXNlbnRzIGFuIEhUVFAgcmVzcG9uc2UuXG5jbGFzcyBSZXNwb25zZVxuICBpbmNsdWRlIE5hdGl2ZTo6V3JhcHBlclxuXG4gIFN0YXR1cyA9IFN0cnVjdC5uZXcoOmNvZGUsIDp0ZXh0KVxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIHJlcXVlc3RcbiAgIyBAcmV0dXJuIFtSZXF1ZXN0XSB0aGUgcmVxdWVzdCB0byB0aGlzIHJlc3BvbnNlXG4gIGF0dHJfcmVhZGVyIDpyZXF1ZXN0XG5cbiAgIyBDcmVhdGUgYSByZXNwb25zZSBmcm9tIGEgcmVxdWVzdC5cbiAgI1xuICAjIEBwYXJhbSByZXF1ZXN0IFtSZXF1ZXN0XSB0aGUgcmVxdWVzdFxuICBkZWYgaW5pdGlhbGl6ZShyZXF1ZXN0KVxuICAgIHN1cGVyKHJlcXVlc3QudG9fbilcblxuICAgIEByZXF1ZXN0ID0gcmVxdWVzdFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBoZWFkZXJzXG4gICMgQHJldHVybiBbSGVhZGVyc10gdGhlIHJlc3BvbnNlIGhlYWRlcnNcbiAgZGVmIGhlYWRlcnNcbiAgICBAaGVhZGVycyB8fD0gSGVhZGVycy5wYXJzZShgI0BuYXRpdmUuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClgKVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBzdGF0dXNcbiAgIyBAcmV0dXJuIFtTdGF0dXNdIHRoZSByZXNwb25zZSBzdGF0dXNcbiAgZGVmIHN0YXR1c1xuICAgIFN0YXR1cy5uZXcoYCNAbmF0aXZlLnN0YXR1cyB8fCBuaWxgLCBgI0BuYXRpdmUuc3RhdHVzVGV4dCB8fCBuaWxgKVxuICBlbmRcblxuICAjIENoZWNrcyBpZiB0aGUgcmVzcG9uc2Ugd2FzIHN1Y2Nlc3NmdWxcbiAgZGVmIHN1Y2Nlc3M/XG4gICAgaWYgY29kZSA9IHN0YXR1cy5jb2RlXG4gICAgICBjb2RlID49IDIwMCAmJiBjb2RlIDwgMzAwIHx8IGNvZGUgPT0gMzA0XG4gICAgZWxzZVxuICAgICAgZmFsc2VcbiAgICBlbmRcbiAgZW5kXG5cbiAgIyBDaGVjayBpZiB0aGUgcmVzcG9uc2UgZmFpbGVkXG4gIGRlZiBmYWlsdXJlP1xuICAgICFzdWNjZXNzP1xuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSB1cmxcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSByZXNwb25zZSBVUkwgKGFmdGVyIHJlZGlyZWN0cylcbiAgYWxpYXNfbmF0aXZlIDp1cmwsIDpyZXNwb25zZVVSTFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIHRleHRcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSByZXNwb25zZSBib2R5IGFzIHRleHRcbiAgZGVmIHRleHRcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSAjQG5hdGl2ZS5yZXNwb25zZVRleHQ7XG5cbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBqc29uXG4gICMgQHJldHVybiBbSGFzaCwgQXJyYXldIHRoZSByZXNwb25zZSBib2R5IGFzIEpTT05cbiAgZGVmIGpzb25cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSAjQG5hdGl2ZS5yZXNwb25zZVRleHQ7XG5cbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje0pTT04ucGFyc2UoYHJlc3VsdGApfTtcbiAgICB9XG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIHhtbFxuICAjIEByZXR1cm4gW0RPTTo6RG9jdW1lbnRdIHRoZSByZXNwb25zZSBib2R5IGFzIERPTSBkb2N1bWVudFxuICBkZWYgeG1sXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gI0BuYXRpdmUucmVzcG9uc2VYTUw7XG5cbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgRE9NKGByZXN1bHRgKVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBiaW5hcnlcbiAgIyBAcmV0dXJuIFtCaW5hcnldIHRoZSByZXNwb25zZSBib2R5IGFzIGJpbmFyeVxuICBkZWYgYmluYXJ5XG4gICAgcmV0dXJuIHVubGVzcyByZXF1ZXN0LmJpbmFyeT9cblxuICAgIGlmIEJ1ZmZlci5zdXBwb3J0ZWQ/XG4gICAgICAleHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICNAbmF0aXZlLnJlc3BvbnNlO1xuXG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBCaW5hcnkubmV3KEJ1ZmZlci5uZXcoYHJlc3VsdGApKVxuICAgIGVsc2VcbiAgICAgIHJldHVybiB1bmxlc3MgdGV4dFxuXG4gICAgICBCaW5hcnkubmV3KHRleHQpXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPG1vZHVsZTpCcm93c2VyPiIsIjxtb2R1bGU6SFRUUD4iLCI8Y2xhc3M6UmVzcG9uc2U+IiwiaW5jbHVkZSIsIk5hdGl2ZTo6V3JhcHBlciIsIk5hdGl2ZSIsIlN0cnVjdCIsIm5ldyIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsInJlcXVlc3QiLCJ0b19uIiwiQHJlcXVlc3QiLCJoZWFkZXJzIiwiQGhlYWRlcnMiLCIkcmV0X29yXzEiLCJIZWFkZXJzIiwicGFyc2UiLCJAbmF0aXZlIiwic3RhdHVzIiwiU3RhdHVzIiwic3VjY2Vzcz8iLCJjb2RlIiwiJHJldF9vcl8yIiwiPj0iLCIyMDAiLCI8IiwiMzAwIiwiPT0iLCIzMDQiLCJmYWlsdXJlPyIsIiEiLCJhbGlhc19uYXRpdmUiLCJ0ZXh0IiwianNvbiIsIkpTT04iLCJ4bWwiLCJET00iLCJiaW5hcnkiLCJiaW5hcnk/IiwiQnVmZmVyIiwic3VwcG9ydGVkPyIsIkJpbmFyeSJdLCJtYXBwaW5ncyI6IkFBQUFBLHdDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixNQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFB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TUEsT0FBQUksWUFBTW5DLEtBQUFBLENBQUtpQyxZQUFNakMsS0FBQUEsQ0FBTStCLE1BQU4vQixDQUFYQTtVQVRSOztZQVdFLEtBQUEsUUFBY1QsSUFBQW1DLE1BQUFBLENBQUFBLENBQWQsQ0FBQTtjQUFBLE9BQUE7WUFBQTtZQUVBSyxPQUFBSSxZQUFNbkMsS0FBQUEsQ0FBS1QsSUFBQW1DLE1BQUFBLENBQUFBLENBQUwxQjtVQWJSO1FBSEYrQixDQUFBQTtNQTVGRnBDLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0lBSGdCRCxHQUFBQSxXQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFGQUg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM4MTAwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9odHRwLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2Jyb3dzZXIvaHR0cC9iaW5hcnknXG5yZXF1aXJlICdicm93c2VyL2h0dHAvaGVhZGVycydcbnJlcXVpcmUgJ2Jyb3dzZXIvaHR0cC9yZXF1ZXN0J1xucmVxdWlyZSAnYnJvd3Nlci9odHRwL3Jlc3BvbnNlJ1xuXG5tb2R1bGUgQnJvd3NlclxuXG5tb2R1bGUgSFRUUFxuICAjIENoZWNrIGlmIEhUVFAgcmVxdWVzdHMgYXJlIHN1cHBvcnRlZC5cbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIEJyb3dzZXIuc3VwcG9ydHM/KCdYSFInKSB8fCBCcm93c2VyLnN1cHBvcnRzPygnQWN0aXZlWE9iamVjdCcpXG4gIGVuZFxuXG4gICMgU2VuZCBhbiBhc3luY2hyb25vdXMgcmVxdWVzdC5cbiAgI1xuICAjIEBwYXJhbSBtZXRob2QgW1N5bWJvbF0gdGhlIEhUVFAgbWV0aG9kIHRvIHVzZVxuICAjIEBwYXJhbSB1cmwgW1N0cmluZ10gdGhlIFVSTCB0byByZXF1ZXN0XG4gICMgQHBhcmFtIGRhdGEgW1N0cmluZywgSGFzaF0gdGhlIGRhdGEgdG8gc2VuZFxuICAjXG4gICMgQHlpZWxkcGFyYW0gcmVxdWVzdCBbUmVxdWVzdF0gdGhlIHJlcXVlc3QgdG8gY29uZmlndXJlXG4gICNcbiAgIyBAcmV0dXJuIFtQcm9taXNlXSBhIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhlIHJlc3BvbnNlXG4gIGRlZiBzZWxmLnNlbmQobWV0aG9kLCB1cmwsIGRhdGEgPSBuaWwsICZibG9jaylcbiAgICBQcm9taXNlLm5ldy50YXAge3xwcm9taXNlfFxuICAgICAgUmVxdWVzdC5uZXcoJmJsb2NrKS50YXAge3xyZXF8XG4gICAgICAgIHJlcS5vbiA6c3VjY2VzcyBkbyB8cmVzfFxuICAgICAgICAgIHByb21pc2UucmVzb2x2ZShyZXMpXG4gICAgICAgIGVuZFxuXG4gICAgICAgIHJlcS5vbiA6ZmFpbHVyZSBkbyB8cmVzfFxuICAgICAgICAgIHByb21pc2UucmVqZWN0KHJlcylcbiAgICAgICAgZW5kXG4gICAgICB9Lm9wZW4obWV0aG9kLCB1cmwpLnNlbmQoZGF0YSlcbiAgICB9XG4gIGVuZFxuXG4gICMgU2VuZCBhbiBhc3luY2hyb25vdXMgR0VUIHJlcXVlc3QuXG4gICNcbiAgIyBAcGFyYW0gdXJsIFtTdHJpbmddIHRoZSBVUkwgdG8gcmVxdWVzdFxuICAjXG4gICMgQHlpZWxkcGFyYW0gcmVxdWVzdCBbUmVxdWVzdF0gdGhlIHJlcXVlc3QgdG8gY29uZmlndXJlXG4gICNcbiAgIyBAcmV0dXJuIFtQcm9taXNlXSBhIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhlIHJlc3BvbnNlXG4gIGRlZiBzZWxmLmdldCh1cmwsICZibG9jaylcbiAgICBzZW5kKDpnZXQsIHVybCwgJmJsb2NrKVxuICBlbmRcblxuICAjIFNlbmQgYW4gYXN5bmNocm9ub3VzIEhFQUQgcmVxdWVzdC5cbiAgI1xuICAjIEBwYXJhbSB1cmwgW1N0cmluZ10gdGhlIFVSTCB0byByZXF1ZXN0XG4gICNcbiAgIyBAeWllbGRwYXJhbSByZXF1ZXN0IFtSZXF1ZXN0XSB0aGUgcmVxdWVzdCB0byBjb25maWd1cmVcbiAgI1xuICAjIEByZXR1cm4gW1Byb21pc2VdIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgcmVzcG9uc2VcbiAgZGVmIHNlbGYuaGVhZCh1cmwsICZibG9jaylcbiAgICBzZW5kKDpoZWFkLCB1cmwsICZibG9jaylcbiAgZW5kXG5cbiAgIyBTZW5kIGFuIGFzeW5jaHJub3VzIFBPU1QgcmVxdWVzdC5cbiAgI1xuICAjIEBwYXJhbSB1cmwgW1N0cmluZ10gdGhlIFVSTCB0byByZXF1ZXN0XG4gICMgQHBhcmFtIGRhdGEgW1N0cmluZywgSGFzaF0gdGhlIGRhdGEgdG8gc2VuZFxuICAjXG4gICMgQHlpZWxkcGFyYW0gcmVxdWVzdCBbUmVxdWVzdF0gdGhlIHJlcXVlc3QgdG8gY29uZmlndXJlXG4gICNcbiAgIyBAcmV0dXJuIFtQcm9taXNlXSBhIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhlIHJlc3BvbnNlXG4gIGRlZiBzZWxmLnBvc3QodXJsLCBkYXRhID0gbmlsLCAmYmxvY2spXG4gICAgc2VuZCg6cG9zdCwgdXJsLCBkYXRhLCAmYmxvY2spXG4gIGVuZFxuXG4gICMgU2VuZCBhbiBhc3luY2hyb25vdXMgUFVUIHJlcXVlc3QuXG4gICNcbiAgIyBAcGFyYW0gdXJsIFtTdHJpbmddIHRoZSBVUkwgdG8gcmVxdWVzdFxuICAjIEBwYXJhbSBkYXRhIFtTdHJpbmcsIEhhc2hdIHRoZSBkYXRhIHRvIHNlbmRcbiAgI1xuICAjIEB5aWVsZHBhcmFtIHJlcXVlc3QgW1JlcXVlc3RdIHRoZSByZXF1ZXN0IHRvIGNvbmZpZ3VyZVxuICAjXG4gICMgQHJldHVybiBbUHJvbWlzZV0gYSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aXRoIHRoZSByZXNwb25zZVxuICBkZWYgc2VsZi5wdXQodXJsLCBkYXRhID0gbmlsLCAmYmxvY2spXG4gICAgc2VuZCg6cHV0LCB1cmwsIGRhdGEsICZibG9jaylcbiAgZW5kXG5cbiAgIyBTZW5kIGFuIGFzeW5jaHJvbm91cyBERUxFVEUgcmVxdWVzdC5cbiAgI1xuICAjIEBwYXJhbSB1cmwgW1N0cmluZ10gdGhlIFVSTCB0byByZXF1ZXN0XG4gICMgQHBhcmFtIGRhdGEgW1N0cmluZywgSGFzaF0gdGhlIGRhdGEgdG8gc2VuZFxuICAjXG4gICMgQHlpZWxkcGFyYW0gcmVxdWVzdCBbUmVxdWVzdF0gdGhlIHJlcXVlc3QgdG8gY29uZmlndXJlXG4gICNcbiAgIyBAcmV0dXJuIFtQcm9taXNlXSBhIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhlIHJlc3BvbnNlXG4gIGRlZiBzZWxmLmRlbGV0ZSh1cmwsIGRhdGEgPSBuaWwsICZibG9jaylcbiAgICBzZW5kKDpkZWxldGUsIHVybCwgZGF0YSwgJmJsb2NrKVxuICBlbmRcblxuICAjIFNlbmQgYSBzeW5jaHJvbm91cyByZXF1ZXN0LlxuICAjXG4gICMgQHBhcmFtIG1ldGhvZCBbU3ltYm9sXSB0aGUgSFRUUCBtZXRob2QgdG8gdXNlXG4gICMgQHBhcmFtIHVybCBbU3RyaW5nXSB0aGUgVVJMIHRvIHJlcXVlc3RcbiAgIyBAcGFyYW0gZGF0YSBbU3RyaW5nLCBIYXNoXSB0aGUgZGF0YSB0byBzZW5kXG4gICNcbiAgIyBAeWllbGRwYXJhbSByZXF1ZXN0IFtSZXF1ZXN0XSB0aGUgcmVxdWVzdCB0byBjb25maWd1cmVcbiAgI1xuICAjIEByZXR1cm4gW1Jlc3BvbnNlXSB0aGUgcmVzcG9uc2VcbiAgZGVmIHNlbGYuc2VuZCEobWV0aG9kLCB1cmwsIGRhdGEgPSBuaWwsICZibG9jaylcbiAgICBSZXF1ZXN0Lm5ldygmYmxvY2spLm9wZW4obWV0aG9kLCB1cmwsIGZhbHNlKS5zZW5kKGRhdGEpXG4gIGVuZFxuXG4gICMgU2VuZCBhIHN5bmNocm9ub3VzIEdFVCByZXF1ZXN0LlxuICAjXG4gICMgQHBhcmFtIHVybCBbU3RyaW5nXSB0aGUgVVJMIHRvIHJlcXVlc3RcbiAgI1xuICAjIEB5aWVsZHBhcmFtIHJlcXVlc3QgW1JlcXVlc3RdIHRoZSByZXF1ZXN0IHRvIGNvbmZpZ3VyZVxuICAjXG4gICMgQHJldHVybiBbUmVzcG9uc2VdIHRoZSByZXNwb25zZVxuICBkZWYgc2VsZi5nZXQhKHVybCwgJmJsb2NrKVxuICAgIHNlbmQhKDpnZXQsIHVybCwgJmJsb2NrKVxuICBlbmRcblxuICAjIFNlbmQgYSBzeW5jaHJvbm91cyBIRUFEIHJlcXVlc3QuXG4gICNcbiAgIyBAcGFyYW0gdXJsIFtTdHJpbmddIHRoZSBVUkwgdG8gcmVxdWVzdFxuICAjXG4gICMgQHlpZWxkcGFyYW0gcmVxdWVzdCBbUmVxdWVzdF0gdGhlIHJlcXVlc3QgdG8gY29uZmlndXJlXG4gICNcbiAgIyBAcmV0dXJuIFtSZXNwb25zZV0gdGhlIHJlc3BvbnNlXG4gIGRlZiBzZWxmLmhlYWQhKHVybCwgJmJsb2NrKVxuICAgIHNlbmQhKDpoZWFkLCB1cmwsICZibG9jaylcbiAgZW5kXG5cbiAgIyBTZW5kIGEgc3luY2hyb25vdXMgUE9TVCByZXF1ZXN0LlxuICAjXG4gICMgQHBhcmFtIHVybCBbU3RyaW5nXSB0aGUgVVJMIHRvIHJlcXVlc3RcbiAgIyBAcGFyYW0gZGF0YSBbU3RyaW5nLCBIYXNoXSB0aGUgZGF0YSB0byBzZW5kXG4gICNcbiAgIyBAeWllbGRwYXJhbSByZXF1ZXN0IFtSZXF1ZXN0XSB0aGUgcmVxdWVzdCB0byBjb25maWd1cmVcbiAgI1xuICAjIEByZXR1cm4gW1Jlc3BvbnNlXSB0aGUgcmVzcG9uc2VcbiAgZGVmIHNlbGYucG9zdCEodXJsLCBkYXRhID0gbmlsLCAmYmxvY2spXG4gICAgc2VuZCEoOnBvc3QsIHVybCwgZGF0YSwgJmJsb2NrKVxuICBlbmRcblxuICAjIFNlbmQgYSBzeW5jaHJvbm91cyBQVVQgcmVxdWVzdC5cbiAgI1xuICAjIEBwYXJhbSB1cmwgW1N0cmluZ10gdGhlIFVSTCB0byByZXF1ZXN0XG4gICMgQHBhcmFtIGRhdGEgW1N0cmluZywgSGFzaF0gdGhlIGRhdGEgdG8gc2VuZFxuICAjXG4gICMgQHlpZWxkcGFyYW0gcmVxdWVzdCBbUmVxdWVzdF0gdGhlIHJlcXVlc3QgdG8gY29uZmlndXJlXG4gICNcbiAgIyBAcmV0dXJuIFtSZXNwb25zZV0gdGhlIHJlc3BvbnNlXG4gIGRlZiBzZWxmLnB1dCEodXJsLCBkYXRhID0gbmlsLCAmYmxvY2spXG4gICAgc2VuZCEoOnB1dCwgdXJsLCBkYXRhLCAmYmxvY2spXG4gIGVuZFxuXG4gICMgU2VuZCBhIHN5bmNocm9ub3VzIERFTEVURSByZXF1ZXN0LlxuICAjXG4gICMgQHBhcmFtIHVybCBbU3RyaW5nXSB0aGUgVVJMIHRvIHJlcXVlc3RcbiAgIyBAcGFyYW0gZGF0YSBbU3RyaW5nLCBIYXNoXSB0aGUgZGF0YSB0byBzZW5kXG4gICNcbiAgIyBAeWllbGRwYXJhbSByZXF1ZXN0IFtSZXF1ZXN0XSB0aGUgcmVxdWVzdCB0byBjb25maWd1cmVcbiAgI1xuICAjIEByZXR1cm4gW1Jlc3BvbnNlXSB0aGUgcmVzcG9uc2VcbiAgZGVmIHNlbGYuZGVsZXRlISh1cmwsIGRhdGEgPSBuaWwsICZibG9jaylcbiAgICBzZW5kISg6ZGVsZXRlLCB1cmwsIGRhdGEsICZibG9jaylcbiAgZW5kXG5lbmRcblxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPG1vZHVsZTpCcm93c2VyPiIsIjxtb2R1bGU6SFRUUD4iLCJzdXBwb3J0ZWQ/IiwiJHJldF9vcl8xIiwiQnJvd3NlciIsInN1cHBvcnRzPyIsInNlbmQiLCJtZXRob2QiLCJ1cmwiLCJkYXRhIiwidGFwIiwiUHJvbWlzZSIsIm5ldyIsImJsb2NrIGluIHNlbmQiLCJwcm9taXNlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzZW5kIiwiUmVxdWVzdCIsImJsb2NrIiwidG9fcHJvYyIsInJlcSIsIm9uIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiBzZW5kIiwicmVzIiwiYmxvY2sgKDQgbGV2ZWxzKSBpbiBzZW5kIiwicmVzb2x2ZSIsInJlamVjdCIsIm9wZW4iLCJnZXQiLCJoZWFkIiwicG9zdCIsInB1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d0IsQ0FBQUEsRUFBbUJmLEtBQURDLFNBQUFBLENBQUFBLENBQWxCYztNQURGRSxDQUFBQTtNQVlBQyxNQUFJckMsSUFBSnFDLFlBQUFBLDRCQUFlM0IsR0FBRCxFQUFNQyxJQUFwQjBCO0FBQUFBLFFBQUFBOztRQUFBQTs7O1FBQW9CLHlCQUFPO1FBQ3pCQSxPQUFBSCxNQUFBbEMsSUFBQWtDLFNBQUFBLEVBQUFBLENBQU0sTUFBTixFQUFheEIsR0FBYixFQUFrQkMsSUFBbEJ1QixDQUFBQSxFQUF5QmYsS0FBREMsU0FBQUEsQ0FBQUEsQ0FBeEJjO01BREZHLENBQUFBLElBQUFBO01BWUFDLE1BQUl0QyxJQUFKc0MsV0FBQUEsMkJBQWM1QixHQUFELEVBQU1DLElBQW5CMkI7QUFBQUEsUUFBQUE7O1FBQUFBOzs7UUFBbUIseUJBQU87UUFDeEJBLE9BQUFKLE1BQUFsQyxJQUFBa0MsU0FBQUEsRUFBQUEsQ0FBTSxLQUFOLEVBQVl4QixHQUFaLEVBQWlCQyxJQUFqQnVCLENBQUFBLEVBQXdCZixLQUFEQyxTQUFBQSxDQUFBQSxDQUF2QmM7TUFERkksQ0FBQUEsSUFBQUE7TUFZQW5DLE9BQUFvQyxNQUFJdkMsSUFBSnVDLGNBQUFBLDhCQUFpQjdCLEdBQUQsRUFBTUMsSUFBdEI0QjtBQUFBQSxRQUFBQTs7UUFBQUE7OztRQUFzQix5QkFBTztRQUMzQkEsT0FBQUwsTUFBQWxDLElBQUFrQyxTQUFBQSxFQUFBQSxDQUFNLFFBQU4sRUFBZXhCLEdBQWYsRUFBb0JDLElBQXBCdUIsQ0FBQUEsRUFBMkJmLEtBQURDLFNBQUFBLENBQUFBLENBQTFCYztNQURGSyxDQUFBQSxJQUFBQTtJQTFKRnBDLEdBQUFBLFdBQUFBO0VBRkFELEdBQUFBLFdBQUFBO0FBTEFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozODI1MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZGVsYXkucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXJcblxuIyBBbGxvd3MgeW91IHRvIGRlbGF5IHRoZSBjYWxsIHRvIGEgZnVuY3Rpb24gd2hpY2ggZ2V0cyBjYWxsZWQgYWZ0ZXIgdGhlXG4jIGdpdmVuIHRpbWUuXG4jXG4jIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy5zZXRUaW1lb3V0XG5jbGFzcyBEZWxheVxuICAjIEAhYXR0cmlidXRlIFtyXSBhZnRlclxuICAjIEByZXR1cm4gW0Zsb2F0XSB0aGUgc2Vjb25kcyBhZnRlciB3aGljaCB0aGUgYmxvY2sgaXMgY2FsbGVkXG4gIGF0dHJfcmVhZGVyIDphZnRlclxuXG4gICMgQ3JlYXRlIGFuZCBzdGFydCBhIHRpbWVvdXQuXG4gICNcbiAgIyBAcGFyYW0gd2luZG93IFtXaW5kb3ddIHRoZSB3aW5kb3cgdG8gc3RhcnQgdGhlIHRpbWVvdXQgb25cbiAgIyBAcGFyYW0gdGltZSBbRmxvYXRdIHNlY29uZHMgYWZ0ZXIgd2hpY2ggdGhlIGJsb2NrIGlzIGNhbGxlZFxuICBkZWYgaW5pdGlhbGl6ZSh3aW5kb3csIHRpbWUsICZibG9jaylcbiAgICBAd2luZG93ID0gTmF0aXZlLmNvbnZlcnQod2luZG93KVxuICAgIEBhZnRlciAgPSB0aW1lXG4gICAgQGJsb2NrICA9IGJsb2NrXG4gIGVuZFxuXG4gICMgQWJvcnQgdGhlIHRpbWVvdXQuXG4gIGRlZiBhYm9ydFxuICAgIGAjQHdpbmRvdy5jbGVhclRpbWVvdXQoI0BpZClgXG4gIGVuZFxuXG4gICMgU3RhcnQgdGhlIGRlbGF5LlxuICBkZWYgc3RhcnRcbiAgICBAaWQgPSBgI0B3aW5kb3cuc2V0VGltZW91dCgje0BibG9jay50b19ufSwgI0BhZnRlciAqIDEwMDApYFxuICBlbmRcbmVuZFxuXG5jbGFzcyBXaW5kb3dcbiAgIyBFeGVjdXRlIGEgYmxvY2sgYWZ0ZXIgdGhlIGdpdmVuIHNlY29uZHMuXG4gICNcbiAgIyBAcGFyYW0gdGltZSBbRmxvYXRdIHRoZSBzZWNvbmRzIGFmdGVyIGl0IGdldHMgY2FsbGVkXG4gICNcbiAgIyBAcmV0dXJuIFtEZWxheV0gdGhlIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHRpbWVvdXRcbiAgZGVmIGFmdGVyKHRpbWUsICZibG9jaylcbiAgICBEZWxheS5uZXcoQG5hdGl2ZSwgdGltZSwgJmJsb2NrKS50YXAoJjpzdGFydClcbiAgZW5kXG5cbiAgIyBFeGVjdXRlIGEgYmxvY2sgYWZ0ZXIgdGhlIGdpdmVuIHNlY29uZHMsIHlvdSBoYXZlIHRvIGNhbGwgWyNzdGFydF0gb24gaXRcbiAgIyB5b3Vyc2VsZi5cbiAgI1xuICAjIEBwYXJhbSB0aW1lIFtGbG9hdF0gdGhlIHNlY29uZHMgYWZ0ZXIgaXQgZ2V0cyBjYWxsZWRcbiAgI1xuICAjIEByZXR1cm4gW0RlbGF5XSB0aGUgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgdGltZW91dFxuICBkZWYgYWZ0ZXIhKHRpbWUsICZibG9jaylcbiAgICBEZWxheS5uZXcoQG5hdGl2ZSwgdGltZSwgJmJsb2NrKVxuICBlbmRcblxuICAjIFJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIGFmdGVyIHRoZSBnaXZlbiBzZWNvbmRzLlxuICAjXG4gICMgQHBhcmFtIHRpbWUgW0Zsb2F0XSB0aGUgc2Vjb25kcyBhZnRlciBpdCBnZXRzIGNhbGxlZFxuICAjXG4gICMgQHJldHVybiBbUHJvbWlzZV0gdGhlIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgYWZ0ZXIgdGltZW91dCBoYXBwZW5zXG4gIGRlZiByZXNvbHZlX2FmdGVyKHRpbWUpXG4gICAgcHJvbWlzZSA9IFByb21pc2UubmV3XG4gICAgRGVsYXkubmV3KEBuYXRpdmUsIHRpbWUpIHsgcHJvbWlzZS5yZXNvbHZlIH0uc3RhcnRcbiAgICBwcm9taXNlXG4gIGVuZFxuZW5kXG5cbmVuZFxuXG5tb2R1bGUgS2VybmVsXG4gICMgKHNlZSBCcm93c2VyOjpXaW5kb3cjYWZ0ZXIpXG4gIGRlZiBhZnRlcih0aW1lLCAmYmxvY2spXG4gICAgJHdpbmRvdy5hZnRlcih0aW1lLCAmYmxvY2spXG4gIGVuZFxuXG4gICMgKHNlZSBCcm93c2VyOjpXaW5kb3cjYWZ0ZXIhKVxuICBkZWYgYWZ0ZXIhKHRpbWUsICZibG9jaylcbiAgICAkd2luZG93LmFmdGVyISh0aW1lLCAmYmxvY2spXG4gIGVuZFxuXG4gICMgKHNlZSBCcm93c2VyOjpXaW5kb3cjcmVzb2x2ZV9hZnRlcilcbiAgZGVmIHJlc29sdmVfYWZ0ZXIodGltZSlcbiAgICAkd2luZG93LnJlc29sdmVfYWZ0ZXIodGltZSlcbiAgZW5kXG5lbmRcblxuY2xhc3MgUHJvY1xuICAjIChzZWUgQnJvd3Nlcjo6V2luZG93I2FmdGVyKVxuICBkZWYgYWZ0ZXIodGltZSlcbiAgICAkd2luZG93LmFmdGVyKHRpbWUsICZzZWxmKVxuICBlbmRcblxuICAjIChzZWUgQnJvd3Nlcjo6V2luZG93I2FmdGVyISlcbiAgZGVmIGFmdGVyISh0aW1lKVxuICAgICR3aW5kb3cuYWZ0ZXIhKHRpbWUsICZzZWxmKVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkRlbGF5PiIsInNlbGYiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJ3aW5kb3ciLCJ0aW1lIiwiQHdpbmRvdyIsIk5hdGl2ZSIsImNvbnZlcnQiLCJAYWZ0ZXIiLCJAYmxvY2siLCJibG9jayIsImFib3J0IiwiQGlkIiwic3RhcnQiLCJ0b19uIiwiPGNsYXNzOldpbmRvdz4iLCJhZnRlciIsInRhcCIsIm5ldyIsIkRlbGF5IiwiQG5hdGl2ZSIsInRvX3Byb2MiLCJhZnRlciEiLCJyZXNvbHZlX2FmdGVyIiwicHJvbWlzZSIsIlByb21pc2UiLCJibG9jayBpbiByZXNvbHZlX2FmdGVyIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZXNvbHZlX2FmdGVyIiwicmVzb2x2ZSIsIjxtb2R1bGU6S2VybmVsPiIsIiR3aW5kb3ciLCI8Y2xhc3M6UHJvYz4iXSwibWFwcGluZ3MiOiJBQUFBQSxnQ0FBQUEsZ0JB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QWNoQixJQUFEcUIsU0FBQUEsQ0FBQUEsQ0FBYkw7SUFEVEEsQ0FBQUE7SUFLQWUsT0FBQVQsc0JBQUFBLDRCQUFXbEIsSUFBWGtCO0FBQUFBLE1BQUFBO0FBQUFBOztNQUNFQSxPQUFPQSxNQUFQUSxhQUFPUixVQUFBQSxFQUFBQSxDQUFRbEIsSUFBUmtCLENBQUFBLEVBQWV0QixJQUFEcUIsU0FBQUEsQ0FBQUEsQ0FBZEM7SUFEVEEsQ0FBQUE7RUFQRlMsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFuRkFsQzsifX0seyJvZmZzZXQiOnsibGluZSI6MzgzODAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2ludGVydmFsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyXG5cbiMgQWxsb3dzIHlvdSB0byBjcmVhdGUgYW4gaW50ZXJ2YWwgdGhhdCBleGVjdXRlcyB0aGUgZnVuY3Rpb24gZXZlcnkgZ2l2ZW5cbiMgc2Vjb25kcy5cbiNcbiMgQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93LnNldEludGVydmFsXG5jbGFzcyBJbnRlcnZhbFxuICAjIEAhYXR0cmlidXRlIFtyXSBldmVyeVxuICAjIEByZXR1cm4gW0Zsb2F0XSB0aGUgc2Vjb25kcyBldmVyeSB3aGljaCB0aGUgYmxvY2sgaXMgY2FsbGVkXG4gIGF0dHJfcmVhZGVyIDpldmVyeVxuXG4gICMgQ3JlYXRlIGFuZCBzdGFydCBhbiBpbnRlcnZhbC5cbiAgI1xuICAjIEBwYXJhbSB3aW5kb3cgW1dpbmRvd10gdGhlIHdpbmRvdyB0byBzdGFydCB0aGUgaW50ZXJ2YWwgb25cbiAgIyBAcGFyYW0gdGltZSBbRmxvYXRdIHNlY29uZHMgZXZlcnkgd2hpY2ggdG8gY2FsbCB0aGUgYmxvY2tcbiAgZGVmIGluaXRpYWxpemUod2luZG93LCB0aW1lLCAmYmxvY2spXG4gICAgQHdpbmRvdyA9IE5hdGl2ZS5jb252ZXJ0KHdpbmRvdylcbiAgICBAZXZlcnkgID0gdGltZVxuICAgIEBibG9jayAgPSBibG9ja1xuXG4gICAgQGFib3J0ZWQgPSBmYWxzZVxuICBlbmRcblxuICAjIENoZWNrIGlmIHRoZSBpbnRlcnZhbCBoYXMgYmVlbiBzdG9wcGVkLlxuICBkZWYgc3RvcHBlZD9cbiAgICBAaWQubmlsP1xuICBlbmRcblxuICAjIENoZWNrIGlmIHRoZSBpbnRlcnZhbCBoYXMgYmVlbiBhYm9ydGVkLlxuICBkZWYgYWJvcnRlZD9cbiAgICBAYWJvcnRlZFxuICBlbmRcblxuICAjIEFib3J0IHRoZSBpbnRlcnZhbCwgaXQgd29uJ3QgYmUgcG9zc2libGUgdG8gc3RhcnQgaXQgYWdhaW4uXG4gIGRlZiBhYm9ydFxuICAgIGAjQHdpbmRvdy5jbGVhckludGVydmFsKCNAaWQpYFxuXG4gICAgQGFib3J0ZWQgPSB0cnVlXG4gICAgQGlkICAgICAgPSBuaWxcbiAgZW5kXG5cbiAgIyBTdG9wIHRoZSBpbnRlcnZhbCwgaXQgd2lsbCBiZSBwb3NzaWJsZSB0byBzdGFydCBpdCBhZ2Fpbi5cbiAgZGVmIHN0b3BcbiAgICByZXR1cm4gaWYgc3RvcHBlZD9cblxuICAgIGAjQHdpbmRvdy5jbGVhckludGVydmFsKCNAaWQpYFxuXG4gICAgQHN0b3BwZWQgPSB0cnVlXG4gICAgQGlkICAgICAgPSBuaWxcbiAgZW5kXG5cbiAgIyBTdGFydCB0aGUgaW50ZXJ2YWwgaWYgaXQgaGFzIGJlZW4gc3RvcHBlZC5cbiAgZGVmIHN0YXJ0XG4gICAgcmFpc2UgXCJ0aGUgaW50ZXJ2YWwgaGFzIGJlZW4gYWJvcnRlZFwiIGlmIGFib3J0ZWQ/XG4gICAgcmV0dXJuIHVubGVzcyBzdG9wcGVkP1xuXG4gICAgQGlkID0gYCNAd2luZG93LnNldEludGVydmFsKCNAYmxvY2ssICNAZXZlcnkgKiAxMDAwKWBcbiAgZW5kXG5cbiAgIyBDYWxsIHRoZSBbSW50ZXJ2YWxdIGJsb2NrLlxuICBkZWYgY2FsbFxuICAgIEBibG9jay5jYWxsXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFdpbmRvd1xuICAjIEV4ZWN1dGUgdGhlIGJsb2NrIGV2ZXJ5IGdpdmVuIHNlY29uZHMuXG4gICNcbiAgIyBAcGFyYW0gdGltZSBbRmxvYXRdIHRoZSBzZWNvbmRzIGJldHdlZW4gZXZlcnkgY2FsbFxuICAjXG4gICMgQHJldHVybiBbSW50ZXJ2YWxdIHRoZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbnRlcnZhbFxuICBkZWYgZXZlcnkodGltZSwgJmJsb2NrKVxuICAgIEludGVydmFsLm5ldyhAbmF0aXZlLCB0aW1lLCAmYmxvY2spLnRhcCgmOnN0YXJ0KVxuICBlbmRcblxuICAjIEV4ZWN1dGUgdGhlIGJsb2NrIGV2ZXJ5IGdpdmVuIHNlY29uZHMsIHlvdSBoYXZlIHRvIGNhbGwgWyNzdGFydF0gb24gaXRcbiAgIyB5b3Vyc2VsZi5cbiAgI1xuICAjIEBwYXJhbSB0aW1lIFtGbG9hdF0gdGhlIHNlY29uZHMgYmV0d2VlbiBldmVyeSBjYWxsXG4gICNcbiAgIyBAcmV0dXJuIFtJbnRlcnZhbF0gdGhlIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGludGVydmFsXG4gIGRlZiBldmVyeSEodGltZSwgJmJsb2NrKVxuICAgIEludGVydmFsLm5ldyhAbmF0aXZlLCB0aW1lLCAmYmxvY2spXG4gIGVuZFxuZW5kXG5cbmVuZFxuXG5tb2R1bGUgS2VybmVsXG4gICMgKHNlZSBCcm93c2VyOjpXaW5kb3cjZXZlcnkpXG4gIGRlZiBldmVyeSh0aW1lLCAmYmxvY2spXG4gICAgJHdpbmRvdy5ldmVyeSh0aW1lLCAmYmxvY2spXG4gIGVuZFxuXG4gICMgKHNlZSBCcm93c2VyOjpXaW5kb3cjZXZlcnkhKVxuICBkZWYgZXZlcnkhKHRpbWUsICZibG9jaylcbiAgICAkd2luZG93LmV2ZXJ5ISh0aW1lLCAmYmxvY2spXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFByb2NcbiAgIyAoc2VlIEJyb3dzZXI6OldpbmRvdyNldmVyeSlcbiAgZGVmIGV2ZXJ5KHRpbWUpXG4gICAgJHdpbmRvdy5ldmVyeSh0aW1lLCAmc2VsZilcbiAgZW5kXG5cbiAgIyAoc2VlIEJyb3dzZXI6OldpbmRvdyNldmVyeSEpXG4gIGRlZiBldmVyeSEodGltZSlcbiAgICAkd2luZG93LmV2ZXJ5ISh0aW1lLCAmc2VsZilcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpJbnRlcnZhbD4iLCJzZWxmIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwid2luZG93IiwidGltZSIsIkB3aW5kb3ciLCJOYXRpdmUiLCJjb252ZXJ0IiwiQGV2ZXJ5IiwiQGJsb2NrIiwiYmxvY2siLCJAYWJvcnRlZCIsInN0b3BwZWQ/IiwiQGlkIiwibmlsPyIsImFib3J0ZWQ/IiwiYWJvcnQiLCJzdG9wIiwiQHN0b3BwZWQiLCJzdGFydCIsInJhaXNlIiwiY2FsbCIsIjxjbGFzczpXaW5kb3c+IiwiZXZlcnkiLCJ0YXAiLCJuZXciLCJJbnRlcnZhbCIsIkBuYXRpdmUiLCJ0b19wcm9jIiwiZXZlcnkhIiwiPG1vZHVsZTpLZXJuZWw+IiwiJHdpbmRvdyIsIjxjbGFzczpQcm9jPiJdLCJtYXBwaW5ncyI6IkFBQUFBLG1DQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQztFQUFBQTs7SUFBQUE7OztJQU1BQztJQUFBQTs7TUFBQUE7O0FBQUFBOztNQUdFQyxJQUFBQyxhQUFBQSxDQUFZLE9BQVpBOztBQU1BQyxNQUFBQSwwQkFBQUEsc0JBQWVDLE1BQUQsRUFBU0MsSUFBdkJGO0FBQUFBLFFBQUFBOztRQUFBQTs7O1FBQ0VHLGNBQVVDLFlBQU1DLFNBQUFBLENBQVNKLE1BQVRJO1FBQ2hCQyxhQUFVSjtRQUNWSyxhQUFVQztRQUVWUixPQUFBUyxDQUFBQSxlQUFXLEtBQVhBO01BTEZULENBQUFBOztBQVNBVSxNQUFBQSx3QkFBQUEsa0NBQUFBO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFBQyxPQUFHQyxTQUFBQSxDQUFBQTtNQURMRixDQUFBQTs7QUFLQUcsTUFBQUEs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QUFBLENBQVF6QixJQUFSeUIsQ0FBQUEsRUFBZTdCLElBQUQ0QixTQUFBQSxDQUFBQSxDQUFkQztJQURUQSxDQUFBQTtFQVBGRyxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQXBHQW5DOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozODUzMSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvaW1tZWRpYXRlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyXG5cbiMgQ2xhc3MgdG8gZWFzaWx5IGNyZWF0ZSBhbmQgZGlzcGF0Y2ggYW4gaW1tZWRpYXRlIGNhbGwuXG4jXG4jIEltbWVkaWF0ZSBjYWxscyBhcmUgZGVmZXJyZWQgZnVuY3Rpb24gY2FsbHMgdGhhdCBoYXBwZW4gYXMgc29vbiBhcyB0aGV5IGNhblxuIyBiZSBzY2hlZHVsZWQuXG4jXG4jIENvbXBhdGliaWxpdHlcbiMgLS0tLS0tLS0tLS0tLVxuIyBUaGUgY29tcGF0aWJpbGl0eSBsYXllciB3aWxsIHRyeSB2YXJpb3VzIGltcGxlbWVudGF0aW9ucyBpbiB0aGUgZm9sbG93aW5nXG4jIG9yZGVyLlxuI1xuIyArIFtzZXRJbW1lZGlhdGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cuc2V0SW1tZWRpYXRlKVxuIyArIFtwb3N0TWVzc2FnZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy5wb3N0TWVzc2FnZSlcbiMgKyBbcmVhZHlzdGF0ZWNoYW5nZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvUmVmZXJlbmNlL0V2ZW50cy9yZWFkeXN0YXRlY2hhbmdlKVxuIyArIFtzZXRUaW1lb3V0XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvd2luZG93LnNldFRpbWVvdXQpXG4jXG4jIFRoZSBvcmRlciBoYXMgYmVlbiBjaG9zZW4gZnJvbSBiZXN0IHRvIHdvcnN0IGZvciBib3RoIHBlcmZvcm1hbmNlIGFuZFxuIyBwcmVlbXB0aXZlbmVzcy5cbmNsYXNzIEltbWVkaWF0ZVxuICAjIENyZWF0ZSBhbiBpbW1lZGlhdGUgZm9yIHRoZSBnaXZlbiBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZVxuICAjIGFyZ3VtZW50cyBhbmQgYmxvY2suXG4gICNcbiAgIyBAcGFyYW0gZnVuYyBbUHJvY10gdGhlIGZ1bmN0aW9uIHRvIGNhbGxcbiAgIyBAcGFyYW0gYXJncyBbQXJyYXldIHRoZSBhcmd1bWVudHMgdG8gY2FsbCBpdCB3aXRoXG4gIGRlZiBpbml0aWFsaXplKGZ1bmMsIGFyZ3MsICZibG9jaylcbiAgICBAYWJvcnRlZCAgID0gZmFsc2VcbiAgICBAZnVuY3Rpb24gID0gZnVuY1xuICAgIEBhcmd1bWVudHMgPSBhcmdzXG4gICAgQGJsb2NrICAgICA9IGJsb2NrXG4gIGVuZFxuXG4gICMgQCFtZXRob2QgZGlzcGF0Y2hcbiAgIyAgIERpc3BhdGNoIHRoZSBpbW1lZGlhdGUuXG5cbiAgIyBAIW1ldGhvZCBwcmV2ZW50XG4gICMgICBQcmV2ZW50IHRoZSBpbW1lZGlhdGUgZnJvbSBiZWluZyBjYWxsZWQgb25jZSBzY2hlZHVsZWQuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdJbW1lZGlhdGUnXG4gICAgZGVmIGRpc3BhdGNoXG4gICAgICBAaWQgPSBgd2luZG93LnNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgI3tAZnVuY3Rpb24uY2FsbCgqQGFyZ3VtZW50cywgJkBibG9jayl9O1xuICAgICAgfSlgXG4gICAgZW5kXG5cbiAgICBkZWYgcHJldmVudFxuICAgICAgYHdpbmRvdy5jbGVhckltbWVkaWF0ZSgjQGlkKWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0ltbWVkaWF0ZSAoSW50ZXJuZXQgRXhwbG9yZXIpJ1xuICAgIGRlZiBkaXNwYXRjaFxuICAgICAgQGlkID0gYHdpbmRvdy5tc1NldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgI3tAZnVuY3Rpb24uY2FsbCgqQGFyZ3VtZW50cywgJkBibG9jayl9O1xuICAgICAgfSlgXG4gICAgZW5kXG5cbiAgICBkZWYgcHJldmVudFxuICAgICAgYHdpbmRvdy5tc0NsZWFySW1tZWRpYXRlKCNAaWQpYFxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnV2luZG93LnNlbmQgKEFzeW5jaHJvbm91cyknXG4gICAgIyBAcHJpdmF0ZVxuICAgIEBAdGFza3MgID0ge31cblxuICAgICMgQHByaXZhdGVcbiAgICBAQHByZWZpeCA9IFwib3BhbC5icm93c2VyLmltbWVkaWF0ZS4je3JhbmQoMV8wMDBfMDAwKX0uXCJcblxuICAgICR3aW5kb3cub24gOm1lc3NhZ2UgZG8gfGV8XG4gICAgICBpZiBTdHJpbmcgPT09IGUuZGF0YSAmJiBlLmRhdGEuc3RhcnRfd2l0aD8oQEBwcmVmaXgpXG4gICAgICAgIGlmIHRhc2sgPSBAQHRhc2tzLmRlbGV0ZShlLmRhdGFbQEBwcmVmaXgubGVuZ3RoIC4uIC0xXSlcbiAgICAgICAgICB0YXNrWzBdLmNhbGwoKnRhc2tbMV0sICZ0YXNrWzJdKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGRpc3BhdGNoXG4gICAgICBAaWQgICAgICAgICAgPSByYW5kKDFfMDAwXzAwMCkudG9fc1xuICAgICAgQEB0YXNrc1tAaWRdID0gW0BmdW5jdGlvbiwgQGFyZ3VtZW50cywgQGJsb2NrXVxuXG4gICAgICAkd2luZG93LnNlbmQgXCIje0BAcHJlZml4fSN7QGlkfVwiXG4gICAgZW5kXG5cbiAgICBkZWYgcHJldmVudFxuICAgICAgQEB0YXNrcy5kZWxldGUoQGlkKVxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQucmVhZHlzdGF0ZWNoYW5nZSdcbiAgICBkZWYgZGlzcGF0Y2hcbiAgICAgICV4e1xuICAgICAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcblxuICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCEje2Fib3J0ZWQ/fSkge1xuICAgICAgICAgICAgI3tAZnVuY3Rpb24uY2FsbCgqQGFyZ3VtZW50cywgJkBibG9jayl9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBkZWYgcHJldmVudDsgZW5kXG4gIGVsc2VcbiAgICBkZWYgZGlzcGF0Y2hcbiAgICAgIEBpZCA9IGB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgI3tAZnVuY3Rpb24uY2FsbCgqQGFyZ3VtZW50cywgJkBibG9jayl9O1xuICAgICAgfSwgMClgXG4gICAgZW5kXG5cbiAgICBkZWYgcHJldmVudFxuICAgICAgYHdpbmRvdy5jbGVhclRpbWVvdXQoI0BpZClgXG4gICAgZW5kXG4gIGVuZFxuXG4gICMgQWJvcnQgdGhlIGltbWVkaWF0ZS5cbiAgZGVmIGFib3J0XG4gICAgcmV0dXJuIGlmIGFib3J0ZWQ/XG5cbiAgICBAYWJvcnRlZCA9IHRydWVcbiAgICBwcmV2ZW50XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gICMgQ2hlY2sgaWYgdGhlIGltbWVkaWF0ZSBoYXMgYmVlbiBhYm9ydGVkLlxuICBkZWYgYWJvcnRlZD9cbiAgICBAYWJvcnRlZFxuICBlbmRcbmVuZFxuXG5lbmRcblxubW9kdWxlIEtlcm5lbFxuICAjIChzZWUgSW1tZWRpYXRlLm5ldylcbiAgZGVmIGRlZmVyKCphcmdzLCAmYmxvY2spXG4gICAgQnJvd3Nlcjo6SW1tZWRpYXRlLm5ldyhibG9jaywgYXJncykudGFwKCY6ZGlzcGF0Y2gpXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFByb2NcbiAgIyAoc2VlIEltbWVkaWF0ZS5uZXcpXG4gIGRlZiBkZWZlcigqYXJncywgJmJsb2NrKVxuICAgIEJyb3dzZXI6OkltbWVkaWF0ZS5uZXcoc2VsZiwgYXJncywgJmJsb2NrKS50YXAoJjpkaXNwYXRjaClcbiAgZW5kXG5lbmRcblxuY2xhc3MgUHJvbWlzZVxuICAjIENyZWF0ZSBhIHByb21pc2Ugd2hpY2ggd2lsbCBiZSByZXNvbHZlZCB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIGltbWVkaWF0ZS5cbiAgI1xuICAjIEBwYXJhbSBhcmdzIFtBcnJheV0gdGhlIGFyZ3VtZW50cyB0aGUgYmxvY2sgd2lsbCBiZSBjYWxsZWQgd2l0aFxuICBkZWYgc2VsZi5kZWZlcigqYXJncywgJmJsb2NrKVxuICAgIG5ldy50YXAge3xwcm9taXNlfFxuICAgICAgcHJvYyB7XG4gICAgICAgIGJlZ2luXG4gICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKGJsb2NrLmNhbGwoKmFyZ3MpKVxuICAgICAgICByZXNjdWUgRXhjZXB0aW9uID0+IGVcbiAgICAgICAgICBwcm9taXNlLnJlamVjdChlKVxuICAgICAgICBlbmRcbiAgICAgIH0uZGVmZXJcbiAgICB9XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8Y2xhc3M6SW1tZWRpYXRlPiIsImluaXRpYWxpemUiLCJmdW5jIiwiYXJncyIsIkBhYm9ydGVkIiwiQGZ1bmN0aW9uIiwiQGFyZ3VtZW50cyIsIkBibG9jayIsImJsb2NrIiwiQnJvd3NlciIsInN1cHBvcnRzPyIsImRpc3BhdGNoIiwiQGlkIiwiY2FsbCIsInRvX3Byb2MiLCJwcmV2ZW50IiwiQEB0YXNrcyIsIkBAcHJlZml4Iiwic2VsZiIsInJhbmQiLCIxMDAwMDAwIiwib24iLCIkd2luZG93IiwiYmxvY2sgaW4gPGNsYXNzOkltbWVkaWF0ZT4iLCJlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8Y2xhc3M6SW1tZWRpYXRlPiIsIlN0cmluZyIsImRhdGEiLCJzdGFydF93aXRoPyIsInRhc2siLCJkZWxldGUiLCJbXSIsImxlbmd0aCIsIi0xIiwiMCIsIjEiLCIyIiwidG9fcyIsIltdPSIsInNlbmQiLCJhYm9ydGVkPyIsImFib3J0IiwiPG1vZHVsZTpLZXJuZWw+IiwiZGVmZXIiLCJ0YXAiLCJCcm93c2VyOjpJbW1lZGlhdGUiLCJuZXciLCI8Y2xhc3M6UHJvYz4iLCI8Y2xhc3M6UHJvbWlzZT4iLCJibG9jayBpbiBkZWZlciIsInByb21pc2UiLCJibG9jayAoMiBsZXZlbHMpIGluIGRlZmVyIiwicHJvYyIsImJsb2NrICgzIGxldmVscykgaW4gZGVmZXIiLCJyZXNvbHZlIiwiRXhjZXB0aW9uIiwicmVqZWN0Il0sIm1hcHBpbmdzIjoiQUFBQUEsb0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDO0VBQUFBOztJQUFBQTs7SUFtQkFBLE9BQUFDO0lBQUFBOztNQUFBQTtBQUFBQTs7QUFBQUE7OztBQU1FQyxNQUFBQSwwQkFBQUEsc0JBQWVDLElBQUQsRUFBT0MsSUFBckJGO0FBQUFBLFFBQUFBOztRQUFBQTs7O1FBQ0VHLGVBQWE7UUFDYkMsbUJBQWFIO1FBQ2JJLG9CQUFhSDtRQUNiRixPQUFBTSxDQUFBQSxhQUFhQyxLQUFiRDtNQUpGTixDQUFBQTtNQVlBLElBQUEsUUFBR1EsYUFBT0MsY0FBQUEsQ0FBV1YsV0FBWFUsQ0FBVixDQUFBOzs7QUFDRUMsUUFBQUEsd0JBQUFBLG9CQUFBQTtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBQUMsQ0FBQUEsVUFBT0Q7QUFDYkEsUUFBbUJFLE1BQVRSLGdCQUFTUSxRQUFBQSxFQUFNLE1BQUNQLGlCQUFELENBQU5PLEVBQW9CTixVQUFETyxTQUFBQSxDQUFBQSxDQUFuQkQsQ0FBNEJGO0FBQy9D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Mzg3NDUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL3N0b3JhZ2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnanNvbidcbnJlcXVpcmUgJ3N0cmluZ2lvJ1xuXG5tb2R1bGUgQnJvd3NlclxuXG4jIEEge1N0b3JhZ2V9IGFsbG93cyB5b3UgdG8gc3RvcmUgZGF0YSBhY3Jvc3MgcGFnZSBsb2FkcyBhbmQgYnJvd3NlclxuIyByZXN0YXJ0cy5cbiNcbiMgQ29tcGF0aWJpbGl0eVxuIyAtLS0tLS0tLS0tLS0tXG4jIFRoZSBjb21wYXRpYmlsaXR5IGxheWVyIHdpbGwgdHJ5IHZhcmlvdXMgaW1wbGVtZW50YXRpb25zIGluIHRoZSBmb2xsb3dpbmdcbiMgb3JkZXIuXG4jXG4jICsgW3dpbmRvdy5sb2NhbFN0b3JhZ2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0d1aWRlL0FQSS9ET00vU3RvcmFnZSNsb2NhbFN0b3JhZ2UpXG4jICsgW3dpbmRvdy5nbG9iYWxTdG9yYWdlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9HdWlkZS9BUEkvRE9NL1N0b3JhZ2UjZ2xvYmFsU3RvcmFnZSlcbiMgKyBbZG9jdW1lbnQuYm9keS5hZGRCZWhhdmlvcl0oaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTMxNDI0KFZTLjg1KS5hc3B4KVxuIyArIFtkb2N1bWVudC5jb29raWVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9kb2N1bWVudC5jb29raWUpXG4jXG4jIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvR3VpZGUvQVBJL0RPTS9TdG9yYWdlXG4jIEB0b2RvIHJlbW92ZSBtZXRob2RfZGVmaW5lZD8gY2hlY2tzIHdoZW4gcmVxdWlyZSBvcmRlciBpcyBmaXhlZFxuY2xhc3MgU3RvcmFnZVxuICBkZWYgc2VsZi5qc29uX2NyZWF0ZShkYXRhKVxuICAgIGRhdGEuZGVsZXRlKEpTT04uY3JlYXRlX2lkKVxuXG4gICAgSGFzaFtkYXRhLm1hcCB7fGtleSwgdmFsdWV8XG4gICAgICBbSlNPTi5wYXJzZShrZXkpLCB2YWx1ZV1cbiAgICB9XVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBuYW1lXG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgbmFtZSBvZiB0aGUgc3RvcmFnZVxuICBhdHRyX3JlYWRlciA6bmFtZVxuXG4gICMgQ3JlYXRlIGEgbmV3IHN0b3JhZ2Ugb24gdGhlIGdpdmVuIHdpbmRvdyB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICAjXG4gICMgQHBhcmFtIHdpbmRvdyBbbmF0aXZlXSB0aGUgd2luZG93IHRvIHNhdmUgdGhlIHN0b3JhZ2UgdG9cbiAgIyBAcGFyYW0gbmFtZSBbU3RyaW5nXSB0aGUgbmFtZSB0byB1c2UgdG8gZGlzY2VybiBkaWZmZXJlbnQgc3RvcmFnZXNcbiAgZGVmIGluaXRpYWxpemUod2luZG93LCBuYW1lKVxuICAgIHN1cGVyKClcblxuICAgIEB3aW5kb3cgPSB3aW5kb3dcbiAgICBAbmFtZSAgID0gbmFtZVxuICAgIEBkYXRhICAgPSB7fVxuXG4gICAgYXV0b3NhdmUhXG4gICAgcmVsb2FkXG4gIGVuZFxuXG4gICMgQ2hlY2sgaWYgYXV0b3NhdmluZyBpcyBlbmFibGVkLlxuICAjXG4gICMgV2hlbiBhdXRvc2F2aW5nIGlzIGVuYWJsZWQgdGhlIHtTdG9yYWdlfSBpcyBzYXZlZCBldmVyeSB0aW1lIGEgY2hhbmdlIGlzXG4gICMgbWFkZSwgb3RoZXJ3aXNlIHlvdSdsbCBoYXZlIHRvIHNhdmUgaXQgbWFudWFsbHkgeW91cnNlbGYuXG4gIGRlZiBhdXRvc2F2ZT9cbiAgICBAYXV0b3NhdmVcbiAgZW5kXG5cbiAgIyBFbmFibGUgYXV0b3NhdmluZy5cbiAgZGVmIGF1dG9zYXZlIVxuICAgIEBhdXRvc2F2ZSA9IHRydWVcbiAgZW5kXG5cbiAgIyBEaXNhYmxlIGF1dG9zYXZpbmcuXG4gIGRlZiBub19hdXRvc2F2ZSFcbiAgICBAYXV0b3NhdmUgPSBmYWxzZVxuICBlbmRcblxuICBpbmNsdWRlIEVudW1lcmFibGVcblxuICAjIEl0ZXJhdGUgb3ZlciB0aGUgKGtleSwgdmFsdWUpIHBhaXJzIGluIHRoZSBzdG9yYWdlLlxuICAjXG4gICMgQHlpZWxkIFtrZXksIHZhbHVlXVxuICBkZWYgZWFjaCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDplYWNoIHVubGVzcyBibG9ja1xuXG4gICAgQGRhdGEuZWFjaCgmYmxvY2spXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBtZXRob2RfbWlzc2luZygqYXJncywgJmJsb2NrKVxuICAgIEBkYXRhLl9fc2VuZF9fKCphcmdzLCAmYmxvY2spXG4gIGVuZFxuXG4gICMgU2V0IGEgdmFsdWUgaW4gdGhlIHN0b3JhZ2UuXG4gIGRlZiBbXT0oa2V5LCB2YWx1ZSlcbiAgICBAZGF0YVtrZXldID0gdmFsdWVcblxuICAgIHNhdmUgaWYgYXV0b3NhdmU/XG4gIGVuZFxuXG4gICMgRGVsZXRlIGEgdmFsdWUgZnJvbSB0aGUgc3RvcmFnZS5cbiAgZGVmIGRlbGV0ZShrZXkpXG4gICAgQGRhdGEuZGVsZXRlKGtleSkudGFwIHtcbiAgICAgIHNhdmUgaWYgYXV0b3NhdmU/XG4gICAgfVxuICBlbmRcblxuICAjIENsZWFyIHRoZSBzdG9yYWdlLlxuICBkZWYgY2xlYXJcbiAgICBAZGF0YS5jbGVhci50YXAge1xuICAgICAgc2F2ZSBpZiBhdXRvc2F2ZT9cbiAgICB9XG4gIGVuZFxuXG4gICMgUmVwbGFjZSB0aGUgY3VycmVudCBzdG9yYWdlIHdpdGggdGhlIGdpdmVuIG9uZS5cbiAgI1xuICAjIEBwYXJhbSBuZXcgW0hhc2gsIFN0cmluZ10gaWYgbmV3IGlzIGEge1N0cmluZ30gaXQgd2lsbCBiZSBwYXJzZWQgYXMgSlNPTlxuICBkZWYgcmVwbGFjZShuZXcpXG4gICAgaWYgU3RyaW5nID09PSBuZXdcbiAgICAgIEBkYXRhLnJlcGxhY2UoSlNPTi5wYXJzZShuZXcpKVxuICAgIGVsc2VcbiAgICAgIEBkYXRhLnJlcGxhY2UobmV3KVxuICAgIGVuZFxuICBlbmRcblxuICAjIENhbGwgdGhlIGJsb2NrIGJldHdlZW4gYSBbI3JlbG9hZF0gYW5kIFsjc2F2ZV0uXG4gIGRlZiBjb21taXQoJmJsb2NrKVxuICAgIGF1dG9zYXZlICA9IEBhdXRvc2F2ZVxuICAgIEBhdXRvc2F2ZSA9IGZhbHNlXG4gICAgcmVzdWx0ICAgID0gbmlsXG5cbiAgICByZWxvYWRcblxuICAgIGJlZ2luXG4gICAgICByZXN1bHQgPSBibG9jay5jYWxsXG4gICAgICBzYXZlXG4gICAgcmVzY3VlXG4gICAgICByZWxvYWRcbiAgICAgIHJhaXNlXG4gICAgZW5zdXJlXG4gICAgICBAYXV0b3NhdmUgPSBhdXRvc2F2ZVxuICAgIGVuZFxuXG4gICAgcmVzdWx0XG4gIGVuZFxuXG4gIGRlZiB0b19oXG4gICAgQGRhdGFcbiAgZW5kXG5cbiAgIyBAIW1ldGhvZCByZWxvYWRcbiAgIyAgIExvYWQgdGhlIHN0b3JhZ2UuXG5cbiAgIyBAIW1ldGhvZCBzYXZlXG4gICMgICBQZXJzaXN0IHRoZSBjdXJyZW50IHN0YXRlIHRvIHRoZSBzdG9yYWdlLlxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdTdG9yYWdlLmxvY2FsJ1xuICAgIGRlZiByZWxvYWRcbiAgICAgIHJlcGxhY2UgYCNAd2luZG93LmxvY2FsU3RvcmFnZVsjQG5hbWVdIHx8ICd7fSdgXG4gICAgZW5kXG5cbiAgICBkZWYgc2F2ZVxuICAgICAgYCNAd2luZG93LmxvY2FsU3RvcmFnZVsjQG5hbWVdID0gI3tKU09OLmR1bXAoc2VsZil9YFxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnU3RvcmFnZS5nbG9iYWwnXG4gICAgZGVmIHJlbG9hZFxuICAgICAgcmVwbGFjZSBgI0B3aW5kb3cuZ2xvYmFsU3RvcmFnZVsjQHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZV1bI0BuYW1lXSB8fCAne30nYFxuICAgIGVuZFxuXG4gICAgZGVmIHNhdmVcbiAgICAgIGAjQHdpbmRvdy5nbG9iYWxTdG9yYWdlWyNAd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lXVsjQG5hbWVdID0gI3tKU09OLmR1bXAoc2VsZil9YFxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnRWxlbWVudC5hZGRCZWhhdmlvcidcbiAgICBkZWYgcmVsb2FkXG4gICAgICAleHtcbiAgICAgICAgI0BlbGVtZW50ID0gI0B3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuICAgICAgICAjQGVsZW1lbnQuYWRkQmVoYXZpb3IoJyNkZWZhdWx0I3VzZXJEYXRhJyk7XG5cbiAgICAgICAgI0B3aW5kb3cuZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZCgjQGVsZW1lbnQpO1xuXG4gICAgICAgICNAZWxlbWVudC5sb2FkKCNAbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHJlcGxhY2UgYCNAZWxlbWVudC5nZXRBdHRyaWJ1dGUoI0BuYW1lKSB8fCAne30nYFxuICAgIGVuZFxuXG4gICAgZGVmIHNhdmVcbiAgICAgICV4e1xuICAgICAgICAjQGVsZW1lbnQuc2V0QXR0cmlidXRlKCNAbmFtZSwgI3tKU09OLmR1bXAoc2VsZil9KTtcbiAgICAgICAgI0BlbGVtZW50LnNhdmUoI0BuYW1lKTtcbiAgICAgIH1cbiAgICBlbmRcbiAgZWxzZVxuICAgIGRlZiByZWxvYWRcbiAgICAgICRkb2N1bWVudC5jb29raWVzLm9wdGlvbnMgZXhwaXJlczogNjAgKiA2MCAqIDI0ICogMzY1XG5cbiAgICAgIHJlcGxhY2UgJGRvY3VtZW50LmNvb2tpZXNbQG5hbWVdXG4gICAgZW5kXG5cbiAgICBkZWYgc2F2ZVxuICAgICAgJGRvY3VtZW50LmNvb2tpZXNbQG5hbWVdID0gSlNPTi5kdW1wKHNlbGYpXG4gICAgZW5kXG4gIGVuZFxuXG4gICMgQ29udmVydCB0aGUgc3RvcmFnZSB0byBKU09OLlxuICAjXG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgSlNPTiByZXByZXNlbnRhdGlvblxuICBkZWYgdG9fanNvblxuICAgIGlvID0gU3RyaW5nSU8ubmV3IDw8IFwie1wiXG5cbiAgICBpbyA8PCBKU09OLmNyZWF0ZV9pZC50b19qc29uIDw8IFwiOlwiIDw8IHNlbGYuY2xhc3MubmFtZS50b19qc29uIDw8IFwiLFwiXG5cbiAgICBAZGF0YS5lYWNoIHt8a2V5LCB2YWx1ZXxcbiAgICAgIGlvIDw8IGtleS50b19qc29uLnRvX3MgPDwgXCI6XCIgPDwgdmFsdWUudG9fanNvbiA8PCBcIixcIlxuICAgIH1cblxuICAgIGlvLnNlZWsoLTEsIElPOjpTRUVLX0NVUilcbiAgICBpbyA8PCBcIn1cIlxuXG4gICAgaW8uc3RyaW5nXG4gIGVuZFxuZW5kXG5cbiMgQSB7U2Vzc2lvblN0b3JhZ2V9IGFsbG93cyB5b3UgdG8gc3RvcmUgZGF0YSBhY3Jvc3MgcGFnZSByZWxvYWRzLCBhcyBsb25nIGFzIHRoZSBzZXNzaW9uXG4jIGlzIGFjdGl2ZS5cbiNcbiMgQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9HdWlkZS9BUEkvRE9NL1N0b3JhZ2Ujc2Vzc2lvblN0b3JhZ2VcbmNsYXNzIFNlc3Npb25TdG9yYWdlIDwgU3RvcmFnZVxuICBkZWYgc2VsZi5zdXBwb3J0ZWQ/XG4gICAgQnJvd3Nlci5zdXBwb3J0cz8gJ1N0b3JhZ2Uuc2Vzc2lvbidcbiAgZW5kXG5cbiAgZGVmIHJlbG9hZFxuICAgIHJlcGxhY2UgYCNAd2luZG93LnNlc3Npb25TdG9yYWdlWyNAbmFtZV0gfHwgJ3t9J2BcbiAgZW5kXG5cbiAgZGVmIHNhdmVcbiAgICBgI0B3aW5kb3cuc2Vzc2lvblN0b3JhZ2VbI0BuYW1lXSA9ICN7SlNPTi5kdW1wKHNlbGYpfWBcbiAgZW5kXG5lbmRcblxuY2xhc3MgV2luZG93XG4gICMgR2V0IGEgc3RvcmFnZSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICAjXG4gICMgQHBhcmFtIG5hbWUgW1N5bWJvbF0gdGhlIG5hbWUgb2YgdGhlIHN0b3JhZ2VcbiAgI1xuICAjIEByZXR1cm4gW1N0b3JhZ2VdXG4gIGRlZiBzdG9yYWdlKG5hbWUgPSA6ZGVmYXVsdClcbiAgICBTdG9yYWdlLm5ldyh0b19uLCBuYW1lKVxuICBlbmRcblxuICAjIEdldCBhIHNlc3Npb24gc3RvcmFnZSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICAjXG4gICMgQHBhcmFtIG5hbWUgW1N5bWJvbF0gdGhlIG5hbWUgb2YgdGhlIHN0b3JhZ2VcbiAgI1xuICAjIEByZXR1cm4gW1Nlc3Npb25TdG9yYWdlXVxuICBkZWYgc2Vzc2lvbl9zdG9yYWdlKG5hbWUgPSA6ZGVmYXVsdClcbiAgICBTZXNzaW9uU3RvcmFnZS5uZXcodG9fbiwgbmFtZSlcbiAgZW5kXG5lbmRcblxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpTdG9yYWdlPiIsImpzb25fY3JlYXRlIiwiZGF0YSIsImRlbGV0ZSIsIkpTT04iLCJjcmVhdGVfaWQiLCJIYXNoIiwiW10iLCJtYXAiLCJibG9jayBpbiBqc29uX2NyZWF0ZSIsImtleSIsInZhbHVlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBqc29uX2NyZWF0ZSIsInBhcnNlIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwid2luZG93IiwibmFtZSIsIkB3aW5kb3ciLCJAbmFtZSIsIkBkYXRhIiwiYXV0b3NhdmUhIiwicmVsb2FkIiwiYXV0b3NhdmU/Iiwibm9fYXV0b3NhdmUhIiwiaW5jbHVkZSIsIkVudW1lcmFibGUiLCJlYWNoIiwiYmxvY2siLCJlbnVtX2ZvciIsInRvX3Byb2MiLCJtZXRob2RfbWlzc2luZyIsIl9fc2VuZF9fIiwiYXJncyIsIltdPSIsInNhdmUiLCJ0YXAiLCJibG9jayBpbiBkZWxldGUiLCJibG9jayAoMiBsZXZlbHMpIGluIGRlbGV0ZSIsImNsZWFyIiwiYmxvY2sgaW4gY2xlYXIiLCJibG9jayAoMiBsZXZlbHMpIGluIGNsZWFyIiwicmVwbGFjZSIsIm5ldyQiLCJTdHJpbmciLCJjb21taXQiLCJhdXRvc2F2ZSIsIkBhdXRvc2F2ZSIsInJlc3VsdCIsImNhbGwiLCJTdGFuZGFyZEVycm9yIiwicmFpc2UiLCJ0b19oIiwiQnJvd3NlciIsInN1cHBvcnRzPyIsImR1bXAiLCJAZWxlbWVudCIsIiRkb2N1bWVudCIsImNvb2tpZXMiLCJvcHRpb25zIiwiKiIsIjYwIiwiMjQiLCIzNjUiLCJ0b19qc29uIiwiaW8iLCJTdHJpbmdJTyIsIm5ldyIsIjw8IiwiY2xhc3MiLCJibG9jayBpbiB0b19qc29uIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0b19qc29uIiwidG9fcyIsInNlZWsiLCItMSIsIklPOjpTRUVLX0NVUiIsIklPIiwic3RyaW5nIiwiPGNsYXNzOlNlc3Npb25TdG9yYWdlPiIsInN1cHBvcnRlZD8iLCJTdG9yYWdlIiwiPGNsYXNzOldpbmRvdz4iLCJzdG9yYWdlIiwidG9fbiIsInNlc3Npb25fc3RvcmFnZSIsIlNlc3Npb25TdG9yYWdlIl0sIm1hcHBpbmdzIjoiQUFBQUEsa0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLE1BQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLFVBQVJFO0VBRUFGLE9BQUFHO0VBQUFBOztJQUFBQTs7O0lBaUJBQztJQUFBQTs7TUFBQUE7O0FBQUFBOztNQUNFQyxNQUFJSixJQUFKSSxrQkFBQUEsdUJBQXFCQyxJQUFyQkQ7QUFBQUE7O1FBQ0VDLElBQUlDLFFBQUFBLENBQVFDLFVBQUlDLFdBQUFBLENBQUFBLENBQVpGO1FBRUpGLE9BQUFLLFVBQUlDLE9BQUFBLENBQUtDLE1BQUpOLElBQUlNLE9BQUFBLEVBQUFBLEVBQUFBLEVBQUpDLGFBQVdDLEdBQUQsRUFBTUMsS0FBaEJGOztVQUFXO1VBQUs7VUFDbkJHLE9BQUEsQ0FBQ1Is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cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9ibG9iLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyXG5cbmNsYXNzIEJsb2JcbiAgaW5jbHVkZSBOYXRpdmVDYWNoZWRXcmFwcGVyXG5cbiAgIyBDcmVhdGUgYSBuZXcgYmxvYiBmcm9tIGFueXRoaW5nIHRoYXQgQmxvYiBBUEkgc3VwcG9ydHNcbiAgZGVmIHNlbGYuY3JlYXRlKGZyb20sIG9wdGlvbnM9e30pXG4gICAgbmV3KGBuZXcgQmxvYigje05hdGl2ZS5jb252ZXJ0KGZyb20pfSwgI3tvcHRpb25zLnRvX259KWApXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIHNpemVcbiAgIyBAcmV0dXJuIFtJbnRlZ2VyXSBibG9iIHNpemUgaW4gYnl0ZXNcbiAgZGVmIHNpemVcbiAgICBgI0BuYXRpdmUuc2l6ZWBcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gdHlwZVxuICAjIEByZXR1cm4gW1N0cmluZ10gYmxvYiBtaW1lIHR5cGVcbiAgZGVmIHR5cGVcbiAgICBgI0BuYXRpdmUudHlwZWBcbiAgZW5kXG5cbiAgIyBDb252ZXJ0IGEgYmxvYiB0byBhIFVURi04IGVuY29kZWQgc3RyaW5nLlxuICAjXG4gICMgSWYgYmxvY2sgaXMgZ2l2ZW4gaXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhIHBhcmFtZXRlciBvbmNlIHdlIHJlY2VpdmVcbiAgIyB0aGUgdGV4dC4gT3RoZXJ3aXNlIHJldHVybiBhIHtQcm9taXNlfSB3aGljaCB3aWxsIHJlc29sdmUgb25jZSB3ZVxuICAjIHJlY2VpdmUgaXQuXG4gIGRlZiB0ZXh0KCZibG9jaylcbiAgICBwcm9taXNlID0gbmlsXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcHJvbWlzZSA9IFByb21pc2UubmV3XG4gICAgICBibG9jayA9IHByb2MgeyB8aXwgcHJvbWlzZS5yZXNvbHZlKGkpIH1cbiAgICBlbmRcbiAgICBgI0BuYXRpdmUudGV4dCgpLnRoZW4oI3tibG9jay50b19ufSlgXG4gICAgcHJvbWlzZVxuICBlbmRcblxuICAjIHtCdWZmZXJ9IHZpZXcgaW50byB0aGUgYmxvYlxuICAjXG4gICMgSWYgYmxvY2sgaXMgZ2l2ZW4gaXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhIHBhcmFtZXRlciBvbmNlIHdlIHJlY2VpdmVcbiAgIyB0aGUgYnVmZmVyLiBPdGhlcndpc2UgcmV0dXJuIGEge1Byb21pc2V9IHdoaWNoIHdpbGwgcmVzb2x2ZSBvbmNlIHdlXG4gICMgcmVjZWl2ZSBpdC5cbiAgZGVmIGJ1ZmZlclxuICAgIHByb21pc2UgPSBuaWxcbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICBwcm9taXNlID0gUHJvbWlzZS5uZXdcbiAgICAgIGJsb2NrID0gcHJvYyB7IHxpfCBwcm9taXNlLnJlc29sdmUoaSkgfVxuICAgIGVuZFxuICAgIHJlc2Jsb2NrID0gcHJvYyB7IHxpfCBibG9jay5jYWxsKEJ1ZmZlci5uZXcoaSkpIH1cbiAgICBgI0BuYXRpdmUuYXJyYXlCdWZmZXIoKS50aGVuKCN7cmVzYmxvY2sudG9fbn0pYFxuICAgIHByb21pc2VcbiAgZW5kXG5cbiAgIyBDcmVhdGUgYSBuZXcgYmxvYiBieSBzbGljaW5nIHRoaXMgYmxvYlxuICBkZWYgc2xpY2Uoc3RhcnQsIGZpbmlzaD1uaWwpXG4gICAgQmxvYi5uZXcoYCNAbmF0aXZlLnNsaWNlKCN7c3RhcnR9LCAje2ZpbmlzaH0pYClcbiAgZW5kXG5cbiAgIyBDb252ZXJ0IGEgYmxvYiB0byBhbiBVUkwgdGhhdCBjYW4gYmUgdXNlZCB0byByZWZlcmVuY2UgdGhpcyBibG9iIGluIERPTVxuICAjIGVnLiBkaXNwbGF5IHNvbWUgbXVsdGltZWRpYVxuICBkZWYgdG9fdXJsKHdpbmRvdz0kd2luZG93KVxuICAgIGAje3dpbmRvdy50b19ufS5VUkwuY3JlYXRlT2JqZWN0VVJMKCNAbmF0aXZlKWBcbiAgZW5kXG5cbiAgIyBSZW5hbWUgYSBibG9iIGFuZCByZXR1cm4gYSB7RmlsZX0gd2l0aCBhIG5ldyBuYW1lLlxuICAjXG4gICMgQHJldHVybiBbRmlsZV0gYSByZW5hbWVkIGJsb2JcbiAgZGVmIHJlbmFtZShuZXdfZmlsZW5hbWUpXG4gICAgRmlsZS5jcmVhdGUoW3NlbGZdLCBuZXdfZmlsZW5hbWUsIHR5cGU6IHR5cGUsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0TW9kaWZpZWQ6IHJlc3BvbmRfdG8/KDpsYXN0X21vZGlmaWVkKSA/IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF9tb2RpZmllZCA6IFRpbWUubm93KVxuICBlbmRcbmVuZFxuXG5jbGFzcyBGaWxlIDwgQmxvYlxuICAjIENyZWF0ZSBhIG5ldyBmaWxlIGZyb20gYW55dGhpbmcgdGhhdCBGaWxlIEFQSSBzdXBwb3J0c1xuICBkZWYgc2VsZi5jcmVhdGUoZnJvbSwgbmFtZSwgb3B0aW9ucz17fSlcbiAgICBuZXcoYG5ldyBGaWxlKCN7TmF0aXZlLmNvbnZlcnQoZnJvbSl9LCAje25hbWV9LCAje29wdGlvbnMudG9fbn0pYClcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gbGFzdF9tb2RpZmllZFxuICAjIEByZXR1cm4gW1RpbWVdIGxhc3QgbW9kaWZpZWQgZGF0ZSBvZiB0aGlzIGZpbGVcbiAgZGVmIGxhc3RfbW9kaWZpZWRcbiAgICBUaW1lLmF0KGAjQG5hdGl2ZS5sYXN0TW9kaWZpZWRgLzEwMDAuMClcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gbmFtZVxuICAjIEByZXR1cm4gW1N0cmluZ10gZmlsZW5hbWUgXG4gIGRlZiBuYW1lXG4gICAgYCNAbmF0aXZlLm5hbWVgXG4gIGVuZFxuZW5kXG5cbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkJsb2I+Iiwic2VsZiIsImluY2x1ZGUiLCJOYXRpdmVDYWNoZWRXcmFwcGVyIiwiY3JlYXRlIiwiZnJvbSIsIm9wdGlvbnMiLCJuZXciLCJOYXRpdmUiLCJjb252ZXJ0IiwidG9fbiIsInNpemUiLCJAbmF0aXZlIiwidHlwZSIsInRleHQiLCJwcm9taXNlIiwiYmxvY2tfZ2l2ZW4/IiwiUHJvbWlzZSIsImJsb2NrIiwicHJvYyIsImJsb2NrIGluIHRleHQiLCJpIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0ZXh0IiwicmVzb2x2ZSIsImJ1ZmZlciIsImJsb2NrIGluIGJ1ZmZlciIsImJsb2NrICgyIGxldmVscykgaW4gYnVmZmVyIiwicmVzYmxvY2siLCJjYWxsIiwiQnVmZmVyIiwic2xpY2UiLCJzdGFydCIsImZpbmlzaCIsIkJsb2IiLCJ0b191cmwiLCJ3aW5kb3ciLCIkd2luZG93IiwicmVuYW1lIiwibmV3X2ZpbGVuYW1lIiwiRmlsZSIsInJlc3BvbmRfdG8/IiwibGFzdF9tb2RpZmllZCIsIlRpbWUiLCJub3ciLCI8Y2xhc3M6RmlsZT4iLCJuYW1lIiwiYXQiLCIvIl0sIm1hcHBpbmdzIjoiQUFBQUEsK0JBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7SUFFQUM7SUFBQUE7O01BQUFBOztBQUFBQTs7TUFDRUMsSUFBQUMsU0FBQUEsQ0FBUUMseUJBQVJEO01BR0FFLE1BQUlILElBQUpHLGFBQUFBLGtCQUFnQkMsSUFBRCxFQUFPQyxPQUF0QkY7QUFBQUEsUUFBQUE7OztRQUFzQiwrQkFBUTtRQUM1QkEsT0FBQUgsSUFBQU0sS0FBQUEsQ0FBS0gsU0FBV0ksWUFBTUMsU0FBQUEsQ0FBU0osSUFBVEksQ0FBZUwsRUFBSUUsT0FBT0ksTUFBQUEsQ0FBQUEsQ0FBTU4sQ0FBdERHO01BREZILENBQUFBLElBQUFBOztBQU1BTyxNQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFFQyxjQUFPRDtNQURYQSxDQUFBQTs7QUFNQUUsTUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBRUQsY0FBT0M7TUFEWEEsQ0FBQUE7O0FB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QUFBO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFFakMsY0FBT2lDO01BRFhBLENBQUFBO0lBZEZELEdBQUFBLFdBQUFBLEVBQWFYLFVBQWJXO0VBMUVBN0MsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM5MTY2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9zb2NrZXQucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXJcblxuIyBBIHtTb2NrZXR9IGFsbG93cyB0aGUgYnJvd3NlciBhbmQgYSBzZXJ2ZXIgdG8gaGF2ZSBhIGJpZGlyZWN0aW9uYWwgZGF0YVxuIyBjb25uZWN0aW9uLlxuI1xuIyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJTb2NrZXRcbmNsYXNzIFNvY2tldCA8IElPXG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPyA6V2ViU29ja2V0XG4gIGVuZFxuXG4gIGluY2x1ZGUgTmF0aXZlOjpXcmFwcGVyXG4gIGluY2x1ZGUgSU86OldyaXRhYmxlIGlmIGRlZmluZWQ/IElPOjpXcml0YWJsZVxuICBpbmNsdWRlIEV2ZW50OjpUYXJnZXRcblxuICB0YXJnZXQge3x2YWx1ZXxcbiAgICBTb2NrZXQubmV3KHZhbHVlKSBpZiBOYXRpdmUuaXNfYT8odmFsdWUsIGB3aW5kb3cuV2ViU29ja2V0YClcbiAgfVxuXG4gICMgQ3JlYXRlIGEgY29ubmVjdGlvbiB0byB0aGUgZ2l2ZW4gVVJMLCBvcHRpb25hbGx5IHVzaW5nIHRoZSBnaXZlbiBwcm90b2NvbC5cbiAgI1xuICAjIEBwYXJhbSB1cmwgW1N0cmluZ10gdGhlIFVSTCB0byBjb25uZWN0IHRvXG4gICMgQHBhcmFtIHByb3RvY29sIFtTdHJpbmddIHRoZSBwcm90b2NvbCB0byB1c2VcbiAgI1xuICAjIEB5aWVsZCBpZiB0aGUgYmxvY2sgaGFzIG5vIHBhcmFtZXRlcnMgaXQncyBgaW5zdGFuY2VfZXhlY2BkLCBvdGhlcndpc2UgaXQnc1xuICAjICAgICAgICBjYWxsZWQgd2l0aCBgc2VsZmBcbiAgZGVmIGluaXRpYWxpemUodXJsLCBwcm90b2NvbCA9IG5pbCwgJmJsb2NrKVxuICAgIGlmIG5hdGl2ZT8odXJsKVxuICAgICAgc3VwZXIodXJsKVxuICAgIGVsc2lmIHByb3RvY29sXG4gICAgICBzdXBlcihgbmV3IHdpbmRvdy5XZWJTb2NrZXQoI3t1cmwudG9fc30sICN7cHJvdG9jb2wudG9fbn0pYClcbiAgICBlbHNlXG4gICAgICBzdXBlcihgbmV3IHdpbmRvdy5XZWJTb2NrZXQoI3t1cmwudG9fc30pYClcbiAgICBlbmRcblxuICAgIGlmIGJsb2NrLmFyaXR5ID09IDBcbiAgICAgIGluc3RhbmNlX2V4ZWMoJmJsb2NrKVxuICAgIGVsc2VcbiAgICAgIGJsb2NrLmNhbGwoc2VsZilcbiAgICBlbmQgaWYgYmxvY2tcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gcHJvdG9jb2xcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBwcm90b2NvbCBvZiB0aGUgc29ja2V0XG4gIGFsaWFzX25hdGl2ZSA6cHJvdG9jb2xcblxuICAjIEAhYXR0cmlidXRlIFtyXSB1cmxcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBVUkwgdGhlIHNvY2tldCBpcyBjb25uZWN0ZWQgdG9cbiAgYWxpYXNfbmF0aXZlIDp1cmxcblxuICAjIEAhYXR0cmlidXRlIFtyXSBidWZmZXJlZFxuICAjIEByZXR1cm4gW0ludGVnZXJdIHRoZSBhbW91bnQgb2YgYnVmZmVyZWQgZGF0YS5cbiAgYWxpYXNfbmF0aXZlIDpidWZmZXJlZCwgOmJ1ZmZlcmVkQW1vdW50XG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gdHlwZVxuICAjIEByZXR1cm4gWzpibG9iLCA6YnVmZmVyLCA6c3RyaW5nXSB0aGUgdHlwZSBvZiB0aGUgc29ja2V0XG4gIGRlZiB0eXBlXG4gICAgJXh7XG4gICAgICBzd2l0Y2ggKCNAbmF0aXZlLmJpbmFyeVR5cGUpIHtcbiAgICAgICAgY2FzZSBcImJsb2JcIjpcbiAgICAgICAgICByZXR1cm4gXCJibG9iXCI7XG5cbiAgICAgICAgY2FzZSBcImFycmF5YnVmZmVyXCI6XG4gICAgICAgICAgcmV0dXJuIFwiYnVmZmVyXCI7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIHN0YXRlXG4gICMgQHJldHVybiBbOmNvbm5lY3RpbmcsIDpvcGVuLCA6Y2xvc2luZywgOmNsb3NlZF0gdGhlIHN0YXRlIG9mIHRoZSBzb2NrZXRcbiAgZGVmIHN0YXRlXG4gICAgJXh7XG4gICAgICBzd2l0Y2ggKCNAbmF0aXZlLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgY2FzZSB3aW5kb3cuV2ViU29ja2V0LkNPTk5FQ1RJTkc6XG4gICAgICAgICAgcmV0dXJuIFwiY29ubmVjdGluZ1wiO1xuXG4gICAgICAgIGNhc2Ugd2luZG93LldlYlNvY2tldC5PUEVOOlxuICAgICAgICAgIHJldHVybiBcIm9wZW5cIjtcblxuICAgICAgICBjYXNlIHdpbmRvdy5XZWJTb2NrZXQuQ0xPU0lORzpcbiAgICAgICAgICByZXR1cm4gXCJjbG9zaW5nXCI7XG5cbiAgICAgICAgY2FzZSB3aW5kb3cuV2ViU29ja2V0LkNMT1NFRDpcbiAgICAgICAgICByZXR1cm4gXCJjbG9zZWRcIjtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIGV4dGVuc2lvbnNcbiAgIyBAcmV0dXJuIFtBcnJheTxTdHJpbmc+XSB0aGUgZXh0ZW5zaW9ucyB1c2VkIGJ5IHRoZSBzb2NrZXRcbiAgZGVmIGV4dGVuc2lvbnNcbiAgICBgI0BuYXRpdmUuZXh0ZW5zaW9uc2Auc3BsaXQoL1xccyosXFxzKi8pXG4gIGVuZFxuXG4gICMgQ2hlY2sgaWYgdGhlIHNvY2tldCBpcyBhbGl2ZS5cbiAgZGVmIGFsaXZlP1xuICAgIHN0YXRlID09IDpvcGVuXG4gIGVuZFxuXG4gICMgU2VuZCBkYXRhIHRvIHRoZSBzb2NrZXQuXG4gICNcbiAgIyBAcGFyYW0gZGF0YSBbI3RvX25dIHRoZSBkYXRhIHRvIHNlbmRcbiAgZGVmIHdyaXRlKGRhdGEpXG4gICAgYCNAbmF0aXZlLnNlbmQoI3tkYXRhLnRvX259KWBcbiAgZW5kXG5cbiAgYWxpYXMgPDwgd3JpdGVcblxuICBhbGlhcyBzZW5kIHdyaXRlXG5cbiAgIyBDbG9zZSB0aGUgc29ja2V0LlxuICAjXG4gICMgQHBhcmFtIGNvZGUgW0ludGVnZXIsIG5pbF0gdGhlIGVycm9yIGNvZGVcbiAgIyBAcGFyYW0gcmVhc29uIFtTdHJpbmcsIG5pbF0gdGhlIHJlYXNvbiBmb3IgY2xvc2luZ1xuICBkZWYgY2xvc2UoY29kZSA9IG5pbCwgcmVhc29uID0gbmlsKVxuICAgIGAjQG5hdGl2ZS5jbG9zZSgje2NvZGUudG9fbn0sICN7cmVhc29uLnRvX259KWBcbiAgZW5kXG5lbmRcblxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8Y2xhc3M6U29ja2V0PiIsInN1cHBvcnRlZD8iLCJzZWxmIiwiQnJvd3NlciIsInN1cHBvcnRzPyIsImluY2x1ZGUiLCJOYXRpdmU6OldyYXBwZXIiLCJOYXRpdmUiLCJJTzo6V3JpdGFibGUiLCJJTyIsIkV2ZW50OjpUYXJnZXQiLCJFdmVudCIsInRhcmdldCIsImJsb2NrIGluIDxjbGFzczpTb2NrZXQ+IiwidmFsdWUiLCJpc19hPyIsImJsb2NrICgyIGxldmVscykgaW4gPGNsYXNzOlNvY2tldD4iLCJTb2NrZXQiLCJuZXciLCJpbml0aWFsaXplIiwidXJsIiwicHJvdG9jb2wiLCJuYXRpdmU/IiwidG9fcyIsInRvX24iLCJibG9jayIsImFyaXR5IiwiMCIsImluc3RhbmNlX2V4ZWMiLCJ0b19wcm9jIiwiY2FsbCIsImFsaWFzX25hdGl2ZSIsInR5cGUiLCJAbmF0aXZlIiwic3RhdGUiLCJleHRlbnNpb25zIiwic3BsaXQiLCJhbGl2ZT8iLCI9PSIsIndyaXRlIiwiZGF0YSIsImNsb3NlIiwiY29kZSIsInJlYXNvbiJdLCJtYXBwaW5ncyI6IkFBQUFBLGlDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFNQUEsT0FBQUM7SUFBQUE7O01BQUFBOztBQUFBQTs7TUFDRUMsTUFBSUMsSUFBSkQsaUJBQUFBLGtDQUFBQTtBQUFBQTtRQUNFQSxPQUFBRSxhQUFPQyxjQUFBQSxDQUFXLFdBQVhBO01BRFRILENBQUFBO01BSUFDLElBQUFHLFNBQUFBLENBQVFDLElBQUFDLFlBQUFELFlBQVJEO01BQ0EsSUFBQSxRQUF3QixDQUFBLDZCQUFBLDRDQUFBLG9CQUF4QixDQUFBO1FBQUFILElBQUFHLFNBQUFBLENBQVFHLElBQUFDLFFBQUFELGFBQVJIO01BQUE7TUFDQUgsSUFBQUcsU0FBQUEsQ0FBUUssSUFBQUMsV0FBQUQsV0FBUkw7TUFFQU8sTUFBQVYsSUFBQVUsVUFBQUEsRUFBQUEsRUFBQUEsRUFBQUMsbUJBQVNDLEtBQVREOztRQUFTO1FBQ1AsSUFBQSxRQUFxQk4sWUFBTVEsVUFBQUEsQ0FBT0QsS0FBYixFQUFxQkUsZ0JBQWZELENBQTNCLENBQUE7VUFBQUMsT0FBQUMsWUFBTUMsS0FBQUEsQ0FBS0osS0FBTEk7UUFBTjtVQWhCSkYsT0FBQTtRQWdCSSxFQURGSCxDQUFBRDs7QUFXQU8sTUFBQUEsMEJBQUFBLHNCQUFlQyxHQUFELEVBQU1DLFFBQXBCRjtBQUFBQSxRQUFBQTs7UUFBQUE7OztRQUFvQixpQ0FBVztRQUM3QixJQUFBLFFBQUdqQixJQUFBb0IsWUFBQUEsQ0FBUUYsR0FBUkUsQ0FBSCxDQUFBO1VBQ0UsT0FBQXBCLElBQUEsRUFBQSwwREFBQSxjQUFBLEVBQUEsQ0FBTWtCLEdBQU4sQ0FBQSxFQUFBLElBQUE7UUFERixPQUVBLElBQUEsUUFBTUMsUUFBTixDQUFBO1VBQ0UsT0FBQW5CLElBQUEsRUFBQSwwREFBQSxjQUFBLEVBQUEsQ0FBT2lCLHFCQUF1QkMsR0FBR0csTUFBQUEsQ0FBQUEsQ0FBTUosRUFBSUUsUUFBUUcsTUFBQUEsQ0FBQUEsQ0FBTUwsQ0FBekQsQ0FBQSxFQUFBLElBQUE7UUFERjtVQUdFLE9BQUFqQixJQUFBLEVBQUEsMERBQUEsY0FBQSxFQUFBLENBQU9pQixxQkFBdUJDLEdBQUdHLE1BQUFBLENBQUFBLENBQU1KLENBQXZDLENBQUEsRUFBQSxJQUFBO1FBSEY7UUFNQSxJQUFBLFFBSU9NLEtBSlAsQ0FBQTtVQUFBLElBQUEsTUFBR0EsS0FBS0MsT0FBQUEsQ0FBQUEsQ0FBUixFQUFrQkMsQ0FBbEIsQ0FBQTtZQUNFUixPQUFBUyxNQUFBMUIsSUFBQTBCLGlCQUFBQSxFQUFBQSxFQUFBQSxFQUFlSCxLQUFESSxTQUFBQSxDQUFBQSxDQUFkRDtVQURGO1lBR0VULE9BQUFNLEtBQUtLLE1BQUFBLENBQU01QixJQUFONEI7VUFIUDtRQUFBO1VBbkNKWCxPQUFBO1FBbUNJO01BVEZBLENBQUFBLElBQUFBO01Ba0JBakIsSUFBQTZCLGNBQUFBLENBQWEsVUFBYkE7TUFJQTdCLElBQUE2QixjQUFBQSxDQUFhLEtBQWJBO01BSUE3QixJQUFBNkIsY0FBQUEsQ0FBYSxVQUFiLEVBQXdCLGdCQUF4QkE7O0FBSUFDLE1BQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsUUFBQUE7OztBQUVGQSxjQUFlQyxjQUFPRDtBQUN0QkE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtNQVpFQSxDQUFBQTs7QUFpQkFFLE1BQUFBLHFCQUFBQSxpQkFBQUE7QUFBQUEsUUFBQUE7OztBQUVGQSxjQUFlRCxjQUFPQztBQUN0QkE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7TUFmRUEsQ0FBQUE7O0FBb0JBQyxNQUFBQSwwQkFBQUEsc0JBQUFBO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFBQSxDQUFFRixjQUFPRSxXQUFUQSxDQUFxQkMsT0FBQUEsQ0FBTyxTQUFQQTtNQUR2QkQsQ0FBQUE7O0FBS0FFLE1BQUFBLHNCQUFBQSw4QkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUFuQyxJQUFBZ0MsT0FBQUEsQ0FBQUEsQ0FBTUksT0FBQUEsQ0FBRyxNQUFIQTtNQURSRCxDQUFBQTs7QUFPQUUsTUFBQUEscUJBQUFBLGlCQUFVQyxJQUFWRDtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBRU4sY0FBT00sTUFBUUMsSUFBSWhCLE1BQUFBLENBQUFBLENBQU1lO01BRDdCQSxDQUFBQTtNQUlBLGFBQU0sSUFBTixFQUFTLE9BQVQ7TUFFQSxhQUFNLE1BQU4sRUFBVyxPQUFYO01BTUF2QyxPQUFBeUMscUJBQUFBLGlCQUFVQyxJQUFELEVBQWFDLE1BQXRCRjtBQUFBQSxRQUFBQTs7O1FBQVUseUJBQU87UUFBSyw2QkFBUztRQUM3QkEsT0FBRVIsY0FBT1EsT0FBU0MsSUFBSWxCLE1BQUFBLENBQUFBLENBQU1pQixFQUFJRSxNQUFNbkIsTUFBQUEsQ0FBQUEsQ0FBTWlCO01BRDlDQSxDQUFBQSxJQUFBQTtJQS9HRnpDLEdBQUFBLFdBQUFBLEVBQWVTLFFBQWZUO0VBTkFELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozOTI5NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvbG9jYXRpb24ucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXJcblxuIyBBbGxvd3MgbWFuaXB1bGF0aW9uIG9mIGEgbG9jYXRpb24sIHVzdWFsbHkgZnJvbSB7V2luZG93fSBhbmQge0RPTTo6RG9jdW1lbnR9LlxuI1xuIyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Mb2NhdGlvblxuY2xhc3MgTG9jYXRpb25cbiAgaW5jbHVkZSBCcm93c2VyOjpOYXRpdmVDYWNoZWRXcmFwcGVyXG5cbiAgIyBDaGFuZ2UgdGhlIGxvY2F0aW9uLlxuICAjXG4gICMgQHBhcmFtIHVybCBbU3RyaW5nLCAjdG9fc10gdGhlIFVSTCB0byBnbyB0b1xuICBkZWYgYXNzaWduKHVybClcbiAgICBgI0BuYXRpdmUuYXNzaWduKCN7dXJsLnRvX3N9KWBcbiAgZW5kXG5cbiAgIyBSZXBsYWNlIHRoZSBjdXJyZW50IFVSTC5cbiAgI1xuICAjIEBwYXJhbSB1cmwgW1N0cmluZywgI3RvX3NdIHRoZSBVUkwgdG8gZ28gdG9cbiAgZGVmIHJlcGxhY2UodXJsKVxuICAgIGAjQG5hdGl2ZS5yZXBsYWNlKCN7dXJsLnRvX3N9KWBcbiAgZW5kXG5cbiAgIyBSZWxvYWQgdGhlIHBhZ2UuXG4gICNcbiAgIyBAcGFyYW0gZm9yY2UgW0Jvb2xlYW5dIHdoZXRoZXIgdG8gZm9yY2UgdGhlIHJlbG9hZFxuICBkZWYgcmVsb2FkKGZvcmNlID0gZmFsc2UpXG4gICAgYCNAbmF0aXZlLnJlbG9hZChmb3JjZSlgXG4gIGVuZFxuXG4gICMgQ29udmVydCB0aGUgbG9jYXRpb24gdG8gYSBzdHJpbmcuXG4gIGRlZiB0b19zXG4gICAgYCNAbmF0aXZlLnRvU3RyaW5nKClgXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgZnJhZ21lbnRcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBoYXNoIGZyYWdtZW50IG9mIHRoZSBsb2NhdGlvbiBVUklcbiAgYWxpYXNfbmF0aXZlIDpmcmFnbWVudCwgOmhhc2hcbiAgYWxpYXNfbmF0aXZlIDpmcmFnbWVudD0sIDpoYXNoPVxuXG4gICMgQCFhdHRyaWJ1dGUgaG9zdFxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIGhvc3QgcGFydCBvZiB0aGUgbG9jYXRpb24gVVJJXG4gIGFsaWFzX25hdGl2ZSA6aG9zdFxuICBhbGlhc19uYXRpdmUgOmhvc3Q9XG5cbiAgIyBAIWF0dHJpYnV0ZSB1cmlcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSB3aG9sZSBsb2NhdGlvbiBVUklcbiAgYWxpYXNfbmF0aXZlIDp1cmksIDpocmVmXG4gIGFsaWFzX25hdGl2ZSA6dXJpPSwgOmhyZWY9XG5cbiAgIyBAIWF0dHJpYnV0ZSBwYXRoXG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgcGF0aCBwYXJ0IG9mIHRoZSBsb2NhdGlvbiBVUklcbiAgYWxpYXNfbmF0aXZlIDpwYXRoLCA6cGF0aG5hbWVcbiAgYWxpYXNfbmF0aXZlIDpwYXRoPSwgOnBhdGhuYW1lPVxuXG4gICMgQCFhdHRyaWJ1dGUgcG9ydFxuICAjIEByZXR1cm4gW0ludGVnZXJdIHRoZSBwb3J0IHBhcnQgb2YgdGhlIGxvY2F0aW9uIFVSSVxuICBhbGlhc19uYXRpdmUgOnBvcnRcbiAgYWxpYXNfbmF0aXZlIDpwb3J0PVxuXG4gICMgQCFhdHRyaWJ1dGUgc2NoZW1lXG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgc2NoZW1lIHBhcnQgb2YgdGhlIGxvY2F0aW9uIFVSSVxuICBhbGlhc19uYXRpdmUgOnNjaGVtZSwgOnByb3RvY29sXG4gIGFsaWFzX25hdGl2ZSA6c2NoZW1lPSwgOnByb3RvY29sPVxuXG4gICMgQCFhdHRyaWJ1dGUgcXVlcnlcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBxdWVyeSBwYXJ0IG9mIHRoZSBsb2NhdGlvbiBVUklcbiAgYWxpYXNfbmF0aXZlIDpxdWVyeSwgOnNlYXJjaFxuICBhbGlhc19uYXRpdmUgOnF1ZXJ5PSwgOnNlYXJjaD1cblxuICAjIFJldHVybnMgdGhlIGZ1bGwgcGF0aCBvZiB0aGUgbG9jYXRpb24gVVJJLCBpbmNsdWRpbmdcbiAgIyB0aGUgcXVlcnkgc3RyaW5nIGFuZCBmcmFnbWVudCwgZWcuIC9zaXRlP2E9YiNjXG4gIGRlZiBmdWxsX3BhdGhcbiAgICBwYXRoICsgcXVlcnkgKyBmcmFnbWVudFxuICBlbmRcbmVuZFxuXG5jbGFzcyBXaW5kb3dcbiAgIyBAIWF0dHJpYnV0ZSBbcl0gbG9jYXRpb25cbiAgIyBAcmV0dXJuIFtMb2NhdGlvbl0gdGhlIGxvY2F0aW9uIGZvciB0aGUgd2luZG93XG4gIGRlZiBsb2NhdGlvblxuICAgIExvY2F0aW9uLm5ldyhgI0BuYXRpdmUubG9jYXRpb25gKSBpZiBgI0BuYXRpdmUubG9jYXRpb25gXG4gIGVuZFxuZW5kXG5cbmNsYXNzIERPTTo6RG9jdW1lbnQgPCBET006OkVsZW1lbnRcbiAgIyBAIWF0dHJpYnV0ZSBbcl0gbG9jYXRpb25cbiAgIyBAcmV0dXJuIFtMb2NhdGlvbl0gdGhlIGxvY2F0aW9uIGZvciB0aGUgZG9jdW1lbnRcbiAgZGVmIGxvY2F0aW9uXG4gICAgTG9jYXRpb24ubmV3KGAjQG5hdGl2ZS5sb2NhdGlvbmApIGlmIGAjQG5hdGl2ZS5sb2NhdGlvbmBcbiAgZW5kXG5lbmRcblxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8Y2xhc3M6TG9jYXRpb24+Iiwic2VsZiIsImluY2x1ZGUiLCJCcm93c2VyOjpOYXRpdmVDYWNoZWRXcmFwcGVyIiwiQnJvd3NlciIsImFzc2lnbiIsInVybCIsIkBuYXRpdmUiLCJ0b19zIiwicmVwbGFjZSIsInJlbG9hZCIsImZvcmNlIiwiYWxpYXNfbmF0aXZlIiwiZnVsbF9wYXRoIiwiKyIsInBhdGgiLCJxdWVyeSIsImZyYWdtZW50IiwiPGNsYXNzOldpbmRvdz4iLCJsb2NhdGlvbiIsIkxvY2F0aW9uIiwibmV3IiwiPGNsYXNzOkRPTTo6RG9jdW1lbnQ+IiwiRE9NIiwiRE9NOjpFbGVtZW50Il0sIm1hcHBpbmdzIjoiQUFBQUEsbUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7SUFLQUM7SUFBQUE7O01BQUFBOztBQUFBQTs7TUFDRUMsSUFBQUMsU0FBQUEsQ0FBUUMsSUFBQUMsYUFBQUQsd0JBQVJEOztBQUtBRyxNQUFBQSxzQkFBQUEsa0JBQVdDLEdBQVhEO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFFRSxjQUFPRixRQUFVQyxHQUFHRSxNQUFBQSxDQUFBQSxDQUFNSDtNQUQ5QkEsQ0FBQUE7O0FBT0FJLE1BQUFBLHVCQUFBQSxtQkFBWUgsR0FBWkc7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUVGLGNBQU9FLFNBQVdILEdBQUdFLE1BQUFBLENBQUFBLENBQU1DO01BRC9CQSxDQUFBQTs7QUFPQUMsTUFBQUEsc0JBQUFBLGtCQUFXQyxLQUFYRDtBQUFBQSxRQUFBQTs7O1FBQVcsMkJBQVE7UUFDakJBLE9BQUVILGNBQU9HO01BRFhBLENBQUFBLElBQUFBOztBQUtBRixNQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFFRCxjQUFPQztNQURYQSxDQUFBQTtNQU1BUCxJQUFBVyxjQUFBQSxDQUFhLFVBQWIsRUFBd0IsTUFBeEJBO01BQ0FYLElBQUFXLGNBQUFBLENBQWEsV0FBYixFQUF5QixPQUF6QkE7TUFJQVgsSUFBQVcsY0FBQUEsQ0FBYSxNQUFiQTtNQUNBWCxJQUFBVyxjQUFBQSxDQUFhLE9BQWJBO01BSUFYLElBQUFXLGNBQUFBLENBQWEsS0FBYixFQUFtQixNQUFuQkE7TUFDQVgsSUFBQVcsY0FBQUEsQ0FBYSxNQUFiLEVBQW9CLE9BQXBCQTtNQUlBWCxJQUFBVyxjQUFBQSxDQUFhLE1BQWIsRUFBb0IsVUFBcEJBO01BQ0FYLElBQUFXLGNBQUFBLENBQWEsT0FBYixFQUFxQixXQUFyQkE7TUFJQVgsSUFBQVcsY0FBQUEsQ0FBYSxNQUFiQTtNQUNBWCxJQUFBVyxjQUFBQSxDQUFhLE9BQWJBO01BSUFYLElBQUFXLGNBQUFBLENBQWEsUUFBYixFQUFzQixVQUF0QkE7TUFDQVgsSUFBQVcsY0FBQUEsQ0FBYSxTQUFiLEVBQXVCLFdBQXZCQTtNQUlBWCxJQUFBVyxjQUFBQSxDQUFhLE9BQWIsRUFBcUIsUUFBckJBO01BQ0FYLElBQUFXLGNBQUFBLENBQWEsUUFBYixFQUFzQixTQUF0QkE7TUFJQVosT0FBQWEseUJBQUFBLHFCQUFBQTtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBYUMsU0FBUkEsU0FBTGIsSUFBQWMsTUFBQUEsQ0FBQUEsQ0FBS0QsRUFBRWIsSUFBQWUsT0FBQUEsQ0FBQUEsQ0FBRkYsQ0FBUUEsRUFBRWIsSUFBQWdCLFVBQUFBLENBQUFBLENBQUZIO01BRGZELENBQUFBO0lBbEVGYixHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtJQXVFQWtCO0lBQUFBOztNQUFBQTs7QUFBQUE7TUFHRUEsT0FBQUMsd0JBQUFBLG9CQUFBQTtBQUFBQSxRQUFBQTs7UUFDRSxJQUFBLFFBQXVDWixjQUFPWSxTQUE5QyxDQUFBO1VBQUFBLE9BQUFDLGNBQVFDLEtBQUFBLENBQU9kLGNBQU9ZLFNBQWRFO1FBQVI7VUFoRkpGLE9BQUE7UUFnRkk7TUFERkEsQ0FBQUE7SUFIRkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7SUFRQW5CLE9BQUF1QjtJQUFBQTs7TUFBQUE7O0FBQUFBO01BR0VBLE9BQUFILHdCQUFBQSxvQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0UsSUFBQSxRQUF1Q1osY0FBT1ksU0FBOUMsQ0FBQTtVQUFBQSxPQUFBQyxjQUFRQyxLQUFBQSxDQUFPZCxjQUFPWSxTQUFkRTtRQUFSO1VBeEZKRixPQUFBO1FBd0ZJO01BREZBLENBQUFBO0lBSEZHLEdBQU1DLFNBQU5ELEVBQXNCRSxJQUFBRCxTQUFBQyxZQUF0QkY7RUFwRkF2QixHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MzkzOTUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2hpc3RvcnkucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnYnJvd3Nlci9sb2NhdGlvbidcblxubW9kdWxlIEJyb3dzZXJcblxuIyB7SGlzdG9yeX0gYWxsb3dzIG1hbmlwdWxhdGlvbiBvZiB0aGUgc2Vzc2lvbiBoaXN0b3J5LlxuI1xuIyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IaXN0b3J5XG5jbGFzcyBIaXN0b3J5XG4gICMgQ2hlY2sgaWYgSFRNTDUgaGlzdG9yeSBpcyBzdXBwb3J0ZWQuXG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPyAnSGlzdG9yeSdcbiAgZW5kXG5cbiAgaW5jbHVkZSBCcm93c2VyOjpOYXRpdmVDYWNoZWRXcmFwcGVyXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gbGVuZ3RoXG4gICMgQHJldHVybiBbSW50ZWdlcl0gaG93IG1hbnkgaXRlbXMgYXJlIGluIHRoZSBoaXN0b3J5XG4gIGFsaWFzX25hdGl2ZSA6bGVuZ3RoXG5cbiAgIyBHbyBiYWNrIGluIHRoZSBoaXN0b3J5LlxuICAjXG4gICMgQHBhcmFtIG51bWJlciBbSW50ZWdlcl0gaG93IG1hbnkgaXRlbXMgdG8gZ28gYmFja1xuICBkZWYgYmFjayhudW1iZXIgPSAxKVxuICAgIGAjQG5hdGl2ZS5nbygtbnVtYmVyKWBcbiAgZW5kXG5cbiAgIyBHbyBmb3J3YXJkIGluIHRoZSBoaXN0b3J5LlxuICAjXG4gICMgQHBhcmFtIG51bWJlciBbSW50ZWdlcl0gaG93IG1hbnkgaXRlbXMgdG8gZ28gZm9yd2FyZFxuICBkZWYgZm9yd2FyZChudW1iZXIgPSAxKVxuICAgIGAjQG5hdGl2ZS5nbyhudW1iZXIpYFxuICBlbmRcblxuICAjIFB1c2ggYW4gaXRlbSBpbiB0aGUgaGlzdG9yeS5cbiAgI1xuICAjIEBwYXJhbSBpdGVtIFtTdHJpbmddIHRoZSBpdGVtIHRvIHB1c2ggaW4gdGhlIGhpc3RvcnlcbiAgIyBAcGFyYW0gZGF0YSBbT2JqZWN0XSBhZGRpdGlvbmFsIHN0YXRlIHRvIHB1c2hcbiAgZGVmIHB1c2goaXRlbSwgZGF0YSA9IG5pbClcbiAgICBgI0BuYXRpdmUucHVzaFN0YXRlKCN7ZGF0YS50b19ufSwgbnVsbCwgaXRlbSlgXG4gIGVuZFxuXG4gICMgUmVwbGFjZSB0aGUgY3VycmVudCBoaXN0b3J5IGl0ZW0gd2l0aCBhbm90aGVyLlxuICAjXG4gICMgQHBhcmFtIGl0ZW0gW1N0cmluZ10gdGhlIGl0ZW0gdG8gcmVwbGFjZSB3aXRoXG4gICMgQHBhcmFtIGRhdGEgW09iamVjdF0gYWRkaXRpb25hbCBzdGF0ZSB0byByZXBsYWNlXG4gIGRlZiByZXBsYWNlKGl0ZW0sIGRhdGEgPSBuaWwpXG4gICAgYCNAbmF0aXZlLnJlcGxhY2VTdGF0ZSgje2RhdGEudG9fbn0sIG51bGwsIGl0ZW0pYFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBjdXJyZW50XG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgY3VycmVudCBpdGVtXG4gIGRlZiBjdXJyZW50XG4gICAgJHdpbmRvdy5sb2NhdGlvbi5mdWxsX3BhdGhcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gc3RhdGVcbiAgIyBAcmV0dXJuIFtPYmplY3RdIHRoZSBjdXJyZW50IHN0YXRlXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdIaXN0b3J5LnN0YXRlJ1xuICAgIGRlZiBzdGF0ZVxuICAgICAgJXh7XG4gICAgICAgIHZhciBzdGF0ZSA9ICNAbmF0aXZlLnN0YXRlO1xuXG4gICAgICAgIGlmIChzdGF0ZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcbiAgZWxzZVxuICAgIGRlZiBzdGF0ZVxuICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgJ2hpc3Rvcnkgc3RhdGUgdW5zdXBwb3J0ZWQnXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFdpbmRvd1xuICAjIEAhYXR0cmlidXRlIFtyXSBoaXN0b3J5XG4gICMgQHJldHVybiBbSGlzdG9yeV0gdGhlIGhpc3RvcnkgZm9yIHRoaXMgd2luZG93XG4gIGRlZiBoaXN0b3J5XG4gICAgSGlzdG9yeS5uZXcoYCNAbmF0aXZlLmhpc3RvcnlgKSBpZiBgI0BuYXRpdmUuaGlzdG9yeWBcbiAgZW5kXG5lbmRcblxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpIaXN0b3J5PiIsInN1cHBvcnRlZD8iLCJCcm93c2VyIiwic3VwcG9ydHM/IiwiaW5jbHVkZSIsIkJyb3dzZXI6Ok5hdGl2ZUNhY2hlZFdyYXBwZXIiLCJhbGlhc19uYXRpdmUiLCJiYWNrIiwibnVtYmVyIiwiMSIsIkBuYXRpdmUiLCJmb3J3YXJkIiwicHVzaCIsIml0ZW0iLCJkYXRhIiwidG9fbiIsInJlcGxhY2UiLCJjdXJyZW50IiwiJHdpbmRvdyIsImxvY2F0aW9uIiwiZnVsbF9wYXRoIiwic3RhdGUiLCJyYWlzZSIsIk5vdEltcGxlbWVudGVkRXJyb3IiLCI8Y2xhc3M6V2luZG93PiIsImhpc3RvcnkiLCJIaXN0b3J5IiwibmV3Il0sIm1hcHBpbmdzIjoiQUFBQUEsa0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLGtCQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7OztJQUtBQztJQUFBQTs7TUFBQUE7O0FBQUFBOztNQUVFQyxNQUFJSixJQUFKSSxpQkFBQUEsbUNBQUFBO0FBQUFBO1FBQ0VBLE9BQUFDLGFBQU9DLGNBQUFBLENBQVdGLFNBQVhFO01BRFRGLENBQUFBO01BSUFKLElBQUFPLFNBQUFBLENBQVFDLElBQUFILGFBQUFHLHdCQUFSRDtNQUlBUCxJQUFBUyxjQUFBQSxDQUFhLFFBQWJBOztBQUtBQyxNQUFBQSxvQkFBQUEsZ0JBQVNDLE1BQVREO0FBQUFBLFFBQUFBOzs7UUFBUyw2QkFBU0U7UUFDaEJGLE9BQUVHLGNBQU9IO01BRFhBLENBQUFBLElBQUFBOztBQU9BSSxNQUFBQSx1QkFBQUEsbUJBQVlILE1BQVpHO0FBQUFBLFFBQUFBOzs7UUFBWSw2QkFBU0Y7UUFDbkJFLE9BQUVELGNBQU9DO01BRFhBLENBQUFBLElBQUFBOztBQVFBQyxNQUFBQSxvQkFBQUEsZ0JBQVNDLElBQUQsRUFBT0MsSUFBZkY7QUFBQUEsUUFBQUE7OztRQUFlLHlCQUFPO1FBQ3BCQSxPQUFFRixjQUFPRSxXQUFhRSxJQUFJQyxNQUFBQSxDQUFBQSxDQUFNSDtNQURsQ0EsQ0FBQUEsSUFBQUE7O0FBUUFJLE1BQUFBLHVCQUFBQSxtQkFBWUgsSUFBRCxFQUFPQyxJQUFsQkU7QUFBQUEsUUFBQUE7OztRQUFrQix5QkFBTztRQUN2QkEsT0FBRU4sY0FBT00sY0FBZ0JGLElBQUlDLE1BQUFBLENBQUFBLENBQU1DO01BRHJDQSxDQUFBQSxJQUFBQTs7QUFNQUMsTUFBQUEsdUJBQUFBLG1CQUFBQTtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBQUMsYUFBT0MsVUFBQUEsQ0FBQUEsQ0FBU0MsV0FBQUEsQ0FBQUE7TUFEbEJILENBQUFBO01BTUEsSUFBQSxRQUFHZixhQUFPQyxjQUFBQSxDQUFXSCxlQUFYRyxDQUFWLENBQUE7UUFDRUgsT0FBQXFCLHFCQUFBQSxpQkFBQUE7QUFBQUEsVUFBQUE7OztBQUVKQSxvQkFBcUJYLGNBQU9XOztBQUU1QkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7UUFWSUEsQ0FBQUE7TUFERjtRQWNFckIsT0FBQXFCLHFCQUFBQSxpQkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUF4QixJQUFBeUIsT0FBQUEsQ0FBTUMseUJBQU4sRUFBMkJGLDJCQUEzQkM7UUFERkQsQ0FBQUE7TUFkRjtJQWxERnJCLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0lBc0VBRCxPQUFBeUI7SUFBQUE7O01BQUFBOztBQUFBQTtNQUdFQSxPQUFBQyx1QkFBQUEsbUJBQUFBO0FBQUFBLFFBQUFBOztRQUNFLElBQUEsUUFBcUNmLGNBQU9lLFFBQTVDLENBQUE7VUFBQUEsT0FBQUMsYUFBT0MsS0FBQUEsQ0FBT2pCLGNBQU9lLFFBQWRFO1FBQVA7VUFqRkpGLE9BQUE7UUFpRkk7TUFERkEsQ0FBQUE7SUFIRkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUEzRUF6QixHQUFBQSxXQUFBQTtBQUZBSDsifX0seyJvZmZzZXQiOnsibGluZSI6Mzk1MDAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL25hdmlnYXRvci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlclxuXG4jIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBuYXZpZ2F0b3IgYXBwbGljYXRpb24uXG4jXG4jIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05hdmlnYXRvclxuY2xhc3MgTmF2aWdhdG9yXG4gIGluY2x1ZGUgQnJvd3Nlcjo6TmF0aXZlQ2FjaGVkV3JhcHBlclxuXG4gIFZlcnNpb24gPSBTdHJ1Y3QubmV3KDptYWpvciwgOm1pbm9yLCA6YnVpbGQpXG4gIFByb2R1Y3QgPSBTdHJ1Y3QubmV3KDpuYW1lLCA6dmVyc2lvbilcbiAgVmVuZG9yICA9IFN0cnVjdC5uZXcoOm5hbWUsIDp2ZXJzaW9uKVxuXG4gICMgUmVwcmVzZW50YXRpb24gb2YgYSBNSU1FIHR5cGUuXG4gIGNsYXNzIE1pbWVUeXBlXG4gICAgaW5jbHVkZSBCcm93c2VyOjpOYXRpdmVDYWNoZWRXcmFwcGVyXG5cbiAgICAjIEAhYXR0cmlidXRlIFtyXSBwbHVnaW5cbiAgICAjIEByZXR1cm4gW1BsdWdpbl0gdGhlIHBsdWdpbiBmb3IgdGhlIE1JTUUgdHlwZVxuICAgIGRlZiBwbHVnaW5cbiAgICAgIFBsdWdpbi5uZXcoYCNAbmF0aXZlLmVuYWJsZWRQbHVnaW5gKVxuICAgIGVuZFxuXG4gICAgIyBAIWF0dHJpYnV0ZSBbcl0gZGVzY3JpcHRpb25cbiAgICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIGRlc2NyaXB0aW9uIGZvciB0aGUgTUlNRSB0eXBlXG4gICAgYWxpYXNfbmF0aXZlIDpkZXNjcmlwdGlvblxuXG4gICAgIyBAIWF0dHJpYnV0ZSBbcl0gZXh0ZW5zaW9uc1xuICAgICMgQHJldHVybiBbQXJyYXk8U3RyaW5nPl0gdGhlIGV4dGVuc2lvbnMgZm9yIHRoaXMgTUlNRSB0eXBlXG4gICAgZGVmIGV4dGVuc2lvbnNcbiAgICAgIGAjQG5hdGl2ZS5zdWZmaXhlc2Auc3BsaXQoL1xccyovKVxuICAgIGVuZFxuXG4gICAgIyBAIWF0dHJpYnV0ZSBbcl0gdHlwZVxuICAgICMgQHJldHVybiBbU3RyaW5nXSB0aGUgTUlNRSB0eXBlXG4gICAgYWxpYXNfbmF0aXZlIDp0eXBlXG4gIGVuZFxuXG4gICMgUmVwcmVzZW50YXRpb24gb2YgYSBuYXZpZ2F0b3IgcGx1Z2luLlxuICAjXG4gICMgQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUGx1Z2luXG4gIGNsYXNzIFBsdWdpbiA8IE5hdGl2ZTo6QXJyYXlcbiAgICBkZWYgaW5pdGlhbGl6ZShwbHVnaW4pXG4gICAgICBzdXBlciBwbHVnaW4gZG8gfG18XG4gICAgICAgIE1pbWVUeXBlLm5ldyhtKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAjIEAhYXR0cmlidXRlIFtyXSBkZXNjcmlwdGlvblxuICAgICMgQHJldHVybiBbU3RyaW5nXSB0aGUgcGx1Z2luIGRlc2NyaXB0aW9uXG4gICAgYWxpYXNfbmF0aXZlIDpkZXNjcmlwdGlvblxuXG4gICAgIyBAIWF0dHJpYnV0ZSBbcl0gZmlsZVxuICAgICMgQHJldHVybiBbU3RyaW5nXSB0aGUgZmlsZSBhc3NvY2lhdGVkIHdpdGggdGhlIHBsdWdpblxuICAgIGFsaWFzX25hdGl2ZSA6ZmlsZSwgOmZpbGVuYW1lXG5cbiAgICAjIEAhYXR0cmlidXRlIFtyXSBuYW1lXG4gICAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBwbHVnaW4gbmFtZVxuICAgIGFsaWFzX25hdGl2ZSA6bmFtZVxuXG4gICAgIyBAIWF0dHJpYnV0ZSBbcl0gdmVyc2lvblxuICAgICMgQHJldHVybiBbU3RyaW5nXSB0aGUgcGx1Z2luIHZlcnNpb25cbiAgICBhbGlhc19uYXRpdmUgOnZlcnNpb25cbiAgZW5kXG5cbiAgIyBSZXByZXNlbnRhdGlvbiBmb3IgdGhlIGFycmF5IG9mIHBsdWdpbnMuXG4gICNcbiAgIyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9OYXZpZ2F0b3JQbHVnaW5zXG4gIGNsYXNzIFBsdWdpbnMgPCBOYXRpdmU6OkFycmF5XG4gICAgZGVmIGluaXRpYWxpemUocGx1Z2lucylcbiAgICAgIHN1cGVyIHBsdWdpbnMgZG8gfHB8XG4gICAgICAgIFBsdWdpbi5uZXcocClcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgIyBSZWxvYWQgYWxsIGJyb3dzZXIgcGx1Z2lucy5cbiAgICBkZWYgcmVmcmVzaFxuICAgICAgYCNAbmF0aXZlLnJlZnJlc2goZmFsc2UpYFxuICAgIGVuZFxuXG4gICAgIyBSZWxvYWQgYWxsIGJyb3dzZXIgcGx1Z2lucyByZWxvYWRpbmcgcGFnZXMgdGhhdCBjb250YWluIGA8ZW1iZWQ+YHMuXG4gICAgZGVmIHJlZnJlc2ghXG4gICAgICBgI0BuYXRpdmUucmVmcmVzaCh0cnVlKWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gY29kZVxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIGJyb3dzZXIgY29kZSBuYW1lXG4gIGFsaWFzX25hdGl2ZSA6Y29kZSwgOmFwcENvZGVOYW1lXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gbmFtZVxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIGJyb3dzZXIgbmFtZVxuICBhbGlhc19uYXRpdmUgOm5hbWUsIDphcHBOYW1lXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gdmVyc2lvblxuICAjIEByZXR1cm4gW1ZlcnNpb25dIHRoZSBicm93c2VyIHZlcnNpb25cbiAgZGVmIHZlcnNpb25cbiAgICBWZXJzaW9uLm5ldyhgI0BuYXRpdmUuYXBwVmVyc2lvbmAsIGAjQG5hdGl2ZS5hcHBNaW5vclZlcnNpb25gLCBgI0BuYXRpdmUuYnVpbGRJRGApXG4gIGVuZFxuXG4gICMgQ2hlY2sgaWYgY29va2llcyBhcmUgZW5hYmxlZC5cbiAgYWxpYXNfbmF0aXZlIDpjb29raWVzPywgOmNvb2tpZUVuYWJsZWRcblxuICAjIENoZWNrIGlmIEROVCBpcyBkaXNhYmxlZC5cbiAgZGVmIHRyYWNrP1xuICAgIGAhI0BuYXRpdmUuZG9Ob3RUcmFja2BcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gbGFuZ3VhZ2VcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBicm93c2VyIGxhbmd1YWdlXG4gIGFsaWFzX25hdGl2ZSA6bGFuZ3VhZ2VcblxuICAjIEAhYXR0cmlidXRlIFtyXSBtaW1lX3R5cGVzXG4gICMgQHJldHVybiBbTmF0aXZlOjpBcnJheTxNaW1lVHlwZT5dIHRoZSBzdXBwb3J0ZWQgTUlNRSB0eXBlc1xuICBkZWYgbWltZV90eXBlc1xuICAgIE5hdGl2ZTo6QXJyYXkubmV3IGAjQG5hdGl2ZS5taW1lVHlwZXNgLCBnZXQ6IDppdGVtLCBuYW1lZDogOm5hbWVkSXRlbSBkbyB8bXxcbiAgICAgIE1pbWVUeXBlLm5ldyhtKVxuICAgIGVuZFxuICBlbmRcblxuICAjIENoZWNrIGlmIHRoZSBicm93c2VyIGlzIGluIG9mZmxpbmUgbW9kZS5cbiAgZGVmIG9mZmxpbmU/XG4gICAgYCEjQG5hdGl2ZS5vbkxpbmVgXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIG9wZXJhdGluZ19zeXN0ZW1cbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBvcGVyYXRpbmcgc3lzdGVtIHRoZSBicm93c2VyIGlzIHJ1bm5pbmcgb25cbiAgYWxpYXNfbmF0aXZlIDpvcGVyYXRpbmdfc3lzdGVtLCA6b3NjcHVcblxuICBhbGlhcyBvcyBvcGVyYXRpbmdfc3lzdGVtXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gcGxhdGZvcm1cbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBwbGF0Zm9ybSB0aGUgYnJvd3NlciBpcyBydW5uaW5nIG9uXG4gIGFsaWFzX25hdGl2ZSA6cGxhdGZvcm1cblxuICAjIEAhYXR0cmlidXRlIFtyXSBwbHVnaW5zXG4gICMgQHJldHVybiBbUGx1Z2luc10gdGhlIGVuYWJsZWQgcGx1Z2luc1xuICBkZWYgcGx1Z2luc1xuICAgIFBsdWdpbnMubmV3KGAjQG5hdGl2ZS5wbHVnaW5zYClcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gcHJvZHVjdFxuICAjIEByZXR1cm4gW1Byb2R1Y3RdIHRoZSBwcm9kdWN0IG5hbWUgYW5kIHZlcnNpb25cbiAgZGVmIHByb2R1Y3RcbiAgICBQcm9kdWN0Lm5ldyhgI0BuYXRpdmUucHJvZHVjdGAsIGAjQG5hdGl2ZS5wcm9kdWN0U3ViYClcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gdXNlcl9hZ2VudFxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIGJyb3dzZXIncyB1c2VyIGFnZW50XG4gIGFsaWFzX25hdGl2ZSA6dXNlcl9hZ2VudCwgOnVzZXJBZ2VudFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIHZlbmRvclxuICAjIEByZXR1cm4gW1ZlbmRvcl0gdGhlIHZlbmRvciBuYW1lIGFuZCB2ZXJzaW9uXG4gIGRlZiB2ZW5kb3JcbiAgICBWZW5kb3IubmV3KGAjQG5hdGl2ZS52ZW5kb3JgLCBgI0BuYXRpdmUudmVuZG9yU3ViYClcbiAgZW5kXG5cbiAgIyBDaGVjayBpZiBKYXZhIGlzIGVuYWJsZWQuXG4gIGRlZiBqYXZhP1xuICAgIGAjQG5hdGl2ZS5qYXZhRW5hYmxlZCgpYFxuICByZXNjdWVcbiAgICBmYWxzZVxuICBlbmRcblxuICAjIFJlcHJlc2VudGF0aW9uIG9mIHVzZXIgbG9jYXRpb24gYmFzZWQgb24gR2VvbG9jYXRpb24gQVBJXG4gICNcbiAgIyBFeGFtcGxlIHVzYWdlOlxuICAjIGBgYFxuICAjICR3aW5kb3cubmF2aWdhdG9yLmdlb2xvY2F0ZS50aGVuIGRvIHxwb3N8XG4gICMgICBwdXRzIFwiI3twb3MuY29vcmRzLmxhdGl0dWRlfSwgI3twb3MuY29vcmRzLmxvbmdpdHVkZX0sICN7cG9zLmNvb3Jkcy5hY2N1cmFjeX1cIlxuICAjIGVuZFxuICAjIGBgYFxuICAjXG4gICMgQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUG9zaXRpb25cbiAgY2xhc3MgUG9zaXRpb25cbiAgICBpbmNsdWRlIEJyb3dzZXI6Ok5hdGl2ZUNhY2hlZFdyYXBwZXJcblxuICAgIGNsYXNzIENvb3Jkc1xuICAgICAgaW5jbHVkZSBOYXRpdmU6OldyYXBwZXJcblxuICAgICAgIyBAIWF0dHJpYnV0ZSBbcl0gbGF0aXR1ZGVcbiAgICAgIGFsaWFzX25hdGl2ZSA6bGF0aXR1ZGVcbiAgICAgICMgQCFhdHRyaWJ1dGUgW3JdIGxvbmdpdHVkZVxuICAgICAgYWxpYXNfbmF0aXZlIDpsb25naXR1ZGVcbiAgICAgICMgQCFhdHRyaWJ1dGUgW3JdIGFsdGl0dWRlXG4gICAgICBhbGlhc19uYXRpdmUgOmFsdGl0dWRlXG4gICAgICAjIEAhYXR0cmlidXRlIFtyXSBhY2N1cmFjeVxuICAgICAgYWxpYXNfbmF0aXZlIDphY2N1cmFjeVxuICAgICAgIyBAIWF0dHJpYnV0ZSBbcl0gYWx0aXR1ZGVfYWNjdXJhY3lcbiAgICAgIGFsaWFzX25hdGl2ZSA6YWx0aXR1ZGVfYWNjdXJhY3ksIDphbHRpdHVkZUFjY3VyYWN5XG4gICAgICAjIEAhYXR0cmlidXRlIFtyXSBoZWFkaW5nXG4gICAgICBhbGlhc19uYXRpdmUgOmhlYWRpbmdcbiAgICAgICMgQCFhdHRyaWJ1dGUgW3JdIHNwZWVkXG4gICAgICBhbGlhc19uYXRpdmUgOnNwZWVkXG4gICAgZW5kXG5cbiAgICAjIEAhYXR0cmlidXRlIFtyXSB0aW1lc3RhbXBcbiAgICBhbGlhc19uYXRpdmUgOnRpbWVzdGFtcFxuXG4gICAgZGVmIGNvb3Jkc1xuICAgICAgQGNvb3JkcyB8fD0gQ29vcmRzLm5ldyhgI0BuYXRpdmUuY29vcmRzYClcbiAgICBlbmRcbiAgZW5kXG5cbiAgIyBHZW9sb2NhdGVzIHRoZSB1c2VyIG9uY2VcbiAgI1xuICAjIEByZXR1cm4gW1Byb21pc2VdIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUge1Bvc2l0aW9ufSBvYmplY3RcbiAgZGVmIGdlb2xvY2F0ZShtYXhfYWdlOiAwLCB0aW1lb3V0OiBGbG9hdDo6SU5GSU5JVFksIGhpZ2hfYWNjdXJhY3k6IGZhbHNlKVxuICAgIHByb21pc2UgPSBQcm9taXNlLm5ld1xuICAgIHN1Y2MgPSBwcm9jIHsgfGl8IHByb21pc2UucmVzb2x2ZShQb3NpdGlvbi5uZXcoaSkpIH1cbiAgICBmYWlsID0gcHJvYyB7IHxpfCBwcm9taXNlLnJlamVjdChOYXRpdmUoaSkpIH1cbiAgICBvcHRzID0ge21heEFnZTogbWF4X2FnZSwgdGltZW91dDogdGltZW91dCwgZW5hYmxlSGlnaEFjY3VyYWN5OiBoaWdoX2FjY3VyYWN5fVxuICAgIGAjQG5hdGl2ZS5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24oI3tzdWNjLnRvX259LCAje2ZhaWwudG9fbn0sICN7b3B0cy50b19ufSlgXG4gICAgcHJvbWlzZVxuICBlbmRcblxuICAjIEdlb2xvY2F0ZXMgdGhlIHVzZXIgbXVsdGlwbGUgdGltZXMgYW5kIGNhbGxzIGEgYmxvY2sgd2l0aCBoaXMgbG9jYXRpb25cbiAgIyB1bnRpbCAjc3RvcF90cmFja2luZyBpcyBjYWxsZWQgd2l0aCBhIHJldHVybmVkIGlkLiBDYWxscyBhIHByb2MgbmFtZWQgZXJyb3JcbiAgIyBpZiBlcnJvciBoYXBwZW5zLlxuICAjXG4gICMgQHJldHVybiBbSW50ZWdlcl0gYW4gSUQgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBhcmd1bWVudCB0byAjc3RvcF90cmFja2luZ1xuICBkZWYgdHJhY2sobWF4X2FnZTogMCwgdGltZW91dDogRmxvYXQ6OklORklOSVRZLCBoaWdoX2FjY3VyYWN5OiBmYWxzZSwgZXJyb3I6IHByb2N7fGl8fSwgJmJsb2NrKVxuICAgIG9wdHMgPSB7bWF4QWdlOiBtYXhfYWdlLCB0aW1lb3V0OiB0aW1lb3V0LCBlbmFibGVIaWdoQWNjdXJhY3k6IGhpZ2hfYWNjdXJhY3l9XG4gICAgc3VjYyA9IHByb2MgeyB8aXwgYmxvY2suY2FsbChQb3NpdGlvbi5uZXcoaSkpIH1cbiAgICBmYWlsID0gcHJvYyB7IHxpfCBlcnJvci5jYWxsKE5hdGl2ZShpKSkgfVxuICAgIGAjQG5hdGl2ZS5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKCN7c3VjYy50b19ufSwgI3tmYWlsLnRvX259LCAje29wdHMudG9fbn0pYFxuICBlbmRcblxuICBkZWYgc3RvcF90cmFja2luZyhpZClcbiAgICBgI0BuYXRpdmUuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCgje2lkfSlgXG4gIGVuZFxuXG4gICMgVHJpZ2dlcnMgYSB2aWJyYXRpb24gb24gYSBkZXZpY2UuIEEgcGF0dGVybiBjYW4gYmUgZWl0aGVyIGEgbnVtYmVyIG9mXG4gICMgbWlsaXNlY29uZHMgZm9yIGEgdmlicmF0aW9uIGxlbmd0aCwgb3IgYW4gYXJyYXkgb2YgbGVuZ3RocyAoaW5cbiAgIyBtaWxpc2Vjb25kcykgd2hpY2ggZGVzY3JpYmVzIGEgdmlicmF0aW9uIHBhdHRlcm4gLSBmaXJzdCBlbGVtZW50IG9mIHNhaWRcbiAgIyBhcnJheSBkZXNjcmliZXMgaG93IGxvbmcgdGhlIGRldmljZSBzaG91bGQgdmlicmF0ZSwgc2Vjb25kIC0gaG93IGxvbmcgdG9cbiAgIyBzdG9wIGZvciBhbmQgc28gb24uXG4gIGRlZiB2aWJyYXRlKHBhdHRlcm4pXG4gICAgYCNAbmF0aXZlLnZpYnJhdGUoI3twYXR0ZXJuLnRvX259KWBcbiAgZW5kXG5cbiAgIyBDaGVjayBhIGJhdHRlcnkgc3RhdHVzIG9mIHVzZXIgZGV2aWNlLiBUaGlzIEFQSSBpcyBkZXByZWNhdGVkIGluIHRoZSBicm93c2VyXG4gICMgY29udGV4dCBhbmQgdXNhYmxlIG1haW5seSBpbiBwcml2aWxlZ2VkIGNvbnRleHRzLlxuICAjXG4gICMgQHJldHVybiBbUHJvbWlzZV0gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBhIGJhdHRlcnkgc3RhdHVzXG4gICNcbiAgIyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9OYXZpZ2F0b3IvZ2V0QmF0dGVyeVxuICBkZWYgZ2V0X2JhdHRlcnlcbiAgICBwcm9taXNlID0gUHJvbWlzZS5uZXdcbiAgICB5ZXMgPSBwcm9jIHsgfHJ8IHByb21pc2UucmVzb2x2ZShOYXRpdmUocikpIH1cbiAgICBubyA9IHByb2MgeyB8cnwgcHJvbWlzZS5yZWplY3QoTmF0aXZlKHIpKSB9XG4gICAgYCNAbmF0aXZlLmdldEJhdHRlcnkoKS50aGVuKCN7eWVzLnRvX259KS5jYXRjaCgje25vLnRvX259KWBcbiAgICBwcm9taXNlXG4gIGVuZFxuXG4gICMgUXVldWUgdG8gc2VuZCBhIHNtYWxsIGFtb3VudCBvZiBkYXRhIHRvIGEgc2VydmVyLlxuICAjXG4gICMgQHBhcmFtIHVybCBbU3RyaW5nXSB1cmwgdG8gdHJpZ2dlclxuICAjIEBwYXJhbSBwYXlsb2FkIFtTdHJpbmcsIEJsb2IsIEZvcm1EYXRhLCBIYXNoXSBkYXRhIHRvIHNlbmRcbiAgI1xuICAjIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05hdmlnYXRvci9zZW5kQmVhY29uXG4gIGRlZiBzZW5kX2JlYWNvbih1cmwsIHBheWxvYWQ9bmlsKVxuICAgIGAjQG5hdGl2ZS5zZW5kQmVhY29uKCN7dXJsfSwgI3twYXlsb2FkLnRvX259KWBcbiAgZW5kXG5lbmRcblxuY2xhc3MgV2luZG93XG4gICMgQCFhdHRyaWJ1dGUgW3JdIG5hdmlnYXRvclxuICAjIEByZXR1cm4gW05hdmlnYXRvcl0gdGhlIG5hdmlnYXRvclxuICBkZWYgbmF2aWdhdG9yXG4gICAgQG5hdmlnYXRvciB8fD0gTmF2aWdhdG9yLm5ldyhgI0BuYXRpdmUubmF2aWdhdG9yYCkgaWYgYCNAbmF0aXZlLm5hdmlnYXRvcmBcbiAgZW5kXG5lbmRcblxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8Y2xhc3M6TmF2aWdhdG9yPiIsInNlbGYiLCJpbmNsdWRlIiwiQnJvd3Nlcjo6TmF0aXZlQ2FjaGVkV3JhcHBlciIsIkJyb3dzZXIiLCJTdHJ1Y3QiLCJuZXciLCI8Y2xhc3M6TWltZVR5cGU+IiwicGx1Z2luIiwiUGx1Z2luIiwiQG5hdGl2ZSIsImFsaWFzX25hdGl2ZSIsImV4dGVuc2lvbnMiLCJzcGxpdCIsIjxjbGFzczpQbHVnaW4+IiwiaW5pdGlhbGl6ZSIsImJsb2NrIGluIGluaXRpYWxpemUiLCJtIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbml0aWFsaXplIiwiTWltZVR5cGUiLCJOYXRpdmU6OkFycmF5IiwiTmF0aXZlIiwiPGNsYXNzOlBsdWdpbnM+IiwicGx1Z2lucyIsInAiLCJyZWZyZXNoIiwicmVmcmVzaCEiLCJ2ZXJzaW9uIiwiVmVyc2lvbiIsInRyYWNrPyIsIm1pbWVfdHlwZXMiLCJibG9jayBpbiBtaW1lX3R5cGVzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBtaW1lX3R5cGVzIiwib2ZmbGluZT8iLCJQbHVnaW5zIiwicHJvZHVjdCIsIlByb2R1Y3QiLCJ2ZW5kb3IiLCJWZW5kb3IiLCJqYXZhPyIsIlN0YW5kYXJkRXJyb3IiLCI8Y2xhc3M6UG9zaXRpb24+IiwiPGNsYXNzOkNvb3Jkcz4iLCJOYXRpdmU6OldyYXBwZXIiLCJjb29yZHMiLCJAY29vcmRzIiwiJHJldF9vcl8xIiwiQ29vcmRzIiwiZ2VvbG9jYXRlIiwiJGt3YXJncyIsIjAiLCJGbG9hdDo6SU5GSU5JVFkiLCJGbG9hdCIsInByb21pc2UiLCJQcm9taXNlIiwic3VjYyIsInByb2MiLCJibG9jayBpbiBnZW9sb2NhdGUiLCJpIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBnZW9sb2NhdGUiLCJyZXNvbHZlIiwiUG9zaXRpb24iLCJmYWlsIiwicmVqZWN0Iiwib3B0cyIsIm1heF9hZ2UiLCJ0aW1lb3V0IiwiaGlnaF9hY2N1cmFjeSIsInRvX24iLCJ0cmFjayIsImJsb2NrIGluIHRyYWNrIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0cmFjayIsImJsb2NrIiwiY2FsbCIsImVycm9yIiwic3RvcF90cmFja2luZyIsImlkIiwidmlicmF0ZSIsInBhdHRlcm4iLCJnZXRfYmF0dGVyeSIsInllcyIsImJsb2NrIGluIGdldF9iYXR0ZXJ5IiwiciIsImJsb2NrICgyIGxldmVscykgaW4gZ2V0X2JhdHRlcnkiLCJubyIsInNlbmRfYmVhY29uIiwidXJsIiwicGF5bG9hZCIsIjxjbGFzczpXaW5kb3c+IiwibmF2aWdhdG9yIiwiQG5hdmlnYXRvciIsIk5hdmlnYXRvciJdLCJtYXBwaW5ncyI6IkFBQUFBLG9DQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7O0lBS0FDO0lBQUFBOztNQUFBQTs7QUFBQUE7O01BQ0VDLElBQUFDLFNBQUFBLENBQVFDLElBQUFDLGFBQUFELHdCQUFSRDtNQUVBLG1DQUFVRyxZQUFNQyxLQUFBQSxDQUFLLE9BQVgsRUFBbUIsT0FBbkIsRUFBMkIsT0FBckJBLENBQWhCO01BQ0EsbUNBQVVELFlBQU1DLEtBQUFBLENBQUssTUFBWCxFQUFrQixTQUFaQSxDQUFoQjtNQUNBLGtDQUFVRCxZQUFNQyxLQUFBQSxDQUFLLE1BQVgsRUFBa0IsU0FBWkEsQ0FBaEI7TUFHQUM7TUFBQUE7O1FBQUFBOztBQUFBQTs7UUFDRU4sSUFBQUMsU0FBQUEsQ0FBUUMsSUFBQUMsYUFBQUQsd0JBQVJEOztBQUlBTSxRQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBQyxZQUFNSCxLQUFBQSxDQUFPSSxjQUFPRixjQUFkRjtRQURSRSxDQUFBQTtRQU1BUCxJQUFBVSxjQUFBQSxDQUFhLGFBQWJBOztBQUlBQyxRQUFBQSwwQkFBQUEsc0JBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBQSxDQUFFRixjQUFPRSxTQUFUQSxDQUFtQkMsT0FBQUEsQ0FBTyxLQUFQQTtRQURyQkQsQ0FBQUE7UUFNQUwsT0FBQU4sSUFBQVUsY0FBQUEsQ0FBYSxNQUFiQTtNQXJCRkosR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7TUEyQkFPO01BQUFBOztRQUFBQTs7OztBQUNFQyxRQUFBQSwwQkFBQUEsc0JBQWVQLE1BQWZPO0FBQUFBLFVBQUFBOztVQUFBQTtVQUNFQSxPQUFBLE9BQUFkLElBQUEsRUFBQSwwREFBQSxjQUFBLEVBQUEsQ0FBTU8sTUFBTixDQUFBLEVBQUFRLGFBQWlCQyxDQUFqQkQ7O1lBQWlCO1lBQ2ZFLE9BQUFDLGNBQVFiLEtBQUFBLENBQUtXLENBQUxYLEVBRFZVLENBQUE7UUFERkQsQ0FBQUE7UUFRQWQsSUFBQVUsY0FBQUEsQ0FBYSxhQUFiQTtRQUlBVixJQUFBVSxjQUFBQSxDQUFhLE1BQWIsRUFBb0IsVUFBcEJBO1FBSUFWLElBQUFVLGNBQUFBLENBQWEsTUFBYkE7UUFJQUcsT0FBQWIsSUFBQVUsY0FBQUEsQ0FBYSxTQUFiQTtNQXJCRkcsR0FBQUEsV0FBQUEsRUFBZU0sSUFBQUMsWUFBQUQsVUFBZk47TUEyQkFRO01BQUFBOztRQUFBQTs7QUFBQUE7OztBQUNFUCxRQUFBQSwwQkFBQUEsc0JBQWVRLE9BQWZSO0FBQUFBLFVBQUFBOztVQUFBQTtVQUNFQSxPQUFBLE9BQUFkLElBQUEsRUFBQSwwREFBQSxjQUFBLEVBQUEsQ0FBTXNCLE9BQU4sQ0FBQSxFQUFBUCxhQUFrQlEsQ0FBbEJSOztZQUFrQjtZQUNoQkUsT0FBQVQsWUFBTUgsS0FBQUEsQ0FBS2tCLENBQUxsQixFQURSVSxDQUFBO1FBREZELENBQUFBOztBQU9BVSxRQUFBQSx1QkFBQUEsbUJBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFFZixjQUFPZTtRQURYQSxDQUFBQTtRQUtBSCxPQUFBSSx3QkFBQUEsaUNBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFFaEIsY0FBT2dCO1FBRFhBLENBQUFBO01BYkZKLEdBQUFBLFdBQUFBLEVBQWdCRixJQUFBQyxZQUFBRCxVQUFoQkU7TUFvQkFyQixJQUFBVSxjQUFBQSxDQUFhLE1BQWIsRUFBb0IsYUFBcEJBO01BSUFWLElBQUFVLGNBQUFBLENBQWEsTUFBYixFQUFvQixTQUFwQkE7O0FBSUFnQixNQUFBQSx1QkFBQUEsbUJBQUFBO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFBQyxhQUFPdEIsS0FBQUEsQ0FBT0ksY0FBT2lCLFdBQXJCLEVBQXFDakIsY0FBT2lCLGdCQUE1QyxFQUFpRWpCLGNBQU9pQixRQUFqRXJCO01BRFRxQixDQUFBQTtNQUtBMUIsSUFBQVUsY0FBQUEsQ0FBYSxVQUFiLEVBQXdCLGVBQXhCQTs7QUFHQWtCLE1BQUFBLHNCQUFBQSxpQ0FBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUNBLENBQUVuQixjQUFPbUI7TUFEWkEsQ0FBQUE7TUFNQTVCLElBQUFVLGNBQUFBLENBQWEsVUFBYkE7O0FBSUFtQixNQUFBQSwwQkFBQUEsc0JBQUFBO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFheEIsTUFBYmMsSUFBQUMsWUFBQUQsVUFBYWQsT0FBQUEsRUFBQUEsQ0FBT0ksY0FBT29CLFVBQTNCLEVBQXdDLFVBQUEsTUFBQSxFQUFLLE1BQUwsQ0FBQSxFQUFBLFFBQUEsRUFBbUIsV0FBbkIsQ0FBQSxHQUEzQnhCLENBQUFBLEVBQWJ5QixhQUEwRWQsQ0FBMUVjOztVQUEwRTtVQUN4RUMsT0FBQWIsY0FBUWIsS0FBQUEsQ0FBS1csQ0FBTFgsRUFEVnlCLENBQWF6QjtNQURmd0IsQ0FBQUE7O0FBT0FHLE1BQUFBLHdCQUFBQSxtQ0FBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUNBLENBQUV2QixjQUFPdUI7TUFEWkEsQ0FBQUE7TUFNQWhDLElBQUFVLGNBQUFBLENBQWEsa0JBQWIsRUFBZ0MsT0FBaENBO01BRUEsYUFBTSxJQUFOLEVBQVMsa0JBQVQ7TUFJQVYsSUFBQVUsY0FBQUEsQ0FBYSxVQUFiQTs7QUFJQVksTUFBQUEsdUJBQUFBLG1CQUFBQTtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBQVcsYUFBTzVCLEtBQUFBLENBQU9JLGNBQU9hLFFBQWRqQjtNQURUaUIsQ0FBQUE7O0FBTUFZLE1BQUFBLHVCQUFBQSxtQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUFDLGFBQU85QixLQUFBQSxDQUFPSSxjQUFPeUIsUUFBckIsRUFBa0N6QixjQUFPeUIsV0FBbEM3QjtNQURUNkIsQ0FBQUE7TUFNQWxDLElBQUFVLGNBQUFBLENBQWEsWUFBYixFQUEwQixXQUExQkE7O0FBSUEwQixNQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFBQyxZQUFNaEMsS0FBQUEsQ0FBT0ksY0FBTzJCLE9BQXBCLEVBQWdDM0IsY0FBTzJCLFVBQWpDL0I7TUFEUitCLENBQUFBOztBQUtBRSxNQUFBQSxxQkFBQUEsZ0NBQUFBO0FBQUFBLFFBQUFBOztRQUNFO1VBQUFBLE9BQUU3QixjQUFPNkI7UUFBVDtVQUNGLHNCQUFBLENBQUFDLG1CQUFBLENBQUE7WUFBQTtjQUNFRCxPQUFBO1lBREY7VUFBQSxDQURFO1FBQUE7TUFERkEsQ0FBQUE7TUFnQkFFO01BQUFBOztRQUFBQTs7QUFBQUE7O1FBQ0V4QyxJQUFBQyxTQUFBQSxDQUFRQyxJQUFBQyxhQUFBRCx3QkFBUkQ7UUFFQXdDO1FBQUFBOztVQUFBQTs7O1VBQ0V6QyxJQUFBQyxTQUFBQSxDQUFReUMsSUFBQXRCLFlBQUFzQixZQUFSekM7VUFHQUQsSUFBQVUsY0FBQUEsQ0FBYSxVQUFiQTtVQUVBVixJQUFBVSxjQUFBQSxDQUFhLFdBQWJBO1VBRUFWLElBQUFVLGNBQUFBLENBQWEsVUFBYkE7VUFFQVYsSUFBQVUsY0FBQUEsQ0FBYSxVQUFiQTtVQUVBVixJQUFBVSxjQUFBQSxDQUFhLG1CQUFiLEVBQWlDLGtCQUFqQ0E7VUFFQVYsSUFBQVUsY0FBQUEsQ0FBYSxTQUFiQTtVQUVBK0IsT0FBQXpDLElBQUFVLGNBQUFBLENBQWEsT0FBYkE7UUFoQkYrQixHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtRQW9CQXpDLElBQUFVLGNBQUFBLENBQWEsV0FBYkE7UUFFQThCLE9BQUFHLHNCQUFBQSxrQkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUFDLENBQUFBLGNBdk1OLENBQUEsUUFBQUMsQ0FBQUEsWUF1TU1ELFdBdk1OQyxDQUFBLENBQUEsR0FBQSxDQUFBLFNBQUEsSUFBQSxDQXVNa0JDLFlBQU16QyxLQUFBQSxDQUFPSSxjQUFPa0MsT0FBZHRDLENBdk14QixDQUFBLENBdU1NdUM7UUFERkQsQ0FBQUE7TUF6QkZILEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBOztBQWlDQU8sTUFBQUEseUJBQUFBLHFCQTlNRkMsT0E4TUVEO0FBQUFBLFFBQUFBOzs7UUE5TUY7O1FBOE1nQix3Q0FBQSwrQkFBU0U7O1FBQUcsd0NBQUEsK0JBQVNDLElBQUFDLFdBQUFEOztRQUFpQixvREFBQSwyQ0FBZTtRQUNqRUUsVUFBVUMsYUFBT2hELEtBQUFBLENBQUFBO1FBQ2pCaUQsT0FBT0MsTUFBQXZELElBQUF1RCxRQUFBQSxFQUFBQSxFQUFBQSxFQUFBQyxhQUFRQyxDQUFSRDs7VUFBUTtVQUFHRSxPQUFBTixPQUFPTyxTQUFBQSxDQUFTQyxjQUFRdkQsS0FBQUEsQ0FBS29ELENBQUxwRCxDQUFqQnNELEVBQWxCSCxDQUFBRDtRQUNQTSxPQUFPTixNQUFBdkQsSUFBQXVELFFBQUFBLEVBQUFBLEVBQUFBLEVBQUFDLGFBQVFDLENBQVJELEVBQUFFOzs7VUFBUTtVQUFHQSxPQUFBTixPQUFPVSxRQUFBQSxDQUFROUQsSUFBQW9CLFFBQUFBLENBQU9xQyxDQUFQckMsQ0FBUjBDLEVBQWxCTixDQUFBQSxHQUFBQSxTQUFBQSxDQUFBRDtRQUNQUSxPQUFPLFVBQUEsU0FBQSxFQUFTQyxPQUFULENBQUEsRUFBQSxVQUFBLEVBQTJCQyxPQUEzQixDQUFBLEVBQUEscUJBQUEsRUFBd0RDLGFBQXhELENBQUE7UUFDTHpELGNBQU9zQyxnQ0FBa0NPLElBQUlhLE1BQUFBLENBQUFBLENBQU1wQixFQUFJYyxJQUFJTSxNQUFBQSxDQUFBQSxDQUFNcEIsRUFBSWdCLElBQUlJLE1BQUFBLENBQUFBLENBQU1wQjtRQUNqRkEsT0FBQUs7TUFORkwsQ0FBQUEsSUFBQUE7O0FBY0FxQixNQUFBQSxxQkFBQUEsaUJBNU5GcEIsT0E0TkVvQjtBQUFBQSxRQUFBQTs7UUFBQUE7OztRQTVORjs7UUE0Tlksd0NBQUEsK0JBQVNuQjs7UUFBRyx3Q0FBQSwrQkFBU0MsSUFBQUMsV0FBQUQ7O1FBQWlCLG9EQUFBLDJDQUFlOztRQUFPLG9DQUFBLDJCQUFPSyxNQUFBdkQsSUFBQXVELFFBQUFBLEVBQUFBLEVBQUFBLEVBQUFjLGNBQU1aLENBQU5ZOztVQUFNO1VBNU5yRkMsT0FBQSxJQTROK0VELENBQUFkO1FBQzNFUSxPQUFPLFVBQUEsU0FBQSxFQUFTQyxPQUFULENBQUEsRUFBQSxVQUFBLEVBQTJCQyxPQUEzQixDQUFBLEVBQUEscUJBQUEsRUFBd0RDLGFBQXhELENBQUE7UUFDUFosT0FBT0MsTUFBQXZELElBQUF1RCxRQUFBQSxFQUFBQSxFQUFBQSxFQUFBYyxjQUFRWixDQUFSWTs7VUFBUTtVQUFHQyxPQUFBQyxLQUFLQyxNQUFBQSxDQUFNWixjQUFRdkQsS0FBQUEsQ0FBS29ELENBQUxwRCxDQUFkbUUsRUFBaEJILENBQUFkO1FBQ1BNLE9BQU9OLE1BQUF2RCxJQUFBdUQsUUFBQUEsRUFBQUEsRUFBQUEsRUFBQWMsY0FBUVosQ0FBUlksRUFBQUM7OztVQUFRO1VBQUdBLE9BQUFHLEtBQUtELE1BQUFBLENBQU14RSxJQUFBb0IsUUFBQUEsQ0FBT3FDLENBQVByQyxDQUFOb0QsRUFBaEJILENBQUFBLEdBQUFBLFNBQUFBLENBQUFkO1FBQ1BhLE9BQUUzRCxjQUFPMkQsMkJBQTZCZCxJQUFJYSxNQUFBQSxDQUFBQSxDQUFNQyxFQUFJUCxJQUFJTSxNQUFBQSxDQUFBQSxDQUFNQyxFQUFJTCxJQUFJSSxNQUFBQSxDQUFBQSxDQUFNQztNQUo5RUEsQ0FBQUEsSUFBQUE7O0FBT0FNLE1BQUFBLDZCQUFBQSx5QkFBa0JDLEVBQWxCRDtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBRWpFLGNBQU9pRSx3QkFBMEJDLEVBQUdEO01BRHhDQSxDQUFBQTs7QUFTQUUsTUFBQUEsdUJBQUFBLG1CQUFZQyxPQUFaRDtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBRW5FLGNBQU9tRSxTQUFXQyxPQUFPVixNQUFBQSxDQUFBQSxDQUFNUztNQURuQ0EsQ0FBQUE7O0FBVUFFLE1BQUFBLDJCQUFBQSx1QkFBQUE7QUFBQUEsUUFBQUE7OztRQUNFMUIsVUFBVUMsYUFBT2hELEtBQUFBLENBQUFBO1FBQ2pCMEUsTUFBTXhCLE1BQUF2RCxJQUFBdUQsUUFBQUEsRUFBQUEsRUFBQUEsRUFBQXlCLGNBQVFDLENBQVJELEVBQUFFOzs7VUFBUTtVQUFHQSxPQUFBOUIsT0FBT08sU0FBQUEsQ0FBUzNELElBQUFvQixRQUFBQSxDQUFPNkQsQ0FBUDdELENBQVR1QyxFQUFsQnFCLENBQUFBLEdBQUFBLFNBQUFBLENBQUF6QjtRQUNONEIsS0FBSzVCLE1BQUF2RCxJQUFBdUQsUUFBQUEsRUFBQUEsRUFBQUEsRUFBQXlCLGNBQVFDLENBQVJELEVBQUFFOzs7VUFBUTtVQUFHQSxPQUFBOUIsT0FBT1UsUUFBQUEsQ0FBUTlELElBQUFvQixRQUFBQSxDQUFPNkQsQ0FBUDdELENBQVIwQyxFQUFsQmtCLENBQUFBLEdBQUFBLFNBQUFBLENBQUF6QjtRQUNIOUMsY0FBT3FFLG1CQUFxQkMsR0FBR1osTUFBQUEsQ0FBQUEsQ0FBTVcsUUFBVUssRUFBRWhCLE1BQUFBLENBQUFBLENBQU1XO1FBQ3pEQSxPQUFBMUI7TUFMRjBCLENBQUFBO01BY0EvRSxPQUFBcUYsMkJBQUFBLHVCQUFnQkMsR0FBRCxFQUFNQyxPQUFyQkY7QUFBQUEsUUFBQUE7OztRQUFxQiwrQkFBUTtRQUMzQkEsT0FBRTNFLGNBQU8yRSxZQUFjQyxHQUFJRCxFQUFJRSxPQUFPbkIsTUFBQUEsQ0FBQUEsQ0FBTWlCO01BRDlDQSxDQUFBQSxJQUFBQTtJQS9QRnJGLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0lBb1FBRCxPQUFBeUY7SUFBQUE7O01BQUFBOztBQUFBQTtNQUdFQSxPQUFBQyx5QkFBQUEscUJBQUFBO0FBQUFBLFFBQUFBOztRQUNFLElBQUEsUUFBd0QvRSxjQUFPK0UsVUFBL0QsQ0FBQTtVQUFBQSxPQUFBQyxDQUFBQSxpQkE3UUosQ0FBQSxRQUFBNUMsQ0FBQUEsWUE2UUk0QyxjQTdRSjVDLENBQUEsQ0FBQSxHQUFBLENBQUEsU0FBQSxJQUFBLENBNlFtQjZDLGVBQVNyRixLQUFBQSxDQUFPSSxjQUFPK0UsVUFBZG5GLENBN1E1QixDQUFBLENBNlFJb0Y7UUFBQTtVQTdRSkQsT0FBQTtRQTZRSTtNQURGQSxDQUFBQTtJQUhGRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQXpRQXpGLEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozOTgwNiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvc2V0dXAvbGFyZ2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBicm93c2VyL3NldHVwL2xhcmdlIC0gYSBsYXJnZXIgc2V0IG9mIHJlcXVpcmVzIGZvciBtb3JlIGNvbXBsZXggYXBwbGljYXRpb25zXG4jXG4jIE5vdGUgLSBpdCBkb2Vzbid0IGluY2x1ZGUgUGFnZ2lvIChvciBQYWdnaW8gc3VwcG9ydCkgb3IgbWFueSBldmVudHNcblxucmVxdWlyZSAnYnJvd3Nlci9zZXR1cC9taW5pJ1xuXG5yZXF1aXJlICdicm93c2VyL2VmZmVjdHMnXG5yZXF1aXJlICdicm93c2VyL2h0dHAnXG5yZXF1aXJlICdicm93c2VyL2RlbGF5J1xucmVxdWlyZSAnYnJvd3Nlci9pbnRlcnZhbCdcbnJlcXVpcmUgJ2Jyb3dzZXIvaW1tZWRpYXRlJ1xucmVxdWlyZSAnYnJvd3Nlci9zdG9yYWdlJ1xucmVxdWlyZSAnYnJvd3Nlci9ibG9iJ1xucmVxdWlyZSAnYnJvd3Nlci9hbmltYXRpb25fZnJhbWUnXG5yZXF1aXJlICdicm93c2VyL3NvY2tldCdcbnJlcXVpcmUgJ2Jyb3dzZXIvaGlzdG9yeSdcbnJlcXVpcmUgJ2Jyb3dzZXIvbmF2aWdhdG9yJ1xuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSJdLCJtYXBwaW5ncyI6IkFBQUFBLHNDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUlBQyxJQUFBQyxTQUFBQSxDQUFRRixvQkFBUkU7RUFFQUQsSUFBQUMsU0FBQUEsQ0FBUUYsaUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLGNBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLGVBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLGtCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixtQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsaUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLGNBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLHlCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixnQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsaUJBQVJFO0VBQ0FGLE9BQUFDLElBQUFDLFNBQUFBLENBQVFGLG1CQUFSRTtBQWhCQUY7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM5ODI1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9ldmVudC9mb2N1cy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgY2xhc3MgRXZlbnRcblxuY2xhc3MgRm9jdXMgPCBVSVxuICBoYW5kbGVzICdibHVyJywgJ2ZvY3VzJywgJ2ZvY3VzaW4nLCAnZm9jdXNvdXQnXG5cbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5Gb2N1cydcbiAgZW5kXG5cbiAgY2xhc3MgRGVmaW5pdGlvbiA8IFVJOjpEZWZpbml0aW9uXG4gICAgZGVmIHZpZXc9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLnZpZXcgPSAje05hdGl2ZS5jb252ZXJ0KHZhbHVlKX1gXG4gICAgZW5kXG5cbiAgICBkZWYgcmVsYXRlZD0oZWxlbSlcbiAgICAgIGAjQG5hdGl2ZS5yZWxhdGVkVGFyZ2V0ID0gI3tOYXRpdmUuY29udmVydChlbGVtKX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgRm9jdXNFdmVudCgje25hbWV9LCAje2Rlc2N9KWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNyZWF0ZSdcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgICV4e1xuICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkZvY3VzRXZlbnRcIik7XG4gICAgICAgICAgICBldmVudC5pbml0Rm9jdXNFdmVudChuYW1lLCBkZXNjLmJ1YmJsZXMsIGRlc2MuY2FuY2VsYWJsZSxcbiAgICAgICAgICAgICAgZGVzYy52aWV3IHx8IHdpbmRvdywgMCwgZGVzYy5yZWxhdGVkVGFyZ2V0KTtcblxuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZCBpZiBzdXBwb3J0ZWQ/XG5cbiAgZGVmIHJlbGF0ZWRcbiAgICBET00oYCNAbmF0aXZlLnJlbGF0ZWRUYXJnZXRgKVxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkV2ZW50PiIsIjxjbGFzczpGb2N1cz4iLCJzZWxmIiwiaGFuZGxlcyIsInN1cHBvcnRlZD8iLCJCcm93c2VyIiwic3VwcG9ydHM/IiwiPGNsYXNzOkRlZmluaXRpb24+Iiwidmlldz0iLCJ2YWx1ZSIsIkBuYXRpdmUiLCJOYXRpdmUiLCJjb252ZXJ0IiwicmVsYXRlZD0iLCJlbGVtIiwiVUk6OkRlZmluaXRpb24iLCJVSSIsImNvbnN0cnVjdCIsIm5hbWUiLCJkZXNjIiwicmVsYXRlZCIsIkRPTSJdLCJtYXBwaW5ncyI6IkFBQUFBLHNDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7QUFBQUE7O1FBQ0VDLElBQUFDLFNBQUFBLENBQVFGLE1BQVIsRUFBZ0JBLE9BQWhCLEVBQXlCQSxTQUF6QixFQUFvQ0EsVUFBcENFO1FBRUFDLE1BQUlGLElBQUpFLGlCQUFBQSxpQ0FBQUE7QUFBQUE7VUFDRUEsT0FBQUMsYUFBT0MsY0FBQUEsQ0FBV0YsYUFBWEU7UUFEVEYsQ0FBQUE7UUFJQUc7UUFBQUE7O1VBQUFBOztBQUFBQTs7O0FBQ0VDLFVBQUFBLHFCQUFBQSwrQkFBVUMsS0FBVkQ7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVFLGNBQU9GLFFBQVVHLFlBQU1DLFNBQUFBLENBQVNILEtBQVRHO1VBRDNCSixDQUFBQTtVQUlBRCxPQUFBTSx3QkFBQUEsa0NBQWFDLElBQWJEO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFSCxjQUFPRyxpQkFBbUJGLFlBQU1DLFNBQUFBLENBQVNFLElBQVRGO1VBRHBDQyxDQUFBQTtRQUxGTixHQUFBQSxXQUFBQSxFQUFtQlEsSUFBQUMsUUFBQUQsZUFBbkJSO1FBVUEsSUFBQSxRQWNPTCxJQUFBRSxlQUFBQSxDQUFBQSxDQWRQLENBQUE7VUFBQSxJQUFBLFFBQUdDLGFBQU9DLGNBQUFBLENBQVdMLG1CQUFYSyxDQUFWLENBQUE7WUFDRVcsTUFBSWYsSUFBSmUsZ0JBQUFBLHFCQUFtQkMsSUFBRCxFQUFPQyxJQUF6QkY7QUFBQUE7Y0FDRUEsT0FBQ0EsZUFBaUJDLElBQUtELEVBQUlFLElBQUtGO1lBRGxDQSxDQUFBQTtVQURGLE9BSUEsSUFBQSxRQUFNWixhQUFPQyxjQUFBQSxDQUFXTCxjQUFYSyxDQUFiLENBQUE7WUFDRVcsTUFBSWYsSUFBSmUsZ0JBQUFBLHFCQUFtQkMsSUFBRCxFQUFPQyxJQUF6QkY7QUFBQUE7O0FBRUpBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtZQVBJQSxDQUFBQTtVQURGO1FBSkE7UUFnQkFoQixPQUFBbUIsdUJBQUFBLG1CQUFBQTtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBQWxCLElBQUFtQixLQUFBQSxDQUFNWCxjQUFPVSxjQUFiQztRQURGRCxDQUFBQTtNQWpDRm5CLEdBQUFBLFdBQUFBLEVBQWNlLFFBQWRmO0lBRmdCRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM5ODk5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9ldmVudC93aGVlbC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgY2xhc3MgRXZlbnRcblxuY2xhc3MgV2hlZWwgPCBVSVxuICBoYW5kbGVzICd3aGVlbCcsICdtb3VzZXdoZWVsJ1xuXG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBub3QgJCRbOldoZWVsRXZlbnRdLm5pbD9cbiAgZW5kXG5cbiAgY2xhc3MgRGVmaW5pdGlvbiA8IERlZmluaXRpb25cbiAgICBkZWYgeD0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuZGVsdGFYID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgeT0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuZGVsdGFZID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgej0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuZGVsdGFaID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgbW9kZT0odmFsdWUpXG4gICAgICB2YWx1ZSA9IGNhc2UgdmFsdWVcbiAgICAgICAgd2hlbiA6cGl4ZWwgdGhlbiBgV2hlZWxFdmVudC5ET01fREVMVEFfUElYRUxgXG4gICAgICAgIHdoZW4gOmxpbmUgIHRoZW4gYFdoZWVsRXZlbnQuRE9NX0RFTFRBX0xJTkVgXG4gICAgICAgIHdoZW4gOnBhZ2UgIHRoZW4gYFdoZWVsRXZlbnQuRE9NX0RFTFRBX1BBR0VgXG4gICAgICBlbmRcblxuICAgICAgYCNAbmF0aXZlLmRlbHRhTW9kZSA9ICN7dmFsdWV9YFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICBgbmV3IFdoZWVsRXZlbnQoI3tuYW1lfSwgI3tkZXNjfSlgXG4gIGVuZFxuXG4gIGFsaWFzX25hdGl2ZSA6eCwgOmRlbHRhWFxuICBhbGlhc19uYXRpdmUgOnksIDpkZWx0YVlcbiAgYWxpYXNfbmF0aXZlIDp6LCA6ZGVsdGFaXG5cbiAgZGVmIG1vZGVcbiAgICBjYXNlIGAjQG5hdGl2ZS5kZWx0YU1vZGVgXG4gICAgICB3aGVuIGBXaGVlbEV2ZW50LkRPTV9ERUxUQV9QSVhFTGAgdGhlbiA6cGl4ZWxcbiAgICAgIHdoZW4gYFdoZWVsRXZlbnQuRE9NX0RFTFRBX0xJTkVgICB0aGVuIDpsaW5lXG4gICAgICB3aGVuIGBXaGVlbEV2ZW50LkRPTV9ERUxUQV9QQUdFYCAgdGhlbiA6cGFnZVxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkV2ZW50PiIsIjxjbGFzczpXaGVlbD4iLCJzZWxmIiwiaGFuZGxlcyIsInN1cHBvcnRlZD8iLCIkJCIsIltdIiwibmlsPyIsIiEiLCI8Y2xhc3M6RGVmaW5pdGlvbj4iLCJ4PSIsInZhbHVlIiwiQG5hdGl2ZSIsInk9Iiwiej0iLCJtb2RlPSIsIiRyZXRfb3JfMSIsIkRlZmluaXRpb24iLCJjb25zdHJ1Y3QiLCJuYW1lIiwiZGVzYyIsImFsaWFzX25hdGl2ZSIsIm1vZGUiLCJVSSJdLCJtYXBwaW5ncyI6IkFBQUFBLHNDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7QUFBQUE7O1FBQ0VDLElBQUFDLFNBQUFBLENBQVFGLE9BQVIsRUFBaUJBLFlBQWpCRTtRQUVBQyxNQUFJRixJQUFKRSxpQkFBQUEsaUNBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFJQyxRQUFFQyxPQUFBQSxDQUFDLFlBQURBLENBQWFDLFNBQUFBLENBQUFBLENBQW5CQyxNQUFBQSxDQUFBQTtRQURGSixDQUFBQTtRQUlBSztRQUFBQTs7VUFBQUE7O0FBQUFBOzs7QUFDRUMsVUFBQUEsa0JBQUFBLDRCQUFPQyxLQUFQRDtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUUsY0FBT0YsVUFBWUM7VUFEdkJELENBQUFBOztBQUlBRyxVQUFBQSxrQkFBQUEsNEJBQU9GLEtBQVBFO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRCxjQUFPQyxVQUFZRjtVQUR2QkUsQ0FBQUE7O0FBSUFDLFVBQUFBLGtCQUFBQSw0QkFBT0gsS0FBUEc7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVGLGNBQU9FLFVBQVlIO1VBRHZCRyxDQUFBQTtVQUlBTCxPQUFBTSxxQkFBQUEsK0JBQVVKLEtBQVZJO0FBQUFBLFlBQUFBOzs7WUFDRUosUUFDRSxDQUFBLFFBQUssT0FBTCxFQURNSyxDQUFBQSxZQUFLTCxLQUFMSyxDQUNOLENBQUEsR0FBQSxDQUFrQkQsMEJBQWxCLElBQ0EsQ0FBQSxRQUFLLE1BQUwsRUF6QlIsU0F5QlEsQ0FBQSxHQUFBLENBQWtCQSx5QkFBbEIsSUFDQSxDQUFBLFFBQUssTUFBTCxFQTFCUixTQTBCUSxDQUFBLEdBQUEsQ0FBa0JBLHlCQUFsQixJQUFBLENBSE0sR0FHTixDQUFBLENBREEsQ0FEQTtZQUtGQSxPQUFFSCxjQUFPRyxhQUFlSjtVQVAxQkksQ0FBQUE7UUFiRk4sR0FBQUEsV0FBQUEsRUFBbUJRLGdCQUFuQlI7UUF3QkFTLE1BQUloQixJQUFKZ0IsZ0JBQUFBLHFCQUFtQkMsSUFBRCxFQUFPQyxJQUF6QkY7QUFBQUE7VUFDRUEsT0FBQ0EsZUFBaUJDLElBQUtELEVBQUlFLElBQUtGO1FBRGxDQSxDQUFBQTtRQUlBaEIsSUFBQW1CLGNBQUFBLENBQWEsR0FBYixFQUFpQixRQUFqQkE7UUFDQW5CLElBQUFtQixjQUFBQSxDQUFhLEdBQWIsRUFBaUIsUUFBakJBO1FBQ0FuQixJQUFBbUIsY0FBQUEsQ0FBYSxHQUFiLEVBQWlCLFFBQWpCQTtRQUVBcEIsT0FBQXFCLG9CQUFBQSxnQkFBQUE7QUFBQUEsVUFBQUE7O1VBRUksSUFBQSxRQUFNQSwwQkFBTixFQURGTixDQUFBQSxZQUFPSixjQUFPVSxVQUFkTixDQUNFLENBQUE7WUFBdUNNLE9BQUE7VUFBdkMsT0FDQSxJQUFBLFFBQU1BLHlCQUFOLEVBNUNOLFNBNENNLENBQUE7WUFBdUNBLE9BQUE7VUFBdkMsT0FDQSxJQUFBLFFBQU1BLHlCQUFOLEVBN0NOLFNBNkNNLENBQUE7WUFBdUNBLE9BQUE7VUFBdkM7WUFIRkEsT0FBQTtVQUdFO1FBSkpBLENBQUFBO01BdkNGckIsR0FBQUEsV0FBQUEsRUFBY3NCLFFBQWR0QjtJQUZnQkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozOTk4NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQvZGF0YV90cmFuc2Zlci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdicm93c2VyL2Jsb2InXG5cbm1vZHVsZSBCcm93c2VyOyBjbGFzcyBFdmVudFxuXG4jIHtEYXRhVHJhbnNmZXJ9IGlzIGFuIG9iamVjdCB3aGljaCBtYW5hZ2VzIGluY2x1ZGVkIGRhdGEgdG9cbiMgYW4gZXZlbnQgb2YgdHlwZSB7RXZlbnQ6OkRyYWd9IG9yIHtFdmVudDo6Q2xpcGJvYXJkfS5cbmNsYXNzIERhdGFUcmFuc2ZlclxuICBpbmNsdWRlIE5hdGl2ZUNhY2hlZFdyYXBwZXJcblxuICAjIEAhYXR0cmlidXRlIFtyd10gZWZmZWN0XG4gICMgQHJldHVybiBbU3ltYm9sXSBFZmZlY3Qgb2YgdGhpcyBkcm9wIG9wZXJhdGlvbi5cbiAgIyAgIE11c3QgYmUgb25lIG9mOiA6bm9uZSwgOmNvcHksIDpsaW5rIG9yIDptb3ZlLlxuICBkZWYgZWZmZWN0XG4gICAgYCNAbmF0aXZlLmRyb3BFZmZlY3RgXG4gIGVuZFxuXG4gIGRlZiBlZmZlY3Q9IChlZmZlY3QpXG4gICAgYCNAbmF0aXZlLmRyb3BFZmZlY3QgPSAje2VmZmVjdH1gXG4gIGVuZFxuXG4gICMgRXh0cmFjdCBzb21lIHRleHQgZGF0YSBmcm9tIHRoaXMge0RhdGFUcmFuc2Zlcn0gaW5zdGFuY2UuXG4gIGRlZiBbXSAodHlwZSlcbiAgICBgI0BuYXRpdmUuZ2V0RGF0YSgje3R5cGV9KWBcbiAgZW5kXG5cbiAgIyBFbWJlZCBzb21lIHRleHQgZGF0YSBpbiB0aGlzIHtEYXRhVHJhbnNmZXJ9IGluc3RhbmNlLlxuICBkZWYgW109ICh0eXBlLCB2YWx1ZSlcbiAgICBgI0BuYXRpdmUuc2V0RGF0YSgje3R5cGV9LCAje05hdGl2ZS5jb252ZXJ0KHZhbHVlKX0pYFxuICBlbmRcblxuICAjIENsZWFyIHNvbWUgKG9yIGFsbCwgaWYgdHlwZSBpcyBub3Qgc3BlY2lmaWVkKSB0ZXh0IGRhdGEgZnJvbVxuICAjIHRoaXMge0RhdGFUcmFuc2Zlcn0gaW5zdGFuY2UuXG4gIGRlZiBjbGVhciAodHlwZT1uaWwpXG4gICAgYCNAbmF0aXZlLmNsZWFyRGF0YSgje3R5cGUudG9fbn0pYFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFt3XSBkcmFnX2ltYWdlXG4gICMgU2V0cyBhIGRyYWcgaW1hZ2UgZm9yIHRoaXMge0RhdGFUcmFuc2Zlcn0uIFVzZSBzb21lXG4gICMge0RPTTo6RWxlbWVudDo6SW1hZ2V9IG9yIHtDYW52YXN9IGFzIGEgdmFsdWUuXG4gIGRlZiBkcmFnX2ltYWdlPSAoaW1hZ2UpXG4gICAgYCNAbmF0aXZlLnNldERyYWdJbWFnZSgje05hdGl2ZS5jb252ZXJ0KGltYWdlKX0pYFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBmaWxlc1xuICAjIEByZXR1cm4gW0FycmF5PEZpbGU+XSBsaXN0IG9mIGZpbGVzIGF0dGFjaGVkIHRvIHRoaXMge0RhdGFUcmFuc2Zlcn1cbiAgZGVmIGZpbGVzXG4gICAgTmF0aXZlOjpBcnJheS5uZXcoYCNAbmF0aXZlLmZpbGVzYCkubWFwIHsgfGZ8IEZpbGUubmV3KGYudG9fbikgfVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBpdGVtc1xuICAjIEByZXR1cm4gW0FycmF5PEl0ZW0+XSBsaXN0IG9mIGl0ZW1zIGF0dGFjaGVkIHRvIHRoaXMge0RhdGFUcmFuc2Zlcn1cbiAgZGVmIGl0ZW1zXG4gICAgTmF0aXZlOjpBcnJheS5uZXcoYCNAbmF0aXZlLml0ZW1zYCkubWFwIHsgfGl8IEl0ZW0ubmV3KGkudG9fbikgfVxuICBlbmRcblxuICAjIEFuIGluc3RhbmNlIG9mIGBEYXRhVHJhbnNmZXJJdGVtYFxuICBjbGFzcyBJdGVtXG4gICAgaW5jbHVkZSBOYXRpdmVDYWNoZWRXcmFwcGVyXG5cbiAgICAjIEAhYXR0cmlidXRlIFtyXSBraW5kXG4gICAgIyBAcmV0dXJuIFtTeW1ib2xdIGtpbmQgb2YgYW4gaXRlbTogOnN0cmluZyBvciA6ZmlsZVxuICAgIGRlZiBraW5kXG4gICAgICBgI0BuYXRpdmUua2luZGBcbiAgICBlbmRcblxuICAgIGRlZiBzdHJpbmc/OyBraW5kID09ICdzdHJpbmcnOyAgICAgICAgICAgZW5kXG4gICAgZGVmIGZpbGU/OyAgIGtpbmQgPT0gJ2ZpbGUnICYmIHRvX2ZpbGU7ICBlbmQgIyBTb21lIGZpbGVzIGNhbid0IGJlIHJlc29sdmVkLi4uXG5cbiAgICAjIEAhYXR0cmlidXRlIFtyXSB0eXBlXG4gICAgIyBAcmV0dXJuIFtTdHJpbmddIG1pbWUgdHlwZSBvZiBhbiBpdGVtXG4gICAgZGVmIHR5cGVcbiAgICAgIGAjQG5hdGl2ZS50eXBlYFxuICAgIGVuZFxuXG4gICAgIyBDb252ZXJ0IHRvIHN0cmluZyBhbmQgY2FsbCBiYWNrIG9uY2UgcmVhZHksIG9yIHJldHVybiBhXG4gICAgIyBwcm9taXNlIGlmIGEgYmxvY2sgaXNuJ3QgZ2l2ZW4uXG4gICAgZGVmIHRvX3N0cmluZygmYmxvY2spXG4gICAgICBwcm9taXNlID0gbmlsXG4gICAgICBpZiAhYmxvY2tcbiAgICAgICAgcHJvbWlzZSA9IFByb21pc2UubmV3XG4gICAgICAgIGJsb2NrID0gcHJvYyB7IHxpfCBwcm9taXNlLnJlc29sdmUoaSkgfVxuICAgICAgZW5kXG4gICAgICBgI0BuYXRpdmUuZ2V0QXNTdHJpbmcoI3tibG9jay50b19ufSlgXG4gICAgICByZXR1cm4gcHJvbWlzZVxuICAgIGVuZFxuXG4gICAgIyBDb252ZXJ0IHRvIGZpbGUgb3IgcmV0dXJuIG5pbCBpZiBpbXBvc3NpYmxlXG4gICAgZGVmIHRvX2ZpbGVcbiAgICAgIGFzX2ZpbGUgPSBgI0BuYXRpdmUuZ2V0QXNGaWxlKClgXG4gICAgICBGaWxlLm5ldyhhc19maWxlKSBpZiBhc19maWxlXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpFdmVudD4iLCI8Y2xhc3M6RGF0YVRyYW5zZmVyPiIsImluY2x1ZGUiLCJOYXRpdmVDYWNoZWRXcmFwcGVyIiwiZWZmZWN0IiwiQG5hdGl2ZSIsImVmZmVjdD0iLCJbXSIsInR5cGUiLCJbXT0iLCJ2YWx1ZSIsIk5hdGl2ZSIsImNvbnZlcnQiLCJjbGVhciIsInRvX24iLCJkcmFnX2ltYWdlPSIsImltYWdlIiwiZmlsZXMiLCJtYXAiLCJOYXRpdmU6OkFycmF5IiwibmV3IiwiYmxvY2sgaW4gZmlsZXMiLCJmIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBmaWxlcyIsIkZpbGUiLCJpdGVtcyIsImJsb2NrIGluIGl0ZW1zIiwiaSIsImJsb2NrICgyIGxldmVscykgaW4gaXRlbXMiLCJJdGVtIiwiPGNsYXNzOkl0ZW0+Iiwia2luZCIsInN0cmluZz8iLCI9PSIsImZpbGU/IiwiJHJldF9vcl8xIiwidG9fZmlsZSIsInRvX3N0cmluZyIsInByb21pc2UiLCJibG9jayIsIlByb21pc2UiLCJwcm9jIiwiYmxvY2sgaW4gdG9fc3RyaW5n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QSxvQkFBQUEsZ0JBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFSCxjQUFPRztVQURYQSxDQUFBQTs7QUFNQTZCLFVBQUFBLHlCQUFBQSxxQkFBQUE7QUFBQUEsWUFBQUE7O1lBQUFBOzs7WUFDRUMsVUFBVTtZQUNWLElBQUEsS0FBSUMsS0FBSixDQUFBOztjQUNFRCxVQUFVRSxhQUFPcEIsS0FBQUEsQ0FBQUE7Y0FDakJtQixRQUFRRSxNQUFBNUMsSUFBQTRDLFFBQUFBLEVBQUFBLEVBQUFBLEVBQUFDLGFBQVFmLENBQVJlOztnQkFBUTtnQkFBR0MsT0FBQUwsT0FBT00sU0FBQUEsQ0FBU2pCLENBQVRpQixFQUFsQkYsQ0FBQUQ7WUFGVjtZQUlFcEMsY0FBT2dDLGFBQWVFLEtBQUt6QixNQUFBQSxDQUFBQSxDQUFNdUI7WUFDbkMsT0FBT0M7VUFQVEQsQ0FBQUE7VUFXQVAsT0FBQU0sdUJBQUFBLG1CQUFBQTtBQUFBQSxZQUFBQTs7O1lBQ0VTLFVBQVl4QyxjQUFPK0I7WUFDbkIsSUFBQSxRQUFxQlMsT0FBckIsQ0FBQTtjQUFBVCxPQUFBWixVQUFJSixLQUFBQSxDQUFLeUIsT0FBTHpCO1lBQUo7Y0F6Rk5nQixPQUFBO1lBeUZNO1VBRkZBLENBQUFBO1FBL0JGTixHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtNQWxERjdCLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0lBSmdCRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFGQUg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjQwMTM2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9ldmVudC9jb21wb3NpdGlvbi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgY2xhc3MgRXZlbnRcblxuY2xhc3MgQ29tcG9zaXRpb24gPCBVSVxuICBoYW5kbGVzICdjb21wb3NpdGlvbmVuZCcsICdjb21wb3NpdGlvbnN0YXJ0JywgJ2NvbXBvc2l0aW9udXBkYXRlJ1xuXG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuQ29tcG9zaXRpb24nXG4gIGVuZFxuXG4gIGNsYXNzIERlZmluaXRpb24gPCBVSTo6RGVmaW5pdGlvblxuICAgIGRlZiBkYXRhPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5kYXRhID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgbG9jYWxlPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5sb2NhbGUgPSAje3ZhbHVlfWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNvbnN0cnVjdG9yJ1xuICAgIGRlZiBzZWxmLmNvbnN0cnVjdChuYW1lLCBkZXNjKVxuICAgICAgYG5ldyBDb21wb3NpdGlvbkV2ZW50KCN7bmFtZX0sICN7ZGVzY30pYFxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY3JlYXRlJ1xuICAgIGRlZiBzZWxmLmNvbnN0cnVjdChuYW1lLCBkZXNjKVxuICAgICAgJXh7XG4gICAgICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ29tcG9zaXRpb25FdmVudFwiKTtcbiAgICAgICAgICAgIGV2ZW50LmluaXRDb21wb3NpdGlvbkV2ZW50KG5hbWUsIGRlc2MuYnViYmxlcywgZGVzYy5jYW5jZWxhYmxlLFxuICAgICAgICAgICAgICBkZXNjLnZpZXcgfHwgd2luZG93LCBkZXNjLmRhdGEsIGRlc2MubG9jYWxlKTtcblxuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZCBpZiBzdXBwb3J0ZWQ/XG5cbiAgYWxpYXNfbmF0aXZlIDpkYXRhXG4gIGFsaWFzX25hdGl2ZSA6bG9jYWxlXG5cbiAgZGVmIHN0YXJ0P1xuICAgIG5hbWUuZG93bmNhc2UgPT0gJ2NvbXBvc2l0aW9uc3RhcnQnXG4gIGVuZFxuXG4gIGRlZiB1cGRhdGU/XG4gICAgbmFtZS5kb3duY2FzZSA9PSAnY29tcG9zaXRpb251cGRhdGUnXG4gIGVuZFxuXG4gIGRlZiBlbmQ/XG4gICAgbmFtZS5kb3duY2FzZSA9PSAnY29tcG9zaXRpb25lbmQnXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8Y2xhc3M6RXZlbnQ+IiwiPGNsYXNzOkNvbXBvc2l0aW9uPiIsInNlbGYiLCJoYW5kbGVzIiwic3VwcG9ydGVkPyIsIkJyb3dzZXIiLCJzdXBwb3J0cz8iLCI8Y2xhc3M6RGVmaW5pdGlvbj4iLCJkYXRhPSIsInZhbHVlIiwiQG5hdGl2ZSIsImxvY2FsZT0iLCJVSTo6RGVmaW5pdGlvbiIsIlVJIiwiY29uc3RydWN0IiwibmFtZSIsImRlc2MiLCJhbGlhc19uYXRpdmUiLCJzdGFydD8iLCJkb3duY2FzZSIsIj09IiwidXBkYXRlPyIsImVuZD8iXSwibWFwcGluZ3MiOiJBQUFBQSw0Q0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWhCQSxPQUFBQztNQUFBQTs7UUFBQUE7OztRQUNFQyxJQUFBQyxTQUFBQSxDQUFRRixnQkFBUixFQUEwQkEsa0JBQTFCLEVBQThDQSxtQkFBOUNFO1FBRUFDLE1BQUlGLElBQUpFLGlCQUFBQSx1Q0FBQUE7QUFBQUE7VUFDRUEsT0FBQUMsYUFBT0MsY0FBQUEsQ0FBV0YsbUJBQVhFO1FBRFRGLENBQUFBO1FBSUFHO1FBQUFBOztVQUFBQTs7QUFBQUE7OztBQUNFQyxVQUFBQSxxQkFBQUEsK0JBQVVDLEtBQVZEO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRSxjQUFPRixRQUFVQztVQURyQkQsQ0FBQUE7VUFJQUQsT0FBQUksdUJBQUFBLGlDQUFZRixLQUFaRTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUQsY0FBT0MsVUFBWUY7VUFEdkJFLENBQUFBO1FBTEZKLEdBQUFBLFdBQUFBLEVBQW1CSyxJQUFBQyxRQUFBRCxlQUFuQkw7UUFVQSxJQUFBLFFBY09MLElBQUFFLGVBQUFBLENBQUFBLENBZFAsQ0FBQTtVQUFBLElBQUEsUUFBR0MsYUFBT0MsY0FBQUEsQ0FBV0wsbUJBQVhLLENBQVYsQ0FBQTtZQUNFUSxNQUFJWixJQUFKWSxnQkFBQUEscUJBQW1CQyxJQUFELEVBQU9DLElBQXpCRjtBQUFBQTtjQUNFQSxPQUFDQSxxQkFBdUJDLElBQUtELEVBQUlFLElBQUtGO1lBRHhDQSxDQUFBQTtVQURGLE9BSUEsSUFBQSxRQUFNVCxhQUFPQyxjQUFBQSxDQUFXTCxjQUFYSyxDQUFiLENBQUE7WUFDRVEsTUFBSVosSUFBSlksZ0JBQUFBLHFCQUFtQkMsSUFBRCxFQUFPQyxJQUF6QkY7QUFBQUE7O0FBRUpBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtZQVBJQSxDQUFBQTtVQURGO1FBSkE7UUFnQkFaLElBQUFlLGNBQUFBLENBQWEsTUFBYkE7UUFDQWYsSUFBQWUsY0FBQUEsQ0FBYSxRQUFiQTs7QUFFQUMsUUFBQUEsc0JBQUFBLG1DQUFBQTtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBQWhCLElBQUFhLE1BQUFBLENBQUFBLENBQUlJLFVBQUFBLENBQUFBLENBQVVDLE9BQUFBLENBQUdGLGtCQUFIRTtRQURoQkYsQ0FBQUE7O0FBSUFHLFFBQUFBLHVCQUFBQSxvQ0FBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUFuQixJQUFBYSxNQUFBQSxDQUFBQSxDQUFJSSxVQUFBQSxDQUFBQSxDQUFVQyxPQUFBQSxDQUFHQyxtQkFBSEQ7UUFEaEJDLENBQUFBO1FBSUFwQixPQUFBcUIsb0JBQUFBLGlDQUFBQTtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBQXBCLElBQUFhLE1BQUFBLENBQUFBLENBQUlJLFVBQUFBLENBQUFBLENBQVVDLE9BQUFBLENBQUdFLGdCQUFIRjtRQURoQkUsQ0FBQUE7TUE1Q0ZyQixHQUFBQSxXQUFBQSxFQUFvQlksUUFBcEJaO0lBRmdCRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjQwMjIzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9ldmVudC9hbmltYXRpb24ucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IGNsYXNzIEV2ZW50XG5cbmNsYXNzIEFuaW1hdGlvbiA8IEV2ZW50XG4gIGhhbmRsZXMgJ2FuaW1hdGlvbmVuZCcsICdhbmltYXRpb25pdGVyYXRpb24nLCAnYW5pbWF0aW9uc3RhcnQnXG5cbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5BbmltYXRpb24nXG4gIGVuZFxuXG4gIGNsYXNzIERlZmluaXRpb24gPCBEZWZpbml0aW9uXG4gICAgZGVmIGFuaW1hdGlvbj0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuYW5pbWF0aW9uTmFtZSA9ICN7dmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIGVsYXBzZWQ9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmVsYXBzZWRUaW1lID0gI3t2YWx1ZX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgQW5pbWF0aW9uRXZlbnQoI3tuYW1lfSwgI3tkZXNjfSlgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jcmVhdGUnXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICAleHtcbiAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJBbmltYXRpb25FdmVudFwiKTtcbiAgICAgICAgICAgIGV2ZW50LmluaXRBbmltYXRpb25FdmVudChuYW1lLCBkZXNjLmJ1YmJsZXMsIGRlc2MuY2FuY2VsYWJsZSxcbiAgICAgICAgICAgICAgZGVzYy5hbmltYXRpb25OYW1lLCBkZXNjLmVsYXBzZWRUaW1lKTtcblxuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZCBpZiBzdXBwb3J0ZWQ/XG5cbiAgYWxpYXNfbmF0aXZlIDpuYW1lLCA6YW5pbWF0aW9uTmFtZVxuICBhbGlhc19uYXRpdmUgOmVsYXBzZWQsIDplbGFwc2VkVGltZVxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8Y2xhc3M6RXZlbnQ+IiwiPGNsYXNzOkFuaW1hdGlvbj4iLCJzZWxmIiwiaGFuZGxlcyIsInN1cHBvcnRlZD8iLCJCcm93c2VyIiwic3VwcG9ydHM/IiwiPGNsYXNzOkRlZmluaXRpb24+IiwiYW5pbWF0aW9uPSIsInZhbHVlIiwiQG5hdGl2ZSIsImVsYXBzZWQ9IiwiRGVmaW5pdGlvbiIsImNvbnN0cnVjdCIsIm5hbWUiLCJkZXNjIiwiYWxpYXNfbmF0aXZlIiwiRXZlbnQiXSwibWFwcGluZ3MiOiJBQUFBQSwwQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWhCQSxPQUFBQztNQUFBQTs7UUFBQUE7OztRQUNFQyxJQUFBQyxTQUFBQSxDQUFRRixjQUFSLEVBQXdCQSxvQkFBeEIsRUFBOENBLGdCQUE5Q0U7UUFFQUMsTUFBSUYsSUFBSkUsaUJBQUFBLHFDQUFBQTtBQUFBQTtVQUNFQSxPQUFBQyxhQUFPQyxjQUFBQSxDQUFXRixpQkFBWEU7UUFEVEYsQ0FBQUE7UUFJQUc7UUFBQUE7O1VBQUFBOztBQUFBQTs7O0FBQ0VDLFVBQUFBLDBCQUFBQSxvQ0FBZUMsS0FBZkQ7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVFLGNBQU9GLGlCQUFtQkM7VUFEOUJELENBQUFBO1VBSUFELE9BQUFJLHdCQUFBQSxrQ0FBYUYsS0FBYkU7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVELGNBQU9DLGVBQWlCRjtVQUQ1QkUsQ0FBQUE7UUFMRkosR0FBQUEsV0FBQUEsRUFBbUJLLGdCQUFuQkw7UUFVQSxJQUFBLFFBY09MLElBQUFFLGVBQUFBLENBQUFBLENBZFAsQ0FBQTtVQUFBLElBQUEsUUFBR0MsYUFBT0MsY0FBQUEsQ0FBV0wsbUJBQVhLLENBQVYsQ0FBQTtZQUNFTyxNQUFJWCxJQUFKVyxnQkFBQUEscUJBQW1CQyxJQUFELEVBQU9DLElBQXpCRjtBQUFBQTtjQUNFQSxPQUFDQSxtQkFBcUJDLElBQUtELEVBQUlFLElBQUtGO1lBRHRDQSxDQUFBQTtVQURGLE9BSUEsSUFBQSxRQUFNUixhQUFPQyxjQUFBQSxDQUFXTCxjQUFYSyxDQUFiLENBQUE7WUFDRU8sTUFBSVgsSUFBSlcsZ0JBQUFBLHFCQUFtQkMsSUFBRCxFQUFPQyxJQUF6QkY7QUFBQUE7O0FBRUpBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtZQVBJQSxDQUFBQTtVQURGO1FBSkE7UUFnQkFYLElBQUFjLGNBQUFBLENBQWEsTUFBYixFQUFvQixlQUFwQkE7UUFDQWYsT0FBQUMsSUFBQWMsY0FBQUEsQ0FBYSxTQUFiLEVBQXVCLGFBQXZCQTtNQWxDRmYsR0FBQUEsV0FBQUEsRUFBa0JnQixXQUFsQmhCO0lBRmdCRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjQwMjkzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9ldmVudC9hdWRpb19wcm9jZXNzaW5nLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBjbGFzcyBFdmVudFxuXG5jbGFzcyBBdWRpb1Byb2Nlc3NpbmcgPCBFdmVudFxuICBoYW5kbGVzICdhdWRpb3Byb2Nlc3MnXG4gIFxuICBkZWYgc2VsZi5zdXBwb3J0ZWQ/XG4gICAgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LkF1ZGlvUHJvY2Vzc2luZydcbiAgZW5kXG5cbiAgY2xhc3MgRGVmaW5pdGlvbiA8IERlZmluaXRpb25cbiAgICBkZWYgdGltZT0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUucGxheWJhY2tUaW1lID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgaW5wdXQ9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmlucHV0QnVmZmVyID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgb3V0cHV0PSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5vdXRwdXRCdWZmZXIgPSAje3ZhbHVlfWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNvbnN0cnVjdG9yJ1xuICAgIGRlZiBzZWxmLmNvbnN0cnVjdChuYW1lLCBkZXNjKVxuICAgICAgYG5ldyBBdWRpb1Byb2Nlc3NpbmdFdmVudCgje25hbWV9LCAje2Rlc2N9KWBcbiAgICBlbmRcbiAgZW5kIGlmIHN1cHBvcnRlZD9cblxuICBhbGlhc19uYXRpdmUgOnRpbWUsIDpwbGF5YmFja1RpbWVcbiAgYWxpYXNfbmF0aXZlIDppbnB1dCwgOmlucHV0QnVmZmVyXG4gIGFsaWFzX25hdGl2ZSA6b3V0cHV0LCA6b3V0cHV0QnVmZmVyXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpFdmVudD4iLCI8Y2xhc3M6QXVkaW9Qcm9jZXNzaW5nPiIsInNlbGYiLCJoYW5kbGVzIiwic3VwcG9ydGVkPyIsIkJyb3dzZXIiLCJzdXBwb3J0cz8iLCI8Y2xhc3M6RGVmaW5pdGlvbj4iLCJ0aW1lPSIsInZhbHVlIiwiQG5hdGl2ZSIsImlucHV0PSIsIm91dHB1dD0iLCJEZWZpbml0aW9uIiwiY29uc3RydWN0IiwibmFtZSIsImRlc2MiLCJhbGlhc19uYXRpdmUiLCJFdmVudCJdLCJtYXBwaW5ncyI6IkFBQUFBLGlEQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7O1FBQ0VDLElBQUFDLFNBQUFBLENBQVFGLGNBQVJFO1FBRUFDLE1BQUlGLElBQUpFLGlCQUFBQSwyQ0FBQUE7QUFBQUE7VUFDRUEsT0FBQUMsYUFBT0MsY0FBQUEsQ0FBV0YsdUJBQVhFO1FBRFRGLENBQUFBO1FBSUFHO1FBQUFBOztVQUFBQTs7QUFBQUE7OztBQUNFQyxVQUFBQSxxQkFBQUEsK0JBQVVDLEtBQVZEO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRSxjQUFPRixnQkFBa0JDO1VBRDdCRCxDQUFBQTs7QUFJQUcsVUFBQUEsc0JBQUFBLGdDQUFXRixLQUFYRTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUQsY0FBT0MsZUFBaUJGO1VBRDVCRSxDQUFBQTtVQUlBSixPQUFBSyx1QkFBQUEsaUNBQVlILEtBQVpHO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRixjQUFPRSxnQkFBa0JIO1VBRDdCRyxDQUFBQTtRQVRGTCxHQUFBQSxXQUFBQSxFQUFtQk0sZ0JBQW5CTjtRQWNBLElBQUEsUUFJT0wsSUFBQUUsZUFBQUEsQ0FBQUEsQ0FKUCxDQUFBO1VBQUEsSUFBQSxRQUFHQyxhQUFPQyxjQUFBQSxDQUFXTCxtQkFBWEssQ0FBVixDQUFBO1lBQ0VRLE1BQUlaLElBQUpZLGdCQUFBQSxxQkFBbUJDLElBQUQsRUFBT0MsSUFBekJGO0FBQUFBO2NBQ0VBLE9BQUNBLHlCQUEyQkMsSUFBS0QsRUFBSUUsSUFBS0Y7WUFENUNBLENBQUFBO1VBREY7UUFBQTtRQU1BWixJQUFBZSxjQUFBQSxDQUFhLE1BQWIsRUFBb0IsY0FBcEJBO1FBQ0FmLElBQUFlLGNBQUFBLENBQWEsT0FBYixFQUFxQixhQUFyQkE7UUFDQWhCLE9BQUFDLElBQUFlLGNBQUFBLENBQWEsUUFBYixFQUFzQixjQUF0QkE7TUE3QkZoQixHQUFBQSxXQUFBQSxFQUF3QmlCLFdBQXhCakI7SUFGZ0JELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6NDAzNTksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L2JlZm9yZV91bmxvYWQucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IGNsYXNzIEV2ZW50XG5cbmNsYXNzIEJlZm9yZVVubG9hZCA8IEV2ZW50XG4gIGhhbmRsZXMgJ2JlZm9yZXVubG9hZCdcblxuICBkZWYgc2VsZi5zdXBwb3J0ZWQ/XG4gICAgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LkJlZm9yZVVubG9hZCdcbiAgZW5kXG5cbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNvbnN0cnVjdG9yJ1xuICAgIGRlZiBzZWxmLmNvbnN0cnVjdChuYW1lLCBkZXNjKVxuICAgICAgYG5ldyBCZWZvcmVVbmxvYWRFdmVudCgje25hbWV9LCAje2Rlc2N9KWBcbiAgICBlbmRcbiAgZW5kIGlmIHN1cHBvcnRlZD9cbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkV2ZW50PiIsIjxjbGFzczpCZWZvcmVVbmxvYWQ+Iiwic2VsZiIsImhhbmRsZXMiLCJzdXBwb3J0ZWQ/IiwiQnJvd3NlciIsInN1cHBvcnRzPyIsImNvbnN0cnVjdCIsIm5hbWUiLCJkZXNjIiwiRXZlbnQiXSwibWFwcGluZ3MiOiJBQUFBQSw4Q0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWhCQSxPQUFBQztNQUFBQTs7UUFBQUE7OztRQUNFQyxJQUFBQyxTQUFBQSxDQUFRRixjQUFSRTtRQUVBQyxNQUFJRixJQUFKRSxpQkFBQUEsd0NBQUFBO0FBQUFBO1VBQ0VBLE9BQUFDLGFBQU9DLGNBQUFBLENBQVdGLG9CQUFYRTtRQURURixDQUFBQTtRQUlBLElBQUEsUUFJT0YsSUFBQUUsZUFBQUEsQ0FBQUEsQ0FKUCxDQUFBO1VBQUEsSUFBQSxRQUFHQyxhQUFPQyxjQUFBQSxDQUFXTCxtQkFBWEssQ0FBVixDQUFBO1lBQ0VMLE9BQUFNLE1BQUlMLElBQUpLLGdCQUFBQSxxQkFBbUJDLElBQUQsRUFBT0MsSUFBekJGO0FBQUFBO2NBQ0VBLE9BQUNBLHNCQUF3QkMsSUFBS0QsRUFBSUUsSUFBS0Y7WUFEekNBLENBQUFBO1VBREY7WUFURk4sT0FBQTtVQVNFO1FBQUE7VUFURkEsT0FBQTtRQVNFO01BUEZBLEdBQUFBLFdBQUFBLEVBQXFCUyxXQUFyQlQ7SUFGZ0JELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6NDA0MDEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L2NsaXBib2FyZC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgY2xhc3MgRXZlbnRcblxuY2xhc3MgQ2xpcGJvYXJkIDwgRXZlbnRcbiAgaGFuZGxlcyAnY29weScsICdjdXQnLCAncGFzdGUnXG5cbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5DbGlwYm9hcmQnXG4gIGVuZFxuXG4gIGNsYXNzIERlZmluaXRpb24gPCBEZWZpbml0aW9uXG4gICAgZGVmIGRhdGE9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmRhdGEgPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiB0eXBlPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5kYXRhVHlwZSA9ICN7dmFsdWV9YFxuICAgIGVuZFxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY29uc3RydWN0b3InXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICBgbmV3IENsaXBib2FyZEV2ZW50KCN7bmFtZX0sICN7ZGVzY30pYFxuICAgIGVuZFxuICBlbmQgaWYgc3VwcG9ydGVkP1xuXG4gIGFsaWFzX25hdGl2ZSA6ZGF0YVxuICBhbGlhc19uYXRpdmUgOnR5cGUsIDpkYXRhVHlwZVxuXG4gICMgUmV0dXJucyBhIHtEYXRhVHJhbnNmZXJ9IHJlbGF0ZWQgdG8gdGhpcyBldmVudFxuICAjXG4gICMgQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRGF0YVRyYW5zZmVyXG4gIGRlZiB0cmFuc2ZlclxuICAgIERhdGFUcmFuc2Zlci5uZXcoYCNAbmF0aXZlLmNsaXBib2FyZERhdGFgKVxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkV2ZW50PiIsIjxjbGFzczpDbGlwYm9hcmQ+Iiwic2VsZiIsImhhbmRsZXMiLCJzdXBwb3J0ZWQ/IiwiQnJvd3NlciIsInN1cHBvcnRzPyIsIjxjbGFzczpEZWZpbml0aW9uPiIsImRhdGE9IiwidmFsdWUiLCJAbmF0aXZlIiwidHlwZT0iLCJEZWZpbml0aW9uIiwiY29uc3RydWN0IiwibmFtZSIsImRlc2MiLCJhbGlhc19uYXRpdmUiLCJ0cmFuc2ZlciIsIkRhdGFUcmFuc2ZlciIsIm5ldyIsIkV2ZW50Il0sIm1hcHBpbmdzIjoiQUFBQUEsMENBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUVoQkEsT0FBQUM7TUFBQUE7O1FBQUFBOztBQUFBQTs7UUFDRUMsSUFBQUMsU0FBQUEsQ0FBUUYsTUFBUixFQUFnQkEsS0FBaEIsRUFBdUJBLE9BQXZCRTtRQUVBQyxNQUFJRixJQUFKRSxpQkFBQUEscUNBQUFBO0FBQUFBO1VBQ0VBLE9BQUFDLGFBQU9DLGNBQUFBLENBQVdGLGlCQUFYRTtRQURURixDQUFBQTtRQUlBRztRQUFBQTs7VUFBQUE7O0FBQUFBOzs7QUFDRUMsVUFBQUEscUJBQUFBLCtCQUFVQyxLQUFWRDtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUUsY0FBT0YsUUFBVUM7VUFEckJELENBQUFBO1VBSUFELE9BQUFJLHFCQUFBQSwrQkFBVUYsS0FBVkU7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVELGNBQU9DLFlBQWNGO1VBRHpCRSxDQUFBQTtRQUxGSixHQUFBQSxXQUFBQSxFQUFtQkssZ0JBQW5CTDtRQVVBLElBQUEsUUFJT0wsSUFBQUUsZUFBQUEsQ0FBQUEsQ0FKUCxDQUFBO1VBQUEsSUFBQSxRQUFHQyxhQUFPQyxjQUFBQSxDQUFXTCxtQkFBWEssQ0FBVixDQUFBO1lBQ0VPLE1BQUlYLElBQUpXLGdCQUFBQSxxQkFBbUJDLElBQUQsRUFBT0MsSUFBekJGO0FBQUFBO2NBQ0VBLE9BQUNBLG1CQUFxQkMsSUFBS0QsRUFBSUUsSUFBS0Y7WUFEdENBLENBQUFBO1VBREY7UUFBQTtRQU1BWCxJQUFBYyxjQUFBQSxDQUFhLE1BQWJBO1FBQ0FkLElBQUFjLGNBQUFBLENBQWEsTUFBYixFQUFvQixVQUFwQkE7UUFLQWYsT0FBQWdCLHdCQUFBQSxvQkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUFDLGtCQUFZQyxLQUFBQSxDQUFPVCxjQUFPTyxjQUFkRTtRQURkRixDQUFBQTtNQTdCRmhCLEdBQUFBLFdBQUFBLEVBQWtCbUIsV0FBbEJuQjtJQUZnQkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo0MDQ2NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQvZGV2aWNlX2xpZ2h0LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBjbGFzcyBFdmVudFxuXG5jbGFzcyBEZXZpY2VMaWdodCA8IEV2ZW50XG4gIGhhbmRsZXMgJ2RldmljZWxpZ2h0J1xuXG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuRGV2aWNlTGlnaHQnXG4gIGVuZFxuXG4gIGNsYXNzIERlZmluaXRpb24gPCBEZWZpbml0aW9uXG4gICAgZGVmIHZhbHVlPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS52YWx1ZSA9ICN7dmFsdWV9YFxuICAgIGVuZFxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY29uc3RydWN0b3InXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICBgbmV3IERldmljZUxpZ2h0RXZlbnQoI3tuYW1lfSwgI3tkZXNjfSlgXG4gICAgZW5kXG4gIGVuZCBpZiBzdXBwb3J0ZWQ/XG5cbiAgYWxpYXNfbmF0aXZlIDp2YWx1ZVxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8Y2xhc3M6RXZlbnQ+IiwiPGNsYXNzOkRldmljZUxpZ2h0PiIsInNlbGYiLCJoYW5kbGVzIiwic3VwcG9ydGVkPyIsIkJyb3dzZXIiLCJzdXBwb3J0cz8iLCI8Y2xhc3M6RGVmaW5pdGlvbj4iLCJ2YWx1ZT0iLCJ2YWx1ZSIsIkBuYXRpdmUiLCJEZWZpbml0aW9uIiwiY29uc3RydWN0IiwibmFtZSIsImRlc2MiLCJhbGlhc19uYXRpdmUiLCJFdmVudCJdLCJtYXBwaW5ncyI6IkFBQUFBLDZDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7O1FBQ0VDLElBQUFDLFNBQUFBLENBQVFGLGFBQVJFO1FBRUFDLE1BQUlGLElBQUpFLGlCQUFBQSx1Q0FBQUE7QUFBQUE7VUFDRUEsT0FBQUMsYUFBT0MsY0FBQUEsQ0FBV0YsbUJBQVhFO1FBRFRGLENBQUFBO1FBSUFHO1FBQUFBOztVQUFBQTs7QUFBQUE7VUFDRUEsT0FBQUMsc0JBQUFBLGdDQUFXQyxLQUFYRDtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUUsY0FBT0YsU0FBV0M7VUFEdEJELENBQUFBO1FBREZELEdBQUFBLFdBQUFBLEVBQW1CSSxnQkFBbkJKO1FBTUEsSUFBQSxRQUlPTCxJQUFBRSxlQUFBQSxDQUFBQSxDQUpQLENBQUE7VUFBQSxJQUFBLFFBQUdDLGFBQU9DLGNBQUFBLENBQVdMLG1CQUFYSyxDQUFWLENBQUE7WUFDRU0sTUFBSVYsSUFBSlUsZ0JBQUFBLHFCQUFtQkMsSUFBRCxFQUFPQyxJQUF6QkY7QUFBQUE7Y0FDRUEsT0FBQ0EscUJBQXVCQyxJQUFLRCxFQUFJRSxJQUFLRjtZQUR4Q0EsQ0FBQUE7VUFERjtRQUFBO1FBTUFYLE9BQUFDLElBQUFhLGNBQUFBLENBQWEsT0FBYkE7TUFuQkZkLEdBQUFBLFdBQUFBLEVBQW9CZSxXQUFwQmY7SUFGZ0JELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6NDA1MTcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L2RldmljZV9tb3Rpb24ucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IGNsYXNzIEV2ZW50XG5cbmNsYXNzIERldmljZU1vdGlvbiA8IEV2ZW50XG4gIGhhbmRsZXMgJ2RldmljZW1vdGlvbidcbiAgXG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuRGV2aWNlTW90aW9uJ1xuICBlbmRcblxuICBBY2NlbGVyYXRpb24gPSBTdHJ1Y3QubmV3KDp4LCA6eSwgOnopXG5cbiAgY2xhc3MgRGVmaW5pdGlvbiA8IERlZmluaXRpb25cbiAgICBkZWYgYWNjZWxlcmF0aW9uPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5hY2NlbGVyYXRpb24gPSAje3ZhbHVlLnRvX259YFxuICAgIGVuZFxuXG4gICAgZGVmIGFjY2VsZXJhdGlvbl93aXRoX2dyYXZpdHk9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkgPSAje3ZhbHVlLnRvX259YFxuICAgIGVuZFxuXG4gICAgZGVmIHJvdGF0aW9uPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5yb3RhdGlvblJhdGUgPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBpbnRlcnZhbD0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuaW50ZXJ2YWwgPSAje3ZhbHVlfWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNvbnN0cnVjdG9yJ1xuICAgIGRlZiBzZWxmLmNvbnN0cnVjdChuYW1lLCBkZXNjKVxuICAgICAgYG5ldyBEZXZpY2VNb3Rpb25FdmVudCgje25hbWV9LCAje2Rlc2N9KWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNyZWF0ZSdcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgICV4e1xuICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkRldmljZU1vdGlvbkV2ZW50XCIpO1xuICAgICAgICAgICAgZXZlbnQuaW5pdERldmljZU1vdGlvbkV2ZW50KG5hbWUsIGRlc2MuYnViYmxlcywgZGVzYy5jYW5jZWxhYmxlLFxuICAgICAgICAgICAgICBkZXNjLmFjY2VsZXJhdGlvbiwgZGVzYy5hY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5LFxuICAgICAgICAgICAgICBkZXNjLnJvdGF0aW9uUmF0ZSwgZGVzYy5pbnRlcnZhbCk7XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIGVuZFxuICBlbmQgaWYgc3VwcG9ydGVkP1xuXG4gIGFsaWFzX25hdGl2ZSA6YWNjZWxlcmF0aW9uXG4gIGFsaWFzX25hdGl2ZSA6YWNjZWxlcmF0aW9uX3dpdGhfZ3Jhdml0eSwgOmFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHlcbiAgYWxpYXNfbmF0aXZlIDpyb3RhdGlvbiwgOnJvdGF0aW9uUmF0ZVxuICBhbGlhc19uYXRpdmUgOmludGVydmFsXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpFdmVudD4iLCI8Y2xhc3M6RGV2aWNlTW90aW9uPiIsInNlbGYiLCJoYW5kbGVzIiwic3VwcG9ydGVkPyIsIkJyb3dzZXIiLCJzdXBwb3J0cz8iLCJTdHJ1Y3QiLCJuZXciLCI8Y2xhc3M6RGVmaW5pdGlvbj4iLCJhY2NlbGVyYXRpb249IiwidmFsdWUiLCJAbmF0aXZlIiwidG9fbiIsImFjY2VsZXJhdGlvbl93aXRoX2dyYXZpdHk9Iiwicm90YXRpb249IiwiaW50ZXJ2YWw9IiwiRGVmaW5pdGlvbiIsImNvbnN0cnVjdCIsIm5hbWUiLCJkZXNjIiwiYWxpYXNfbmF0aXZlIiwiRXZlbnQiXSwibWFwcGluZ3MiOiJBQUFBQSw4Q0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWhCQSxPQUFBQztNQUFBQTs7UUFBQUE7OztRQUNFQyxJQUFBQyxTQUFBQSxDQUFRRixjQUFSRTtRQUVBQyxNQUFJRixJQUFKRSxpQkFBQUEsd0NBQUFBO0FBQUFBO1VBQ0VBLE9BQUFDLGFBQU9DLGNBQUFBLENBQVdGLG9CQUFYRTtRQURURixDQUFBQTtRQUlBLHdDQUFlRyxZQUFNQyxLQUFBQSxDQUFLLEdBQVgsRUFBZSxHQUFmLEVBQW1CLEdBQWJBLENBQXJCO1FBRUFDO1FBQUFBOztVQUFBQTs7QUFBQUE7OztBQUNFQyxVQUFBQSw2QkFBQUEsdUNBQWtCQyxLQUFsQkQ7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVFLGNBQU9GLGdCQUFrQkMsS0FBS0UsTUFBQUEsQ0FBQUE7VUFEbENILENBQUFBOztBQUlBSSxVQUFBQSwwQ0FBQUEsb0RBQStCSCxLQUEvQkc7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVGLGNBQU9FLGdDQUFrQ0gsS0FBS0UsTUFBQUEsQ0FBQUE7VUFEbERDLENBQUFBOztBQUlBQyxVQUFBQSx5QkFBQUEsbUNBQWNKLEtBQWRJO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFSCxjQUFPRyxnQkFBa0JKO1VBRDdCSSxDQUFBQTtVQUlBTixPQUFBTyx5QkFBQUEsbUNBQWNMLEtBQWRLO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFSixjQUFPSSxZQUFjTDtVQUR6QkssQ0FBQUE7UUFiRlAsR0FBQUEsV0FBQUEsRUFBbUJRLGdCQUFuQlI7UUFrQkEsSUFBQSxRQWVPUCxJQUFBRSxlQUFBQSxDQUFBQSxDQWZQLENBQUE7VUFBQSxJQUFBLFFBQUdDLGFBQU9DLGNBQUFBLENBQVdMLG1CQUFYSyxDQUFWLENBQUE7WUFDRVksTUFBSWhCLElBQUpnQixnQkFBQUEscUJBQW1CQyxJQUFELEVBQU9DLElBQXpCRjtBQUFBQTtjQUNFQSxPQUFDQSxzQkFBd0JDLElBQUtELEVBQUlFLElBQUtGO1lBRHpDQSxDQUFBQTtVQURGLE9BSUEsSUFBQSxRQUFNYixhQUFPQyxjQUFBQSxDQUFXTCxjQUFYSyxDQUFiLENBQUE7WUFDRVksTUFBSWhCLElBQUpnQixnQkFBQUEscUJBQW1CQyxJQUFELEVBQU9DLElBQXpCRjtBQUFBQTs7QUFFSkE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO1lBUklBLENBQUFBO1VBREY7UUFKQTtRQWlCQWhCLElBQUFtQixjQUFBQSxDQUFhLGNBQWJBO1FBQ0FuQixJQUFBbUIsY0FBQUEsQ0FBYSwyQkFBYixFQUF5Qyw4QkFBekNBO1FBQ0FuQixJQUFBbUIsY0FBQUEsQ0FBYSxVQUFiLEVBQXdCLGNBQXhCQTtRQUNBcEIsT0FBQUMsSUFBQW1CLGNBQUFBLENBQWEsVUFBYkE7TUEvQ0ZwQixHQUFBQSxXQUFBQSxFQUFxQnFCLFdBQXJCckI7SUFGZ0JELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6NDA2MDMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L2RldmljZV9vcmllbnRhdGlvbi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgY2xhc3MgRXZlbnRcblxuY2xhc3MgRGV2aWNlT3JpZW50YXRpb24gPCBFdmVudFxuICBoYW5kbGVzICdkZXZpY2VvcmllbnRhdGlvbidcblxuICBkZWYgc2VsZi5zdXBwb3J0ZWQ/XG4gICAgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LkRldmljZU9yaWVudGF0aW9uJ1xuICBlbmRcblxuICBjbGFzcyBEZWZpbml0aW9uIDwgRGVmaW5pdGlvblxuICAgIGRlZiBhYnNvbHV0ZT0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuYWJzb2x1dGUgPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBhbHBoYT0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuYWxwaGEgPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBiZXRhPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5iZXRhID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgZ2FtbWE9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmdhbW1hID0gI3t2YWx1ZX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgRGV2aWNlT3JpZW50YXRpb25FdmVudCgje25hbWV9LCAje2Rlc2N9KWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNyZWF0ZSdcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgICV4e1xuICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkRldmljZU9yaWVudGF0aW9uRXZlbnRcIik7XG4gICAgICAgICAgICBldmVudC5pbml0RGV2aWNlT3JpZW50YXRpb25FdmVudChuYW1lLCBkZXNjLmJ1YmJsZXMsIGRlc2MuY2FuY2VsYWJsZSxcbiAgICAgICAgICAgICAgZGVzYy5hbHBoYSwgZGVzYy5iZXRhLCBkZXNjLmdhbW1hLCBkZXNjLmFic29sdXRlKTtcblxuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZCBpZiBzdXBwb3J0ZWQ/XG5cbiAgYWxpYXNfbmF0aXZlIDphYnNvbHV0ZVxuICBhbGlhc19uYXRpdmUgOmFscGhhXG4gIGFsaWFzX25hdGl2ZSA6YmV0YVxuICBhbGlhc19uYXRpdmUgOmdhbW1hXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpFdmVudD4iLCI8Y2xhc3M6RGV2aWNlT3JpZW50YXRpb24+Iiwic2VsZiIsImhhbmRsZXMiLCJzdXBwb3J0ZWQ/IiwiQnJvd3NlciIsInN1cHBvcnRzPyIsIjxjbGFzczpEZWZpbml0aW9uPiIsImFic29sdXRlPSIsInZhbHVlIiwiQG5hdGl2ZSIsImFscGhhPSIsImJldGE9IiwiZ2FtbWE9IiwiRGVmaW5pdGlvbiIsImNvbnN0cnVjdCIsIm5hbWUiLCJkZXNjIiwiYWxpYXNfbmF0aXZlIiwiRXZlbnQiXSwibWFwcGluZ3MiOiJBQUFBQSxtREFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWhCQSxPQUFBQztNQUFBQTs7UUFBQUE7OztRQUNFQyxJQUFBQyxTQUFBQSxDQUFRRixtQkFBUkU7UUFFQUMsTUFBSUYsSUFBSkUsaUJBQUFBLDZDQUFBQTtBQUFBQTtVQUNFQSxPQUFBQyxhQUFPQyxjQUFBQSxDQUFXRix5QkFBWEU7UUFEVEYsQ0FBQUE7UUFJQUc7UUFBQUE7O1VBQUFBOztBQUFBQTs7O0FBQ0VDLFVBQUFBLHlCQUFBQSxtQ0FBY0MsS0FBZEQ7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVFLGNBQU9GLFlBQWNDO1VBRHpCRCxDQUFBQTs7QUFJQUcsVUFBQUEsc0JBQUFBLGdDQUFXRixLQUFYRTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUQsY0FBT0MsU0FBV0Y7VUFEdEJFLENBQUFBOztBQUlBQyxVQUFBQSxxQkFBQUEsK0JBQVVILEtBQVZHO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRixjQUFPRSxRQUFVSDtVQURyQkcsQ0FBQUE7VUFJQUwsT0FBQU0sc0JBQUFBLGdDQUFXSixLQUFYSTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUgsY0FBT0csU0FBV0o7VUFEdEJJLENBQUFBO1FBYkZOLEdBQUFBLFdBQUFBLEVBQW1CTyxnQkFBbkJQO1FBa0JBLElBQUEsUUFjT0wsSUFBQUUsZUFBQUEsQ0FBQUEsQ0FkUCxDQUFBO1VBQUEsSUFBQSxRQUFHQyxhQUFPQyxjQUFBQSxDQUFXTCxtQkFBWEssQ0FBVixDQUFBO1lBQ0VTLE1BQUliLElBQUphLGdCQUFBQSxxQkFBbUJDLElBQUQsRUFBT0MsSUFBekJGO0FBQUFBO2NBQ0VBLE9BQUNBLDJCQUE2QkMsSUFBS0QsRUFBSUUsSUFBS0Y7WUFEOUNBLENBQUFBO1VBREYsT0FJQSxJQUFBLFFBQU1WLGFBQU9DLGNBQUFBLENBQVdMLGNBQVhLLENBQWIsQ0FBQTtZQUNFUyxNQUFJYixJQUFKYSxnQkFBQUEscUJBQW1CQyxJQUFELEVBQU9DLElBQXpCRjtBQUFBQTs7QUFFSkE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO1lBUElBLENBQUFBO1VBREY7UUFKQTtRQWdCQWIsSUFBQWdCLGNBQUFBLENBQWEsVUFBYkE7UUFDQWhCLElBQUFnQixjQUFBQSxDQUFhLE9BQWJBO1FBQ0FoQixJQUFBZ0IsY0FBQUEsQ0FBYSxNQUFiQTtRQUNBakIsT0FBQUMsSUFBQWdCLGNBQUFBLENBQWEsT0FBYkE7TUE1Q0ZqQixHQUFBQSxXQUFBQSxFQUEwQmtCLFdBQTFCbEI7SUFGZ0JELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6NDA2ODcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L2RldmljZV9wcm94aW1pdHkucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IGNsYXNzIEV2ZW50XG5cbmNsYXNzIERldmljZVByb3hpbWl0eSA8IEV2ZW50XG4gIGhhbmRsZXMgJ2RldmljZXByb3hpbWl0eSdcblxuICBkZWYgc2VsZi5zdXBwb3J0ZWQ/XG4gICAgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LkRldmljZVByb3hpbWl0eSdcbiAgZW5kXG5cbiAgY2xhc3MgRGVmaW5pdGlvbiA8IERlZmluaXRpb25cbiAgICBkZWYgdmFsdWU9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLnZhbHVlID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgbWluPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5taW4gPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBtYXg9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLm1heCA9ICN7dmFsdWV9YFxuICAgIGVuZFxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY29uc3RydWN0b3InXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICBgbmV3IERldmljZVByb3hpbWl0eUV2ZW50KCN7bmFtZX0sICN7ZGVzY30pYFxuICAgIGVuZFxuICBlbmQgaWYgc3VwcG9ydGVkP1xuXG4gIGFsaWFzX25hdGl2ZSA6dmFsdWVcbiAgYWxpYXNfbmF0aXZlIDptaW5cbiAgYWxpYXNfbmF0aXZlIDptYXhcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkV2ZW50PiIsIjxjbGFzczpEZXZpY2VQcm94aW1pdHk+Iiwic2VsZiIsImhhbmRsZXMiLCJzdXBwb3J0ZWQ/IiwiQnJvd3NlciIsInN1cHBvcnRzPyIsIjxjbGFzczpEZWZpbml0aW9uPiIsInZhbHVlPSIsInZhbHVlIiwiQG5hdGl2ZSIsIm1pbj0iLCJtYXg9IiwiRGVmaW5pdGlvbiIsImNvbnN0cnVjdCIsIm5hbWUiLCJkZXNjIiwiYWxpYXNfbmF0aXZlIiwiRXZlbnQiXSwibWFwcGluZ3MiOiJBQUFBQSxpREFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWhCQSxPQUFBQztNQUFBQTs7UUFBQUE7OztRQUNFQyxJQUFBQyxTQUFBQSxDQUFRRixpQkFBUkU7UUFFQUMsTUFBSUYsSUFBSkUsaUJBQUFBLDJDQUFBQTtBQUFBQTtVQUNFQSxPQUFBQyxhQUFPQyxjQUFBQSxDQUFXRix1QkFBWEU7UUFEVEYsQ0FBQUE7UUFJQUc7UUFBQUE7O1VBQUFBOztBQUFBQTs7O0FBQ0VDLFVBQUFBLHNCQUFBQSxnQ0FBV0MsS0FBWEQ7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVFLGNBQU9GLFNBQVdDO1VBRHRCRCxDQUFBQTs7QUFJQUcsVUFBQUEsb0JBQUFBLDhCQUFTRixLQUFURTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUQsY0FBT0MsT0FBU0Y7VUFEcEJFLENBQUFBO1VBSUFKLE9BQUFLLG9CQUFBQSw4QkFBU0gsS0FBVEc7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVGLGNBQU9FLE9BQVNIO1VBRHBCRyxDQUFBQTtRQVRGTCxHQUFBQSxXQUFBQSxFQUFtQk0sZ0JBQW5CTjtRQWNBLElBQUEsUUFJT0wsSUFBQUUsZUFBQUEsQ0FBQUEsQ0FKUCxDQUFBO1VBQUEsSUFBQSxRQUFHQyxhQUFPQyxjQUFBQSxDQUFXTCxtQkFBWEssQ0FBVixDQUFBO1lBQ0VRLE1BQUlaLElBQUpZLGdCQUFBQSxxQkFBbUJDLElBQUQsRUFBT0MsSUFBekJGO0FBQUFBO2NBQ0VBLE9BQUNBLHlCQUEyQkMsSUFBS0QsRUFBSUUsSUFBS0Y7WUFENUNBLENBQUFBO1VBREY7UUFBQTtRQU1BWixJQUFBZSxjQUFBQSxDQUFhLE9BQWJBO1FBQ0FmLElBQUFlLGNBQUFBLENBQWEsS0FBYkE7UUFDQWhCLE9BQUFDLElBQUFlLGNBQUFBLENBQWEsS0FBYkE7TUE3QkZoQixHQUFBQSxXQUFBQSxFQUF3QmlCLFdBQXhCakI7SUFGZ0JELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6NDA3NTMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L2RyYWcucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IGNsYXNzIEV2ZW50XG5cbmNsYXNzIERyYWcgPCBFdmVudFxuICBoYW5kbGVzICdkcmFnJywgJ2RyYWdlbmQnLCAnZHJhZ2VudGVyJywgJ2RyYWdleGl0JywgJ2RyYWdsZWF2ZScsICdkcmFnb3ZlcicsXG4gICAgICAgICAgJ2RyYWdzdGFydCcsICdkcm9wJ1xuXG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuRHJhZydcbiAgZW5kXG5cbiAgY2xhc3MgRGVmaW5pdGlvbiA8IERlZmluaXRpb25cbiAgICBjbGFzcyBDbGllbnRcbiAgICAgIGluY2x1ZGUgTmF0aXZlOjpXcmFwcGVyXG5cbiAgICAgIGRlZiB4PSh2YWx1ZSlcbiAgICAgICAgYCNAbmF0aXZlLmNsaWVudFggPSAje3ZhbHVlfWBcbiAgICAgIGVuZFxuXG4gICAgICBkZWYgeT0odmFsdWUpXG4gICAgICAgIGAjQG5hdGl2ZS5jbGllbnRZID0gI3t2YWx1ZX1gXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGNsYXNzIFNjcmVlblxuICAgICAgaW5jbHVkZSBOYXRpdmU6OldyYXBwZXJcblxuICAgICAgZGVmIHg9KHZhbHVlKVxuICAgICAgICBgI0BuYXRpdmUuc2NyZWVuWCA9ICN7dmFsdWV9YFxuICAgICAgZW5kXG5cbiAgICAgIGRlZiB5PSh2YWx1ZSlcbiAgICAgICAgYCNAbmF0aXZlLnNjcmVlblkgPSAje3ZhbHVlfWBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGFsdCFcbiAgICAgIGAjQG5hdGl2ZS5hbHRLZXkgPSB0cnVlYFxuICAgIGVuZFxuXG4gICAgZGVmIGN0cmwhXG4gICAgICBgI0BuYXRpdmUuY3RybEtleSA9IHRydWVgXG4gICAgZW5kXG5cbiAgICBkZWYgbWV0YSFcbiAgICAgIGAjQG5hdGl2ZS5tZXRhS2V5ID0gdHJ1ZWBcbiAgICBlbmRcblxuICAgIGRlZiBidXR0b249KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmJ1dHRvbiA9ICN7dmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIGNsaWVudFxuICAgICAgQ2xpZW50Lm5ldyhAbmF0aXZlKVxuICAgIGVuZFxuXG4gICAgZGVmIHNjcmVlblxuICAgICAgU2NyZWVuLm5ldyhAbmF0aXZlKVxuICAgIGVuZFxuXG4gICAgZGVmIHJlbGF0ZWQ9KGVsZW0pXG4gICAgICBgI0BuYXRpdmUucmVsYXRlZFRhcmdldCA9ICN7TmF0aXZlLmNvbnZlcnQoZWxlbSl9YFxuICAgIGVuZFxuXG4gICAgZGVmIHRyYW5zZmVyPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5kYXRhVHJhbnNmZXIgPSAje05hdGl2ZS5jb252ZXJ0KHZhbHVlKX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgRHJhZ0V2ZW50KCN7bmFtZX0sICN7ZGVzY30pYFxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY3JlYXRlJ1xuICAgIGRlZiBzZWxmLmNvbnN0cnVjdChuYW1lLCBkZXNjKVxuICAgICAgJXh7XG4gICAgICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRHJhZ0V2ZW50XCIpO1xuICAgICAgICAgICAgZXZlbnQuaW5pdERyYWdFdmVudChuYW1lLCBkZXNjLmJ1YmJsZXMsIGRlc2MuY2FuY2VsYWJsZSxcbiAgICAgICAgICAgICAgZGVzYy52aWV3IHx8IHdpbmRvdywgMCxcbiAgICAgICAgICAgICAgZGVzYy5zY3JlZW5YIHx8IDAsIGRlc2Muc2NyZWVuWSB8fCAwLFxuICAgICAgICAgICAgICBkZXNjLmNsaWVudFggfHwgMCwgZGVzYy5jbGllbnRZIHx8IDAsXG4gICAgICAgICAgICAgIGRlc2MuY3RybEtleSwgZGVzYy5hbHRLZXksIGRlc2Muc2hpZnRLZXksIGRlc2MubWV0YUtleSxcbiAgICAgICAgICAgICAgZGVzYy5idXR0b24gfHwgMCwgZGVzYy5yZWxhdGVkVGFyZ2V0LCBkZXNjLmRhdGFUcmFuc2Zlcik7XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIGVuZFxuICBlbmQgaWYgc3VwcG9ydGVkP1xuXG4gIGFsaWFzX25hdGl2ZSA6YWx0PywgOmFsdEtleVxuICBhbGlhc19uYXRpdmUgOmN0cmw/LCA6Y3RybEtleVxuICBhbGlhc19uYXRpdmUgOm1ldGE/LCA6bWV0YUtleVxuICBhbGlhc19uYXRpdmUgOnNoaWZ0PywgOnNoaWZ0S2V5XG4gIGFsaWFzX25hdGl2ZSA6YnV0dG9uXG5cbiAgZGVmIGNsaWVudFxuICAgIFBvc2l0aW9uLm5ldyhgI0BuYXRpdmUuY2xpZW50WGAsIGAjQG5hdGl2ZS5jbGllbnRZYClcbiAgZW5kXG5cbiAgZGVmIHNjcmVlblxuICAgIFBvc2l0aW9uLm5ldyhgI0BuYXRpdmUuc2NyZWVuWGAsIGAjQG5hdGl2ZS5zY3JlZW5ZYCkgaWYgZGVmaW5lZD8oYCNAbmF0aXZlLnNjcmVlblhgKVxuICBlbmRcblxuICBkZWYgeFxuICAgIHNjcmVlbi54XG4gIGVuZFxuXG4gIGRlZiB5XG4gICAgc2NyZWVuLnlcbiAgZW5kXG5cbiAgZGVmIHJlbGF0ZWRcbiAgICBET00oYCNAbmF0aXZlLnJlbGF0ZWRUYXJnZXRgKVxuICBlbmRcblxuICAjIFJldHVybnMgYSB7RGF0YVRyYW5zZmVyfSByZWxhdGVkIHRvIHRoaXMgZXZlbnRcbiAgI1xuICAjIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RhdGFUcmFuc2ZlclxuICBkZWYgdHJhbnNmZXJcbiAgICBEYXRhVHJhbnNmZXIubmV3KGAjQG5hdGl2ZS5kYXRhVHJhbnNmZXJgKVxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkV2ZW50PiIsIjxjbGFzczpEcmFnPiIsInNlbGYiLCJoYW5kbGVzIiwic3VwcG9ydGVkPyIsIkJyb3dzZXIiLCJzdXBwb3J0cz8iLCI8Y2xhc3M6RGVmaW5pdGlvbj4iLCI8Y2xhc3M6Q2xpZW50PiIsImluY2x1ZGUiLCJOYXRpdmU6OldyYXBwZXIiLCJOYXRpdmUiLCJ4PSIsInZhbHVlIiwiQG5hdGl2ZSIsInk9IiwiPGNsYXNzOlNjcmVlbj4iLCJhbHQhIiwiY3RybCEiLCJtZXRhISIsImJ1dHRvbj0iLCJjbGllbnQiLCJDbGllbnQiLCJuZXciLCJzY3JlZW4iLCJTY3JlZW4iLCJyZWxhdGVkPSIsImVsZW0iLCJjb252ZXJ0IiwidHJhbnNmZXI9IiwiRGVmaW5pdGlvbiIsImNvbnN0cnVjdCIsIm5hbWUiLCJkZXNjIiwiYWxpYXNfbmF0aXZlIiwiUG9zaXRpb24iLCJ4IiwieSIsInJlbGF0ZWQiLCJET00iLCJ0cmFuc2ZlciIsIkRhdGFUcmFuc2ZlciIsIkV2ZW50Il0sIm1hcHBpbmdzIjoiQUFBQUEscUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUVoQkEsT0FBQUM7TUFBQUE7O1FBQUFBOztBQUFBQTs7UUFDRUMsSUFBQUMsU0FBQUEsQ0FBUUYsTUFBUixFQUFnQkEsU0FBaEIsRUFBMkJBLFdBQTNCLEVBQXdDQSxVQUF4QyxFQUFvREEsV0FBcEQsRUFBaUVBLFVBQWpFLEVBQ1FBLFdBRFIsRUFDcUJBLE1BRHJCRTtRQUdBQyxNQUFJRixJQUFKRSxpQkFBQUEsZ0NBQUFBO0FBQUFBO1VBQ0VBLE9BQUFDLGFBQU9DLGNBQUFBLENBQVdGLFlBQVhFO1FBRFRGLENBQUFBO1FBSUFHO1FBQUFBOztVQUFBQTs7QUFBQUE7O1VBQ0VDO1VBQUFBOztZQUFBQTs7QUFBQUE7O1lBQ0VOLElBQUFPLFNBQUFBLENBQVFDLElBQUFDLFlBQUFELFlBQVJEOztBQUVBRyxZQUFBQSxrQkFBQUEsd0JBQU9DLEtBQVBEO0FBQUFBLGNBQUFBOztjQUNFQSxPQUFFRSxjQUFPRixXQUFhQztZQUR4QkQsQ0FBQUE7WUFJQUosT0FBQU8sa0JBQUFBLHdCQUFPRixLQUFQRTtBQUFBQSxjQUFBQTs7Y0FDRUEsT0FBRUQsY0FBT0MsV0FBYUY7WUFEeEJFLENBQUFBO1VBUEZQLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO1VBWUFRO1VBQUFBOztZQUFBQTs7QUFBQUE7O1lBQ0VkLElBQUFPLFNBQUFBLENBQVFDLElBQUFDLFlBQUFELFlBQVJEOztBQUVBRyxZQUFBQSxrQkFBQUEsd0JBQU9DLEtBQVBEO0FBQUFBLGNBQUFBOztjQUNFQSxPQUFFRSxjQUFPRixXQUFhQztZQUR4QkQsQ0FBQUE7WUFJQUks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QUFBLENBQUFBLENBQU1ZLEdBQUFBLENBQUFBO1FBRFJBLENBQUFBOztBQUlBQyxRQUFBQSxpQkFBQUEsYUFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUFuQyxJQUFBc0IsUUFBQUEsQ0FBQUEsQ0FBTWEsR0FBQUEsQ0FBQUE7UUFEUkEsQ0FBQUE7O0FBSUFDLFFBQUFBLHVCQUFBQSxtQkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUFwQyxJQUFBcUMsS0FBQUEsQ0FBTXpCLGNBQU93QixjQUFiQztRQURGRCxDQUFBQTtRQU9BckMsT0FBQXVDLHdCQUFBQSxvQkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUFDLGtCQUFZbEIsS0FBQUEsQ0FBT1QsY0FBTzBCLGFBQWRqQjtRQURkaUIsQ0FBQUE7TUFuSEZ2QyxHQUFBQSxXQUFBQSxFQUFheUMsV0FBYnpDO0lBRmdCRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjQwOTQ2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9ldmVudC9nYW1lcGFkLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBjbGFzcyBFdmVudFxuXG5jbGFzcyBHYW1lcGFkIDwgRXZlbnRcbiAgaGFuZGxlcyAnZ2FtZXBhZGNvbm5lY3RlZCcsICdnYW1lcGFkZGlzY29ubmVjdGVkJ1xuXG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuR2FtZXBhZCdcbiAgZW5kXG5cbiAgY2xhc3MgRGVmaW5pdGlvbiA8IERlZmluaXRpb25cbiAgICBkZWYgaWQ9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmlkID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgaW5kZXg9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmluZGV4ID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgYXQ9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLnRpbWVzdGFtcCA9ICN7dmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIGF4ZXM9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmF4ZXMgPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBidXR0b25zPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5idXR0b25zID0gI3t2YWx1ZX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGByZXR1cm4gbmV3IEdhbWVwYWRFdmVudCgje25hbWV9LCB7XG4gICAgICAgIGJ1YmJsZXM6ICAgIGRlc2MuYnViYmxlcyxcbiAgICAgICAgY2FuY2VsYWJsZTogZGVzYy5jYW5jZWxhYmxlLFxuICAgICAgICBnYW1lcGFkOiAgICBkZXNjIH0pYFxuICAgIGVuZFxuICBlbmQgaWYgc3VwcG9ydGVkP1xuXG4gIGRlZiBpZFxuICAgIGAjQG5hdGl2ZS5nYW1lcGFkLmlkYFxuICBlbmRcblxuICBkZWYgaW5kZXhcbiAgICBgI0BuYXRpdmUuZ2FtZXBhZC5pbmRleGBcbiAgZW5kXG5cbiAgZGVmIGF0XG4gICAgYCNAbmF0aXZlLmdhbWVwYWQudGltZXN0YW1wYFxuICBlbmRcblxuICBkZWYgYXhlc1xuICAgIGAjQG5hdGl2ZS5nYW1lcGFkLmF4ZXNgXG4gIGVuZFxuXG4gIGRlZiBidXR0b25zXG4gICAgYCNAbmF0aXZlLmdhbWVwYWQuYnV0dG9uc2BcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpFdmVudD4iLCI8Y2xhc3M6R2FtZXBhZD4iLCJzZWxmIiwiaGFuZGxlcyIsInN1cHBvcnRlZD8iLCJCcm93c2VyIiwic3VwcG9ydHM/IiwiPGNsYXNzOkRlZmluaXRpb24+IiwiaWQ9IiwidmFsdWUiLCJAbmF0aXZlIiwiaW5kZXg9IiwiYXQ9IiwiYXhlcz0iLCJidXR0b25zPSIsIkRlZmluaXRpb24iLCJjb25zdHJ1Y3QiLCJuYW1lIiwiZGVzYyIsImlkIiwiaW5kZXgiLCJhdCIsImF4ZXMiLCJidXR0b25zIiwiRXZlbnQiXSwibWFwcGluZ3MiOiJBQUFBQSx3Q0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWhCQSxPQUFBQztNQUFBQTs7UUFBQUE7O0FBQUFBOztRQUNFQyxJQUFBQyxTQUFBQSxDQUFRRixrQkFBUixFQUE0QkEscUJBQTVCRTtRQUVBQyxNQUFJRixJQUFKRSxpQkFBQUEsbUNBQUFBO0FBQUFBO1VBQ0VBLE9BQUFDLGFBQU9DLGNBQUFBLENBQVdGLGVBQVhFO1FBRFRGLENBQUFBO1FBSUFHO1FBQUFBOztVQUFBQTs7QUFBQUE7OztBQUNFQyxVQUFBQSxtQkFBQUEsNkJBQVFDLEtBQVJEO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRSxjQUFPRixNQUFRQztVQURuQkQsQ0FBQUE7O0FBSUFHLFVBQUFBLHNCQUFBQSxnQ0FBV0YsS0FBWEU7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVELGNBQU9DLFNBQVdGO1VBRHRCRSxDQUFBQTs7QUFJQUMsVUFBQUEsbUJBQUFBLDZCQUFRSCxLQUFSRztBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUYsY0FBT0UsYUFBZUg7VUFEMUJHLENBQUFBOztBQUlBQyxVQUFBQSxxQkFBQUEsK0JBQVVKLEtBQVZJO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFSCxjQUFPRyxRQUFVSjtVQURyQkksQ0FBQUE7VUFJQU4sT0FBQU8sd0JBQUFBLGtDQUFhTCxLQUFiSztBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUosY0FBT0ksV0FBYUw7VUFEeEJLLENBQUFBO1FBakJGUCxHQUFBQSxXQUFBQSxFQUFtQlEsZ0JBQW5CUjtRQXNCQSxJQUFBLFFBT09MLElBQUFFLGVBQUFBLENBQUFBLENBUFAsQ0FBQTtVQUFBLElBQUEsUUFBR0MsYUFBT0MsY0FBQUEsQ0FBV0wsbUJBQVhLLENBQVYsQ0FBQTtZQUNFVSxNQUFJZCxJQUFKYyxnQkFBQUEscUJBQW1CQyxJQUFELEVBQU9DLElBQXpCRjtBQUFBQTtjQUNHQSx3QkFBMEJDLElBQUtEO0FBQ3RDQTtBQUNBQTtBQUNBQTtZQUpJQSxDQUFBQTtVQURGO1FBQUE7O0FBU0FHLFFBQUFBLGtCQUFBQSxjQUFBQTtBQUFBQSxVQUFBQTs7VUFDRUEsT0FBRVQsY0FBT1M7UUFEWEEsQ0FBQUE7O0FBSUFDLFFBQUFBLHFCQUFBQSxpQkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUVWLGNBQU9VO1FBRFhBLENBQUFBOztBQUlBQyxRQUFBQSxrQkFBQUEsY0FBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUVYLGNBQU9XO1FBRFhBLENBQUFBOztBQUlBQyxRQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFFWixjQUFPWTtRQURYQSxDQUFBQTtRQUlBckIsT0FBQXNCLHVCQUFBQSxtQkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUViLGNBQU9hO1FBRFhBLENBQUFBO01BdERGdEIsR0FBQUEsV0FBQUEsRUFBZ0J1QixXQUFoQnZCO0lBRmdCRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjQxMDU0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9ldmVudC9oYXNoX2NoYW5nZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgY2xhc3MgRXZlbnRcblxuY2xhc3MgSGFzaENoYW5nZSA8IEV2ZW50XG4gIGhhbmRsZXMgJ2hhc2hjaGFuZ2UnXG5cbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5IYXNoQ2hhbmdlJ1xuICBlbmRcblxuICBjbGFzcyBEZWZpbml0aW9uIDwgRGVmaW5pdGlvblxuICAgIGRlZiBvbGQ9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLm9sZFVSTCA9ICN7dmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIG5ldz0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUubmV3VVJMID0gI3t2YWx1ZX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgSGFzaENoYW5nZUV2ZW50KCN7bmFtZX0sICN7ZGVzY30pYFxuICAgIGVuZFxuICBlbmQgaWYgc3VwcG9ydGVkP1xuXG4gIGFsaWFzX25hdGl2ZSA6b2xkLCA6b2xkVVJMXG4gIGFsaWFzX25hdGl2ZSA6bmV3LCA6bmV3VVJMXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpFdmVudD4iLCI8Y2xhc3M6SGFzaENoYW5nZT4iLCJzZWxmIiwiaGFuZGxlcyIsInN1cHBvcnRlZD8iLCJCcm93c2VyIiwic3VwcG9ydHM/IiwiPGNsYXNzOkRlZmluaXRpb24+Iiwib2xkPSIsInZhbHVlIiwiQG5hdGl2ZSIsIm5ldz0iLCJEZWZpbml0aW9uIiwiY29uc3RydWN0IiwibmFtZSIsImRlc2MiLCJhbGlhc19uYXRpdmUiLCJFdmVudCJdLCJtYXBwaW5ncyI6IkFBQUFBLDRDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7O1FBQ0VDLElBQUFDLFNBQUFBLENBQVFGLFlBQVJFO1FBRUFDLE1BQUlGLElBQUpFLGlCQUFBQSxzQ0FBQUE7QUFBQUE7VUFDRUEsT0FBQUMsYUFBT0MsY0FBQUEsQ0FBV0Ysa0JBQVhFO1FBRFRGLENBQUFBO1FBSUFHO1FBQUFBOztVQUFBQTs7QUFBQUE7OztBQUNFQyxVQUFBQSxvQkFBQUEsOEJBQVNDLEtBQVREO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRSxjQUFPRixVQUFZQztVQUR2QkQsQ0FBQUE7VUFJQUQsT0FBQUksb0JBQUFBLDhCQUFTRixLQUFURTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUQsY0FBT0MsVUFBWUY7VUFEdkJFLENBQUFBO1FBTEZKLEdBQUFBLFdBQUFBLEVBQW1CSyxnQkFBbkJMO1FBVUEsSUFBQSxRQUlPTCxJQUFBRSxlQUFBQSxDQUFBQSxDQUpQLENBQUE7VUFBQSxJQUFBLFFBQUdDLGFBQU9DLGNBQUFBLENBQVdMLG1CQUFYSyxDQUFWLENBQUE7WUFDRU8sTUFBSVgsSUFBSlcsZ0JBQUFBLHFCQUFtQkMsSUFBRCxFQUFPQyxJQUF6QkY7QUFBQUE7Y0FDRUEsT0FBQ0Esb0JBQXNCQyxJQUFLRCxFQUFJRSxJQUFLRjtZQUR2Q0EsQ0FBQUE7VUFERjtRQUFBO1FBTUFYLElBQUFjLGNBQUFBLENBQWEsS0FBYixFQUFtQixRQUFuQkE7UUFDQWYsT0FBQUMsSUFBQWMsY0FBQUEsQ0FBYSxLQUFiLEVBQW1CLFFBQW5CQTtNQXhCRmYsR0FBQUEsV0FBQUEsRUFBbUJnQixXQUFuQmhCO0lBRmdCRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjQxMTEzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9ldmVudC9wcm9ncmVzcy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgY2xhc3MgRXZlbnRcblxuY2xhc3MgUHJvZ3Jlc3MgPCBFdmVudFxuICBoYW5kbGVzICdwcm9ncmVzcycsICdsb2FkJywgJ2xvYWRlbmQnLCAnbG9hZHN0YXJ0J1xuXG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuUHJvZ3Jlc3MnXG4gIGVuZFxuXG4gIGNsYXNzIERlZmluaXRpb24gPCBEZWZpbml0aW9uXG4gICAgZGVmIGNvbXB1dGFibGU9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmNvbXB1dGFibGVMZW5ndGggPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBsb2FkZWQ9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmxvYWRlZCA9ICN7dmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIHRvdGFsPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS50b3RhbCA9ICN7dmFsdWV9YFxuICAgIGVuZFxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY29uc3RydWN0b3InXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICBgbmV3IFByb2dyZXNzRXZlbnQoI3tuYW1lfSwgI3tkZXNjfSlgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jcmVhdGUnXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICAleHtcbiAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJQcm9ncmVzc0V2ZW50XCIpO1xuICAgICAgICAgICAgZXZlbnQuaW5pdFByb2dyZXNzRXZlbnQobmFtZSwgZGVzYy5idWJibGVzLCBkZXNjLmNhbmNlbGFibGUsXG4gICAgICAgICAgICAgIGRlc2MuY29tcHV0YWJsZSwgZGVzYy5sb2FkZWQsIGRlc2MudG90YWwpO1xuXG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kIGlmIHN1cHBvcnRlZD9cblxuICBhbGlhc19uYXRpdmUgOmNvbXB1dGFibGU/LCA6Y29tcHV0YWJsZUxlbmd0aFxuICBhbGlhc19uYXRpdmUgOmxvYWRlZFxuICBhbGlhc19uYXRpdmUgOnRvdGFsXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpFdmVudD4iLCI8Y2xhc3M6UHJvZ3Jlc3M+Iiwic2VsZiIsImhhbmRsZXMiLCJzdXBwb3J0ZWQ/IiwiQnJvd3NlciIsInN1cHBvcnRzPyIsIjxjbGFzczpEZWZpbml0aW9uPiIsImNvbXB1dGFibGU9IiwidmFsdWUiLCJAbmF0aXZlIiwibG9hZGVkPSIsInRvdGFsPSIsIkRlZmluaXRpb24iLCJjb25zdHJ1Y3QiLCJuYW1lIiwiZGVzYyIsImFsaWFzX25hdGl2ZSIsIkV2ZW50Il0sIm1hcHBpbmdzIjoiQUFBQUEseUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUVoQkEsT0FBQUM7TUFBQUE7O1FBQUFBOzs7UUFDRUMsSUFBQUMsU0FBQUEsQ0FBUUYsVUFBUixFQUFvQkEsTUFBcEIsRUFBNEJBLFNBQTVCLEVBQXVDQSxXQUF2Q0U7UUFFQUMsTUFBSUYsSUFBSkUsaUJBQUFBLG9DQUFBQTtBQUFBQTtVQUNFQSxPQUFBQyxhQUFPQyxjQUFBQSxDQUFXRixnQkFBWEU7UUFEVEYsQ0FBQUE7UUFJQUc7UUFBQUE7O1VBQUFBOztBQUFBQTs7O0FBQ0VDLFVBQUFBLDJCQUFBQSxxQ0FBZ0JDLEtBQWhCRDtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUUsY0FBT0Ysb0JBQXNCQztVQURqQ0QsQ0FBQUE7O0FBSUFHLFVBQUFBLHVCQUFBQSxpQ0FBWUYsS0FBWkU7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVELGNBQU9DLFVBQVlGO1VBRHZCRSxDQUFBQTtVQUlBSixPQUFBSyxzQkFBQUEsZ0NBQVdILEtBQVhHO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRixjQUFPRSxTQUFXSDtVQUR0QkcsQ0FBQUE7UUFURkwsR0FBQUEsV0FBQUEsRUFBbUJNLGdCQUFuQk47UUFjQSxJQUFBLFFBY09MLElBQUFFLGVBQUFBLENBQUFBLENBZFAsQ0FBQTtVQUFBLElBQUEsUUFBR0MsYUFBT0MsY0FBQUEsQ0FBV0wsbUJBQVhLLENBQVYsQ0FBQTtZQUNFUSxNQUFJWixJQUFKWSxnQkFBQUEscUJBQW1CQyxJQUFELEVBQU9DLElBQXpCRjtBQUFBQTtjQUNFQSxPQUFDQSxrQkFBb0JDLElBQUtELEVBQUlFLElBQUtGO1lBRHJDQSxDQUFBQTtVQURGLE9BSUEsSUFBQSxRQUFNVCxhQUFPQyxjQUFBQSxDQUFXTCxjQUFYSyxDQUFiLENBQUE7WUFDRVEsTUFBSVosSUFBSlksZ0JBQUFBLHFCQUFtQkMsSUFBRCxFQUFPQyxJQUF6QkY7QUFBQUE7O0FBRUpBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtZQVBJQSxDQUFBQTtVQURGO1FBSkE7UUFnQkFaLElBQUFlLGNBQUFBLENBQWEsYUFBYixFQUEyQixrQkFBM0JBO1FBQ0FmLElBQUFlLGNBQUFBLENBQWEsUUFBYkE7UUFDQWhCLE9BQUFDLElBQUFlLGNBQUFBLENBQWEsT0FBYkE7TUF2Q0ZoQixHQUFBQSxXQUFBQSxFQUFpQmlCLFdBQWpCakI7SUFGZ0JELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6NDExOTAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L3BhZ2VfdHJhbnNpdGlvbi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgY2xhc3MgRXZlbnRcblxuY2xhc3MgUGFnZVRyYW5zaXRpb24gPCBFdmVudFxuICBoYW5kbGVzICdwYWdlaGlkZScsICdwYWdlc2hvdydcblxuICBkZWYgc2VsZi5zdXBwb3J0ZWQ/XG4gICAgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LlBhZ2VUcmFuc2l0aW9uJ1xuICBlbmRcblxuICBjbGFzcyBEZWZpbml0aW9uIDwgRGVmaW5pdGlvblxuICAgIGRlZiBwZXJzaXN0ZWQ9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLnBlcnNpc3RlZCA9ICN7dmFsdWV9YFxuICAgIGVuZFxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuUGFnZVRyYW5zaXRpb24nXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICBgbmV3IFBhZ2VUcmFuc2l0aW9uRXZlbnQobmFtZSwgZGVzYylgXG4gICAgZW5kXG4gIGVuZCBpZiBzdXBwb3J0ZWQ/XG5cbiAgYWxpYXNfbmF0aXZlIDpwZXJzaXN0ZWQ/LCA6cGVyc2lzdGVkXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpFdmVudD4iLCI8Y2xhc3M6UGFnZVRyYW5zaXRpb24+Iiwic2VsZiIsImhhbmRsZXMiLCJzdXBwb3J0ZWQ/IiwiQnJvd3NlciIsInN1cHBvcnRzPyIsIjxjbGFzczpEZWZpbml0aW9uPiIsInBlcnNpc3RlZD0iLCJ2YWx1ZSIsIkBuYXRpdmUiLCJEZWZpbml0aW9uIiwiY29uc3RydWN0IiwibmFtZSIsImRlc2MiLCJhbGlhc19uYXRpdmUiLCJFdmVudCJdLCJtYXBwaW5ncyI6IkFBQUFBLGdEQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7O1FBQ0VDLElBQUFDLFNBQUFBLENBQVFGLFVBQVIsRUFBb0JBLFVBQXBCRTtRQUVBQyxNQUFJRixJQUFKRSxpQkFBQUEsMENBQUFBO0FBQUFBO1VBQ0VBLE9BQUFDLGFBQU9DLGNBQUFBLENBQVdGLHNCQUFYRTtRQURURixDQUFBQTtRQUlBRztRQUFBQTs7VUFBQUE7O0FBQUFBO1VBQ0VBLE9BQUFDLDBCQUFBQSxvQ0FBZUMsS0FBZkQ7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVFLGNBQU9GLGFBQWVDO1VBRDFCRCxDQUFBQTtRQURGRCxHQUFBQSxXQUFBQSxFQUFtQkksZ0JBQW5CSjtRQU1BLElBQUEsUUFJT0wsSUFBQUUsZUFBQUEsQ0FBQUEsQ0FKUCxDQUFBO1VBQUEsSUFBQSxRQUFHQyxhQUFPQyxjQUFBQSxDQUFXTCxzQkFBWEssQ0FBVixDQUFBO1lBQ0VNLE1BQUlWLElBQUpVLGdCQUFBQSxxQkFBbUJDLElBQUQsRUFBT0MsSUFBekJGO0FBQUFBO2NBQ0VBLE9BQUNBLG1DQUFEQTtZQURGQSxDQUFBQTtVQURGO1FBQUE7UUFNQVgsT0FBQUMsSUFBQWEsY0FBQUEsQ0FBYSxZQUFiLEVBQTBCLFdBQTFCQTtNQW5CRmQsR0FBQUEsV0FBQUEsRUFBdUJlLFdBQXZCZjtJQUZnQkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo0MTI0MSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQvcG9wX3N0YXRlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBjbGFzcyBFdmVudFxuXG5jbGFzcyBQb3BTdGF0ZSA8IEV2ZW50XG4gIGhhbmRsZXMgJ3BvcHN0YXRlJ1xuXG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuUG9wU3RhdGUnXG4gIGVuZFxuXG4gIGNsYXNzIERlZmluaXRpb24gPCBEZWZpbml0aW9uXG4gICAgZGVmIHN0YXRlPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5zdGF0ZSA9ICN7dmFsdWV9YFxuICAgIGVuZFxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY29uc3RydWN0b3InXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICBgbmV3IFBvcFN0YXRlRXZlbnQoI3tuYW1lfSwgI3tkZXNjfSlgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jcmVhdGUnXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICAleHtcbiAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ1BvcFN0YXRlRXZlbnQnKTtcbiAgICAgICAgICAgIGV2ZW50LmluaXRQb3BTdGF0ZUV2ZW50KG5hbWUsIGRlc2MuYnViYmxlcywgZGVzYy5jYW5jZWxhYmxlLFxuICAgICAgICAgICAgICBkZXNjLnN0YXRlKTtcblxuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZCBpZiBzdXBwb3J0ZWQ/XG5cbiAgYWxpYXNfbmF0aXZlIDpzdGF0ZVxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8Y2xhc3M6RXZlbnQ+IiwiPGNsYXNzOlBvcFN0YXRlPiIsInNlbGYiLCJoYW5kbGVzIiwic3VwcG9ydGVkPyIsIkJyb3dzZXIiLCJzdXBwb3J0cz8iLCI8Y2xhc3M6RGVmaW5pdGlvbj4iLCJzdGF0ZT0iLCJ2YWx1ZSIsIkBuYXRpdmUiLCJEZWZpbml0aW9uIiwiY29uc3RydWN0IiwibmFtZSIsImRlc2MiLCJhbGlhc19uYXRpdmUiLCJFdmVudCJdLCJtYXBwaW5ncyI6IkFBQUFBLDBDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7O1FBQ0VDLElBQUFDLFNBQUFBLENBQVFGLFVBQVJFO1FBRUFDLE1BQUlGLElBQUpFLGlCQUFBQSxvQ0FBQUE7QUFBQUE7VUFDRUEsT0FBQUMsYUFBT0MsY0FBQUEsQ0FBV0YsZ0JBQVhFO1FBRFRGLENBQUFBO1FBSUFHO1FBQUFBOztVQUFBQTs7QUFBQUE7VUFDRUEsT0FBQUMsc0JBQUFBLGdDQUFXQyxLQUFYRDtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUUsY0FBT0YsU0FBV0M7VUFEdEJELENBQUFBO1FBREZELEdBQUFBLFdBQUFBLEVBQW1CSSxnQkFBbkJKO1FBTUEsSUFBQSxRQWNPTCxJQUFBRSxlQUFBQSxDQUFBQSxDQWRQLENBQUE7VUFBQSxJQUFBLFFBQUdDLGFBQU9DLGNBQUFBLENBQVdMLG1CQUFYSyxDQUFWLENBQUE7WUFDRU0sTUFBSVYsSUFBSlUsZ0JBQUFBLHFCQUFtQkMsSUFBRCxFQUFPQyxJQUF6QkY7QUFBQUE7Y0FDRUEsT0FBQ0Esa0JBQW9CQyxJQUFLRCxFQUFJRSxJQUFLRjtZQURyQ0EsQ0FBQUE7VUFERixPQUlBLElBQUEsUUFBTVAsYUFBT0MsY0FBQUEsQ0FBV0wsY0FBWEssQ0FBYixDQUFBO1lBQ0VNLE1BQUlWLElBQUpVLGdCQUFBQSxxQkFBbUJDLElBQUQsRUFBT0MsSUFBekJGO0FBQUFBOztBQUVKQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7WUFQSUEsQ0FBQUE7VUFERjtRQUpBO1FBZ0JBWCxPQUFBQyxJQUFBYSxjQUFBQSxDQUFhLE9BQWJBO01BN0JGZCxHQUFBQSxXQUFBQSxFQUFpQmUsV0FBakJmO0lBRmdCRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjQxMzAzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9ldmVudC9zdG9yYWdlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBjbGFzcyBFdmVudFxuXG5jbGFzcyBTdG9yYWdlIDwgRXZlbnRcbiAgaGFuZGxlcyAnc3RvcmFnZSdcblxuICBkZWYgc2VsZi5zdXBwb3J0ZWQ/XG4gICAgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LlN0b3JhZ2UnXG4gIGVuZFxuXG4gIGNsYXNzIERlZmluaXRpb24gPCBEZWZpbml0aW9uXG4gICAgZGVmIGtleT0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUua2V5ID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgbmV3PSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5uZXdWYWx1ZSA9ICN7dmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIG9sZD0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUub2xkVmFsdWUgPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBhcmVhPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5zdG9yYWdlQXJlYSA9ICN7dmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIHVybD0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUudXJsID0gI3t2YWx1ZX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgU3RvcmFnZUV2ZW50KCN7bmFtZX0sICN7ZGVzY30pYFxuICAgIGVuZFxuICBlbmQgaWYgc3VwcG9ydGVkP1xuXG4gIGFsaWFzX25hdGl2ZSA6a2V5XG4gIGFsaWFzX25hdGl2ZSA6bmV3LCA6bmV3VmFsdWVcbiAgYWxpYXNfbmF0aXZlIDpvbGQsIDpvbGRWYWx1ZVxuICBhbGlhc19uYXRpdmUgOmFyZWEsIDpzdG9yYWdlQXJlYVxuICBhbGlhc19uYXRpdmUgOnVybFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8Y2xhc3M6RXZlbnQ+IiwiPGNsYXNzOlN0b3JhZ2U+Iiwic2VsZiIsImhhbmRsZXMiLCJzdXBwb3J0ZWQ/IiwiQnJvd3NlciIsInN1cHBvcnRzPyIsIjxjbGFzczpEZWZpbml0aW9uPiIsImtleT0iLCJ2YWx1ZSIsIkBuYXRpdmUiLCJuZXc9Iiwib2xkPSIsImFyZWE9IiwidXJsPSIsIkRlZmluaXRpb24iLCJjb25zdHJ1Y3QiLCJuYW1lIiwiZGVzYyIsImFsaWFzX25hdGl2ZSIsIkV2ZW50Il0sIm1hcHBpbmdzIjoiQUFBQUEsd0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUVoQkEsT0FBQUM7TUFBQUE7O1FBQUFBOzs7UUFDRUMsSUFBQUMsU0FBQUEsQ0FBUUYsU0FBUkU7UUFFQUMsTUFBSUYsSUFBSkUsaUJBQUFBLG1DQUFBQTtBQUFBQTtVQUNFQSxPQUFBQyxhQUFPQyxjQUFBQSxDQUFXRixlQUFYRTtRQURURixDQUFBQTtRQUlBRztRQUFBQTs7VUFBQUE7O0FBQUFBOzs7QUFDRUMsVUFBQUEsb0JBQUFBLDhCQUFTQyxLQUFURDtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUUsY0FBT0YsT0FBU0M7VUFEcEJELENBQUFBOztBQUlBRyxVQUFBQSxvQkFBQUEsOEJBQVNGLEtBQVRFO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRCxjQUFPQyxZQUFjRjtVQUR6QkUsQ0FBQUE7O0FBSUFDLFVBQUFBLG9CQUFBQSw4QkFBU0gsS0FBVEc7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVGLGNBQU9FLFlBQWNIO1VBRHpCRyxDQUFBQTs7QUFJQUMsVUFBQUEscUJBQUFBLCtCQUFVSixLQUFWSTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUgsY0FBT0csZUFBaUJKO1VBRDVCSSxDQUFBQTtVQUlBTixPQUFBTyxvQkFBQUEsOEJBQVNMLEtBQVRLO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFSixjQUFPSSxPQUFTTDtVQURwQkssQ0FBQUE7UUFqQkZQLEdBQUFBLFdBQUFBLEVBQW1CUSxnQkFBbkJSO1FBc0JBLElBQUEsUUFJT0wsSUFBQUUsZUFBQUEsQ0FBQUEsQ0FKUCxDQUFBO1VBQUEsSUFBQSxRQUFHQyxhQUFPQyxjQUFBQSxDQUFXTCxtQkFBWEssQ0FBVixDQUFBO1lBQ0VVLE1BQUlkLElBQUpjLGdCQUFBQSxxQkFBbUJDLElBQUQsRUFBT0MsSUFBekJGO0FBQUFBO2NBQ0VBLE9BQUNBLGlCQUFtQkMsSUFBS0QsRUFBSUUsSUFBS0Y7WUFEcENBLENBQUFBO1VBREY7UUFBQTtRQU1BZCxJQUFBaUIsY0FBQUEsQ0FBYSxLQUFiQTtRQUNBakIsSUFBQWlCLGNBQUFBLENBQWEsS0FBYixFQUFtQixVQUFuQkE7UUFDQWpCLElBQUFpQixjQUFBQSxDQUFhLEtBQWIsRUFBbUIsVUFBbkJBO1FBQ0FqQixJQUFBaUIsY0FBQUEsQ0FBYSxNQUFiLEVBQW9CLGFBQXBCQTtRQUNBbEIsT0FBQUMsSUFBQWlCLGNBQUFBLENBQWEsS0FBYkE7TUF2Q0ZsQixHQUFBQSxXQUFBQSxFQUFnQm1CLFdBQWhCbkI7SUFGZ0JELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6NDEzODMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L3RvdWNoLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBjbGFzcyBFdmVudFxuXG5jbGFzcyBUb3VjaCA8IEV2ZW50XG4gIGhhbmRsZXMgJ3RvdWNoY2FuY2VsJywgJ3RvdWNoZW5kJywgJ3RvdWNobGVhdmUnLCAndG91Y2htb3ZlJywgJ3RvdWNoc3RhcnQnXG5cbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5Ub3VjaCdcbiAgZW5kXG5cbiAgY2xhc3MgRGVmaW5pdGlvbiA8IERlZmluaXRpb25cbiAgICBkZWYgYWx0IVxuICAgICAgYCNAbmF0aXZlLmFsdEtleSA9IHRydWVgXG4gICAgZW5kXG5cbiAgICBkZWYgY3RybCFcbiAgICAgIGAjQG5hdGl2ZS5jdHJsS2V5ID0gdHJ1ZWBcbiAgICBlbmRcblxuICAgIGRlZiBtZXRhIVxuICAgICAgYCNAbmF0aXZlLm1ldGFLZXkgPSB0cnVlYFxuICAgIGVuZFxuXG4gICAgZGVmIHNoaWZ0IVxuICAgICAgYCNAbmF0aXZlLnNoaWZ0S2V5ID0gdHJ1ZWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNvbnN0cnVjdG9yJ1xuICAgIGRlZiBzZWxmLmNvbnN0cnVjdChuYW1lLCBkZXNjKVxuICAgICAgYG5ldyBUb3VjaEV2ZW50KCN7bmFtZX0sICN7ZGVzY30pYFxuICAgIGVuZFxuICBlbmQgaWYgc3VwcG9ydGVkP1xuXG4gIGFsaWFzX25hdGl2ZSA6YWx0PywgOmFsdEtleVxuICBhbGlhc19uYXRpdmUgOmN0cmw/LCA6Y3RybEtleVxuICBhbGlhc19uYXRpdmUgOm1ldGE/LCA6bWV0YUtleVxuICBhbGlhc19uYXRpdmUgOnNoaWZ0PywgOnNoaWZ0S2V5XG5cbiAgIyBUT0RPOiBpbXBsZW1lbnQgdG91Y2hlcyBhbmQgdGFyZ2V0VG91Y2hlc1xuXG4gIGRlZiBjYW5jZWw/XG4gICAgbmFtZS5kb3duY2FzZSA9PSAndG91Y2hjYW5jZWwnXG4gIGVuZFxuXG4gIGRlZiBlbmQ/XG4gICAgbmFtZS5kb3duY2FzZSA9PSAndG91Y2hlbmQnXG4gIGVuZFxuXG4gIGRlZiBsZWF2ZT9cbiAgICBuYW1lLmRvd25jYXNlID09ICd0b3VjaGxlYXZlJ1xuICBlbmRcblxuICBkZWYgbW92ZT9cbiAgICBuYW1lLmRvd25jYXNlID09ICd0b3VjaG1vdmUnXG4gIGVuZFxuXG4gIGRlZiBzdGFydD9cbiAgICBuYW1lLmRvd25jYXNlID09ICd0b3VjaHN0YXJ0J1xuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkV2ZW50PiIsIjxjbGFzczpUb3VjaD4iLCJzZWxmIiwiaGFuZGxlcyIsInN1cHBvcnRlZD8iLCJCcm93c2VyIiwic3VwcG9ydHM/IiwiPGNsYXNzOkRlZmluaXRpb24+IiwiYWx0ISIsIkBuYXRpdmUiLCJjdHJsISIsIm1ldGEhIiwic2hpZnQhIiwiRGVmaW5pdGlvbiIsImNvbnN0cnVjdCIsIm5hbWUiLCJkZXNjIiwiYWxpYXNfbmF0aXZlIiwiY2FuY2VsPyIsImRvd25jYXNlIiwiPT0iLCJlbmQ/IiwibGVhdmU/IiwibW92ZT8iLCJzdGFydD8iLCJFdmVudCJdLCJtYXBwaW5ncyI6IkFBQUFBLHNDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7O1FBQ0VDLElBQUFDLFNBQUFBLENBQVFGLGFBQVIsRUFBdUJBLFVBQXZCLEVBQW1DQSxZQUFuQyxFQUFpREEsV0FBakQsRUFBOERBLFlBQTlERTtRQUVBQyxNQUFJRixJQUFKRSxpQkFBQUEsaUNBQUFBO0FBQUFBO1VBQ0VBLE9BQUFDLGFBQU9DLGNBQUFBLENBQVdGLGFBQVhFO1FBRFRGLENBQUFBO1FBSUFHO1FBQUFBOztVQUFBQTs7QUFBQUE7OztBQUNFQyxVQUFBQSxvQkFBQUEsZ0NBQUFBO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFQyxjQUFPRDtVQURYQSxDQUFBQTs7QUFJQUUsVUFBQUEscUJBQUFBLGlDQUFBQTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUQsY0FBT0M7VUFEWEEsQ0FBQUE7O0FBSUFDLFVBQUFBLHFCQUFBQSxpQ0FBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVGLGNBQU9FO1VBRFhBLENBQUFBO1VBSUFKLE9BQUFLLHNCQUFBQSxrQ0FBQUE7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVILGNBQU9HO1VBRFhBLENBQUFBO1FBYkZMLEdBQUFBLFdBQUFBLEVBQW1CTSxnQkFBbkJOO1FBa0JBLElBQUEsUUFJT0wsSUFBQUUsZUFBQUEsQ0FBQUEsQ0FKUCxDQUFBO1VBQUEsSUFBQSxRQUFHQyxhQUFPQyxjQUFBQSxDQUFXTCxtQkFBWEssQ0FBVixDQUFBO1lBQ0VRLE1BQUlaLElBQUpZLGdCQUFBQSxxQkFBbUJDLElBQUQsRUFBT0MsSUFBekJGO0FBQUFBO2NBQ0VBLE9BQUNBLGVBQWlCQyxJQUFLRCxFQUFJRSxJQUFLRjtZQURsQ0EsQ0FBQUE7VUFERjtRQUFBO1FBTUFaLElBQUFlLGNBQUFBLENBQWEsTUFBYixFQUFvQixRQUFwQkE7UUFDQWYsSUFBQWUsY0FBQUEsQ0FBYSxPQUFiLEVBQXFCLFNBQXJCQTtRQUNBZixJQUFBZSxjQUFBQSxDQUFhLE9BQWIsRUFBcUIsU0FBckJBO1FBQ0FmLElBQUFlLGNBQUFBLENBQWEsUUFBYixFQUFzQixVQUF0QkE7O0FBSUFDLFFBQUFBLHVCQUFBQSw4QkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUFoQixJQUFBYSxNQUFBQSxDQUFBQSxDQUFJSSxVQUFBQSxDQUFBQSxDQUFVQyxPQUFBQSxDQUFHRixhQUFIRTtRQURoQkYsQ0FBQUE7O0FBSUFHLFFBQUFBLG9CQUFBQSwyQkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUFuQixJQUFBYSxNQUFBQSxDQUFBQSxDQUFJSSxVQUFBQSxDQUFBQSxDQUFVQyxPQUFBQSxDQUFHQyxVQUFIRDtRQURoQkMsQ0FBQUE7O0FBSUFDLFFBQUFBLHNCQUFBQSw2QkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUFwQixJQUFBYSxNQUFBQSxDQUFBQSxDQUFJSSxVQUFBQSxDQUFBQSxDQUFVQyxPQUFBQSxDQUFHRSxZQUFIRjtRQURoQkUsQ0FBQUE7O0FBSUFDLFFBQUFBLHFCQUFBQSw0QkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUFyQixJQUFBYSxNQUFBQSxDQUFBQSxDQUFJSSxVQUFBQSxDQUFBQSxDQUFVQyxPQUFBQSxDQUFHRyxXQUFISDtRQURoQkcsQ0FBQUE7UUFJQXRCLE9BQUF1QixzQkFBQUEsOEJBQUFBO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFBdEIsSUFBQWEsTUFBQUEsQ0FBQUEsQ0FBSUksVUFBQUEsQ0FBQUEsQ0FBVUMsT0FBQUEsQ0FBR0ksWUFBSEo7UUFEaEJJLENBQUFBO01BdERGdkIsR0FBQUEsV0FBQUEsRUFBY3dCLFdBQWR4QjtJQUZnQkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo0MTQ4NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQvc2Vuc29yLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBjbGFzcyBFdmVudFxuXG5jbGFzcyBTZW5zb3IgPCBFdmVudFxuICBoYW5kbGVzICdjb21wYXNzbmVlZHNjYWxpYnJhdGlvbicsICd1c2VycHJveGltaXR5J1xuXG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuU2Vuc29yJ1xuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY29uc3RydWN0b3InXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICBgbmV3IFNlbnNvckV2ZW50KCN7bmFtZX0sICN7ZGVzY30pYFxuICAgIGVuZFxuICBlbmQgaWYgc3VwcG9ydGVkP1xuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8Y2xhc3M6RXZlbnQ+IiwiPGNsYXNzOlNlbnNvcj4iLCJzZWxmIiwiaGFuZGxlcyIsInN1cHBvcnRlZD8iLCJCcm93c2VyIiwic3VwcG9ydHM/IiwiY29uc3RydWN0IiwibmFtZSIsImRlc2MiLCJFdmVudCJdLCJtYXBwaW5ncyI6IkFBQUFBLHVDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7O1FBQ0VDLElBQUFDLFNBQUFBLENBQVFGLHlCQUFSLEVBQW1DQSxlQUFuQ0U7UUFFQUMsTUFBSUYsSUFBSkUsaUJBQUFBLGtDQUFBQTtBQUFBQTtVQUNFQSxPQUFBQyxhQUFPQyxjQUFBQSxDQUFXRixjQUFYRTtRQURURixDQUFBQTtRQUlBLElBQUEsUUFJT0YsSUFBQUUsZUFBQUEsQ0FBQUEsQ0FKUCxDQUFBO1VBQUEsSUFBQSxRQUFHQyxhQUFPQyxjQUFBQSxDQUFXTCxtQkFBWEssQ0FBVixDQUFBO1lBQ0VMLE9BQUFNLE1BQUlMLElBQUpLLGdCQUFBQSxxQkFBbUJDLElBQUQsRUFBT0MsSUFBekJGO0FBQUFBO2NBQ0VBLE9BQUNBLGdCQUFrQkMsSUFBS0QsRUFBSUUsSUFBS0Y7WUFEbkNBLENBQUFBO1VBREY7WUFURk4sT0FBQTtVQVNFO1FBQUE7VUFURkEsT0FBQTtRQVNFO01BUEZBLEdBQUFBLFdBQUFBLEVBQWVTLFdBQWZUO0lBRmdCRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjQxNTI3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnVmZmVyL2FycmF5LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxuXG5jbGFzcyBCdWZmZXJcbiAgY2xhc3MgQXJyYXlcbiAgICBpbmNsdWRlIE5hdGl2ZTo6V3JhcHBlclxuXG4gICAgZGVmIHNlbGYuZm9yKGJpdHMsIHR5cGUpXG4gICAgICAkJFtcIiN7QnVmZmVyLm5hbWVfZm9yIGJpdHMsIHR5cGV9QXJyYXlcIl1cbiAgICBlbmRcblxuICAgIGluY2x1ZGUgRW51bWVyYWJsZVxuXG4gICAgYXR0cl9yZWFkZXIgOmJ1ZmZlciwgOnR5cGVcblxuICAgIGRlZiBpbml0aWFsaXplKGJ1ZmZlciwgYml0cyA9IG5pbCwgdHlwZSA9IG5pbClcbiAgICAgIGlmIE5hdGl2ZSA9PSBidWZmZXJcbiAgICAgICAgc3VwZXIoYnVmZmVyKVxuICAgICAgZWxzZVxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIga2xhc3MgPSAje0FycmF5LmZvcihiaXRzLCB0eXBlKX07XG5cbiAgICAgICAgICAje3N1cGVyKGBuZXcga2xhc3MoI3tidWZmZXIudG9fbn0pYCl9XG4gICAgICAgIH1cbiAgICAgIGVuZFxuXG4gICAgICBAYnVmZmVyID0gYnVmZmVyXG4gICAgICBAdHlwZSAgID0gdHlwZVxuICAgIGVuZFxuXG4gICAgZGVmIGJpdHNcbiAgICAgIGAje0BuYXRpdmV9LkJZVEVTX1BFUl9FTEVNRU5UICogOGBcbiAgICBlbmRcblxuICAgIGRlZiBbXShpbmRleCwgb2Zmc2V0ID0gbmlsKVxuICAgICAgb2Zmc2V0ID8gYCN7QG5hdGl2ZX0uc3ViYXJyYXkoaW5kZXgsIG9mZnNldClgIDogYCN7QG5hdGl2ZX1baW5kZXhdYFxuICAgIGVuZFxuXG4gICAgZGVmIFtdPShpbmRleCwgdmFsdWUpXG4gICAgICBgI3tAbmF0aXZlfVtpbmRleF0gPSB2YWx1ZWBcbiAgICBlbmRcblxuICAgIGRlZiBieXRlc2l6ZVxuICAgICAgYCN7QG5hdGl2ZX0uYnl0ZUxlbmd0aGBcbiAgICBlbmRcblxuICAgIGRlZiBlYWNoXG4gICAgICByZXR1cm4gZW51bV9mb3IgOmVhY2ggdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgICAleHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9ICN7QG5hdGl2ZX0ubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAje3lpZWxkIGAje0BuYXRpdmV9W2ldYH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmXG4gICAgZW5kXG5cbiAgICBkZWYgbGVuZ3RoXG4gICAgICBgI3tAbmF0aXZlfS5sZW5ndGhgXG4gICAgZW5kXG5cbiAgICBkZWYgbWVyZ2UhKG90aGVyLCBvZmZzZXQgPSB1bmRlZmluZWQpXG4gICAgICBgI3tAbmF0aXZlfS5zZXQoI3tvdGhlci50b19ufSwgb2Zmc2V0KWBcbiAgICBlbmRcblxuICAgIGFsaWFzIHNpemUgbGVuZ3RoXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpCdWZmZXI+IiwiPGNsYXNzOkFycmF5PiIsInNlbGYiLCJpbmNsdWRlIiwiTmF0aXZlOjpXcmFwcGVyIiwiTmF0aXZlIiwiZm9yIiwiYml0cyIsInR5cGUiLCIkJCIsIltdIiwiQnVmZmVyIiwibmFtZV9mb3IiLCJFbnVtZXJhYmxlIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiYnVmZmVyIiwiQXJyYXkiLCJ0b19uIiwiQGJ1ZmZlciIsIkB0eXBlIiwiQG5hdGl2ZSIsImluZGV4Iiwib2Zmc2V0IiwiW109IiwidmFsdWUiLCJieXRlc2l6ZSIsImVhY2giLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsImxlbmd0aCIsIm1lcmdlISIsIm90aGVyIl0sIm1hcHBpbmdzIjoiQUFBQUEsK0JBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBQztJQUFBQTs7TUFBQUE7O0FBQUFBOztNQUNFQyxJQUFBQyxTQUFBQSxDQUFRQyxJQUFBQyxZQUFBRCxZQUFSRDtNQUVBRyxNQUFJSixJQUFKSSxVQUFBQSxzQkFBYUMsSUFBRCxFQUFPQyxJQUFuQkY7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUFHLFFBQUVDLE9BQUFBLENBQUMsRUFBQSxHQUFBLENBQUdDLFlBQU1DLFVBQUFBLENBQVVMLElBQWhCLEVBQXNCQyxJQUFoQkksQ0FBVCxDQUFBLEdBQThCTixPQUEvQkk7TUFESkosQ0FBQUE7TUFJQUosSUFBQUMsU0FBQUEsQ0FBUVUsZ0JBQVJWO01BRUFELElBQUFZLGFBQUFBLENBQVksUUFBWixFQUFxQixNQUFyQkE7O0FBRUFDLE1BQUFBLDBCQUFBQSxzQkFBZUMsTUFBRCxFQUFTVCxJQUFULEVBQXFCQyxJQUFuQ087QUFBQUEsUUFBQUE7O1FBQUFBOztRQUF1Qix5QkFBTztRQUFLLHlCQUFPO1FBQ3hDLElBQUEsTUFBR1YsWUFBSCxFQUFhVyxNQUFiLENBQUE7VUFDRSxPQUFBZCxJQUFBLEVBQUEsMERBQUEsY0FBQSxFQUFBLENBQU1jLE1BQU4sQ0FBQSxFQUFBLElBQUE7UUFERjs7QUFJTkQsc0JBQXdCRSxXQUFLWCxLQUFBQSxDQUFLQyxJQUFWLEVBQWdCQyxJQUFYRixDQUFpQlM7O0FBRTlDQSxVQUFZLE9BQUFiLElBQUEsRUFBQSwwREFBQSxjQUFBLEVBQUEsQ0FBT2EsVUFBWUMsTUFBTUUsTUFBQUEsQ0FBQUEsQ0FBTUgsQ0FBL0IsQ0FBQSxFQUFBLElBQUE7QUFDWkE7UUFQTTtRQVVBSSxjQUFVSDtRQUNWRCxPQUFBSyxDQUFBQSxZQUFVWixJQUFWWTtNQVpGTCxDQUFBQSxJQUFBQTs7QUFlQVIsTUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBR2MsY0FBUWQ7TUFEYkEsQ0FBQUE7O0FBSUFHLE1BQUFBLGtCQUFBQSxxQkFBT1ksS0FBRCxFQUFRQyxNQUFkYjtBQUFBQSxRQUFBQTs7O1FBQWMsNkJBQVM7UUFDckIsSUFBQSxRQUFBYSxNQUFBLENBQUE7VUFBU2IsT0FBR1csY0FBUVg7UUFBcEI7VUFBZ0RBLE9BQUdXLGNBQVFYO1FBQTNEO01BREZBLENBQUFBLElBQUFBOztBQUlBYyxNQUFBQSxtQkFBQUEsd0JBQVFGLEtBQUQsRUFBUUcsS0FBZkQ7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUdILGNBQVFHO01BRGJBLENBQUFBOztBQUlBRSxNQUFBQSx3QkFBQUEsb0JBQUFBO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFHTCxjQUFRSztNQURiQSxDQUFBQTs7QUFJQUMsTUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxRQUFBQTs7UUFBQUE7O1FBQ0UsS0FBNkJDLGdCQUE3QjtVQUFBLE9BQU8xQixJQUFBMkIsVUFBQUEsQ0FBUyxNQUFUQTtRQUFQOztBQUdORixpQ0FBbUNOLGNBQVFNO0FBQzNDQSxVQUFZLG9CQUFTTixjQUFRTSxHQUFqQjtBQUNaQTtBQUNBQTtRQUVNQSxPQUFBekI7TUFURnlCLENBQUFBOztBQVlBRyxNQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFHVCxjQUFRUztNQURiQSxDQUFBQTs7QUFJQUMsTUFBQUEsc0JBQUFBLDZCQUFXQyxLQUFELEVBQVFULE1BQWxCUTtBQUFBQSxRQUFBQTs7OztRQUNFQSxPQUFHVixjQUFRVSxLQUFPQyxLQUFLZCxNQUFBQSxDQUFBQSxDQUFNYTtNQUQvQkEsQ0FBQUEsSUFBQUE7TUFJQTlCLE9BQUEsYUFBTSxNQUFOLEVBQVcsUUFBWDtJQTlERkEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFERkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFGQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjQxNjM2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnVmZmVyL3ZpZXcucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBiYWNrdGlja19qYXZhc2NyaXB0OiB0cnVlXG5cbmNsYXNzIEJ1ZmZlclxuICBjbGFzcyBWaWV3XG4gICAgaW5jbHVkZSBOYXRpdmU6OldyYXBwZXJcblxuICAgIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICAgICEkJFs6RGF0YVZpZXddLm5pbD9cbiAgICBlbmRcblxuICAgIGF0dHJfcmVhZGVyIDpidWZmZXIsIDpvZmZzZXRcblxuICAgIGRlZiBpbml0aWFsaXplKGJ1ZmZlciwgb2Zmc2V0ID0gbmlsLCBsZW5ndGggPSBuaWwpXG4gICAgICBpZiBuYXRpdmU/KGJ1ZmZlcilcbiAgICAgICAgc3VwZXIoYnVmZmVyKVxuICAgICAgZWxzaWYgb2Zmc2V0ICYmIGxlbmd0aFxuICAgICAgICBzdXBlcihgbmV3IERhdGFWaWV3KCN7YnVmZmVyLnRvX259LCAje29mZnNldC50b19ufSwgI3tsZW5ndGgudG9fbn0pYClcbiAgICAgIGVsc2lmIG9mZnNldFxuICAgICAgICBzdXBlcihgbmV3IERhdGFWaWV3KCN7YnVmZmVyLnRvX259LCAje29mZnNldC50b19ufSlgKVxuICAgICAgZWxzZVxuICAgICAgICBzdXBlcihgbmV3IERhdGFWaWV3KCN7YnVmZmVyLnRvX259KWApXG4gICAgICBlbmRcblxuICAgICAgQGJ1ZmZlciA9IGJ1ZmZlclxuICAgICAgQG9mZnNldCA9IG9mZnNldFxuICAgIGVuZFxuXG4gICAgZGVmIGxlbmd0aFxuICAgICAgYCN7QG5hdGl2ZX0uYnl0ZUxlbmd0aGBcbiAgICBlbmRcblxuICAgIGRlZiBnZXQob2Zmc2V0LCBiaXRzID0gOCwgdHlwZSA9IDp1bnNpZ25lZCwgbGl0dGxlID0gZmFsc2UpXG4gICAgICBgI3tAbmF0aXZlfVtcImdldFwiICsgI3tCdWZmZXIubmFtZV9mb3IgYml0cywgdHlwZX1dKG9mZnNldCwgbGl0dGxlKWBcbiAgICBlbmRcblxuICAgIGFsaWFzIFtdIGdldFxuXG4gICAgZGVmIHNldChvZmZzZXQsIHZhbHVlLCBiaXRzID0gOCwgdHlwZSA9IDp1bnNpZ25lZCwgbGl0dGxlID0gZmFsc2UpXG4gICAgICBgI3tAbmF0aXZlfVtcInNldFwiICsgI3tCdWZmZXIubmFtZV9mb3IgYml0cywgdHlwZX1dKG9mZnNldCwgdmFsdWUsIGxpdHRsZSlgXG4gICAgZW5kXG5cbiAgICBhbGlhcyBbXT0gc2V0XG5cbiAgICBkZWYgZ2V0X2ludDgob2Zmc2V0LCBsaXR0bGUgPSBmYWxzZSlcbiAgICAgIGAje0BuYXRpdmV9LmdldEludDgob2Zmc2V0LCBsaXR0bGUpYFxuICAgIGVuZFxuXG4gICAgZGVmIHNldF9pbnQ4KG9mZnNldCwgdmFsdWUsIGxpdHRsZSA9IGZhbHNlKVxuICAgICAgYCN7QG5hdGl2ZX0uc2V0SW50OChvZmZzZXQsIHZhbHVlLCBsaXR0bGUpYFxuICAgIGVuZFxuXG4gICAgZGVmIGdldF91aW50OChvZmZzZXQsIGxpdHRsZSA9IGZhbHNlKVxuICAgICAgYCN7QG5hdGl2ZX0uZ2V0VWludDgob2Zmc2V0LCBsaXR0bGUpYFxuICAgIGVuZFxuXG4gICAgZGVmIHNldF91aW50OChvZmZzZXQsIHZhbHVlLCBsaXR0bGUgPSBmYWxzZSlcbiAgICAgIGAje0BuYXRpdmV9LnNldFVpbnQ4KG9mZnNldCwgdmFsdWUsIGxpdHRsZSlgXG4gICAgZW5kXG5cbiAgICBkZWYgZ2V0X2ludDE2KG9mZnNldCwgbGl0dGxlID0gZmFsc2UpXG4gICAgICBgI3tAbmF0aXZlfS5nZXRJbnQxNihvZmZzZXQsIGxpdHRsZSlgXG4gICAgZW5kXG5cbiAgICBkZWYgc2V0X2ludDE2KG9mZnNldCwgdmFsdWUsIGxpdHRsZSA9IGZhbHNlKVxuICAgICAgYCN7QG5hdGl2ZX0uc2V0SW50MTYob2Zmc2V0LCB2YWx1ZSwgbGl0dGxlKWBcbiAgICBlbmRcblxuICAgIGRlZiBnZXRfdWludDE2KG9mZnNldCwgbGl0dGxlID0gZmFsc2UpXG4gICAgICBgI3tAbmF0aXZlfS5nZXRVaW50MTYob2Zmc2V0LCBsaXR0bGUpYFxuICAgIGVuZFxuXG4gICAgZGVmIHNldF91aW50MTYob2Zmc2V0LCB2YWx1ZSwgbGl0dGxlID0gZmFsc2UpXG4gICAgICBgI3tAbmF0aXZlfS5zZXRVaW50MTYob2Zmc2V0LCB2YWx1ZSwgbGl0dGxlKWBcbiAgICBlbmRcblxuICAgIGRlZiBnZXRfaW50MzIob2Zmc2V0LCBsaXR0bGUgPSBmYWxzZSlcbiAgICAgIGAje0BuYXRpdmV9LmdldEludDMyKG9mZnNldCwgbGl0dGxlKWBcbiAgICBlbmRcblxuICAgIGRlZiBzZXRfaW50MzIob2Zmc2V0LCB2YWx1ZSwgbGl0dGxlID0gZmFsc2UpXG4gICAgICBgI3tAbmF0aXZlfS5zZXRJbnQzMihvZmZzZXQsIHZhbHVlLCBsaXR0bGUpYFxuICAgIGVuZFxuXG4gICAgZGVmIGdldF91aW50MzIob2Zmc2V0LCBsaXR0bGUgPSBmYWxzZSlcbiAgICAgIGAje0BuYXRpdmV9LmdldFVpbnQzMihvZmZzZXQsIGxpdHRsZSlgXG4gICAgZW5kXG5cbiAgICBkZWYgc2V0X3VpbnQzMihvZmZzZXQsIHZhbHVlLCBsaXR0bGUgPSBmYWxzZSlcbiAgICAgIGAje0BuYXRpdmV9LnNldFVpbnQzMihvZmZzZXQsIHZhbHVlLCBsaXR0bGUpYFxuICAgIGVuZFxuXG4gICAgZGVmIGdldF9mbG9hdDMyKG9mZnNldCwgbGl0dGxlID0gZmFsc2UpXG4gICAgICBgI3tAbmF0aXZlfS5nZXRGbG9hdDMyKG9mZnNldCwgbGl0dGxlKWBcbiAgICBlbmRcblxuICAgIGRlZiBzZXRfZmxvYXQzMihvZmZzZXQsIHZhbHVlLCBsaXR0bGUgPSBmYWxzZSlcbiAgICAgIGAje0BuYXRpdmV9LnNldEZsb2F0MzIob2Zmc2V0LCB2YWx1ZSwgbGl0dGxlKWBcbiAgICBlbmRcblxuICAgIGRlZiBnZXRfZmxvYXQ2NChvZmZzZXQsIGxpdHRsZSA9IGZhbHNlKVxuICAgICAgYCN7QG5hdGl2ZX0uZ2V0RmxvYXQ2NChvZmZzZXQsIGxpdHRsZSlgXG4gICAgZW5kXG5cbiAgICBkZWYgc2V0X2Zsb2F0NjQob2Zmc2V0LCB2YWx1ZSwgbGl0dGxlID0gZmFsc2UpXG4gICAgICBgI3tAbmF0aXZlfS5zZXRGbG9hdDY0KG9mZnNldCwgdmFsdWUsIGxpdHRsZSlgXG4gICAgZW5kXG5cbiAgICBhbGlhcyBzaXplIGxlbmd0aFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6QnVmZmVyPiIsIjxjbGFzczpWaWV3PiIsInNlbGYiLCJpbmNsdWRlIiwiTmF0aXZlOjpXcmFwcGVyIiwiTmF0aXZlIiwic3VwcG9ydGVkPyIsIiQkIiwiW10iLCJuaWw/IiwiISIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsImJ1ZmZlciIsIm9mZnNldCIsImxlbmd0aCIsIm5hdGl2ZT8iLCJ0b19uIiwiQGJ1ZmZlciIsIkBvZmZzZXQiLCJAbmF0aXZlIiwiZ2V0IiwiYml0cyIsInR5cGUiLCJsaXR0bGUiLCI4IiwiQnVmZmVyIiwibmFtZV9mb3IiLCJzZXQiLCJ2YWx1ZSIsImdldF9pbnQ4Iiwic2V0X2ludDgiLCJnZXRfdWludDgiLCJzZXRfdWludDgiLCJnZXRfaW50MTYiLCJzZXRfaW50MTYiLCJnZXRfdWludDE2Iiwic2V0X3VpbnQxNiIsImdldF9pbnQzMiIsInNldF9pbnQzMiIsImdldF91aW50MzIiLCJzZXRfdWludDMyIiwiZ2V0X2Zsb2F0MzIiLCJzZXRfZmxvYXQzMiIsImdldF9mbG9hdDY0Iiwic2V0X2Zsb2F0NjQiXSwibWFwcGluZ3MiOiJBQUFBQSw4QkFBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUVBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQ0VBLE9BQUFDO0lBQUFBOztNQUFBQTs7QUFBQUE7O01BQ0VDLElBQUFDLFNBQUFBLENBQVFDLElBQUFDLFlBQUFELFlBQVJEO01BRUFHLE1BQUlKLElBQUpJLGlCQUFBQSxnQ0FBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUNDLFFBQUVDLE9BQUFBLENBQUMsVUFBREEsQ0FBV0MsU0FBQUEsQ0FBQUEsQ0FBZEMsTUFBQUEsQ0FBQUE7TUFERkosQ0FBQUE7TUFJQUosSUFBQVMsYUFBQUEsQ0FBWSxRQUFaLEVBQXFCLFFBQXJCQTs7QUFFQUMsTUFBQUEsMEJBQUFBLHNCQUFlQyxNQUFELEVBQVNDLE1BQVQsRUFBdUJDLE1BQXJDSDtBQUFBQSxRQUFBQTs7UUFBQUE7O1FBQXVCLDZCQUFTO1FBQUssNkJBQVM7UUFDNUMsSUFBQSxRQUFHVixJQUFBYyxZQUFBQSxDQUFRSCxNQUFSRyxDQUFILENBQUE7VUFDRSxPQUFBZCxJQUFBLEVBQUEsMERBQUEsY0FBQSxFQUFBLENBQU1XLE1BQU4sQ0FBQSxFQUFBLElBQUE7UUFERixPQUVBLElBQU0sQ0FBQSxRQUFBQyxNQUFBLENBQUEsSUFBQSxDQUFBLFFBQVVDLE1BQVYsQ0FBQSxDQUFBLENBQU47VUFDRSxPQUFBYixJQUFBLEVBQUEsMERBQUEsY0FBQSxFQUFBLENBQU9VLGFBQWVDLE1BQU1JLE1BQUFBLENBQUFBLENBQU1MLEVBQUlFLE1BQU1HLE1BQUFBLENBQUFBLENBQU1MLEVBQUlHLE1BQU1FLE1BQUFBLENBQUFBLENBQU1MLENBQWxFLENBQUEsRUFBQSxJQUFBO1FB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QSxPQUFHekIsY0FBUXlCO01BRGJBLENBQUFBLElBQUFBO01BSUE1QyxPQUFBLGFBQU0sTUFBTixFQUFXLFFBQVg7SUF4R0ZBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBREZELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBRkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo0MTg0MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4vYnVmZmVyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgYmFja3RpY2tfamF2YXNjcmlwdDogdHJ1ZVxuXG5yZXF1aXJlICduYXRpdmUnXG5yZXF1aXJlICdidWZmZXIvYXJyYXknXG5yZXF1aXJlICdidWZmZXIvdmlldydcblxuY2xhc3MgQnVmZmVyXG4gIGluY2x1ZGUgTmF0aXZlOjpXcmFwcGVyXG5cbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgICEkJFs6QXJyYXlCdWZmZXJdLm5pbD9cbiAgZW5kXG5cbiAgZGVmIHNlbGYubmFtZV9mb3IoYml0cywgdHlwZSlcbiAgICBwYXJ0ID0gY2FzZSB0eXBlXG4gICAgICAgICAgIHdoZW4gOnVuc2lnbmVkIHRoZW4gJ1VpbnQnXG4gICAgICAgICAgIHdoZW4gOnNpZ25lZCAgIHRoZW4gJ0ludCdcbiAgICAgICAgICAgd2hlbiA6ZmxvYXQgICAgdGhlbiAnRmxvYXQnXG4gICAgICAgICAgIGVuZFxuICAgIFwiI3twYXJ0fSN7Yml0c31cIlxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZShzaXplLCBiaXRzID0gOClcbiAgICBpZiBuYXRpdmU/KHNpemUpXG4gICAgICBzdXBlcihzaXplKVxuICAgIGVsc2VcbiAgICAgIHN1cGVyKGBuZXcgQXJyYXlCdWZmZXIoc2l6ZSAqIChiaXRzIC8gOCkpYClcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGxlbmd0aFxuICAgIGAje0BuYXRpdmV9LmJ5dGVMZW5ndGhgXG4gIGVuZFxuXG4gIGRlZiB0b19hKGJpdHMgPSA4LCB0eXBlID0gOnVuc2lnbmVkKVxuICAgIEFycmF5Lm5ldyhzZWxmLCBiaXRzLCB0eXBlKVxuICBlbmRcblxuICBkZWYgdmlldyhvZmZzZXQgPSBuaWwsIGxlbmd0aCA9IG5pbClcbiAgICBWaWV3Lm5ldyhzZWxmLCBvZmZzZXQsIGxlbmd0aClcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICB0b19hLnRvX2EucGFjaygnYyonKVxuICBlbmRcblxuICBhbGlhcyBzaXplIGxlbmd0aFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOkJ1ZmZlcj4iLCJpbmNsdWRlIiwiTmF0aXZlOjpXcmFwcGVyIiwiTmF0aXZlIiwic3VwcG9ydGVkPyIsIiQkIiwiW10iLCJuaWw/IiwiISIsIm5hbWVfZm9yIiwiYml0cyIsInR5cGUiLCJwYXJ0IiwiJHJldF9vcl8xIiwiaW5pdGlhbGl6ZSIsInNpemUiLCI4IiwibmF0aXZlPyIsImxlbmd0aCIsIkBuYXRpdmUiLCJ0b19hIiwiQXJyYXkiLCJuZXciLCJ2aWV3Iiwib2Zmc2V0IiwiVmlldyIsInRvX3MiLCJwYWNrIl0sIm1hcHBpbmdzIjoiQUFBQUEseUJBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBRUFDLElBQUFDLFNBQUFBLENBQVFGLFFBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLGNBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLGFBQVJFO0VBRUFGLE9BQUFHO0VBQUFBOztJQUFBQTs7QUFBQUE7O0lBQ0VGLElBQUFHLFNBQUFBLENBQVFDLElBQUFDLFlBQUFELFlBQVJEO0lBRUFHLE1BQUlOLElBQUpNLGlCQUFBQSxrQ0FBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUNDLFFBQUVDLE9BQUFBLENBQUMsYUFBREEsQ0FBY0MsU0FBQUEsQ0FBQUEsQ0FBakJDLE1BQUFBLENBQUFBO0lBREZKLENBQUFBO0lBSUFLLE1BQUlYLElBQUpXLGVBQUFBLG9CQUFrQkMsSUFBRCxFQUFPQyxJQUF4QkY7QUFBQUEsTUFBQUE7OztNQUNFRyxPQUNPLENBQUEsUUFBSyxVQUFMLEVBREFDLENBQUFBLFlBQUtGLElBQUxFLENBQ0EsQ0FBQSxHQUFBLENBQW9CSixNQUFwQixJQUNBLENBQUEsUUFBSyxRQUFMLEVBaEJYLFNBZ0JXLENBQUEsR0FBQSxDQUFvQkEsS0FBcEIsSUFDQSxDQUFBLFFBQUssT0FBTCxFQWpCWCxTQWlCVyxDQUFBLEdBQUEsQ0FBb0JBLE9BQXBCLElBQUEsQ0FIQSxHQUdBLENBQUEsQ0FEQSxDQURBO01BSVBBLE9BQUEsRUFBQSxHQUFBLENBQUdHLElBQUgsQ0FBQSxHQUFBLENBQVVGLElBQVY7SUFORkQsQ0FBQUE7O0FBU0FLLElBQUFBLDBCQUFBQSxzQkFBZUMsSUFBRCxFQUFPTCxJQUFyQkk7QUFBQUEsTUFBQUE7O01BQUFBOztNQUFxQix5QkFBT0U7TUFDMUIsSUFBQSxRQUFHbEIsSUFBQW1CLFlBQUFBLENBQVFGLElBQVJFLENBQUgsQ0FBQTtRQUNFSCxPQUFBLE9BQUFoQixJQUFBLEVBQUEsMERBQUEsY0FBQSxFQUFBLENBQU1pQixJQUFOLENBQUEsRUFBQSxJQUFBO01BREY7UUFHRUQsT0FBQSxPQUFBaEIsSUFBQSxFQUFBLDBEQUFBLGNBQUEsRUFBQSxDQUFPZ0Isa0NBQVAsQ0FBQSxFQUFBLElBQUE7TUFIRjtJQURGQSxDQUFBQSxJQUFBQTs7QUFRQUksSUFBQUEsc0JBQUFBLGtCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBR0MsY0FBUUQ7SUFEYkEsQ0FBQUE7O0FBSUFFLElBQUFBLG9CQUFBQSxnQkFBU1YsSUFBRCxFQUFXQyxJQUFuQlM7QUFBQUEsTUFBQUE7OztNQUFTLHlCQUFPSjtNQUFHLHlCQUFPO01BQ3hCSSxPQUFBQyxXQUFLQyxLQUFBQSxDQUFLeEIsSUFBVixFQUFnQlksSUFBaEIsRUFBc0JDLElBQWpCVztJQURQRixDQUFBQSxJQUFBQTs7QUFJQUcsSUFBQUEsb0JBQUFBLGdCQUFTQyxNQUFELEVBQWVOLE1BQXZCSztBQUFBQSxNQUFBQTs7O01BQVMsNkJBQVM7TUFBSyw2QkFBUztNQUM5QkEsT0FBQUUsVUFBSUgsS0FBQUEsQ0FBS3hCLElBQVQsRUFBZTBCLE1BQWYsRUFBdUJOLE1BQW5CSTtJQUROQyxDQUFBQSxJQUFBQTs7QUFJQUcsSUFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQTVCLElBQUFzQixNQUFBQSxDQUFBQSxDQUFJQSxNQUFBQSxDQUFBQSxDQUFLTyxNQUFBQSxDQUFNRCxJQUFOQztJQURYRCxDQUFBQTtJQUlBMUIsT0FBQSxhQUFNLE1BQU4sRUFBVyxRQUFYO0VBeENGQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQU5BSDsifX0seyJvZmZzZXQiOnsibGluZSI6NDE5MTUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L21lc3NhZ2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnYnVmZmVyJ1xuXG5tb2R1bGUgQnJvd3NlcjsgY2xhc3MgRXZlbnRcblxuY2xhc3MgTWVzc2FnZSA8IEV2ZW50XG4gIGhhbmRsZXMgJ21lc3NhZ2UnXG5cbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5NZXNzYWdlJ1xuICBlbmRcblxuICBjbGFzcyBEZWZpbml0aW9uIDwgRGVmaW5pdGlvblxuICAgIGRlZiBkYXRhPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5kYXRhID0gdmFsdWVgXG4gICAgZW5kXG5cbiAgICBkZWYgb3JpZ2luPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5vcmlnaW4gPSB2YWx1ZWBcbiAgICBlbmRcblxuICAgIGRlZiBzb3VyY2U9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLnNvdXJjZSA9ICN7TmF0aXZlLmNvbnZlcnQodmFsdWUpfWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNvbnN0cnVjdG9yJ1xuICAgIGRlZiBzZWxmLmNvbnN0cnVjdChuYW1lLCBkZXNjKVxuICAgICAgYG5ldyBNZXNzYWdlRXZlbnQoI3tuYW1lfSwgI3tkZXNjfSlgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jcmVhdGUnXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICAleHtcbiAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJNZXNzYWdlRXZlbnRcIik7XG4gICAgICAgICAgICBldmVudC5pbml0TWVzc2FnZUV2ZW50KG5hbWUsIGRlc2MuYnViYmxlcywgZGVzYy5jYW5jZWxhYmxlLFxuICAgICAgICAgICAgICBkZXNjLmRhdGEsIGRlc2Mub3JpZ2luLCBcIlwiLCBkZXNjLnNvdXJjZSB8fCB3aW5kb3cpO1xuXG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kIGlmIHN1cHBvcnRlZD9cblxuICBkZWYgZGF0YVxuICAgICV4e1xuICAgICAgaWYgKHdpbmRvdy5BcnJheUJ1ZmZlciAmJiAjQG5hdGl2ZS5kYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuICN7QnVmZmVyLm5ldyhgI0BuYXRpdmUuZGF0YWApfTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHdpbmRvdy5CbG9iICYmICNAbmF0aXZlLmRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIHJldHVybiAje0Jsb2IubmV3KGAjQG5hdGl2ZS5kYXRhYCl9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAjQG5hdGl2ZS5kYXRhO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXNfbmF0aXZlIDpvcmlnaW5cblxuICBkZWYgc291cmNlXG4gICAgJXh7XG4gICAgICB2YXIgc291cmNlID0gI0BuYXRpdmUuc291cmNlO1xuXG4gICAgICBpZiAod2luZG93LldpbmRvdyAmJiBzb3VyY2UgaW5zdGFuY2VvZiB3aW5kb3cuV2luZG93KSB7XG4gICAgICAgIHJldHVybiAje1dpbmRvdy5uZXcoYHNvdXJjZWApfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkV2ZW50PiIsIjxjbGFzczpNZXNzYWdlPiIsImhhbmRsZXMiLCJzdXBwb3J0ZWQ/IiwiQnJvd3NlciIsInN1cHBvcnRzPyIsIjxjbGFzczpEZWZpbml0aW9uPiIsImRhdGE9IiwidmFsdWUiLCJAbmF0aXZlIiwib3JpZ2luPSIsInNvdXJjZT0iLCJOYXRpdmUiLCJjb252ZXJ0IiwiRGVmaW5pdGlvbiIsImNvbnN0cnVjdCIsIm5hbWUiLCJkZXNjIiwiZGF0YSIsIkJ1ZmZlciIsIm5ldyIsIkJsb2IiLCJhbGlhc19uYXRpdmUiLCJzb3VyY2UiLCJXaW5kb3ciLCJFdmVudCJdLCJtYXBwaW5ncyI6IkFBQUFBLHdDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixRQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWhCQSxPQUFBQztNQUFBQTs7UUFBQUE7O0FBQUFBOztRQUNFSixJQUFBSyxTQUFBQSxDQUFRRCxTQUFSQztRQUVBQyxNQUFJTixJQUFKTSxpQkFBQUEsbUNBQUFBO0FBQUFBO1VBQ0VBLE9BQUFDLGFBQU9DLGNBQUFBLENBQVdGLGVBQVhFO1FBRFRGLENBQUFBO1FBSUFHO1FBQUFBOztVQUFBQTs7QUFBQUE7OztBQUNFQyxVQUFBQSxxQkFBQUEsK0JBQVVDLEtBQVZEO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRSxjQUFPRjtVQURYQSxDQUFBQTs7QUFJQUcsVUFBQUEsdUJBQUFBLGlDQUFZRixLQUFaRTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUQsY0FBT0M7VUFEWEEsQ0FBQUE7VUFJQUosT0FBQUssdUJBQUFBLGlDQUFZSCxLQUFaRztBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUYsY0FBT0UsVUFBWUMsWUFBTUMsU0FBQUEsQ0FBU0wsS0FBVEs7VUFEN0JGLENBQUFBO1FBVEZMLEdBQUFBLFdBQUFBLEVBQW1CUSxnQkFBbkJSO1FBY0EsSUFBQSxRQWNPVCxJQUFBTSxlQUFBQSxDQUFBQSxDQWRQLENBQUE7VUFBQSxJQUFBLFFBQUdDLGFBQU9DLGNBQUFBLENBQVdKLG1CQUFYSSxDQUFWLENBQUE7WUFDRVUsTUFBSWxCLElBQUprQixnQkFBQUEscUJBQW1CQyxJQUFELEVBQU9DLElBQXpCRjtBQUFBQTtjQUNFQSxPQUFDQSxpQkFBbUJDLElBQUtELEVBQUlFLElBQUtGO1lBRHBDQSxDQUFBQTtVQURGLE9BSUEsSUFBQSxRQUFNWCxhQUFPQyxjQUFBQSxDQUFXSixjQUFYSSxDQUFiLENBQUE7WUFDRVUsTUFBSWxCLElBQUprQixnQkFBQUEscUJBQW1CQyxJQUFELEVBQU9DLElBQXpCRjtBQUFBQTs7QUFFSkE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO1lBUElBLENBQUFBO1VBREY7UUFKQTs7QUFnQkFHLFFBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsVUFBQUE7OztBQUVGQSxnQ0FBaUNULGNBQU9TO0FBQ3hDQSxlQUFpQkMsWUFBTUMsS0FBQUEsQ0FBT1gsY0FBT1MsS0FBZEUsQ0FBc0JGO0FBQzdDQTtBQUNBQSw4QkFBK0JULGNBQU9TO0FBQ3RDQSxlQUFpQkcsVUFBSUQsS0FBQUEsQ0FBT1gsY0FBT1MsS0FBZEUsQ0FBc0JGO0FBQzNDQTtBQUNBQTtBQUNBQSxlQUFnQlQsY0FBT1M7QUFDdkJBO0FBQ0FBO1FBWEVBLENBQUFBO1FBY0FyQixJQUFBeUIsY0FBQUEsQ0FBYSxRQUFiQTtRQUVBckIsT0FBQXNCLHNCQUFBQSxrQkFBQUE7QUFBQUEsVUFBQUE7OztBQUVGQSxtQkFBb0JkLGNBQU9jOztBQUUzQkE7QUFDQUEsZUFBaUJDLFlBQU1KLEtBQUFBLENBQU1HLE1BQU5ILENBQWVHO0FBQ3RDQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtRQVZFQSxDQUFBQTtNQXJERnRCLEdBQUFBLFdBQUFBLEVBQWdCd0IsV0FBaEJ4QjtJQUZnQkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBRkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo0MjAyMywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQvY2xvc2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IGNsYXNzIEV2ZW50XG5cbmNsYXNzIENsb3NlIDwgRXZlbnRcbiAgaGFuZGxlcyAnY2xvc2UnXG5cbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5DbG9zZSdcbiAgZW5kXG5cbiAgY2xhc3MgRGVmaW5pdGlvbiA8IERlZmluaXRpb25cbiAgICBkZWYgY29kZT0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuY29kZSA9ICN7dmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIHJlYXNvbj0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUucmVhc29uID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgY2xlYW4hKHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLndhc0NsZWFuID0gdHJ1ZWBcbiAgICBlbmRcblxuICAgIGRlZiBub3RfY2xlYW4hKHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLndhc0NsZWFuID0gZmFsc2VgXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgQ2xvc2VFdmVudCgje25hbWV9LCAje2Rlc2N9KWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNyZWF0ZSdcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgICV4e1xuICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkNsb3NlRXZlbnRcIik7XG4gICAgICAgICAgICBldmVudC5pbml0Q2xvc2VFdmVudChuYW1lLCBkZXNjLmJ1YmJsZXMsIGRlc2MuY2FuY2VsYWJsZSxcbiAgICAgICAgICAgICAgZGVzYy53YXNDbGVhbiwgZGVzYy5jb2RlLCBkZXNjLnJlYXNvbik7XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIGVuZFxuICBlbmQgaWYgc3VwcG9ydGVkP1xuXG4gIGFsaWFzX25hdGl2ZSA6Y29kZVxuICBhbGlhc19uYXRpdmUgOnJlYXNvblxuICBhbGlhc19uYXRpdmUgOmNsZWFuPywgOndhc0NsZWFuXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpFdmVudD4iLCI8Y2xhc3M6Q2xvc2U+Iiwic2VsZiIsImhhbmRsZXMiLCJzdXBwb3J0ZWQ/IiwiQnJvd3NlciIsInN1cHBvcnRzPyIsIjxjbGFzczpEZWZpbml0aW9uPiIsImNvZGU9IiwidmFsdWUiLCJAbmF0aXZlIiwicmVhc29uPSIsImNsZWFuISIsIm5vdF9jbGVhbiEiLCJEZWZpbml0aW9uIiwiY29uc3RydWN0IiwibmFtZSIsImRlc2MiLCJhbGlhc19uYXRpdmUiLCJFdmVudCJdLCJtYXBwaW5ncyI6IkFBQUFBLHNDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFBZ0JBLE9BQUFDO0lBQUFBOztNQUFBQTs7TUFFaEJBLE9BQUFDO01BQUFBOztRQUFBQTs7O1FBQ0VDLElBQUFDLFNBQUFBLENBQVFGLE9BQVJFO1FBRUFDLE1BQUlGLElBQUpFLGlCQUFBQSxpQ0FBQUE7QUFBQUE7VUFDRUEsT0FBQUMsYUFBT0MsY0FBQUEsQ0FBV0YsYUFBWEU7UUFEVEYsQ0FBQUE7UUFJQUc7UUFBQUE7O1VBQUFBOztBQUFBQTs7O0FBQ0VDLFVBQUFBLHFCQUFBQSwrQkFBVUMsS0FBVkQ7QUFBQUEsWUFBQUE7O1lBQ0VBLE9BQUVFLGNBQU9GLFFBQVVDO1VBRHJCRCxDQUFBQTs7QUFJQUcsVUFBQUEsdUJBQUFBLGlDQUFZRixLQUFaRTtBQUFBQSxZQUFBQTs7WUFDRUEsT0FBRUQsY0FBT0MsVUFBWUY7VUFEdkJFLENBQUFBOztBQUlBQyxVQUFBQSxzQkFBQUEsa0NBQVdILEtBQVhHO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFRixjQUFPRTtVQURYQSxDQUFBQTtVQUlBTCxPQUFBTSwwQkFBQUEsc0NBQWVKLEtBQWZJO0FBQUFBLFlBQUFBOztZQUNFQSxPQUFFSCxjQUFPRztVQURYQSxDQUFBQTtRQWJGTixHQUFBQSxXQUFBQSxFQUFtQk8sZ0JBQW5CUDtRQWtCQSxJQUFBLFFBY09MLElBQUFFLGVBQUFBLENBQUFBLENBZFAsQ0FBQTtVQUFBLElBQUEsUUFBR0MsYUFBT0MsY0FBQUEsQ0FBV0wsbUJBQVhLLENBQVYsQ0FBQTtZQUNFUyxNQUFJYixJQUFKYSxnQkFBQUEscUJBQW1CQyxJQUFELEVBQU9DLElBQXpCRjtBQUFBQTtjQUNFQSxPQUFDQSxlQUFpQkMsSUFBS0QsRUFBSUUsSUFBS0Y7WUFEbENBLENBQUFBO1VBREYsT0FJQSxJQUFBLFFBQU1WLGFBQU9DLGNBQUFBLENBQVdMLGNBQVhLLENBQWIsQ0FBQTtZQUNFUyxNQUFJYixJQUFKYSxnQkFBQUEscUJBQW1CQyxJQUFELEVBQU9DLElBQXpCRjtBQUFBQTs7QUFFSkE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO1lBUElBLENBQUFBO1VBREY7UUFKQTtRQWdCQWIsSUFBQWdCLGNBQUFBLENBQWEsTUFBYkE7UUFDQWhCLElBQUFnQixjQUFBQSxDQUFhLFFBQWJBO1FBQ0FqQixPQUFBQyxJQUFBZ0IsY0FBQUEsQ0FBYSxRQUFiLEVBQXNCLFVBQXRCQTtNQTNDRmpCLEdBQUFBLFdBQUFBLEVBQWNrQixXQUFkbEI7SUFGZ0JELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6NDIxMDYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L2FsbC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGJyb3dzZXIvZXZlbnQvYWxsOiBMb2FkIHN1cHBvcnQgZm9yIGFsbCBldmVudHNcblxucmVxdWlyZSAnYnJvd3Nlci9ldmVudC9mb2N1cydcbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQvd2hlZWwnXG5yZXF1aXJlICdicm93c2VyL2V2ZW50L2RhdGFfdHJhbnNmZXInXG5yZXF1aXJlICdicm93c2VyL2V2ZW50L2NvbXBvc2l0aW9uJ1xucmVxdWlyZSAnYnJvd3Nlci9ldmVudC9hbmltYXRpb24nXG5yZXF1aXJlICdicm93c2VyL2V2ZW50L2F1ZGlvX3Byb2Nlc3NpbmcnXG5yZXF1aXJlICdicm93c2VyL2V2ZW50L2JlZm9yZV91bmxvYWQnXG5yZXF1aXJlICdicm93c2VyL2V2ZW50L2NvbXBvc2l0aW9uJ1xucmVxdWlyZSAnYnJvd3Nlci9ldmVudC9jbGlwYm9hcmQnXG5yZXF1aXJlICdicm93c2VyL2V2ZW50L2RldmljZV9saWdodCdcbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQvZGV2aWNlX21vdGlvbidcbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQvZGV2aWNlX29yaWVudGF0aW9uJ1xucmVxdWlyZSAnYnJvd3Nlci9ldmVudC9kZXZpY2VfcHJveGltaXR5J1xucmVxdWlyZSAnYnJvd3Nlci9ldmVudC9kcmFnJ1xucmVxdWlyZSAnYnJvd3Nlci9ldmVudC9nYW1lcGFkJ1xucmVxdWlyZSAnYnJvd3Nlci9ldmVudC9oYXNoX2NoYW5nZSdcbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQvcHJvZ3Jlc3MnXG5yZXF1aXJlICdicm93c2VyL2V2ZW50L3BhZ2VfdHJhbnNpdGlvbidcbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQvcG9wX3N0YXRlJ1xucmVxdWlyZSAnYnJvd3Nlci9ldmVudC9zdG9yYWdlJ1xucmVxdWlyZSAnYnJvd3Nlci9ldmVudC90b3VjaCdcbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQvc2Vuc29yJ1xucmVxdWlyZSAnYnJvd3Nlci9ldmVudC9tZXNzYWdlJ1xucmVxdWlyZSAnYnJvd3Nlci9ldmVudC9jbG9zZSdcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiXSwibWFwcGluZ3MiOiJBQUFBQSxvQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTs7RUFFQUMsSUFBQUMsU0FBQUEsQ0FBUUYscUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLHFCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRiw2QkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsMkJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLHlCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixnQ0FBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsNkJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLDJCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRix5QkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsNEJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLDZCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixrQ0FBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsZ0NBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLG9CQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRix1QkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsMkJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLHdCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRiwrQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYseUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLHVCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixxQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsc0JBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLHVCQUFSRTtFQUNBRixPQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixxQkFBUkU7QUF6QkFGOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo0MjEzNywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZG9tL2J1aWxkZXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBUZW1wb3JhcnkgZml4IGZvciBhIGJ1ZyBpbiBTdHJpbmcjc2NhblxubW9kdWxlIFBhZ2dpbzo6VXRpbHNcbiAgZGVmIHNlbGYuaGVyZWRvYyhzdHJpbmcpXG4gICAgc3RyaW5nXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFBhZ2dpbzo6SFRNTDo6RWxlbWVudCA8IEJhc2ljT2JqZWN0XG4gIGRlZiBvbigqYXJncywgJmJsb2NrKVxuICAgIChAb24gfHw9IFtdKSA8PCBbYXJncywgYmxvY2tdXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NXG5cbmNsYXNzIEJ1aWxkZXJcbiAgZGVmIHNlbGYudG9faFxuICAgIEBidWlsZGVycyB8fD0ge31cbiAgZW5kXG5cbiAgZGVmIHNlbGYuZm9yKGtsYXNzLCAmYmxvY2spXG4gICAgaWYgYmxvY2tcbiAgICAgIHRvX2hba2xhc3NdID0gYmxvY2tcbiAgICBlbHNlXG4gICAgICB0b19oW2tsYXNzXVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2VsZi5idWlsZChidWlsZGVyLCBpdGVtKVxuICAgIHRvX2guZWFjaCB7fGtsYXNzLCBibG9ja3xcbiAgICAgIGlmIGtsYXNzID09PSBpdGVtXG4gICAgICAgIHJldHVybiBibG9jay5jYWxsKGJ1aWxkZXIsIGl0ZW0pXG4gICAgICBlbmRcbiAgICB9XG5cbiAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcImNhbm5vdCBidWlsZCB1bmtub3duIGl0ZW0gI3tpdGVtfVwiXG4gIGVuZFxuXG4gIGF0dHJfcmVhZGVyIDpkb2N1bWVudCwgOmVsZW1lbnRcblxuICBORVdfUEFHR0lPID0gKFBhZ2dpbzo6SFRNTC5pbnN0YW5jZV9tZXRob2QoOmJ1aWxkISkgcmVzY3VlIGZhbHNlKVxuXG4gIGRlZiBpbml0aWFsaXplKGRvY3VtZW50LCBidWlsZGVyPW5pbCwgJmJsb2NrKVxuICAgIEBkb2N1bWVudCA9IGRvY3VtZW50XG5cbiAgICAjIENvbXBhdGliaWxpdHkgaXNzdWUgZHVlIHRvIGFuIHVucmVsZWFzZWQgUGFnZ2lvIGdlbS5cbiAgICAjIExldCdzIHRyeSB0byBzdXBwb3J0IGJvdGggdmVyc2lvbnMuIFdoZW4gUGFnZ2lvIGlzIHJlbGVhc2VkLFxuICAgICMgd2UgbWF5IHJlbW92ZSBpdC5cblxuICAgIGlmIE5FV19QQUdHSU9cbiAgICAgIEBidWlsZGVyID0gUGFnZ2lvOjpIVE1MLm5ldyhkZWZlcjogdHJ1ZSwgJmJsb2NrKVxuXG4gICAgICBidWlsZCA9IHByb2MgZG9cbiAgICAgICAgQGJ1aWxkZXIuYnVpbGQhKGZvcmNlX2NhbGw6ICEhYnVpbGRlcilcbiAgICAgICAgQHJvb3RzID0gQGJ1aWxkZXIuZWFjaC5tYXAgeyB8ZXwgQnVpbGRlci5idWlsZChzZWxmLCBlKSB9XG4gICAgICBlbmRcblxuICAgICAgaWYgYnVpbGRlclxuICAgICAgICBidWlsZGVyLmV4dGVuZCEoQGJ1aWxkZXIsICZidWlsZClcbiAgICAgIGVsc2VcbiAgICAgICAgYnVpbGQuKClcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIEBidWlsZGVyID0gUGFnZ2lvOjpIVE1MLm5ldygmYmxvY2spXG4gICAgICBAcm9vdHMgPSBAYnVpbGRlci5lYWNoLm1hcCB7IHxlfCBCdWlsZGVyLmJ1aWxkKHNlbGYsIGUpIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHRvX2FcbiAgICBAcm9vdHNcbiAgZW5kXG5lbmRcblxuQnVpbGRlci5mb3IgU3RyaW5nIGRvIHxiLCBpdGVtfFxuICBiLmRvY3VtZW50LmNyZWF0ZV90ZXh0KGl0ZW0pXG5lbmRcblxuQnVpbGRlci5mb3IgUGFnZ2lvOjpIVE1MOjpFbGVtZW50IGRvIHxiLCBpdGVtfFxuICBvcHRpb25zID0ge31cblxuICBvcHRpb25zWzphdHRyc10gPSBgaXRlbS5hdHRyaWJ1dGVzYCBpZiBIYXNoID09PSBgaXRlbS5hdHRyaWJ1dGVzYFxuICBvcHRpb25zWzpjbGFzc2VzXSA9IGBpdGVtLmNsYXNzX25hbWVzYFxuXG4gIGRvbSA9IGIuZG9jdW1lbnQuY3JlYXRlX2VsZW1lbnQoYGl0ZW0ubmFtZWAsICoqb3B0aW9ucylcblxuICBpZiBvbiA9IGBpdGVtLm9uIHx8IG5pbGBcbiAgICBvbi5lYWNoIHt8YXJncywgYmxvY2t8XG4gICAgICBkb20ub24oKmFyZ3MsICZibG9jaylcbiAgICB9XG4gIGVuZFxuXG4gIGlmIGlubmVyID0gYGl0ZW0uaW5uZXJfaHRtbCB8fCBuaWxgXG4gICAgZG9tLmlubmVyX2h0bWwgPSBpbm5lclxuICBlbHNlXG4gICAgaXRlbS5lYWNoIHt8Y2hpbGR8XG4gICAgICBkb20gPDwgQnVpbGRlci5idWlsZChiLCBjaGlsZClcbiAgICB9XG4gIGVuZFxuXG4gIGRvbVxuZW5kXG5cbkJ1aWxkZXIuZm9yIERPTTo6Tm9kZSBkbyB8YiwgaXRlbXxcbiAgaXRlbVxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6UGFnZ2lvOjpVdGlscz4iLCJoZXJlZG9jIiwic2VsZiIsInN0cmluZyIsIlBhZ2dpbyIsIjxjbGFzczpQYWdnaW86OkhUTUw6OkVsZW1lbnQ+Iiwib24iLCJAb24iLCIkcmV0X29yXzEiLCI8PCIsImFyZ3MiLCJibG9jayIsIlBhZ2dpbzo6SFRNTCIsIkJhc2ljT2JqZWN0IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxtb2R1bGU6RE9NPiIsIjxjbGFzczpCdWlsZGVyPiIsInRvX2giLCJAYnVpbGRlcnMiLCJmb3IiLCJrbGFzcyIsIltdPSIsIltdIiwiYnVpbGQiLCJidWlsZGVyIiwiaXRlbSIsImVhY2giLCJibG9jayBpbiBidWlsZCIsImNhbGwiLCJibG9jayAoMiBsZXZlbHMpIGluIGJ1aWxkIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwiYXR0cl9yZWFkZXIiLCJpbnN0YW5jZV9tZXRob2QiLCJTdGFuZGFyZEVycm9yIiwiaW5pdGlhbGl6ZSIsImRvY3VtZW50IiwiQGRvY3VtZW50IiwiTkVXX1BBR0dJTyIsIkBidWlsZGVyIiwibmV3IiwidG9fcHJvYyIsInByb2MiLCJibG9jayBpbiBpbml0aWFsaXplIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbml0aWFsaXplIiwiYnVpbGQhIiwiISIsIkByb290cyIsIm1hcCIsImUiLCJibG9jayAoMyBsZXZlbHMpIGluIGluaXRpYWxpemUiLCJCdWlsZGVyIiwiZXh0ZW5kISIsInRvX2EiLCJTdHJpbmciLCJibG9jayBpbiA8bW9kdWxlOkRPTT4iLCJiIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8bW9kdWxlOkRPTT4iLCJjcmVhdGVfdGV4dCIsIlBhZ2dpbzo6SFRNTDo6RWxlbWVudCIsIm9wdGlvbnMiLCJIYXNoIiwiZG9tIiwiY3JlYXRlX2VsZW1lbnQiLCJibG9jayAoMyBsZXZlbHMpIGluIDxtb2R1bGU6RE9NPiIsImlubmVyIiwiaW5uZXJfaHRtbD0iLCJjaGlsZCIsIkRPTTo6Tm9kZSIsIkRPTSJdLCJtYXBwaW5ncyI6IkFBQUFBLHNDQUFBQSxnQkFBQUE7RUFBQUE7O0VBQUFBOztFQUNBQztFQUFBQTs7O0lBQ0VBLE9BQUFDLE1BQUlDLElBQUpELGNBQUFBLG1CQUFpQkUsTUFBakJGO0FBQUFBO01BQ0VBLE9BQUFFO0lBREZGLENBQUFBO0VBREZELEdBQU9JLFlBQVBKO0VBTUFLO0VBQUFBOztJQUFBQTs7QUFBQUE7SUFDRUEs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QUFBLENBQUcwQyxhQUFPNUIsT0FBQUEsQ0FBT2lDLENBQWQsRUFBaUJXLEtBQVY1QyxDQUFWZCxFQUROZ0QsQ0FBSS9CO1FBSE47UUFRQStCLE9BQUFLLElBdEJGUCxDQUFPcEM7TUF5QlBKLE9BQU9JLE1BQVBnQyxhQUFPaEMsT0FBQUEsRUFBQUEsQ0FBS2lELElBQUFDLFNBQUFELFNBQUxqRCxDQUFBQSxFQUFQb0MsaUJBQTBCQyxDQUFELEVBQUkvQixJQUE3QjhCOztRQUEwQjtRQUFHO1FBQzNCRSxPQUFBaEMsS0FERjhCLENBQU9wQztJQXpGU0osR0FBQUEsV0FBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBYkFmOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo0MjMxMiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZG9tL2VsZW1lbnQvY3VzdG9tLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgdXNlX3N0cmljdDogdHJ1ZVxuIyBoZWxwZXJzOiB0cnV0aHlcblxubW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBET007IGNsYXNzIEVsZW1lbnQgPCBOb2RlXG5cbiMgQ3VzdG9tRWxlbWVudHMgaW1wbGVtZW50YXRpb24gZm9yIG9wYWwtYnJvd3Nlci4gU2VlIGV4YW1wbGVzL2N1c3RvbV9lbGVtZW50cy8uXG4jXG4jIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvV2ViX0NvbXBvbmVudHMvVXNpbmdfY3VzdG9tX2VsZW1lbnRzXG4jIEBhYnN0cmFjdCBUaGlzIGNsYXNzIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseS4gUGxlYXNlIGV4dGVuZCBpdCBhbmQgaW1wbGVtZW50IG5lZWRlZCBtZXRob2RzLlxuY2xhc3MgQ3VzdG9tIDwgRWxlbWVudFxuICAjIFRoZSByZWFzb24gd2h5IHdlIHdyYXAgY2xhc3MgZGVmaW5pdGlvbiB3aXRoIGFuIGV2YWwgaXMga2luZCBvZiBzZWxmaXNoLiBJIHdhbnQgaXQgdG8gd29ya1xuICAjIHdpdGggb3BhbC1vcHRpbWl6ZXIgd2hpY2ggZG9lc24ndCBzdXBwb3J0IHRoZSBuZXcgY2xhc3Mgc3ludGF4LiBJIHdvdWxkIGRvIGl0IHdpdGggcHJvdG90eXBlcyxcbiAgIyBidXQgdGhlIHByb3RvdHlwZXMgc3lzdGVtIGlzIHNvIG1lc3N5IEkgZ2F2ZSB1cC5cbiAgI1xuICAjIFRoZXJlZm9yZSwgZm9yIGl0IHRvIGJlIGNsZWFuZWQgdXAsIG9uZSBvZiB0aG9zZSB0d28gbXVzdCBoYXBwZW46XG4gICMgLSB3ZSByYWlzZSB0aGUgc3VwcG9ydGVkIEVTIHZlcnNpb24gaW4gT3BhbCBhbmQgd2UgaW1wbGVtZW50IHRob3NlIEVTIHN5bnRheCBmZWF0dXJlcyBpblxuICAjICAgcmtlbGx5LXR1cmJvLiBBbmQgdGhlbiB3ZSByZW1vdmUgdGhlIHBvbHlmaWxsLlxuICAjIC0gd2UgcmVpbXBsZW1lbnQgaXQgaW4gdGVybXMgb2YgcHJvdG90eXBlcy5cbiAgJXh7XG4gICAgdmFyIG1ha2VfY3VzdG9tX2NsYXNzID0gRnVuY3Rpb24oJ3NlbGYsYmFzZV9jbGFzcycsXG4gICAgICAnXCJ1c2Ugc3RyaWN0XCI7IFxcXG4gICAgICB2YXIga2xhc3MgPSBjbGFzcyBleHRlbmRzIGJhc2VfY2xhc3MgeyBcXFxuICAgICAgICBjb25zdHJ1Y3RvcigpIHsgXFxcbiAgICAgICAgICBzdXBlcigpOyBcXFxuICAgICAgICAgIHNlbGYuJF9kaXNwYXRjaF9jb25zdHJ1Y3Rvcih0aGlzKTsgXFxcbiAgICAgICAgfSBcXFxuICAgICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHsgXFxcbiAgICAgICAgICByZXR1cm4gdGhpcy4kJG9wYWxfbmF0aXZlX2NhY2hlZC4kYXR0YWNoZWQoKTsgXFxcbiAgICAgICAgfSBcXFxuICAgICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHsgXFxcbiAgICAgICAgICByZXR1cm4gdGhpcy4kJG9wYWxfbmF0aXZlX2NhY2hlZC4kZGV0YWNoZWQoKTsgXFxcbiAgICAgICAgfSBcXFxuICAgICAgICBhZG9wdGVkQ2FsbGJhY2soKSB7IFxcXG4gICAgICAgICAgcmV0dXJuIHRoaXMuJCRvcGFsX25hdGl2ZV9jYWNoZWQuJGFkb3B0ZWQoKTsgXFxcbiAgICAgICAgfSBcXFxuICAgICAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ciwgZnJvbSwgdG8pIHsgXFxcbiAgICAgICAgICBpZiAoZnJvbSA9PT0gbnVsbCkgZnJvbSA9IE9wYWwubmlsOyBcXFxuICAgICAgICAgIGlmICh0byA9PT0gbnVsbCkgdG8gPSBPcGFsLm5pbDsgXFxcbiAgICAgICAgICByZXR1cm4gdGhpcy4kJG9wYWxfbmF0aXZlX2NhY2hlZC4kYXR0cmlidXRlX2NoYW5nZWQoYXR0ciwgZnJvbSwgdG8pOyBcXFxuICAgICAgICB9IFxcXG4gICAgICAgIFxcXG4gICAgICAgIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkgeyBcXFxuICAgICAgICAgIHJldHVybiBzZWxmLiRvYnNlcnZlZF9hdHRyaWJ1dGVzKCk7IFxcXG4gICAgICAgIH0gXFxcbiAgICAgIH07IFxcXG4gICAgICBrbGFzcy4kJG9wYWxfY2xhc3MgPSBzZWxmOyBcXFxuICAgICAgcmV0dXJuIGtsYXNzOydcbiAgICApO1xuICB9IGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdDdXN0b20gRWxlbWVudHMnICMnXG5cbiAgbW9kdWxlIENsYXNzTWV0aG9kc1xuICAgIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdDdXN0b20gRWxlbWVudHMnXG4gICAgICAjIERlZmluZXMgYSBuZXcgY3VzdG9tIGVsZW1lbnQuIFRoaXMgc2hvdWxkIGNvbWUgYXMgdGhlIGxhc3QgY2FsbFxuICAgICAgIyBpbiB0aGUgY2xhc3MgZGVmaW5pdGlvbiwgYmVjYXVzZSBhdCB0aGlzIHBvaW50IHRoZSBtZXRob2RzIG1heVxuICAgICAgIyBiZSBjYWxsZWQhXG4gICAgICAjXG4gICAgICAjIEBvcGFsb3B0IHVzZXM6X2Rpc3BhdGNoX2NvbnN0cnVjdG9yLGF0dGFjaGVkLGRldGFjaGVkLGFkb3B0ZWQsYXR0cmlidXRlX2NoYW5nZWQsb2JzZXJ2ZWRfYXR0cmlidXRlc1xuICAgICAgZGVmIGRlZl9jdXN0b20odGFnX25hbWUsIGJhc2VfY2xhc3M6IG5pbCwgZXh0ZW5kczogbmlsKVxuICAgICAgICBpZiBgYmFzZV9jbGFzcyAhPT0gbmlsYFxuICAgICAgICBlbHNpZiBzZWxmLnN1cGVyY2xhc3MgPT0gQ3VzdG9tXG4gICAgICAgICAgYmFzZV9jbGFzcyA9IGBIVE1MRWxlbWVudGBcbiAgICAgICAgZWxzaWYgc2VsZi5hbmNlc3RvcnMuaW5jbHVkZT8gQ3VzdG9tXG4gICAgICAgICAgYmFzZV9jbGFzcyA9IGAje3NlbGYuc3VwZXJjbGFzc30uY3VzdG9tX2NsYXNzYFxuICAgICAgICBlbHNlXG4gICAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJZb3UgbXVzdCBkZWZpbmUgYmFzZV9jbGFzc1wiXG4gICAgICAgIGVuZFxuXG4gICAgICAgIEBjdXN0b21fY2xhc3MgPSBgbWFrZV9jdXN0b21fY2xhc3Moc2VsZiwgI3tiYXNlX2NsYXNzfSlgXG4gICAgICAgIEBvYnNlcnZlZF9hdHRyaWJ1dGVzIHx8PSBbXVxuXG4gICAgICAgIGRlZl9zZWxlY3RvciB0YWdfbmFtZVxuXG4gICAgICAgICV4e1xuICAgICAgICAgIGlmICgkdHJ1dGh5KCN7ZXh0ZW5kc30pKSBjdXN0b21FbGVtZW50cy5kZWZpbmUoI3t0YWdfbmFtZX0sICN7QGN1c3RvbV9jbGFzc30sIHtleHRlbmRzOiAje2V4dGVuZHN9fSk7XG4gICAgICAgICAgZWxzZSBjdXN0b21FbGVtZW50cy5kZWZpbmUoI3t0YWdfbmFtZX0sICN7QGN1c3RvbV9jbGFzc30pO1xuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnTXV0YXRpb25PYnNlcnZlcidcbiAgICAgICMgQ2FuIHdlIHBvbHlmaWxsIGl0P1xuICAgICAgQnJvd3Nlcjo6RE9NOjpNdXRhdGlvbk9ic2VydmVyLm5ldyBkbyB8b2JzfFxuICAgICAgICBvYnMuZWFjaCBkbyB8ZXxcbiAgICAgICAgICB0YXJnZXQgPSBlLnRhcmdldFxuXG4gICAgICAgICAgY2FzZSBlLnR5cGVcbiAgICAgICAgICB3aGVuIDphdHRyaWJ1dGVcbiAgICAgICAgICAgIGlmIEN1c3RvbTo6TWl4aW4gPT09IHRhcmdldCAmJiB0YXJnZXQuY2xhc3Mub2JzZXJ2ZWRfYXR0cmlidXRlcy5pbmNsdWRlPyhlLm5hbWUpXG4gICAgICAgICAgICAgIHRhcmdldC5hdHRyaWJ1dGVfY2hhbmdlZChlLm5hbWUsIGUub2xkLCB0YXJnZXRbZS5uYW1lXSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIHdoZW4gOnRyZWVcbiAgICAgICAgICAgIGUuYWRkZWQuZWFjaCB7IHxufCBuLmF0dGFjaGVkX29uY2UgaWYgQ3VzdG9tOjpNaXhpbiA9PT0gbiB9XG4gICAgICAgICAgICBlLnJlbW92ZWQuZWFjaCB7IHxufCBuLmRldGFjaGVkX29uY2UgaWYgQ3VzdG9tOjpNaXhpbiA9PT0gbiB9XG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kLm9ic2VydmUoJGRvY3VtZW50LCB0cmVlOiB0cnVlLCBjaGlsZHJlbjogdHJ1ZSwgYXR0cmlidXRlczogOm9sZClcbiAgICBlbmRcblxuICAgIHVubGVzcyBCcm93c2VyLnN1cHBvcnRzPyAnQ3VzdG9tIEVsZW1lbnRzJ1xuICAgICAgIyBUaGUgcG9seWZpbGxlZCBpbXBsZW1lbnRhdGlvbi4gRGVmaW5lIHRoZSBzZWxlY3RvciBhbmQgdGhlblxuICAgICAgIyB0cnkgdG8gdXBncmFkZSB0aGUgZWxlbWVudHMgdGhhdCBhcmUgYWxyZWFkeSBpbiB0aGUgZG9jdW1lbnQuXG4gICAgICBkZWYgZGVmX2N1c3RvbSh0YWdfbmFtZSwgYmFzZV9jbGFzczogbmlsLCBleHRlbmRzOiBuaWwpXG4gICAgICAgIGRlZl9zZWxlY3RvciB0YWdfbmFtZVxuXG4gICAgICAgICRkb2N1bWVudC5ib2R5LmNzcyh0YWdfbmFtZSkuZWFjaCBkbyB8ZWxlbXxcbiAgICAgICAgICBfZGlzcGF0Y2hfY29uc3RydWN0b3IoZWxlbS50b19uKSYuYXR0YWNoZWRfb25jZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgcHJpdmF0ZSBkZWYgX2Rpc3BhdGNoX2NvbnN0cnVjdG9yKG9iailcbiAgICAgICV4e1xuICAgICAgICBpZiAodHlwZW9mIG9iai4kJG9wYWxfbmF0aXZlX2NhY2hlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBkZWxldGUgb2JqLiQkb3BhbF9uYXRpdmVfY2FjaGVkO1xuICAgICAgICAgIHJldHVybiBzZWxmLiRuZXcob2JqKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzZWxmLiRuZXcob2JqKTtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICAjIFRoaXMgbXVzdCBiZSBkZWZpbmVkIGJlZm9yZSBkZWZfY3VzdG9tIGlzIGNhbGxlZCFcbiAgICBhdHRyX2FjY2Vzc29yIDpvYnNlcnZlZF9hdHRyaWJ1dGVzXG5cbiAgICBhdHRyX3JlYWRlciA6Y3VzdG9tX2NsYXNzXG4gIGVuZFxuXG4gIG1vZHVsZSBNaXhpblxuICAgIGRlZiBzZWxmLmluY2x1ZGVkKGtsYXNzKVxuICAgICAga2xhc3MuZXh0ZW5kIENsYXNzTWV0aG9kc1xuICAgIGVuZFxuXG4gICAgIyBAYWJzdHJhY3RcbiAgICBkZWYgYXR0YWNoZWRcbiAgICBlbmRcblxuICAgICMgQGFic3RyYWN0XG4gICAgZGVmIGRldGFjaGVkXG4gICAgZW5kXG5cbiAgICAjIEBhYnN0cmFjdFxuICAgIGRlZiBhZG9wdGVkXG4gICAgZW5kXG5cbiAgICAjIE5vdGU6IGZvciB0aGlzIG1ldGhvZCB0byBmaXJlLCB5b3Ugd2lsbCBuZWVkIHRvIGRlZmluZVxuICAgICMgdGhlIG9ic2VydmVkIGF0dHJpYnV0ZXMuXG4gICAgI1xuICAgICMgQGFic3RyYWN0XG4gICAgZGVmIGF0dHJpYnV0ZV9jaGFuZ2VkKGF0dHIsIGZyb20sIHRvKVxuICAgIGVuZFxuXG4gICAgIyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbm9kZSBpcyBhIGN1c3RvbSBlbGVtZW50LlxuICAgIGRlZiBjdXN0b20/XG4gICAgICB0cnVlXG4gICAgZW5kXG5cbiAgICAjIFRob3NlIG1ldGhvZHMga2VlcCB0cmFjayBvZiB0aGUgYXR0YWNobWVudCBzdGF0dXMgb2YgdGhlIGVsZW1lbnRzLFxuICAgICMgc28gdGhhdCAjYXR0YWNoZWQvI2RldGFjaGVkIGlzbid0IGNhbGxlZCB0d2ljZS5cbiAgICB1bmxlc3MgQnJvd3Nlci5zdXBwb3J0cz8gJ0N1c3RvbSBFbGVtZW50cydcbiAgICAgICMgQHByaXZhdGVcbiAgICAgIGRlZiBhdHRhY2hlZF9vbmNlXG4gICAgICAgIGF0dGFjaGVkIHVubGVzcyBAX3BvbHlmaWxsX2F0dGFjaGVkXG4gICAgICAgIEBfcG9seWZpbGxfYXR0YWNoZWQgPSB0cnVlXG4gICAgICBlbmRcblxuICAgICAgIyBAcHJpdmF0ZVxuICAgICAgZGVmIGRldGFjaGVkX29uY2VcbiAgICAgICAgZGV0YWNoZWQgaWYgQF9wb2x5ZmlsbF9hdHRhY2hlZFxuICAgICAgICBAX3BvbHlmaWxsX2F0dGFjaGVkID0gZmFsc2VcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcblxuICBpbmNsdWRlIE1peGluXG5lbmRcblxuZW5kOyBlbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPG1vZHVsZTpET00+IiwiPGNsYXNzOkVsZW1lbnQ+IiwiPGNsYXNzOkN1c3RvbT4iLCJCcm93c2VyIiwic3VwcG9ydHM/IiwiPG1vZHVsZTpDbGFzc01ldGhvZHM+IiwiZGVmX2N1c3RvbSIsInRhZ19uYW1lIiwiJGt3YXJncyIsInNlbGYiLCJzdXBlcmNsYXNzIiwiQ3VzdG9tIiwiYmFzZV9jbGFzcyIsImFuY2VzdG9ycyIsImluY2x1ZGU/IiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwiQGN1c3RvbV9jbGFzcyIsIkBvYnNlcnZlZF9hdHRyaWJ1dGVzIiwiJHJldF9vcl8xIiwiZGVmX3NlbGVjdG9yIiwiZXh0ZW5kcyQiLCJuZXciLCJCcm93c2VyOjpET006Ok11dGF0aW9uT2JzZXJ2ZXIiLCJCcm93c2VyOjpET00iLCJibG9jayBpbiA8bW9kdWxlOkNsYXNzTWV0aG9kcz4iLCJvYnMiLCJibG9jayAoMiBsZXZlbHMpIGluIDxtb2R1bGU6Q2xhc3NNZXRob2RzPiIsImVhY2giLCJlIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiA8bW9kdWxlOkNsYXNzTWV0aG9kcz4iLCJ0YXJnZXQiLCJ0eXBlIiwiQ3VzdG9tOjpNaXhpbiIsImNsYXNzIiwib2JzZXJ2ZWRfYXR0cmlidXRlcyIsIm5hbWUiLCJhdHRyaWJ1dGVfY2hhbmdlZCIsIm9sZCIsIltdIiwiYWRkZWQiLCJuIiwiYmxvY2sgKDQgbGV2ZWxzKSBpbiA8bW9kdWxlOkNsYXNzTWV0aG9kcz4iLCJhdHRhY2hlZF9vbmNlIiwicmVtb3ZlZCIsImRldGFjaGVkX29uY2UiLCJvYnNlcnZlIiwiJGRvY3VtZW50IiwiYm9keSIsImNzcyIsImJsb2NrIGluIGRlZl9jdXN0b20iLCJlbGVtIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkZWZfY3VzdG9tIiwiX2Rpc3BhdGNoX2NvbnN0cnVjdG9yIiwidG9fbiIsInByaXZhdGUiLCJvYmoiLCJhdHRyX2FjY2Vzc29yIiwiYXR0cl9yZWFkZXIiLCI8bW9kdWxlOk1peGluPiIsImluY2x1ZGVkIiwia2xhc3MiLCJleHRlbmQiLCJDbGFzc01ldGhvZHMiLCJhdHRhY2hlZCIsImRldGFjaGVkIiwiYWRvcHRlZCIsImN1c3RvbT8iLCJAX3BvbHlmaWxsX2F0dGFjaGVkIiwiaW5jbHVkZSIsIk1peGluIiwiRWxlbWVudCIsIk5vZGUiXSwibWFwcGluZ3MiOiJBQUFBQSw2Q0FBQUEsZ0JBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTtFQUdBQSxPQUFB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T0FBQXlCLENBQUFBLDBCQUFzQixJQUF0QkE7Y0FGRnpCLENBQUFBO2NBTUFnQixPQUFBZCw2QkFBQUEseUJBQUFBO0FBQUFBLGdCQUFBQTtBQUFBQTs7O2dCQUNFLElBQUEsUUFBWXVCLHVCQUFaLENBQUE7a0JBQUEzRCxJQUFBd0QsVUFBQUEsQ0FBQUE7Z0JBQUE7Z0JBQ0FwQixPQUFBdUIsQ0FBQUEsMEJBQXNCLEtBQXRCQTtjQUZGdkIsQ0FBQUE7WUFSRjtVQS9CRmMsR0FBQUEsV0FBQUE7VUE4Q0F6RCxPQUFBTyxJQUFBNEQsU0FBQUEsQ0FBUUMsV0FBUkQ7UUFwS0ZuRSxHQUFBQSxXQUFBQSxFQUFlcUUsYUFBZnJFO01BTjRCRCxHQUFBQSxXQUFBQSxFQUFnQnVFLFVBQWhCdkU7SUFBWkQsR0FBQUEsV0FBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBSEFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo0MjUzOSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvY2FudmFzL3N0eWxlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBjbGFzcyBDYW52YXNcblxuY2xhc3MgU3R5bGVPYmplY3RcbiAgaW5jbHVkZSBOYXRpdmU6OldyYXBwZXJcblxuICBhdHRyX3JlYWRlciA6Y29udGV4dFxuXG4gIGRlZiBpbml0aWFsaXplKGNvbnRleHQpXG4gICAgQGNvbnRleHQgPSBjb250ZXh0XG5cbiAgICBzdXBlcihAY29udGV4dC50b19uKVxuICBlbmRcbmVuZFxuXG5jbGFzcyBTdHlsZSA8IFN0eWxlT2JqZWN0XG4gIGNsYXNzIExpbmUgPCBTdHlsZU9iamVjdFxuICAgIGF0dHJfcmVhZGVyIDp3aWR0aCwgOmNhcCwgOmpvaW4sIDptaXRlcl9saW1pdFxuXG4gICAgZGVmIHdpZHRoPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5saW5lV2lkdGggPSAje0B3aWR0aCA9IHZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBjYXA9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmxpbmVDYXAgPSAje0BjYXAgPSB2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgam9pbj0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUubGluZUpvaW4gPSAje0Bqb2luID0gdmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIG1pdGVyX2xpbWl0PSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5taXRlckxpbWl0ID0gI3tAbWl0ZXJfbGltaXQgPSB2YWx1ZX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGNsYXNzIFRleHQgPCBTdHlsZU9iamVjdFxuICAgIGF0dHJfcmVhZGVyIDpmb250LCA6YWxpZ24sIDpiYXNlbGluZVxuXG4gICAgZGVmIGZvbnQ9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmZvbnQgPSAje0Bmb250ID0gdmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIGFsaWduPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS50ZXh0QWxpZ24gPSAje0BhbGlnbiA9IHZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBiYXNlbGluZT0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUudGV4dEJhc2VsaW5lID0gI3tAYmFzZWxpbmUgPSB2YWx1ZX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGNsYXNzIEltYWdlIDwgU3R5bGVPYmplY3RcbiAgICBhdHRyX3JlYWRlciA6c21vb3RoXG5cbiAgICBhbGlhcyBzbW9vdGg/IHNtb290aFxuXG4gICAgZGVmIHNtb290aCFcbiAgICAgIGAjQG5hdGl2ZS5tb3pJbWFnZVNtb290aGluZ0VuYWJsZWQgPSAje0BzbW9vdGggPSB0cnVlfWBcbiAgICAgIGAjQG5hdGl2ZS5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSAje0BzbW9vdGggPSB0cnVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBub19zbW9vdGghXG4gICAgICBgI0BuYXRpdmUubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gI3tAc21vb3RoID0gZmFsc2V9YFxuICAgICAgYCNAbmF0aXZlLmltYWdlU21vb3RoaW5nRW5hYmxlZCA9ICN7QHNtb290aCA9IGZhbHNlfWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgY2xhc3MgU2hhZG93IDwgU3R5bGVPYmplY3RcbiAgICBhdHRyX3JlYWRlciA6b2Zmc2V0LCA6Ymx1ciwgOmNvbG9yXG5cbiAgICBkZWYgb2Zmc2V0PSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5zaGFkb3dPZmZzZXRYID0gI3t2YWx1ZVs6eF19YFxuICAgICAgYCNAbmF0aXZlLnNoYWRvd09mZnNldFkgPSAje3ZhbHVlWzp5XX1gXG5cbiAgICAgIEBvZmZzZXQgPSB2YWx1ZVxuICAgIGVuZFxuXG4gICAgZGVmIGJsdXI9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLnNoYWRvd0JsdXIgPSAje0BibHVyID0gdmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIGNvbG9yPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5zaGFkb3dDb2xvciA9ICN7QGNvbG9yID0gdmFsdWV9YFxuICAgIGVuZFxuICBlbmRcblxuICBhdHRyX3JlYWRlciA6bGluZSwgOnRleHQsIDppbWFnZSwgOnNoYWRvdywgOmZpbGwsIDpzdHJva2UsIDphbHBoYSwgOmNvbXBvc2l0ZV9vcGVyYXRpb25cblxuICBkZWYgaW5pdGlhbGl6ZShjb250ZXh0KVxuICAgIHN1cGVyKGNvbnRleHQpXG5cbiAgICBAbGluZSAgID0gTGluZS5uZXcoY29udGV4dClcbiAgICBAdGV4dCAgID0gVGV4dC5uZXcoY29udGV4dClcbiAgICBAaW1hZ2UgID0gSW1hZ2UubmV3KGNvbnRleHQpXG4gICAgQHNoYWRvdyA9IFNoYWRvdy5uZXcoY29udGV4dClcbiAgZW5kXG5cbiAgZGVmIGZpbGw9KHZhbHVlKVxuICAgIGAjQG5hdGl2ZS5maWxsU3R5bGUgPSAjeyhAZmlsbCA9IHZhbHVlKS50b19ufWBcbiAgZW5kXG5cbiAgZGVmIHN0cm9rZT0odmFsdWUpXG4gICAgYCNAbmF0aXZlLnN0cm9rZVN0eWxlID0gI3soQHN0cm9rZSA9IHZhbHVlKS50b19ufWBcbiAgZW5kXG5cbiAgZGVmIGFscGhhPSh2YWx1ZSlcbiAgICBgI0BuYXRpdmUuZ2xvYmFsQWxwaGEgPSAje0BhbHBoYSA9IHZhbHVlfWBcbiAgZW5kXG5cbiAgZGVmIGNvbXBvc2l0ZV9vcGVyYXRpb249KHZhbHVlKVxuICAgIGAjQG5hdGl2ZS5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAje0Bjb21wb3NpdGVfb3BlcmF0aW9uID0gdmFsdWV9YFxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJyb3dzZXI+IiwiPGNsYXNzOkNhbnZhcz4iLCI8Y2xhc3M6U3R5bGVPYmplY3Q+Iiwic2VsZiIsImluY2x1ZGUiLCJOYXRpdmU6OldyYXBwZXIiLCJOYXRpdmUiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJjb250ZXh0IiwiQGNvbnRleHQiLCJ0b19uIiwiPGNsYXNzOlN0eWxlPiIsIjxjbGFzczpMaW5lPiIsIndpZHRoPSIsInZhbHVlIiwiQG5hdGl2ZSIsIkB3aWR0aCIsImNhcD0iLCJAY2FwIiwiam9pbj0iLCJAam9pbiIsIm1pdGVyX2xpbWl0PSIsIkBtaXRlcl9saW1pdCIsIlN0eWxlT2JqZWN0IiwiPGNsYXNzOlRleHQ+IiwiZm9udD0iLCJAZm9udCIsImFsaWduPSIsIkBhbGlnbiIsImJhc2VsaW5lPSIsIkBiYXNlbGluZSIsIjxjbGFzczpJbWFnZT4iLCJzbW9vdGghIiwiQHNtb290aCIsIm5vX3Ntb290aCEiLCI8Y2xhc3M6U2hhZG93PiIsIm9mZnNldD0iLCJbXSIsIkBvZmZzZXQiLCJibHVyPSIsIkBibHVyIiwiY29sb3I9IiwiQGNvbG9yIiwiQGxpbmUiLCJMaW5lIiwibmV3IiwiQHRleHQiLCJUZXh0IiwiQGltYWdlIiwiSW1hZ2UiLCJAc2hhZG93IiwiU2hhZG93IiwiZmlsbD0iLCJAZmlsbCIsInN0cm9rZT0iLCJAc3Ryb2tlIiwiYWxwaGE9IiwiQGFscGhhIiwiY29tcG9z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QU1OLEtBQUFBLENBQUtyQyxPQUFMcUMsQ0FBaEJLO1FBTkYzQyxDQUFBQTs7QUFTQTZDLFFBQUFBLHFCQUFBQSwyQkFBVXRDLEtBQVZzQztBQUFBQSxVQUFBQTs7VUFDRUEsT0FBRXJDLGNBQU9xQyxhQUFnQkMsQ0FBQUEsWUFBUXZDLEtBQVJ1QyxDQUFjM0MsTUFBQUEsQ0FBQUE7UUFEekMwQyxDQUFBQTs7QUFJQUUsUUFBQUEsdUJBQUFBLDZCQUFZeEMsS0FBWndDO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFFdkMsY0FBT3VDLGVBQWtCQyxDQUFBQSxjQUFVekMsS0FBVnlDLENBQWdCN0MsTUFBQUEsQ0FBQUE7UUFEN0M0QyxDQUFBQTs7QUFJQUUsUUFBQUEsc0JBQUFBLDRCQUFXMUMsS0FBWDBDO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFFekMsY0FBT3lDLGVBQWlCQyxDQUFBQSxhQUFTM0MsS0FBVDJDO1FBRDVCRCxDQUFBQTtRQUlBN0MsT0FBQStDLG9DQUFBQSwwQ0FBeUI1QyxLQUF6QjRDO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFFM0MsY0FBTzJDLDRCQUE4QkMsQ0FBQUEsMkJBQXVCN0MsS0FBdkI2QztRQUR6Q0QsQ0FBQUE7TUEvRkYvQyxHQUFBQSxXQUFBQSxFQUFjWSxpQkFBZFo7SUFkZ0JYLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBQWhCRCxHQUFBQSxXQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6NDI3MzIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2NhbnZhcy90ZXh0LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBjbGFzcyBDYW52YXNcblxuY2xhc3MgVGV4dFxuICBpbmNsdWRlIE5hdGl2ZTo6V3JhcHBlclxuXG4gIGF0dHJfcmVhZGVyIDpjb250ZXh0XG5cbiAgZGVmIGluaXRpYWxpemUoY29udGV4dClcbiAgICBAY29udGV4dCA9IGNvbnRleHRcblxuICAgIHN1cGVyKEBjb250ZXh0LnRvX24pXG4gIGVuZFxuXG4gIGRlZiBtZWFzdXJlKHRleHQpXG4gICAgYCNAbmF0aXZlLm1lYXN1cmVUZXh0KHRleHQpYFxuICBlbmRcblxuICBkZWYgZmlsbCh0ZXh0LCB4ID0gbmlsLCB5ID0gbmlsLCBtYXhfd2lkdGggPSBuaWwpXG4gICAgeCB8fD0gMFxuICAgIHkgfHw9IDBcblxuICAgIGlmIG1heF93aWR0aFxuICAgICAgYCNAbmF0aXZlLmZpbGxUZXh0KHRleHQsIHgsIHksIG1heF93aWR0aClgXG4gICAgZWxzZVxuICAgICAgYCNAbmF0aXZlLmZpbGxUZXh0KHRleHQsIHgsIHkpYFxuICAgIGVuZFxuXG4gICAgQGNvbnRleHRcbiAgZW5kXG5cbiAgZGVmIHN0cm9rZSh0ZXh0LCB4ID0gbmlsLCB5ID0gbmlsLCBtYXhfd2lkdGggPSBuaWwpXG4gICAgeCB8fD0gMFxuICAgIHkgfHw9IDBcblxuICAgIGlmIG1heF93aWR0aFxuICAgICAgYCNAbmF0aXZlLnN0cm9rZVRleHQodGV4dCwgeCwgeSwgbWF4X3dpZHRoKWBcbiAgICBlbHNlXG4gICAgICBgI0BuYXRpdmUuc3Ryb2tlVGV4dCh0ZXh0LCB4LCB5KWBcbiAgICBlbmRcblxuICAgIEBjb250ZXh0XG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QnJvd3Nlcj4iLCI8Y2xhc3M6Q2FudmFzPiIsIjxjbGFzczpUZXh0PiIsInNlbGYiLCJpbmNsdWRlIiwiTmF0aXZlOjpXcmFwcGVyIiwiTmF0aXZlIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiY29udGV4dCIsIkBjb250ZXh0IiwidG9fbiIsIm1lYXN1cmUiLCJ0ZXh0IiwiQG5hdGl2ZSIsImZpbGwiLCJ4IiwieSIsIm1heF93aWR0aCIsIiRyZXRfb3JfMSIsIjAiLCJzdHJva2UiXSwibWFwcGluZ3MiOiJBQUFBQSxzQ0FBQUEsZ0JBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7O0lBQWdCQSxPQUFBQztJQUFBQTs7TUFBQUE7O01BRWhCQSxPQUFBQztNQUFBQTs7UUFBQUE7O0FBQUFBOztRQUNFQyxJQUFBQyxTQUFBQSxDQUFRQyxJQUFBQyxZQUFBRCxZQUFSRDtRQUVBRCxJQUFBSSxhQUFBQSxDQUFZLFNBQVpBOztBQUVBQyxRQUFBQSwwQkFBQUEsc0JBQWVDLE9BQWZEO0FBQUFBLFVBQUFBOztVQUFBQTs7VUFDRUUsZUFBV0Q7VUFFWEQsT0FBQSxPQUFBTCxJQUFBLEVBQUEsMERBQUEsY0FBQSxFQUFBLENBQU1PLFlBQVFDLE1BQUFBLENBQUFBLENBQWQsQ0FBQSxFQUFBLElBQUE7UUFIRkgsQ0FBQUE7O0FBTUFJLFFBQUFBLHVCQUFBQSxtQkFBWUMsSUFBWkQ7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUVFLGNBQU9GO1FBRFhBLENBQUFBOztBQUlBRyxRQUFBQSxvQkFBQUEsZ0JBQVNGLElBQUQsRUFBT0csQ0FBUCxFQUFnQkMsQ0FBaEIsRUFBeUJDLFNBQWpDSDtBQUFBQSxVQUFBQTs7O1VBQWUsbUJBQUk7VUFBSyxtQkFBSTtVQUFLLG1DQUFZO1VBQzNDQyxJQWxCSixDQUFBLFFBQUFHLENBQUFBLFlBa0JJSCxDQWxCSkcsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxTQUFBLElBQUEsQ0FrQlVDLENBbEJWLENBQUE7VUFtQklILElBbkJKLENBQUEsUUFBQUUsQ0FBQUEsWUFtQklGLENBbkJKRSxDQUFBLENBQUEsR0FBQSxDQUFBLFNBQUEsSUFBQSxDQW1CVUMsQ0FuQlYsQ0FBQTtVQXFCSSxJQUFBLFFBQUdGLFNBQUgsQ0FBQTtZQUNJSixjQUFPQztVQURYO1lBR0lELGNBQU9DO1VBSFg7VUFNQUEsT0FBQUw7UUFWRkssQ0FBQUEsSUFBQUE7UUFhQWIsT0FBQW1CLHNCQUFBQSxrQkFBV1IsSUFBRCxFQUFPRyxDQUFQLEVBQWdCQyxDQUFoQixFQUF5QkMsU0FBbkNHO0FBQUFBLFVBQUFBOzs7VUFBaUIsbUJBQUk7VUFBSyxtQkFBSTtVQUFLLG1DQUFZO1VBQzdDTCxJQS9CSixDQUFBLFFBQUFHLENBQUFBLFlBK0JJSCxDQS9CSkcsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxTQUFBLElBQUEsQ0ErQlVDLENBL0JWLENBQUE7VUFnQ0lILElBaENKLENBQUEsUUFBQUUsQ0FBQUEsWUFnQ0lGLENBaENKRSxDQUFBLENBQUEsR0FBQSxDQUFBLFNBQUEsSUFBQSxDQWdDVUMsQ0FoQ1YsQ0FBQTtVQWtDSSxJQUFBLFFBQUdGLFNBQUgsQ0FBQTtZQUNJSixjQUFPTztVQURYO1lBR0lQLGNBQU9PO1VBSFg7VUFNQUEsT0FBQVg7UUFWRlcsQ0FBQUEsSUFBQUE7TUE1QkZuQixHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtJQUZnQkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo0MjgwOCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvY2FudmFzL2RhdGEucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IGNsYXNzIENhbnZhc1xuXG5jbGFzcyBEYXRhXG4gIGRlZiBzZWxmLmNyZWF0ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQpXG4gICAgZGF0YSA9IGFsbG9jYXRlXG5cbiAgICBkYXRhLmluc3RhbmNlX2V2YWwge1xuICAgICAgQGNhbnZhcyA9IGNhbnZhcy50b19hXG4gICAgICBAeCAgICAgID0gMFxuICAgICAgQHkgICAgICA9IDBcbiAgICAgIEB3aWR0aCAgPSB3aWR0aFxuICAgICAgQGhlaWdodCA9IGhlaWdodFxuXG4gICAgICBAbmF0aXZlID0gYCN7Y2FudmFzLnRvX259LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KWBcbiAgICB9XG5cbiAgICBkYXRhXG4gIGVuZFxuXG4gIGluY2x1ZGUgTmF0aXZlOjpXcmFwcGVyXG5cbiAgYXR0cl9yZWFkZXIgOngsIDp5LCA6d2lkdGgsIDpoZWlnaHRcblxuICBkZWYgaW5pdGlhbGl6ZShjYW52YXMsIHgsIHksIHdpZHRoLCBoZWlnaHQpXG4gICAgQGNhbnZhcyA9IGNhbnZhcy50b19uXG4gICAgQHggICAgICA9IHhcbiAgICBAeSAgICAgID0geVxuICAgIEB3aWR0aCAgPSB3aWR0aFxuICAgIEBoZWlnaHQgPSBoZWlnaHRcblxuICAgIHN1cGVyKGAjQGNhbnZhcy5nZXRJbWFnZURhdGEoeCwgeSwgd2lkdGgsIGhlaWdodClgKVxuICBlbmRcblxuICBkZWYgbGVuZ3RoXG4gICAgYCNAbmF0aXZlLmRhdGEubGVuZ3RoYFxuICBlbmRcblxuICBkZWYgW10oaW5kZXgpXG4gICAgYCNAbmF0aXZlLmRhdGFbaW5kZXhdYFxuICBlbmRcblxuICBkZWYgW109KGluZGV4LCB2YWx1ZSlcbiAgICBgI0BuYXRpdmUuZGF0YVtpbmRleF0gPSB2YWx1ZWBcbiAgZW5kXG5cbiAgZGVmIHNhdmUoeCA9IG5pbCwgeSA9IG5pbClcbiAgICB4IHx8PSAwXG4gICAgeSB8fD0gMFxuXG4gICAgYCNAY2FudmFzLnB1dEltYWdlRGF0YSgjQG5hdGl2ZSwgeCwgeSlgXG4gIGVuZFxuXG4gIGRlZiBzYXZlX3RvKGNhbnZhcywgeCA9IG5pbCwgeSA9IG5pbClcbiAgICB4IHx8PSAwXG4gICAgeSB8fD0gMFxuXG4gICAgYCN7Y2FudmFzLnRvX259LnB1dEltYWdlRGF0YSgjQG5hdGl2ZSwgeCwgeSlgXG4gIGVuZFxuXG4gIGFsaWFzIHNpemUgbGVuZ3RoXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpDYW52YXM+IiwiPGNsYXNzOkRhdGE+IiwiY3JlYXRlIiwic2VsZiIsImNhbnZhcyIsIndpZHRoIiwiaGVpZ2h0IiwiZGF0YSIsImFsbG9jYXRlIiwiaW5zdGFuY2VfZXZhbCIsImJsb2NrIGluIGNyZWF0ZSIsImJsb2NrICgyIGxldmVscykgaW4gY3JlYXRlIiwiQGNhbnZhcyIsInRvX2EiLCJAeCIsIjAiLCJAeSIsIkB3aWR0aCIsIkBoZWlnaHQiLCJAbmF0aXZlIiwidG9fbiIsImluY2x1ZGUiLCJOYXRpdmU6OldyYXBwZXIiLCJOYXRpdmUiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJ4IiwieSIsImxlbmd0aCIsIltdIiwiaW5kZXgiLCJbXT0iLCJ2YWx1ZSIsInNhdmUiLCIkcmV0X29yXzEiLCJzYXZlX3RvIl0sIm1hcHBpbmdzIjoiQUFBQUEsc0NBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUVoQkEsT0FBQUM7TUFBQUE7O1FBQUFBOztBQUFBQTs7UUFDRUMsTUFBSUMsSUFBSkQsYUFBQUEsa0JBQWdCRSxNQUFELEVBQVNDLEtBQVQsRUFBZ0JDLE1BQS9CSjtBQUFBQSxVQUFBQTs7O1VBQ0VLLE9BQU9KLElBQUFLLFVBQUFBLENBQUFBO1VBRUhDLE1BQUpGLElBQUlFLGlCQUFBQSxFQUFBQSxFQUFBQSxFQUFKQyxhQUFBQSxFQUFBQzs7O1lBQ0VDLGNBQVVSLE1BQU1TLE1BQUFBLENBQUFBO1lBQ2hCQyxTQUFVQztZQUNWQyxTQUFVRDtZQUNWRSxhQUFVWjtZQUNWYSxjQUFVWjtZQUVWSyxPQUFBUSxDQUFBQSxpQkFBYWYsTUFBTWdCLE1BQUFBLENBQUFBLENBQU1ULCtCQUF6QlEsRUFQRlQsQ0FBQUEsR0FBQUEsU0FBQUEsQ0FBSUQ7VUFVSlAsT0FBQUs7UUFiRkwsQ0FBQUE7UUFnQkFDLElBQUFrQixTQUFBQSxDQUFRQyxJQUFBQyxZQUFBRCxZQUFSRDtRQUVBbEIsSUFBQXFCLGFBQUFBLENBQVksR0FBWixFQUFnQixHQUFoQixFQUFvQixPQUFwQixFQUE0QixRQUE1QkE7O0FBRUFDLFFBQUFBLDBCQUFBQSxzQkFBZXJCLE1BQUQsRUFBU3NCLENBQVQsRUFBWUMsQ0FBWixFQUFldEIsS0FBZixFQUFzQkMsTUFBcENtQjtBQUFBQSxVQUFBQTs7VUFBQUE7O1VBQ0ViLGNBQVVSLE1BQU1nQixNQUFBQSxDQUFBQTtVQUNoQk4sU0FBVVk7VUFDVlYsU0FBVVc7VUFDVlYsYUFBVVo7VUFDVmEsY0FBVVo7VUFFVm1CLE9BQUEsT0FBQXRCLElBQUEsRUFBQSwwREFBQSxjQUFBLEVBQUEsQ0FBUVMsV0FBT2Esa0NBQWYsQ0FBQSxFQUFBLElBQUE7UUFQRkEsQ0FBQUE7O0FBVUFHLFFBQUFBLHNCQUFBQSxrQkFBQUE7QUFBQUEsVUFBQUE7O1VBQ0VBLE9BQUVULGNBQU9TO1FBRFhBLENBQUFBOztBQUlBQyxRQUFBQSxrQkFBQUEsb0JBQU9DLEtBQVBEO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFFVixjQUFPVTtRQURYQSxDQUFBQTs7QUFJQUUsUUFBQUEsbUJBQUFBLHVCQUFRRCxLQUFELEVBQVFFLEtBQWZEO0FBQUFBLFVBQUFBOztVQUNFQSxPQUFFWixjQUFPWTtRQURYQSxDQUFBQTs7QUFJQUUsUUFBQUEsb0JBQUFBLGdCQUFTUCxDQUFELEVBQVVDLENBQWxCTTtBQUFBQSxVQUFBQTs7O1VBQVMsbUJBQUk7VUFBSyxtQkFBSTtVQUNwQlAsSUE5Q0osQ0FBQSxRQUFBUSxDQUFBQSxZQThDSVIsQ0E5Q0pRLENBQUEsQ0FBQSxHQUFBLENBQUEsU0FBQSxJQUFBLENBOENVbkIsQ0E5Q1YsQ0FBQTtVQStDSVksSUEvQ0osQ0FBQSxRQUFBTyxDQUFBQSxZQStDSVAsQ0EvQ0pPLENBQUEsQ0FBQSxHQUFBLENBQUEsU0FBQSxJQUFBLENBK0NVbkIsQ0EvQ1YsQ0FBQTtVQWlESWtCLE9BQUVyQixXQUFPcUIsY0FBZWQsY0FBT2M7UUFKakNBLENBQUFBLElBQUFBOztBQU9BRSxRQUFBQSx1QkFBQUEsbUJBQVkvQixNQUFELEVBQVNzQixDQUFULEVBQWtCQyxDQUE3QlE7QUFBQUEsVUFBQUE7OztVQUFvQixtQkFBSTtVQUFLLG1CQUFJO1VBQy9CVCxJQXJESixDQUFBLFFBQUFRLENBQUFBLFlBcURJUixDQXJESlEsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxTQUFBLElBQUEsQ0FxRFVuQixDQXJEVixDQUFBO1VBc0RJWSxJQXRESixDQUFBLFFBQUFPLENBQUFBLFlBc0RJUCxDQXRESk8sQ0FBQSxDQUFBLEdBQUEsQ0FBQSxTQUFBLElBQUEsQ0FzRFVuQixDQXREVixDQUFBO1VBd0RJb0IsT0FBRy9CLE1BQU1nQixNQUFBQSxDQUFBQSxDQUFNZSxjQUFlaEIsY0FBT2dCO1FBSnZDQSxDQUFBQSxJQUFBQTtRQU9BbEMsT0FBQSxhQUFNLE1BQU4sRUFBVyxRQUFYO01BekRGQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtJQUZnQkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFBaEJELEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo0MjkwNiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvY2FudmFzL2dyYWRpZW50LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBjbGFzcyBDYW52YXNcblxuY2xhc3MgR3JhZGllbnRcbiAgaW5jbHVkZSBOYXRpdmU6OldyYXBwZXJcblxuICBhdHRyX3JlYWRlciA6Y29udGV4dFxuXG4gIGRlZiBpbml0aWFsaXplKGNvbnRleHQsICphcmdzLCAmYmxvY2spXG4gICAgQGNvbnRleHQgPSBjb250ZXh0XG5cbiAgICBzdXBlcihjYXNlIGFyZ3MubGVuZ3RoXG4gICAgICB3aGVuIDQgdGhlbiBgI3tAY29udGV4dC50b19ufS5jcmVhdGVMaW5lYXJHcmFkaWVudC5hcHBseShzZWxmLCBhcmdzKWBcbiAgICAgIHdoZW4gNiB0aGVuIGAje0Bjb250ZXh0LnRvX259LmNyZWF0ZVJhZGlhbEdyYWRpZW50LmFwcGx5KHNlbGYsIGFyZ3MpYFxuICAgICAgZWxzZSByYWlzZSBBcmd1bWVudEVycm9yLCBcImRvbid0IGtub3cgd2hlcmUgdG8gZGlzcGF0Y2hcIlxuICAgIGVuZClcblxuICAgIGluc3RhbmNlX2V2YWwoJmJsb2NrKVxuICBlbmRcblxuICBkZWYgYWRkKHBvc2l0aW9uLCBjb2xvcilcbiAgICBgI3tAY29udGV4dC50b19ufS5hZGRDb2xvclN0b3AocG9zaXRpb24sIGNvbG9yKWBcblxuICAgIHNlbGZcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpDYW52YXM+IiwiPGNsYXNzOkdyYWRpZW50PiIsInNlbGYiLCJpbmNsdWRlIiwiTmF0aXZlOjpXcmFwcGVyIiwiTmF0aXZlIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiY29udGV4dCIsIkBjb250ZXh0IiwiNCIsIiRyZXRfb3JfMSIsImFyZ3MiLCJsZW5ndGgiLCJ0b19uIiwiNiIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsImluc3RhbmNlX2V2YWwiLCJibG9jayIsInRvX3Byb2MiLCJhZGQiLCJwb3NpdGlvbiIsImNvbG9yIl0sIm1hcHBpbmdzIjoiQUFBQUEsMENBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUFnQkEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUVoQkEsT0FBQUM7TUFBQUE7O1FBQUFBOztBQUFBQTs7UUFDRUMsSUFBQUMsU0FBQUEsQ0FBUUMsSUFBQUMsWUFBQUQsWUFBUkQ7UUFFQUQsSUFBQUksYUFBQUEsQ0FBWSxTQUFaQTs7QUFFQUMsUUFBQUEsMEJBQUFBLHNCQUFlQyxPQUFELEVBUGhCLEVBT0VEO0FBQUFBLFVBQUFBOztVQUFBQTs7O1VBUEY7VUFPMEI7VUFDdEJFLGVBQVdEO1VBRVgsT0FBQU4sSUFBQSxFQUFBLDBEQUFBLGNBQUEsRUFBQSxDQUNFLENBQUEsUUFBS1EsQ0FBTCxFQURJQyxDQUFBQSxZQUFLQyxJQUFJQyxRQUFBQSxDQUFBQSxDQUFURixDQUNKLENBQUEsR0FBQSxDQUFlRixZQUFRSyxNQUFBQSxDQUFBQSxDQUFNUCx1Q0FBN0IsSUFDQSxDQUFBLFFBQUtRLENBQUwsRUFaTixTQVlNLENBQUEsR0FBQSxDQUFlTixZQUFRSyxNQUFBQSxDQUFBQSxDQUFNUCx1Q0FBN0IsSUFBQSxDQUNLTCxJQUFBYyxPQUFBQSxDQUFNQyxtQkFBTixFQUFxQlYsOEJBQXJCUyxDQURMLENBQUEsQ0FEQSxDQURGLENBQUEsRUFBQSxJQUFBO1VBTUFULE9BQUFXLE1BQUFoQixJQUFBZ0IsaUJBQUFBLEVBQUFBLEVBQUFBLEVBQWVDLEtBQURDLFNBQUFBLENBQUFBLENBQWRGO1FBVEZYLENBQUFBLElBQUFBO1FBWUFOLE9BQUFvQixtQkFBQUEsZUFBUUMsUUFBRCxFQUFXQyxLQUFsQkY7QUFBQUEsVUFBQUE7OztVQUNLWixZQUFRSyxNQUFBQSxDQUFBQSxDQUFNTztVQUVqQkEsT0FBQW5CO1FBSEZtQixDQUFBQTtNQWpCRnBCLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0lBRmdCRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQUFoQkQsR0FBQUEsV0FBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjQyOTU0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9jYW52YXMucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnYnJvd3Nlci9jYW52YXMvc3R5bGUnXG5yZXF1aXJlICdicm93c2VyL2NhbnZhcy90ZXh0J1xucmVxdWlyZSAnYnJvd3Nlci9jYW52YXMvZGF0YSdcbnJlcXVpcmUgJ2Jyb3dzZXIvY2FudmFzL2dyYWRpZW50J1xuXG5tb2R1bGUgQnJvd3NlclxuXG5jbGFzcyBDYW52YXNcbiAgaW5jbHVkZSBOYXRpdmU6OldyYXBwZXJcblxuICBhdHRyX3JlYWRlciA6ZWxlbWVudCwgOnN0eWxlLCA6dGV4dFxuXG4gIGRlZiBpbml0aWFsaXplKCphcmdzKVxuICAgIGlmIERPTTo6RWxlbWVudCA9PT0gYXJncy5maXJzdFxuICAgICAgZWxlbWVudCA9IGFyZ3Muc2hpZnRcblxuICAgICAgaWYgRE9NOjpFbGVtZW50OjpJbWFnZSA9PT0gZWxlbWVudFxuICAgICAgICBAaW1hZ2UgICA9IGVsZW1lbnRcbiAgICAgIGVsc2VcbiAgICAgICAgQGVsZW1lbnQgPSBlbGVtZW50XG4gICAgICBlbmRcbiAgICBlbHNpZiBDYW52YXMgPT09IGFyZ3MuZmlyc3RcbiAgICAgIEBpbWFnZSA9IGFyZ3MuZmlyc3RcbiAgICBlbmRcblxuICAgIHVubGVzcyBAZWxlbWVudFxuICAgICAgQGVsZW1lbnQgPSAkZG9jdW1lbnQuY3JlYXRlX2VsZW1lbnQoJ2NhbnZhcycpXG5cbiAgICAgIGlmIEBpbWFnZVxuICAgICAgICBAZWxlbWVudFs6d2lkdGhdICA9IEBpbWFnZS53aWR0aFxuICAgICAgICBAZWxlbWVudFs6aGVpZ2h0XSA9IEBpbWFnZS5oZWlnaHRcbiAgICAgIGVsc2VcbiAgICAgICAgQGVsZW1lbnRbOndpZHRoXSAgPSBhcmdzLnNoaWZ0XG4gICAgICAgIEBlbGVtZW50WzpoZWlnaHRdID0gYXJncy5zaGlmdFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBpZiBAZWxlbWVudC5ub2RlX25hbWUgIT0gJ0NBTlZBUydcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwidGhlIGVsZW1lbnQgaXNuJ3QgYSA8Y2FudmFzPiBlbGVtZW50XCJcbiAgICBlbmRcblxuICAgIHN1cGVyKGAje0BlbGVtZW50LnRvX259LmdldENvbnRleHQoJzJkJylgKVxuXG4gICAgQHN0eWxlID0gU3R5bGUubmV3KHNlbGYpXG4gICAgQHRleHQgID0gVGV4dC5uZXcoc2VsZilcblxuICAgIGlmIEBpbWFnZVxuICAgICAgZHJhd19pbWFnZShAaW1hZ2UpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB3aWR0aFxuICAgIEBlbGVtZW50Wzp3aWR0aF0udG9faVxuICBlbmRcblxuICBkZWYgaGVpZ2h0XG4gICAgQGVsZW1lbnRbOmhlaWdodF0udG9faVxuICBlbmRcblxuICBkZWYgd2lkdGg9KG5ld193aWR0aClcbiAgICBAZWxlbWVudFs6d2lkdGhdID0gbmV3X3dpZHRoLnRvX2lcbiAgZW5kXG5cbiAgZGVmIGhlaWdodD0obmV3X2hlaWdodClcbiAgICBAZWxlbWVudFs6aGVpZ2h0XSA9IG5ld19oZWlnaHQudG9faVxuICBlbmRcblxuICBkZWYgYXBwZW5kX3RvKHBhcmVudClcbiAgICBAZWxlbWVudC5hcHBlbmRfdG8ocGFyZW50KVxuICBlbmRcblxuICBkZWYgbG9hZChwYXRoKVxuICAgIHByb21pc2UgPSBQcm9taXNlLm5ld1xuICAgIGltYWdlICAgPSAkZG9jdW1lbnQuY3JlYXRlX2VsZW1lbnQoJ2ltZycpXG5cbiAgICBpbWFnZS5vbiA6bG9hZCBkb1xuICAgICAgcHJvbWlzZS5yZXNvbHZlKGltYWdlKVxuICAgIGVuZFxuXG4gICAgaW1hZ2VbOnNyY10gPSBwYXRoXG5cbiAgICBwcm9taXNlXG4gIGVuZFxuXG4gIGRlZiBkYXRhKHggPSBuaWwsIHkgPSBuaWwsIHdpZHRoID0gbmlsLCBoZWlnaHQgPSBuaWwpXG4gICAgeCAgICAgIHx8PSAwXG4gICAgeSAgICAgIHx8PSAwXG4gICAgd2lkdGggIHx8PSBzZWxmLndpZHRoXG4gICAgaGVpZ2h0IHx8PSBzZWxmLmhlaWdodFxuXG4gICAgRGF0YS5uZXcoc2VsZiwgeCwgeSwgd2lkdGgsIGhlaWdodClcbiAgZW5kXG5cbiAgZGVmIHBhdHRlcm4oaW1hZ2UsIHR5cGUgPSA6cmVwZWF0KVxuICAgIGAjQG5hdGl2ZS5jcmVhdGVQYXR0ZXJuKCN7RE9NKGltYWdlKS50b19ufSwgdHlwZSlgXG4gIGVuZFxuXG4gIGRlZiBncmFkaWVudCgqYXJncywgJmJsb2NrKVxuICAgIEdyYWRpZW50Lm5ldyhzZWxmLCAqYXJncywgJmJsb2NrKVxuICBlbmRcblxuICBkZWYgY2xlYXIoeCA9IG5pbCwgeSA9IG5pbCwgd2lkdGggPSBuaWwsIGhlaWdodCA9IG5pbClcbiAgICB4ICAgICAgfHw9IDBcbiAgICB5ICAgICAgfHw9IDBcbiAgICB3aWR0aCAgfHw9IHNlbGYud2lkdGhcbiAgICBoZWlnaHQgfHw9IHNlbGYuaGVpZ2h0XG5cbiAgICBgI0BuYXRpdmUuY2xlYXJSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpYFxuICBlbmRcblxuICBkZWYgYmVnaW5cbiAgICBgI0BuYXRpdmUuYmVnaW5QYXRoKClgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjbG9zZVxuICAgIGAjQG5hdGl2ZS5jbG9zZVBhdGgoKWBcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHNhdmVcbiAgICBgI0BuYXRpdmUuc2F2ZSgpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmVzdG9yZVxuICAgIGAjQG5hdGl2ZS5yZXN0b3JlKClgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBtb3ZlX3RvKHgsIHkpXG4gICAgYCNAbmF0aXZlLm1vdmVUbyh4LCB5KWBcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgYWxpYXMgbW92ZSBtb3ZlX3RvXG5cbiAgZGVmIGxpbmVfdG8oeCwgeSlcbiAgICBgI0BuYXRpdmUubGluZVRvKHgsIHkpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgbGluZSh4MSwgeTEsIHgyLCB5MilcbiAgICBtb3ZlX3RvIHgxLCB5MVxuICAgIGxpbmVfdG8geDIsIHkyXG4gIGVuZFxuXG4gIGRlZiByZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpXG4gICAgYCNAbmF0aXZlLnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodClgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBhcmMoeCwgeSwgcmFkaXVzLCBhbmdsZSwgY2xvY2t3aXNlID0gZmFsc2UpXG4gICAgYCNAbmF0aXZlLmFyYyh4LCB5LCByYWRpdXMsICN7YW5nbGVbOnN0YXJ0XX0sICN7YW5nbGVbOmVuZF19LCAhY2xvY2t3aXNlKWBcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHF1YWRyYXRpY19jdXJ2ZV90byhjcDF4LCBjcDF5LCB4LCB5KVxuICAgIGAjQG5hdGl2ZS5xdWFkcmF0aWNDdXJ2ZVRvKGNwMXgsIGNwMXksIHgsIHkpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgYmV6aWVyX2N1cnZlX3RvKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpXG4gICAgYCNAbmF0aXZlLmJlemllckN1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSlgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjdXJ2ZV90bygqYXJncylcbiAgICBjYXNlIGFyZ3MubGVuZ3RoXG4gICAgd2hlbiA0IHRoZW4gcXVhZHJhdGljX2N1cnZlX3RvKCphcmdzKVxuICAgIHdoZW4gNiB0aGVuIGJlemllcl9jdXJ2ZV90bygqYXJncylcblxuICAgIGVsc2UgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJkb24ndCBrbm93IHdoZXJlIHRvIGRpc3BhdGNoXCJcbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGRyYXdfaW1hZ2UoaW1hZ2UsICphcmdzKVxuICAgIGlmIENhbnZhcyA9PT0gaW1hZ2VcbiAgICAgIGltYWdlID0gaW1hZ2UuZWxlbWVudFxuICAgIGVsc2VcbiAgICAgIGltYWdlID0gRE9NKGltYWdlKVxuICAgIGVuZFxuXG4gICAgaWYgYXJncy5maXJzdC5pc19hPyhIYXNoKVxuICAgICAgc291cmNlLCBkZXN0aW5hdGlvbiA9IGFyZ3NcblxuICAgICAgYCNAbmF0aXZlLmRyYXdJbWFnZSgje2ltYWdlLnRvX259LCAje3NvdXJjZVs6eF19LCAje3NvdXJjZVs6eV19LCAje3NvdXJjZVs6d2lkdGhdfSwgI3tzb3VyY2VbOmhlaWdodF19LCAje2Rlc3RpbmF0aW9uWzp4XX0sICN7ZGVzdGluYXRpb25bOnldfSwgI3tkZXN0aW5hdGlvbls6d2lkdGhdfSwgI3tkZXN0aW5hdGlvbls6aGVpZ2h0XX0pYFxuICAgIGVsc2VcbiAgICAgIGNhc2UgYXJncy5sZW5ndGhcbiAgICAgIHdoZW4gMFxuICAgICAgICBgI0BuYXRpdmUuZHJhd0ltYWdlKCN7aW1hZ2UudG9fbn0sIDAsIDApYFxuXG4gICAgICB3aGVuIDJcbiAgICAgICAgYCNAbmF0aXZlLmRyYXdJbWFnZSgje2ltYWdlLnRvX259LCAje2FyZ3NbMF19LCAje2FyZ3NbMV19KWBcblxuICAgICAgd2hlbiA0XG4gICAgICAgIGAjQG5hdGl2ZS5kcmF3SW1hZ2UoI3tpbWFnZS50b19ufSwgI3thcmdzWzBdfSwgI3thcmdzWzFdfSwgI3thcmdzWzJdfSwgI3thcmdzWzNdfSlgXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRyYW5zbGF0ZSh4LCB5LCAmYmxvY2spXG4gICAgaWYgYmxvY2tcbiAgICAgIHNhdmVcblxuICAgICAgYCNAbmF0aXZlLnRyYW5zbGF0ZSh4LCB5KWBcblxuICAgICAgaW5zdGFuY2VfZXZhbCgmYmxvY2spXG5cbiAgICAgIHJlc3RvcmVcbiAgICBlbHNlXG4gICAgICBgI0BuYXRpdmUudHJhbnNsYXRlKHgsIHkpYFxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcm90YXRlKGFuZ2xlLCAmYmxvY2spXG4gICAgaWYgYmxvY2tcbiAgICAgIHNhdmVcblxuICAgICAgYCNAbmF0aXZlLnJvdGF0ZShhbmdsZSlgXG5cbiAgICAgIGluc3RhbmNlX2V2YWwoJmJsb2NrKVxuXG4gICAgICByZXN0b3JlXG4gICAgZWxzZVxuICAgICAgYCNAbmF0aXZlLnJvdGF0ZShhbmdsZSlgXG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBzY2FsZSh4LCB5LCAmYmxvY2spXG4gICAgaWYgYmxvY2tcbiAgICAgIHNhdmVcblxuICAgICAgYCNAbmF0aXZlLnNjYWxlKHgsIHkpYFxuXG4gICAgICBpbnN0YW5jZV9ldmFsKCZibG9jaylcblxuICAgICAgcmVzdG9yZVxuICAgIGVsc2VcbiAgICAgIGAjQG5hdGl2ZS5zY2FsZSh4LCB5KWBcbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRyYW5zZm9ybShtMTEsIG0xMiwgbTIxLCBtMjIsIGR4LCBkeSwgJmJsb2NrKVxuICAgIGlmIGJsb2NrXG4gICAgICBzYXZlXG5cbiAgICAgIGAjQG5hdGl2ZS50cmFuc2Zvcm0obTExLCBtMTIsIG0yMSwgbTIyLCBkeCwgZHkpYFxuXG4gICAgICBpbnN0YW5jZV9ldmFsKCZibG9jaylcblxuICAgICAgcmVzdG9yZVxuICAgIGVsc2VcbiAgICAgIGAjQG5hdGl2ZS50cmFuc2Zvcm0obTExLCBtMTIsIG0yMSwgbTIyLCBkeCwgZHkpYFxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcGF0aCgmYmxvY2spXG4gICAgYCNAbmF0aXZlLmJlZ2luUGF0aCgpYFxuXG4gICAgaW5zdGFuY2VfZXZhbCgmYmxvY2spXG5cbiAgICBgI0BuYXRpdmUuY2xvc2VQYXRoKClgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBmaWxsKCZibG9jaylcbiAgICBwYXRoKCZibG9jaykgaWYgYmxvY2tcblxuICAgIGAjQG5hdGl2ZS5maWxsKClgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBzdHJva2UoJmJsb2NrKVxuICAgIHBhdGgoJmJsb2NrKSBpZiBibG9ja1xuXG4gICAgYCNAbmF0aXZlLnN0cm9rZSgpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY2xpcCgmYmxvY2spXG4gICAgcGF0aCgmYmxvY2spIGlmIGJsb2NrXG5cbiAgICBgI0BuYXRpdmUuY2xpcCgpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcG9pbnRfaW5fcGF0aD8oeCwgeSlcbiAgICBgI0BuYXRpdmUuaXNQb2ludEluUGF0aCh4LCB5KWBcbiAgZW5kXG5cbiAgZGVmIHRvX2RhdGEodHlwZSA9IHVuZGVmaW5lZClcbiAgICBgI3tAZWxlbWVudC50b19ufS50b0RhdGFVcmwodHlwZSlgXG4gIGVuZFxuXG4gIGRlZiB0b19kb20oKilcbiAgICBAZWxlbWVudFxuICBlbmRcblxuICBkZWYgb24oKmFyZ3MsICZibG9jayk7IEBlbGVtZW50Lm9uKCphcmdzLCAmYmxvY2spOyBlbmRcbiAgZGVmIG9uZSgqYXJncywgJmJsb2NrKTsgQGVsZW1lbnQub25lKCphcmdzLCAmYmxvY2spOyBlbmRcbiAgZGVmIG9mZigqYXJncywgJmJsb2NrKTsgQGVsZW1lbnQub2ZmKCphcmdzLCAmYmxvY2spOyBlbmRcbmVuZFxuXG5Ccm93c2VyOjpET006OkJ1aWxkZXIuZm9yIENhbnZhcyBkbyB8YiwgaXRlbXxcbiAgaXRlbS5lbGVtZW50XG5lbmRcblxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPG1vZHVsZTpCcm93c2VyPiIsIjxjbGFzczpDYW52YXM+IiwiaW5jbHVkZSIsIk5hdGl2ZTo6V3JhcHBlciIsIk5hdGl2ZSIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsIkRPTTo6RWxlbWVudCIsIkRPTSIsImFyZ3MiLCJmaXJzdCIsImVsZW1lbnQiLCJzaGlmdCIsIkRPTTo6RWxlbWVudDo6SW1hZ2UiLCJAaW1hZ2UiLCJAZWxlbWVudCIsIkNhbnZhcyIsIiRkb2N1bWVudCIsImNyZWF0ZV9lbGVtZW50IiwiW109Iiwid2lkdGgiLCJoZWlnaHQiLCJub2RlX25hbWUiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJ0b19uIiwiQHN0eWxlIiwiU3R5bGUiLCJuZXciLCJAdGV4dCIsIlRleHQiLCJkcmF3X2ltYWdlIiwiW10iLCJ0b19pIiwid2lkdGg9IiwibmV3X3dpZHRoIiwiaGVpZ2h0PSIsIm5ld19oZWlnaHQiLCJhcHBlbmRfdG8iLCJwYXJlbnQiLCJsb2FkIiwicGF0aCIsInByb21pc2UiLCJQcm9taXNlIiwiaW1hZ2UiLCJvbiIsImJsb2NrIGluIGxvYWQiLCJibG9jayAoMiBsZXZlbHMpIGluIGxvYWQiLCJyZXNvbHZlIiwiZGF0YSIsIngiLCJ5IiwiJHJldF9vcl8xIiwiMCIsIkRhdGEiLCJwYXR0ZXJuIiwidHlwZSIsIkBuYXRpdmUiLCJncmFkaWVudCIsIkdyYWRpZW50IiwiYmxvY2siLCJ0b19wcm9jIiwiY2xlYXIiLCJiZWdpbiIsImNsb3NlIiwic2F2ZSIsInJlc3RvcmUiLCJtb3ZlX3RvIiwibGluZV90byIsImxpbmUiLCJ4MSIsInkxIiwieDIiLCJ5MiIsInJlY3QiLCJhcmMiLCJyYWRpdXMiLCJhbmdsZSIsImNsb2Nrd2lzZSIsInF1YWRyYXRpY19jdXJ2ZV90byIsImNwMXgiLCJjcDF5IiwiYmV6aWVyX2N1cnZlX3RvIiwiY3AyeCIsImNwMnkiLCJjdXJ2ZV90byIsImxlbmd0aCIsIjQiLCI2IiwiaXNfYT8iLCJIYXNoIiwic291cmNlIiwiZGVzdGluYXRpb24iLCIyIiwiMSIsIjMiLCJ0cmFuc2xhdGUiLCJpbnN0YW5jZV9ldmFsIiwicm90YXRlIiwic2NhbGUiLCJ0cmFuc2Zvcm0iLCJtMTEiLCJtMTIiLCJtMjEiLCJtMjIiLCJkeCIsImR5IiwiZmlsbCIsInN0cm9rZSIsImNsaXAiLCJwb2ludF9pbl9wYXRoPyIsInRvX2RhdGEiLCJ0b19kb20iLCJvbmUiLCJvZmYiLCJmb3IiLCJCcm93c2VyOjpET006OkJ1aWxkZXIiLCJCcm93c2VyOjpET00iLCJCcm93c2VyIiwiYmxvY2sgaW4gPG1vZHVsZTpCcm93c2VyPiIsImIiLCJpdGVtIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8bW9kdWxlOkJyb3dzZXI+Il0sIm1hcHBpbmdzIjoiQUFBQUEsaUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLHNCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixxQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYscUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLHlCQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7OztJQUVBQztJQUFBQTs7TUFBQUE7O0FBQUFBOztNQUNFSCxJQUFBSSxTQUFBQSxDQUFRQyxJQUFBQyxZQUFBRCxZQUFSRDtNQUVBSixJQUFBTyxhQUFBQSxDQUFZLFNBQVosRUFBc0IsT0FBdEIsRUFBOEIsTUFBOUJBOztBQUVBQyxNQUFBQSwwQkFBQUEsc0JBWkYsRUFZRUE7QUFBQUEsUUFBQUE7QUFBQUE7O1FBQUFBOztRQVpGO1FBWWlC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RyxPQUFBQSxFQUFLLE1BQUN4RyxJQUFELENBQUx3RyxFQUFhckQsS0FBREMsU0FBQUEsQ0FBQUEsQ0FBWm9EO01BQWhDQSxDQUFBQSxJQUFBQTtNQUNBaEgsT0FBQWlILG1CQUFBQSxlQXZVRixFQXVVRUE7QUFBQUEsUUFBQUE7O1FBQUFBOzs7UUF2VUY7UUF1VVU7UUFBZ0JBLE9BQVFBLE1BQVJuRyxZQUFRbUcsT0FBQUEsRUFBSyxNQUFDekcsSUFBRCxDQUFMeUcsRUFBYXRELEtBQURDLFNBQUFBLENBQUFBLENBQVpxRDtNQUFoQ0EsQ0FBQUEsSUFBQUE7SUFoVUZqSCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtJQW1VQUQsT0FBcUJtSCxNQUFyQkMsSUFBQUMsSUFBQUMsYUFBQUQsUUFBQUQsWUFBcUJELE9BQUFBLEVBQUFBLENBQUtuRyxZQUFMbUcsQ0FBQUEsRUFBckJJLG9CQUFxQ0MsQ0FBRCxFQUFJQyxJQUF4Q0Y7O01BQXFDO01BQUc7TUFDdENHLE9BQUFELElBQUk5RyxTQUFBQSxDQUFBQSxFQURONEcsQ0FBcUJKO0VBclVyQm5ILEdBQUFBLFdBQUFBO0FBTEFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo0MzQ0NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvc2V0dXAvZnVsbC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGJyb3dzZXIvc2V0dXAvZnVsbCAtIGEgZnVsbCBzZXQgb2YgcmVxdWlyZXMgdG8gcHJvdmlkZSBhbGwgZmVhdHVyZXMgYXQgb25jZVxuXG5yZXF1aXJlICdwYWdnaW8nXG5cbnJlcXVpcmUgJ2Jyb3dzZXIvc2V0dXAvbGFyZ2UnXG5cbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQvYWxsJ1xuXG5yZXF1aXJlICdicm93c2VyL2RvbS9idWlsZGVyJ1xucmVxdWlyZSAnYnJvd3Nlci9kb20vbXV0YXRpb25fb2JzZXJ2ZXInXG5yZXF1aXJlICdicm93c2VyL2RvbS9lbGVtZW50L2N1c3RvbSdcblxucmVxdWlyZSAnYnJvd3Nlci9jYW52YXMnXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiQUFBQUEscUNBQUFBLGdCQUFBQTtFQUFBQTs7RUFBQUE7O0VBRUFDLElBQUFDLFNBQUFBLENBQVFGLFFBQVJFO0VBRUFELElBQUFDLFNBQUFBLENBQVFGLHFCQUFSRTtFQUVBRCxJQUFBQyxTQUFBQSxDQUFRRixtQkFBUkU7RUFFQUQsSUFBQUMsU0FBQUEsQ0FBUUYscUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLCtCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRiw0QkFBUkU7RUFFQUYsT0FBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsZ0JBQVJFO0FBWkFGOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo0MzQ1OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImFwcC9hcHBsaWNhdGlvbi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlIFwib3BhbFwiXG5yZXF1aXJlIFwiY29uc29sZVwiXG5yZXF1aXJlIFwicHJvbWlzZVwiXG5yZXF1aXJlIFwiYnJvd3Nlci9zZXR1cC9mdWxsXCJcblxuIyBMZXQncyB0ZXN0IHNvbWUgZWxlbWVudCBiZWZvcmUgd2UgaGF2ZSBiZWVuIGluaXRpYWxpemVkLlxuIyBUaGlzIGlzIHNvIHdlIGNhbiB0ZXN0IHRoZSB1cGdyYWRpbmcgYmVoYXZpb3IuXG4kZG9jdW1lbnQuYm9keSA8PCAkZG9jdW1lbnQuY3JlYXRlX2VsZW1lbnQoXCJhcHAtbXljb3VudGVyXCIpXG5cbmQgPSBET00oXCI8ZGl2PlwiKVxuJGRvY3VtZW50LmJvZHkgPDwgZFxuZC5pbm5lcl9odG1sID0gXCI8YXBwLW15Y291bnRlcj5cIlxuXG5jbGFzcyBNeUNvdW50ZXIgPCBCcm93c2VyOjpET006OkVsZW1lbnQ6OkN1c3RvbVxuICAjIEN1c3RvbSBFbGVtZW50IGludGVyZmFjZTpcblxuICBzZWxmLm9ic2VydmVkX2F0dHJpYnV0ZXMgPSAld1t2YWx1ZV1cblxuICBkZWYgaW5pdGlhbGl6ZShub2RlKVxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBhdHRhY2hlZFxuICAgIHNlbGZbOnZhbHVlXSB8fD0gXCIwXCJcbiAgICBvbiA6Y2xpY2sgZG9cbiAgICAgIGluY3JlYXNlIVxuICAgIGVuZFxuICAgIHJlbmRlciAgXG4gIGVuZFxuXG4gIGRlZiBkZXRhY2hlZFxuICAgIG9mZiA6Y2xpY2tcbiAgZW5kXG5cbiAgZGVmIGF0dHJpYnV0ZV9jaGFuZ2VkKGF0dHIsIGZyb20sIHRvKVxuICAgIHJlbmRlclxuICBlbmRcblxuICAjIE91ciBpbnRlcmZhY2U6XG5cbiAgZGVmIGluY3JlYXNlIVxuICAgIHNlbGZbOnZhbHVlXSA9IChzZWxmWzp2YWx1ZV0udG9faSArIDEpXG4gIGVuZFxuXG4gICMgUHJpdmF0ZTpcblxuICBkZWYgcmVuZGVyXG4gICAgc2VsZi5pbm5lcl9odG1sID0gXCI8aDE+WyN7c2VsZls6dmFsdWVdfV08L2gxPlwiXG4gIGVuZFxuXG4gICMgVGhpcyBzaG91bGQgY29tZSBhZnRlciB0aGUgbWV0aG9kcyBoYXZlIGJlZW4gZGVmaW5lZC5cbiAgZGVmX2N1c3RvbSBcImFwcC1teWNvdW50ZXJcIlxuZW5kXG5cbiRkb2N1bWVudC5ib2R5IDw8IERPTShcIjxhcHAtbXljb3VudGVyPjwvYXBwLW15Y291bnRlcj5cIilcbiRkb2N1bWVudC5ib2R5IDw8ICRkb2N1bWVudC5jcmVhdGVfZWxlbWVudChcImFwcC1teWNvdW50ZXJcIilcbiRkb2N1bWVudC5ib2R5IDw8IE15Q291bnRlci5uZXdcbiRkb2N1bWVudC5ib2R5IDw8IERPTSB7IGUoJ2FwcC1teWNvdW50ZXInKSB9XG5cbmFsbCA9IERPTShcIjxoMT5JbmNyZWFzZSBhbGwhPC9oMT5cIilcbmFsbC5vbig6Y2xpY2spIGRvXG4gICRkb2N1bWVudC5jc3MoXCJhcHAtbXljb3VudGVyXCIpLmVhY2ggZG8gfGN8XG4gICAgYy5pbmNyZWFzZSFcbiAgZW5kXG5lbmRcbiRkb2N1bWVudC5ib2R5IDw8IGFsbFxuIl0sIm5hbWVzIjpbIjxtYWluPiIsInNlbGYiLCJyZXF1aXJlIiwiJGRvY3VtZW50IiwiYm9keSIsIjw8IiwiY3JlYXRlX2VsZW1lbnQiLCJkIiwiRE9NIiwiaW5uZXJfaHRtbD0iLCI8Y2xhc3M6TXlDb3VudGVyPiIsIm9ic2VydmVkX2F0dHJpYnV0ZXM9IiwiaW5pdGlhbGl6ZSIsIm5vZGUiLCJhdHRhY2hlZCIsIiRyZXRfb3JfMSIsIltdIiwiW109Iiwib24iLCJibG9jayBpbiBhdHRhY2hlZCIsImJsb2NrICgyIGxldmVscykgaW4gYXR0YWNoZWQiLCJpbmNyZWFzZSEiLCJyZW5kZXIiLCJkZXRhY2hlZCIsIm9mZiIsImF0dHJpYnV0ZV9jaGFuZ2VkIiwiYXR0ciIsImZyb20iLCJ0byIsIisiLCJ0b19pIiwiMSIsImRlZl9jdXN0b20iLCJCcm93c2VyOjpET006OkVsZW1lbnQ6OkN1c3RvbSIsIkJyb3dzZXI6OkRPTTo6RWxlbWVudCIsIkJyb3dzZXI6OkRPTSIsIkJyb3dzZXIiLCJNeUNvdW50ZXIiLCJuZXciLCJibG9jayBpbiA8bWFpbj4iLCJibG9jayAoMiBsZXZlbHMpIGluIDxtYWluPiIsImUiLCJhbGwiLCJlYWNoIiwiY3NzIiwiYyIsImJsb2NrICgzIGxldmVscykgaW4gPG1haW4+Il0sIm1hcHBpbmdzIjoiQUFBQUEsMkJBQUFBO0VBQUFBO0FBQUFBOztFQUFBQTs7RUFBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsTUFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsU0FBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsU0FBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsb0JBQVJFO0VBSUFDLGVBQVNDLE1BQUFBLENBQUFBLENBQU1DLE9BQUFBLENBQUdGLGVBQVNHLGdCQUFBQSxDQUFnQk4sZUFBaEJNLENBQVpEO0VBRWZFLElBQUlOLElBQUFPLEtBQUFBLENBQUlSLE9BQUpRO0VBQ0pMLGVB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QUFBLEVBQUhxQixhQUFBQSxFQUFBQzs7SUFDRUEsT0FBOEJHLE1BQTlCeEMsZUFBU3lDLEtBQUFBLENBQUtKLGVBQUxJLENBQXFCRCxRQUFBQSxFQUFBQSxFQUFBQSxFQUE5QkgsYUFBd0NLLENBQXhDTDs7TUFBd0M7TUFDdENNLE9BQUFELENBQUN4QixjQUFBQSxDQUFBQSxFQURIbUIsQ0FBOEJHLENBRGhDSixDQUFHckI7RUFLSGxCLE9BQUFHLGVBQVNDLE1BQUFBLENBQUFBLENBQU1DLE9BQUFBLENBQUdxQyxHQUFIckM7QUFqRWZMOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo0MzU0MiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIihleGl0KSJdLCJzb3VyY2VzQ29udGVudCI6WyI6Oktlcm5lbC5leGl0XG4iXSwibmFtZXMiOlsiPG1haW4+IiwiS2VybmVsIiwiZXhpdCJdLCJtYXBwaW5ncyI6IkFBQUFBLDJCQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUMsT0FBUUMsTUFBQUEsQ0FBQUE7QUFBUkY7In19XX0=
